   1:			;==================================================================================
   2:			; The updates to the original BASIC within this file are copyright Grant Searle
   3:			;
   4:			; You have permission to use this for NON COMMERCIAL USE ONLY
   5:			; If you wish to use it elsewhere, please include an acknowledgement to myself.
   6:			;
   7:			; http://searle.hostei.com/grant/index.html
   8:			;
   9:			; eMail: home.micros01@btinternet.com
  10:			;
  11:			; If the above don't work, please perform an Internet search to see if I have
  12:			; updated the web page hosting service.
  13:			;
  14:			;==================================================================================
  15:			
  16:			; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
  17:			; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
  18:			; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
  19:			; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
  20:			; the original ROM code (checksum A934H). PA
  21:			
  22:			; GENERAL EQUATES
  23:			
  24:	0003          	CTRLC   .EQU   03H             ; Control "C"
  25:	0007          	CTRLG   .EQU   07H             ; Control "G"
  26:	0008          	BKSP    .EQU   08H             ; Back space
  27:	000A          	LF      .EQU   0AH             ; Line feed
  28:	000C          	CS      .EQU   0CH             ; Clear screen
  29:	000D          	CR      .EQU   0DH             ; Carriage return
  30:	000F          	CTRLO   .EQU   0FH             ; Control "O"
  31:	0011          	CTRLQ   .EQU   11H	       ; Control "Q"
  32:	0012          	CTRLR   .EQU   12H             ; Control "R"
  33:	0013          	CTRLS   .EQU   13H             ; Control "S"
  34:	0015          	CTRLU   .EQU   15H             ; Control "U"
  35:	0018          	CAN     .EQU   18H             ; Cancel Control 'X'
  36:	001B          	ESC     .EQU   1BH             ; Escape
  37:	0020          	SPACE   .EQU   20H             ; Space
  38:	007F          	DEL     .EQU   7FH             ; Delete
  39:			
  40:			; BASIC WORK SPACE LOCATIONS
  41:			
  42:	2000          	        .ORG   2000H
  43:			
  44:	2000          	RAMSTART .ds    45H     ; .EQU   2000H           ; Start of RAM
  45:	2045          	WRKSPC  .ds     3       ; .EQU   2045H           ; BASIC Work space
  46:	2048          	USR     .ds     3       ; .EQU   WRKSPC + 3H     ; "USR (x)" jump
  47:	204B          	OUTSUB  .ds     3       ; .EQU   WRKSPC + 6H     ; "OUT p,n"
  48:	204C          	OTPORT  .equ    OUTSUB+1 ; .EQU   WRKSPC + 7H     ; Port (p)
  49:	204E          	DIVSUP  .ds     14      ; .EQU   WRKSPC + 9H     ; Division support routine
  50:	204F          	DIV1    .equ    DIVSUP+1  ; .EQU   WRKSPC + 0AH    ; <- Values
  51:	2053          	DIV2    .equ    DIVSUP+5  ; .EQU   WRKSPC + 0EH    ; <-   to
  52:	2057          	DIV3    .equ    DIVSUP+9  ; .EQU   WRKSPC + 12H    ; <-   be
  53:	205A          	DIV4    .equ    DIVSUP+12 ; .EQU   WRKSPC + 15H    ; <-inserted
  54:	205C          	SEED    .ds     35       ; .EQU   WRKSPC + 17H    ; Random number seed
  55:	207F          	LSTRND  .ds     4       ; .EQU   WRKSPC + 3AH    ; Last random number
  56:	2083          	INPSUB  .ds     3       ; .EQU   WRKSPC + 3EH    ; #INP (x)" Routine
  57:	2084          	INPORT  .equ    INPSUB+1 ; .EQU   WRKSPC + 3FH    ; PORT (x)
  58:	2086          	NULLS   .ds     1       ; .EQU   WRKSPC + 41H    ; Number of nulls
  59:	2087          	LWIDTH  .ds     1       ; .EQU   WRKSPC + 42H    ; Terminal width
  60:	2088          	COMMAN  .ds     1       ; .EQU   WRKSPC + 43H    ; Width for commas
  61:	2089          	NULFLG  .ds     1       ; .EQU   WRKSPC + 44H    ; Null after input byte flag
  62:	208A          	CTLOFG  .ds     1       ; .EQU   WRKSPC + 45H    ; Control "O" flag
  63:	208B          	LINESC  .ds     2       ; .EQU   WRKSPC + 46H    ; Lines counter
  64:	208D          	LINESN  .ds     2       ; .EQU   WRKSPC + 48H    ; Lines number
  65:	208F          	CHKSUM  .ds     2       ; .EQU   WRKSPC + 4AH    ; Array load/save check sum
  66:	2091          	NMIFLG  .ds     1       ; .EQU   WRKSPC + 4CH    ; Flag for NMI break routine
  67:	2092          	BRKFLG  .ds     1       ; .EQU   WRKSPC + 4DH    ; Break flag
  68:	2093          	RINPUT  .ds     3       ; .EQU   WRKSPC + 4EH    ; Input reflection
  69:	2096          	POINT   .ds     3       ; .EQU   WRKSPC + 51H    ; "POINT" reflection (unused)
  70:	2099          	PSET    .ds     3       ; .EQU   WRKSPC + 54H    ; "SET"   reflection
  71:	209C          	RESET   .ds     3       ; .EQU   WRKSPC + 57H    ; "RESET" reflection
  72:	209F          	STRSPC  .ds     2       ; .EQU   WRKSPC + 5AH    ; Bottom of string space
  73:	20A1          	LINEAT  .ds     2       ; .EQU   WRKSPC + 5CH    ; Current line number
  74:	20A3          	BASTXT  .ds     2       ; .EQU   WRKSPC + 5EH    ; Pointer to start of program
  75:	20A5          	        .ds     1
  76:	20A6          	BUFFER  .ds     74      ; .EQU   WRKSPC + 61H    ; Input buffer
  77:	20F0          	STACK   .equ    BUFFER+74 ; .EQU   WRKSPC + 66H    ; Initial stack
  78:	20F0          	CURPOS  .ds     1       ; .EQU   WRKSPC + 0ABH   ; Character position on line
  79:	20F1          	LCRFLG  .ds     1       ; .EQU   WRKSPC + 0ACH   ; Locate/Create flag
  80:	20F2          	TYPE    .ds     1       ; .EQU   WRKSPC + 0ADH   ; Data type flag
  81:	20F3          	DATFLG  .ds     1       ; .EQU   WRKSPC + 0AEH   ; Literal statement flag
  82:	20F4          	LSTRAM  .ds     2       ; .EQU   WRKSPC + 0AFH   ; Last available RAM
  83:	20F6          	TMSTPT  .ds     2       ; .EQU   WRKSPC + 0B1H   ; Temporary string pointer
  84:	20F8          	TMSTPL  .ds     12      ; .EQU   WRKSPC + 0B3H   ; Temporary string pool
  85:	2104          	TMPSTR  .ds     4       ; .EQU   WRKSPC + 0BFH   ; Temporary string
  86:	2108          	STRBOT  .ds     2       ; .EQU   WRKSPC + 0C3H   ; Bottom of string space
  87:	210A          	CUROPR  .ds     2       ; .EQU   WRKSPC + 0C5H   ; Current operator in EVAL
  88:	210C          	LOOPST  .ds     2       ; .EQU   WRKSPC + 0C7H   ; First statement of loop
  89:	210E          	DATLIN  .ds     2       ; .EQU   WRKSPC + 0C9H   ; Line of current DATA item
  90:	2110          	FORFLG  .ds     1       ; .EQU   WRKSPC + 0CBH   ; "FOR" loop flag
  91:	2111          	LSTBIN  .ds     1       ; .EQU   WRKSPC + 0CCH   ; Last byte entered
  92:	2112          	READFG  .ds     1       ; .EQU   WRKSPC + 0CDH   ; Read/Input flag
  93:	2113          	BRKLIN  .ds     2       ; .EQU   WRKSPC + 0CEH   ; Line of break
  94:	2115          	NXTOPR  .ds     2       ; .EQU   WRKSPC + 0D0H   ; Next operator in EVAL
  95:	2117          	ERRLIN  .ds     2       ; .EQU   WRKSPC + 0D2H   ; Line of error
  96:	2119          	CONTAD  .ds     2       ; .EQU   WRKSPC + 0D4H   ; Where to CONTinue
  97:	211B          	PROGND  .ds     2       ; .EQU   WRKSPC + 0D6H   ; End of program
  98:	211D          	VAREND  .ds     2       ; .EQU   WRKSPC + 0D8H   ; End of variables
  99:	211F          	ARREND  .ds     2       ; .EQU   WRKSPC + 0DAH   ; End of arrays
 100:	2121          	NXTDAT  .ds     2       ; .EQU   WRKSPC + 0DCH   ; Next data item
 101:	2123          	FNRGNM  .ds     2       ; .EQU   WRKSPC + 0DEH   ; Name of FN argument
 102:	2125          	FNARG   .ds     4       ; .EQU   WRKSPC + 0E0H   ; FN argument value
 103:	2129          	FPREG   .ds     4       ; .EQU   WRKSPC + 0E4H   ; Floating point register
 104:	212C          	FPEXP   .EQU   FPREG + 3       ; Floating point exponent
 105:	212D          	SGNRES  .ds     1       ; .EQU   WRKSPC + 0E8H   ; Sign of result
 106:	212E          	PBUFF   .ds     13      ; .EQU   WRKSPC + 0E9H   ; Number print buffer
 107:	213B          	MULVAL  .ds     3       ; .EQU   WRKSPC + 0F6H   ; Multiplier
 108:	213E          	PROGST  .ds     1       ; .EQU   WRKSPC + 0F9H   ; Start of program text area
 109:	21A2          	STLOOK  .EQU   WRKSPC + 15DH   ; Start of memory test
 110:			
 111:			; BASIC ERROR CODE VALUES
 112:			
 113:	0000          	NF      .EQU   00H             ; NEXT without FOR
 114:	0002          	SN      .EQU   02H             ; Syntax error
 115:	0004          	RG      .EQU   04H             ; RETURN without GOSUB
 116:	0006          	OD      .EQU   06H             ; Out of DATA
 117:	0008          	FC      .EQU   08H             ; Function call error
 118:	000A          	OV      .EQU   0AH             ; Overflow
 119:	000C          	OM      .EQU   0CH             ; Out of memory
 120:	000E          	UL      .EQU   0EH             ; Undefined line number
 121:	0010          	BS      .EQU   10H             ; Bad subscript
 122:	0012          	DD      .EQU   12H             ; Re-DIMensioned array
 123:	0014          	DZ      .EQU   14H             ; Division by zero (/0)
 124:	0016          	ID      .EQU   16H             ; Illegal direct
 125:	0018          	TM      .EQU   18H             ; Type miss-match
 126:	001A          	OS      .EQU   1AH             ; Out of string space
 127:	001C          	LS      .EQU   1CH             ; String too long
 128:	001E          	ST      .EQU   1EH             ; String formula too complex
 129:	0020          	CN      .EQU   20H             ; Can't CONTinue
 130:	0022          	UF      .EQU   22H             ; UnDEFined FN function
 131:	0024          	MO      .EQU   24H             ; Missing operand
 132:	0026          	HE      .EQU   26H             ; HEX error
 133:	0028          	BN      .EQU   28H             ; BIN error
 134:			
 135:	0150          	        .ORG   00150H
 136:			
 137:	0150  C35A01  	COLD:   JP      STARTB          ; Jump for cold start
 138:	0153  C3F101  	WARM:   JP      WARMST          ; Jump for warm start
 139:			
 140:			; USR(X) is called with a single argument.
 141:			; Get the argument in DE as int16_t by calling DEINT.
 142:			; Put return value (int16_t) in AB and call ABPASS.
 143:			;
 144:	0156  CC09    	        .DW     DEINT           ; Get integer -32768 to 32767 in DE
 145:	0158  4211    	        .DW     ABPASS          ; Return integer in AB
 146:			
 147:	015A  DD210000	STARTB: LD      IX,0            ; Flag cold start ???
 148:	015E  214520  	CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
 149:	0161  F9      	        LD      SP,HL           ; Set up a temporary stack
 150:	0162  C35F1D  	        JP      INITST          ; Go to initialise
 151:			
 152:	0165  112704  	INIT:   LD      DE,INITAB       ; Initialise workspace
 153:	0168  0663    	        LD      B,INITBE-INITAB+3; Bytes to copy
 154:	016A  214520  	        LD      HL,WRKSPC       ; Into workspace RAM
 155:	016D  1A      	COPY:   LD      A,(DE)          ; Get source
 156:	016E  77      	        LD      (HL),A          ; To destination
 157:	016F  23      	        INC     HL              ; Next destination
 158:	0170  13      	        INC     DE              ; Next source
 159:	0171  05      	        DEC     B               ; Count bytes
 160:	0172  C26D01  	        JP      NZ,COPY         ; More to move
 161:	0175  F9      	        LD      SP,HL           ; Temporary stack
 162:	0176  CD2806  	        CALL    CLREG           ; Clear registers and stack
 163:	0179  CDC20B  	        CALL    PRNTCRLF        ; Output CRLF
 164:	017C  32EF20  	        LD      (BUFFER+72+1),A ; Mark end of buffer
 165:	017F  323E21  	        LD      (PROGST),A      ; Initialise program area
 166:			
 167:			;MSIZE: LD      HL,MEMMSG       ; Point to message
 168:			;       CALL    PRS             ; Output "Memory size"
 169:	0182  2A0020  	MSIZE:  LD      HL,(RAMSTART)   ; Read RAM end from memory
 170:	0185  C3B901  	        JP      SETTOP          ; Skip user input and mem check
 171:			
 172:	0188  CD4506  	        CALL    PROMPT          ; Get input with '?'
 173:	018B  CD1A09  	        CALL    GETCHR          ; Get next character
 174:	018E  B7      	        OR      A               ; Set flags
 175:	018F  C2A701  	        JP      NZ,TSTMEM       ; If number - Test if RAM there
 176:	0192  21A221  	        LD      HL,STLOOK       ; Point to start of RAM
 177:	0195  23      	MLOOP:  INC     HL              ; Next byte
 178:	0196  7C      	        LD      A,H             ; Above address FFFF ?
 179:	0197  B5      	        OR      L
 180:	0198  CAB901  	        JP      Z,SETTOP        ; Yes - 64K RAM
 181:	019B  7E      	        LD      A,(HL)          ; Get contents
 182:	019C  47      	        LD      B,A             ; Save it
 183:	019D  2F      	        CPL                     ; Flip all bits
 184:	019E  77      	        LD      (HL),A          ; Put it back
 185:	019F  BE      	        CP      (HL)            ; RAM there if same
 186:	01A0  70      	        LD      (HL),B          ; Restore old contents
 187:	01A1  CA9501  	        JP      Z,MLOOP         ; If RAM - test next byte
 188:	01A4  C3B901  	        JP      SETTOP          ; Top of RAM found
 189:			
 190:	01A7  CDE609  	TSTMEM: CALL    ATOH            ; Get high memory into DE
 191:	01AA  B7      	        OR      A               ; Set flags on last byte
 192:	01AB  C2F604  	        JP      NZ,SNERR        ; ?SN Error if bad character
 193:	01AE  EB      	        EX      DE,HL           ; Address into HL
 194:	01AF  2B      	        DEC     HL              ; Back one byte
 195:	01B0  3ED9    	        LD      A,11011001B     ; Test byte
 196:	01B2  46      	        LD      B,(HL)          ; Get old contents
 197:	01B3  77      	        LD      (HL),A          ; Load test byte
 198:	01B4  BE      	        CP      (HL)            ; RAM there if same
 199:	01B5  70      	        LD      (HL),B          ; Restore old contents
 200:	01B6  C28201  	        JP      NZ,MSIZE        ; Ask again if no RAM
 201:			
 202:	01B9  2B      	SETTOP: DEC     HL              ; Back one byte
 203:	01BA  11A121  	        LD      DE,STLOOK-1     ; See if enough RAM
 204:	01BD  CD8A07  	        CALL    CPDEHL          ; Compare DE with HL
 205:	01C0  DA8201  	        JP      C,MSIZE         ; Ask again if not enough RAM
 206:	01C3  11CEFF  	        LD      DE,0-50         ; 50 Bytes string space
 207:	01C6  22F420  	        LD      (LSTRAM),HL     ; Save last available RAM
 208:	01C9  19      	        ADD     HL,DE           ; Allocate string space
 209:	01CA  229F20  	        LD      (STRSPC),HL     ; Save string space
 210:	01CD  CD0306  	        CALL    CLRPTR          ; Clear program area
 211:	01D0  2A9F20  	        LD      HL,(STRSPC)     ; Get end of memory
 212:	01D3  11EFFF  	        LD      DE,0-17         ; Offset for free bytes
 213:	01D6  19      	        ADD     HL,DE           ; Adjust HL
 214:	01D7  113E21  	        LD      DE,PROGST       ; Start of program text
 215:	01DA  7D      	        LD      A,L             ; Get LSB
 216:	01DB  93      	        SUB     E               ; Adjust it
 217:	01DC  6F      	        LD      L,A             ; Re-save
 218:	01DD  7C      	        LD      A,H             ; Get MSB
 219:	01DE  9A      	        SBC     A,D             ; Adjust it
 220:	01DF  67      	        LD      H,A             ; Re-save
 221:	01E0  E5      	        PUSH    HL              ; Save bytes free
 222:	01E1  210902  	        LD      HL,SIGNON       ; Sign-on message
 223:	01E4  CD6012  	        CALL    PRS             ; Output string
 224:	01E7  E1      	        POP     HL              ; Get bytes free back
 225:	01E8  CD0319  	        CALL    PRNTHL          ; Output amount of free memory
 226:	01EB  21FA01  	        LD      HL,BFREE        ; " Bytes free" message
 227:	01EE  CD6012  	        CALL    PRS             ; Output string
 228:			
 229:	01F1  31F020  	WARMST: LD      SP,STACK        ; Temporary stack
 230:	01F4  CD2806  	BRKRET: CALL    CLREG           ; Clear registers and stack
 231:	01F7  C34105  	        JP      PRNTOK          ; Go to get command line
 232:			
 233:	01FA  20427974	BFREE:  .DB  " Bytes free",CR,LF,0,0
	      65732066
	      7265650D
	      0A0000
 234:			
 235:	0209  4E415343	SIGNON: .DB  "NASCOM ROM BASIC Ver 4.7b",CR,LF
	      4F4D2052
	      4F4D2042
	      41534943
	      20566572
	      20342E37
	      620D0A
 236:	0224  436F7079	        .DB  "Copyright (c) 1978 by Microsoft",CR,LF,0,0
	      72696768
	      74202863
	      29203139
	      37382062
	      79204D69
	      63726F73
	      6F66740D
	      0A0000
 237:			
 238:			;MEMMSG: .DB  "Memory top",0
 239:			
 240:			; FUNCTION ADDRESS TABLE
 241:			
 242:	0247  7817    	FNCTAB: .DW     SGN
 243:	0249  3C18    	        .DW     INT
 244:	024B  8E17    	        .DW     ABS
 245:	024D  4820    	        .DW     USR
 246:	024F  2011    	        .DW     FRE
 247:	0251  A514    	        .DW     INP
 248:	0253  4E11    	        .DW     POS
 249:	0255  021A    	        .DW     SQR
 250:	0257  E11A    	        .DW     RND
 251:	0259  1D16    	        .DW     LOG
 252:	025B  501A    	        .DW     EXP
 253:	025D  561B    	        .DW     COS
 254:	025F  5C1B    	        .DW     SIN
 255:	0261  BD1B    	        .DW     TAN
 256:	0263  D21B    	        .DW     ATN
 257:	0265  F914    	        .DW     PEEK
 258:	0267  3D1C    	        .DW     DEEK
 259:	0269  9620    	        .DW     POINT
 260:	026B  D213    	        .DW     LEN
 261:	026D  EA11    	        .DW     STR
 262:	026F  6C14    	        .DW     VAL
 263:	0271  E113    	        .DW     ASC
 264:	0273  F213    	        .DW     CHR
 265:	0275  5F1C    	        .DW     HEX
 266:	0277  F21C    	        .DW     BIN
 267:	0279  0214    	        .DW     LEFT
 268:	027B  3214    	        .DW     RIGHT
 269:	027D  3C14    	        .DW     MID
 270:			
 271:			; RESERVED WORD LIST
 272:			
 273:	027F  C54E44  	WORDS:  .DB     'E' + 80H,"ND"
 274:	0282  C64F52  	        .DB     'F' + 80H,"OR"
 275:	0285  CE455854	        .DB     'N' + 80H,"EXT"
 276:	0289  C4415441	        .DB     'D' + 80H,"ATA"
 277:	028D  C94E5055	        .DB     'I' + 80H,"NPUT"
	      54
 278:	0292  C4494D  	        .DB     'D' + 80H,"IM"
 279:	0295  D2454144	        .DB     'R' + 80H,"EAD"
 280:	0299  CC4554  	        .DB     'L' + 80H,"ET"
 281:	029C  C74F544F	        .DB     'G' + 80H,"OTO"
 282:	02A0  D2554E  	        .DB     'R' + 80H,"UN"
 283:	02A3  C946    	        .DB     'I' + 80H,"F"
 284:	02A5  D2455354	        .DB     'R' + 80H,"ESTORE"
	      4F5245
 285:	02AC  C74F5355	        .DB     'G' + 80H,"OSUB"
	      42
 286:	02B1  D2455455	        .DB     'R' + 80H,"ETURN"
	      524E
 287:	02B7  D2454D  	        .DB     'R' + 80H,"EM"
 288:	02BA  D3544F50	        .DB     'S' + 80H,"TOP"
 289:	02BE  CF5554  	        .DB     'O' + 80H,"UT"
 290:	02C1  CF4E    	        .DB     'O' + 80H,"N"
 291:	02C3  CE554C4C	        .DB     'N' + 80H,"ULL"
 292:	02C7  D7414954	        .DB     'W' + 80H,"AIT"
 293:	02CB  C44546  	        .DB     'D' + 80H,"EF"
 294:	02CE  D04F4B45	        .DB     'P' + 80H,"OKE"
 295:	02D2  C44F4B45	        .DB     'D' + 80H,"OKE"
 296:	02D6  D3435245	        .DB     'S' + 80H,"CREEN"
	      454E
 297:	02DC  CC494E45	        .DB     'L' + 80H,"INES"
	      53
 298:	02E1  C34C53  	        .DB     'C' + 80H,"LS"
 299:	02E4  D7494454	        .DB     'W' + 80H,"IDTH"
	      48
 300:	02E9  CD4F4E49	        .DB     'M' + 80H,"ONITOR"
	      544F52
 301:	02F0  D34554  	        .DB     'S' + 80H,"ET"
 302:	02F3  D2455345	        .DB     'R' + 80H,"ESET"
	      54
 303:	02F8  D052494E	        .DB     'P' + 80H,"RINT"
	      54
 304:	02FD  C34F4E54	        .DB     'C' + 80H,"ONT"
 305:	0301  CC495354	        .DB     'L' + 80H,"IST"
 306:	0305  C34C4541	        .DB     'C' + 80H,"LEAR"
	      52
 307:	030A  C34C4F41	        .DB     'C' + 80H,"LOAD"
	      44
 308:	030F  C3534156	        .DB     'C' + 80H,"SAVE"
	      45
 309:	0314  CE4557  	        .DB     'N' + 80H,"EW"
 310:			
 311:	0317  D4414228	        .DB     'T' + 80H,"AB("
 312:	031B  D44F    	        .DB     'T' + 80H,"O"
 313:	031D  C64E    	        .DB     'F' + 80H,"N"
 314:	031F  D3504328	        .DB     'S' + 80H,"PC("
 315:	0323  D448454E	        .DB     'T' + 80H,"HEN"
 316:	0327  CE4F54  	        .DB     'N' + 80H,"OT"
 317:	032A  D3544550	        .DB     'S' + 80H,"TEP"
 318:			
 319:	032E  AB      	        .DB     '+' + 80H
 320:	032F  AD      	        .DB     '-' + 80H
 321:	0330  AA      	        .DB     '*' + 80H
 322:	0331  AF      	        .DB     '/' + 80H
 323:	0332  DE      	        .DB     '^' + 80H
 324:	0333  C14E44  	        .DB     'A' + 80H,"ND"
 325:	0336  CF52    	        .DB     'O' + 80H,"R"
 326:	0338  BE      	        .DB     '>' + 80H
 327:	0339  BD      	        .DB     '=' + 80H
 328:	033A  BC      	        .DB     '<' + 80H
 329:			
 330:	033B  D3474E  	        .DB     'S' + 80H,"GN"
 331:	033E  C94E54  	        .DB     'I' + 80H,"NT"
 332:	0341  C14253  	        .DB     'A' + 80H,"BS"
 333:	0344  D55352  	        .DB     'U' + 80H,"SR"
 334:	0347  C65245  	        .DB     'F' + 80H,"RE"
 335:	034A  C94E50  	        .DB     'I' + 80H,"NP"
 336:	034D  D04F53  	        .DB     'P' + 80H,"OS"
 337:	0350  D35152  	        .DB     'S' + 80H,"QR"
 338:	0353  D24E44  	        .DB     'R' + 80H,"ND"
 339:	0356  CC4F47  	        .DB     'L' + 80H,"OG"
 340:	0359  C55850  	        .DB     'E' + 80H,"XP"
 341:	035C  C34F53  	        .DB     'C' + 80H,"OS"
 342:	035F  D3494E  	        .DB     'S' + 80H,"IN"
 343:	0362  D4414E  	        .DB     'T' + 80H,"AN"
 344:	0365  C1544E  	        .DB     'A' + 80H,"TN"
 345:	0368  D045454B	        .DB     'P' + 80H,"EEK"
 346:	036C  C445454B	        .DB     'D' + 80H,"EEK"
 347:	0370  D04F494E	        .DB     'P' + 80H,"OINT"
	      54
 348:	0375  CC454E  	        .DB     'L' + 80H,"EN"
 349:	0378  D3545224	        .DB     'S' + 80H,"TR$"
 350:	037C  D6414C  	        .DB     'V' + 80H,"AL"
 351:	037F  C15343  	        .DB     'A' + 80H,"SC"
 352:	0382  C3485224	        .DB     'C' + 80H,"HR$"
 353:	0386  C8455824	        .DB     'H' + 80H,"EX$"
 354:	038A  C2494E24	        .DB     'B' + 80H,"IN$"
 355:	038E  CC454654	        .DB     'L' + 80H,"EFT$"
	      24
 356:	0393  D2494748	        .DB     'R' + 80H,"IGHT$"
	      5424
 357:	0399  CD494424	        .DB     'M' + 80H,"ID$"
 358:	039D  80      	        .DB     80H             ; End of list marker
 359:			
 360:			; KEYWORD ADDRESS TABLE
 361:			
 362:	039E  6409    	WORDTB: .DW     PEND
 363:	03A0  6108    	        .DW     FOR
 364:	03A2  3C0D    	        .DW     NEXT
 365:	03A4  B10A    	        .DW     DATA
 366:	03A6  430C    	        .DW     INPUT
 367:	03A8  780F    	        .DW     DIM
 368:	03AA  720C    	        .DW     READ
 369:	03AC  C80A    	        .DW     LET
 370:	03AE  6E0A    	        .DW     GOTO
 371:	03B0  510A    	        .DW     RUN
 372:	03B2  400B    	        .DW     IF
 373:	03B4  2A09    	        .DW     RESTOR
 374:	03B6  5D0A    	        .DW     GOSUB
 375:	03B8  8C0A    	        .DW     RETURN
 376:	03BA  B30A    	        .DW     REM
 377:	03BC  6209    	        .DW     STOP
 378:	03BE  B114    	        .DW     POUT
 379:	03C0  220B    	        .DW     ON
 380:	03C2  A309    	        .DW     NULL
 381:	03C4  B714    	        .DW     WAIT
 382:	03C6  5611    	        .DW     DEF
 383:	03C8  0015    	        .DW     POKE
 384:	03CA  481C    	        .DW     DOKE
 385:	03CC  B30A    	        .DW     REM             ;SCREEN
 386:	03CE  2E1C    	        .DW     LINES
 387:	03D0  211C    	        .DW     CLS
 388:	03D2  261C    	        .DW     WIDTH
 389:	03D4  5E1D    	        .DW     MONITR
 390:	03D6  9920    	        .DW     PSET
 391:	03D8  9C20    	        .DW     RESET
 392:	03DA  640B    	        .DW     PRINT
 393:	03DC  9009    	        .DW     CONT
 394:	03DE  D607    	        .DW     LIST
 395:	03E0  0B0A    	        .DW     CLEAR
 396:	03E2  B30A    	        .DW     REM             ;CLOAD
 397:	03E4  B30A    	        .DW     REM             ;CSAVE
 398:	03E6  0206    	        .DW     NEW
 399:			
 400:			; RESERVED WORD TOKEN VALUES
 401:			
 402:	0080          	ZEND    .EQU    080H            ; END
 403:	0081          	ZFOR    .EQU    081H            ; FOR
 404:	0083          	ZDATA   .EQU    083H            ; DATA
 405:	0088          	ZGOTO   .EQU    088H            ; GOTO
 406:	008C          	ZGOSUB  .EQU    08CH            ; GOSUB
 407:	008E          	ZREM    .EQU    08EH            ; REM
 408:	009E          	ZPRINT  .EQU    09EH            ; PRINT
 409:	00A4          	ZNEW    .EQU    0A4H            ; NEW
 410:			
 411:	00A5          	ZTAB    .EQU    0A5H            ; TAB
 412:	00A6          	ZTO     .EQU    0A6H            ; TO
 413:	00A7          	ZFN     .EQU    0A7H            ; FN
 414:	00A8          	ZSPC    .EQU    0A8H            ; SPC
 415:	00A9          	ZTHEN   .EQU    0A9H            ; THEN
 416:	00AA          	ZNOT    .EQU    0AAH            ; NOT
 417:	00AB          	ZSTEP   .EQU    0ABH            ; STEP
 418:			
 419:	00AC          	ZPLUS   .EQU    0ACH            ; +
 420:	00AD          	ZMINUS  .EQU    0ADH            ; -
 421:	00AE          	ZTIMES  .EQU    0AEH            ; *
 422:	00AF          	ZDIV    .EQU    0AFH            ; /
 423:	00B2          	ZOR     .EQU    0B2H            ; OR
 424:	00B3          	ZGTR    .EQU    0B3H            ; >
 425:	00B4          	ZEQUAL  .EQU    0B4H            ; M
 426:	00B5          	ZLTH    .EQU    0B5H            ; <
 427:	00B6          	ZSGN    .EQU    0B6H            ; SGN
 428:	00C7          	ZPOINT  .EQU    0C7H            ; POINT
 429:	00CF          	ZLEFT   .EQU    0CDH +2         ; LEFT$
 430:			
 431:			; ARITHMETIC PRECEDENCE TABLE
 432:			
 433:	03E8  79      	PRITAB: .DB     79H             ; Precedence value
 434:	03E9  EA18    	        .DW     PADD            ; FPREG = <last> + FPREG
 435:			
 436:	03EB  79      	        .DB     79H             ; Precedence value
 437:	03EC  1E15    	        .DW     PSUB            ; FPREG = <last> - FPREG
 438:			
 439:	03EE  7C      	        .DB     7CH             ; Precedence value
 440:	03EF  5C16    	        .DW     MULT            ; PPREG = <last> * FPREG
 441:			
 442:	03F1  7C      	        .DB     7CH             ; Precedence value
 443:	03F2  BD16    	        .DW     DIV             ; FPREG = <last> / FPREG
 444:			
 445:	03F4  7F      	        .DB     7FH             ; Precedence value
 446:	03F5  0B1A    	        .DW     POWER           ; FPREG = <last> ^ FPREG
 447:			
 448:	03F7  50      	        .DB     50H             ; Precedence value
 449:	03F8  D10E    	        .DW     PAND            ; FPREG = <last> AND FPREG
 450:			
 451:	03FA  46      	        .DB     46H             ; Precedence value
 452:	03FB  D00E    	        .DW     POR             ; FPREG = <last> OR FPREG
 453:			
 454:			; BASIC ERROR CODE LIST
 455:			
 456:	03FD  4E46    	ERRORS: .DB     "NF"            ; NEXT without FOR
 457:	03FF  534E    	        .DB     "SN"            ; Syntax error
 458:	0401  5247    	        .DB     "RG"            ; RETURN without GOSUB
 459:	0403  4F44    	        .DB     "OD"            ; Out of DATA
 460:	0405  4643    	        .DB     "FC"            ; Illegal function call
 461:	0407  4F56    	        .DB     "OV"            ; Overflow error
 462:	0409  4F4D    	        .DB     "OM"            ; Out of memory
 463:	040B  554C    	        .DB     "UL"            ; Undefined line
 464:	040D  4253    	        .DB     "BS"            ; Bad subscript
 465:	040F  4444    	        .DB     "DD"            ; Re-DIMensioned array
 466:	0411  2F30    	        .DB     "/0"            ; Division by zero
 467:	0413  4944    	        .DB     "ID"            ; Illegal direct
 468:	0415  544D    	        .DB     "TM"            ; Type mis-match
 469:	0417  4F53    	        .DB     "OS"            ; Out of string space
 470:	0419  4C53    	        .DB     "LS"            ; String too long
 471:	041B  5354    	        .DB     "ST"            ; String formula too complex
 472:	041D  434E    	        .DB     "CN"            ; Can't CONTinue
 473:	041F  5546    	        .DB     "UF"            ; Undefined FN function
 474:	0421  4D4F    	        .DB     "MO"            ; Missing operand
 475:	0423  4858    	        .DB     "HX"            ; HEX error
 476:	0425  424E    	        .DB     "BN"            ; BIN error
 477:			
 478:			; INITIALISATION TABLE -------------------------------------------------------
 479:			
 480:	0427  C3F101  	INITAB: JP      WARMST          ; Warm start jump
 481:	042A  C3E109  	        JP      FCERR           ; "USR (X)" jump (Set to Error)
 482:	042D  D300    	        OUT     (0),A           ; "OUT p,n" skeleton
 483:	042F  C9      	        RET
 484:	0430  D600    	        SUB     0               ; Division support routine
 485:	0432  6F      	        LD      L,A
 486:	0433  7C      	        LD      A,H
 487:	0434  DE00    	        SBC     A,0
 488:	0436  67      	        LD      H,A
 489:	0437  78      	        LD      A,B
 490:	0438  DE00    	        SBC     A,0
 491:	043A  47      	        LD      B,A
 492:	043B  3E00    	        LD      A,0
 493:	043D  C9      	        RET
 494:	043E  000000  	        .DB     0,0,0                   ; Random number seed table used by RND
 495:	0441  354ACA99	        .DB     035H,04AH,0CAH,099H     ;-2.65145E+07
 496:	0445  391C7698	        .DB     039H,01CH,076H,098H     ; 1.61291E+07
 497:	0449  2295B398	        .DB     022H,095H,0B3H,098H     ;-1.17691E+07
 498:	044D  0ADD4798	        .DB     00AH,0DDH,047H,098H     ; 1.30983E+07
 499:	0451  53D19999	        .DB     053H,0D1H,099H,099H     ;-2-01612E+07
 500:	0455  0A1A9F98	        .DB     00AH,01AH,09FH,098H     ;-1.04269E+07
 501:	0459  65BCCD98	        .DB     065H,0BCH,0CDH,098H     ;-1.34831E+07
 502:	045D  D6773E98	        .DB     0D6H,077H,03EH,098H     ; 1.24825E+07
 503:	0461  52C74F80	        .DB     052H,0C7H,04FH,080H     ; Last random number
 504:	0465  DB00    	        IN      A,(0)           ; INP (x) skeleton
 505:	0467  C9      	        RET
 506:	0468  01      	        .DB     1               ; POS (x) number (1)
 507:	0469  FF      	        .DB     255             ; Terminal width (255 = no auto CRLF)
 508:	046A  1C      	        .DB     28              ; Width for commas (3 columns)
 509:	046B  00      	        .DB     0               ; No nulls after input bytes
 510:	046C  00      	        .DB     0               ; Output enabled (^O off)
 511:	046D  1400    	        .DW     20              ; Initial lines counter
 512:	046F  1400    	        .DW     20              ; Initial lines number
 513:	0471  0000    	        .DW     0               ; Array load/save check sum
 514:	0473  00      	        .DB     0               ; Break not by NMI
 515:	0474  00      	        .DB     0               ; Break flag
 516:	0475  C32707  	        JP      TTYLIN          ; Input reflection (set to TTY)
 517:	0478  C30000  	        JP      0000H           ; POINT(X) reflection unused
 518:	047B  C30000  	        JP      0000H           ; SET reflection
 519:	047E  C30000  	        JP      0000H          	; RESET reflection
 520:	0481  A221    	        .DW     STLOOK          ; Temp string space
 521:	0483  FEFF    	        .DW     -2              ; Current line number (cold)
 522:	0485  3F21    	        .DW     PROGST+1        ; Start of program text
 523:	0487          	INITBE:
 524:			
 525:			; END OF INITIALISATION TABLE ---------------------------------------------------
 526:			
 527:	0487  20457272	ERRMSG: .DB     " Error",0
	      6F7200
 528:	048E  20696E20	INMSG:  .DB     " in ",0
	      00
 529:	0492          	ZERBYT  .EQU    $-1             ; A zero byte
 530:	0493  4F6B0D0A	OKMSG:  .DB     "Ok",CR,LF,0,0
	      0000
 531:	0499  42726561	BRKMSG: .DB     "Break",0
	      6B00
 532:			
 533:	049F  210400  	BAKSTK: LD      HL,4            ; Look for "FOR" block with
 534:	04A2  39      	        ADD     HL,SP           ; same index as specified
 535:	04A3  7E      	LOKFOR: LD      A,(HL)          ; Get block ID
 536:	04A4  23      	        INC     HL              ; Point to index address
 537:	04A5  FE81    	        CP      ZFOR            ; Is it a "FOR" token
 538:	04A7  C0      	        RET     NZ              ; No - exit
 539:	04A8  4E      	        LD      C,(HL)          ; BC = Address of "FOR" index
 540:	04A9  23      	        INC     HL
 541:	04AA  46      	        LD      B,(HL)
 542:	04AB  23      	        INC     HL              ; Point to sign of STEP
 543:	04AC  E5      	        PUSH    HL              ; Save pointer to sign
 544:	04AD  69      	        LD      L,C             ; HL = address of "FOR" index
 545:	04AE  60      	        LD      H,B
 546:	04AF  7A      	        LD      A,D             ; See if an index was specified
 547:	04B0  B3      	        OR      E               ; DE = 0 if no index specified
 548:	04B1  EB      	        EX      DE,HL           ; Specified index into HL
 549:	04B2  CAB904  	        JP      Z,INDFND        ; Skip if no index given
 550:	04B5  EB      	        EX      DE,HL           ; Index back into DE
 551:	04B6  CD8A07  	        CALL    CPDEHL          ; Compare index with one given
 552:	04B9  010D00  	INDFND: LD      BC,16-3         ; Offset to next block
 553:	04BC  E1      	        POP     HL              ; Restore pointer to sign
 554:	04BD  C8      	        RET     Z               ; Return if block found
 555:	04BE  09      	        ADD     HL,BC           ; Point to next block
 556:	04BF  C3A304  	        JP      LOKFOR          ; Keep on looking
 557:			
 558:	04C2  CDDC04  	MOVUP:  CALL    ENFMEM          ; See if enough memory
 559:	04C5  C5      	MOVSTR: PUSH    BC              ; Save end of source
 560:	04C6  E3      	        EX      (SP),HL         ; Swap source and dest" end
 561:	04C7  C1      	        POP     BC              ; Get end of destination
 562:	04C8  CD8A07  	MOVLP:  CALL    CPDEHL          ; See if list moved
 563:	04CB  7E      	        LD      A,(HL)          ; Get byte
 564:	04CC  02      	        LD      (BC),A          ; Move it
 565:	04CD  C8      	        RET     Z               ; Exit if all done
 566:	04CE  0B      	        DEC     BC              ; Next byte to move to
 567:	04CF  2B      	        DEC     HL              ; Next byte to move
 568:	04D0  C3C804  	        JP      MOVLP           ; Loop until all bytes moved
 569:			
 570:	04D3  E5      	CHKSTK: PUSH    HL              ; Save code string address
 571:	04D4  2A1F21  	        LD      HL,(ARREND)     ; Lowest free memory
 572:	04D7  0600    	        LD      B,0             ; BC = Number of levels to test
 573:	04D9  09      	        ADD     HL,BC           ; 2 Bytes for each level
 574:	04DA  09      	        ADD     HL,BC
 575:	04DB  3E      	        .DB     3EH             ; Skip "PUSH HL"
 576:	04DC  E5      	ENFMEM: PUSH    HL              ; Save code string address
 577:	04DD  3ED0    	        LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
 578:	04DF  95      	        SUB     L
 579:	04E0  6F      	        LD      L,A
 580:	04E1  3EFF    	        LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
 581:	04E3  9C      	        SBC     A,H
 582:	04E4  DAEB04  	        JP      C,OMERR         ; Not enough - ?OM Error
 583:	04E7  67      	        LD      H,A
 584:	04E8  39      	        ADD     HL,SP           ; Test if stack is overflowed
 585:	04E9  E1      	        POP     HL              ; Restore code string address
 586:	04EA  D8      	        RET     C               ; Return if enough mmory
 587:	04EB  1E0C    	OMERR:  LD      E,OM            ; ?OM Error
 588:	04ED  C30A05  	        JP      ERROR
 589:			
 590:	04F0  2A0E21  	DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
 591:	04F3  22A120  	        LD      (LINEAT),HL     ; Save as current line
 592:	04F6  1E02    	SNERR:  LD      E,SN            ; ?SN Error
 593:	04F8  01      	        .DB     01H             ; Skip "LD E,DZ"
 594:	04F9  1E14    	DZERR:  LD      E,DZ            ; ?/0 Error
 595:	04FB  01      	        .DB     01H             ; Skip "LD E,NF"
 596:	04FC  1E00    	NFERR:  LD      E,NF            ; ?NF Error
 597:	04FE  01      	        .DB     01H             ; Skip "LD E,DD"
 598:	04FF  1E12    	DDERR:  LD      E,DD            ; ?DD Error
 599:	0501  01      	        .DB     01H             ; Skip "LD E,UF"
 600:	0502  1E22    	UFERR:  LD      E,UF            ; ?UF Error
 601:	0504  01      	        .DB     01H             ; Skip "LD E,OV
 602:	0505  1E0A    	OVERR:  LD      E,OV            ; ?OV Error
 603:	0507  01      	        .DB     01H             ; Skip "LD E,TM"
 604:	0508  1E18    	TMERR:  LD      E,TM            ; ?TM Error
 605:			
 606:	050A  CD2806  	ERROR:  CALL    CLREG           ; Clear registers and stack
 607:	050D  328A20  	        LD      (CTLOFG),A      ; Enable output (A is 0)
 608:	0510  CDB50B  	        CALL    STTLIN          ; Start new line
 609:	0513  21FD03  	        LD      HL,ERRORS       ; Point to error codes
 610:	0516  57      	        LD      D,A             ; D = 0 (A is 0)
 611:	0517  3E3F    	        LD      A,'?'
 612:	0519  CD9B07  	        CALL    OUTC            ; Output '?'
 613:	051C  19      	        ADD     HL,DE           ; Offset to correct error code
 614:	051D  7E      	        LD      A,(HL)          ; First character
 615:	051E  CD9B07  	        CALL    OUTC            ; Output it
 616:	0521  CD1A09  	        CALL    GETCHR          ; Get next character
 617:	0524  CD9B07  	        CALL    OUTC            ; Output it
 618:	0527  218704  	        LD      HL,ERRMSG       ; "Error" message
 619:	052A  CD6012  	ERRIN:  CALL    PRS             ; Output message
 620:	052D  2AA120  	        LD      HL,(LINEAT)     ; Get line of error
 621:	0530  11FEFF  	        LD      DE,-2           ; Cold start error if -2
 622:	0533  CD8A07  	        CALL    CPDEHL          ; See if cold start error
 623:	0536  CA5E01  	        JP      Z,CSTART        ; Cold start error - Restart
 624:	0539  7C      	        LD      A,H             ; Was it a direct error?
 625:	053A  A5      	        AND     L               ; Line = -1 if direct error
 626:	053B  3C      	        INC     A
 627:	053C  C4FB18  	        CALL    NZ,LINEIN       ; No - output line of error
 628:	053F  3E      	        .DB     3EH             ; Skip "POP BC"
 629:	0540  C1      	POPNOK: POP     BC              ; Drop address in input buffer
 630:			
 631:	0541  AF      	PRNTOK: XOR     A               ; Output "Ok" and get command
 632:	0542  328A20  	        LD      (CTLOFG),A      ; Enable output
 633:	0545  CDB50B  	        CALL    STTLIN          ; Start new line
 634:	0548  219304  	        LD      HL,OKMSG        ; "Ok" message
 635:	054B  CD6012  	        CALL    PRS             ; Output "Ok"
 636:	054E  21FFFF  	GETCMD: LD      HL,-1           ; Flag direct mode
 637:	0551  22A120  	        LD      (LINEAT),HL     ; Save as current line
 638:	0554  CD2707  	        CALL    GETLIN          ; Get an input line
 639:	0557  DA4E05  	        JP      C,GETCMD        ; Get line again if break
 640:	055A  CD1A09  	        CALL    GETCHR          ; Get first character
 641:	055D  3C      	        INC     A               ; Test if end of line
 642:	055E  3D      	        DEC     A               ; Without affecting Carry
 643:	055F  CA4E05  	        JP      Z,GETCMD        ; Nothing entered - Get another
 644:	0562  F5      	        PUSH    AF              ; Save Carry status
 645:	0563  CDE609  	        CALL    ATOH            ; Get line number into DE
 646:	0566  D5      	        PUSH    DE              ; Save line number
 647:	0567  CD5206  	        CALL    CRUNCH          ; Tokenise rest of line
 648:	056A  47      	        LD      B,A             ; Length of tokenised line
 649:	056B  D1      	        POP     DE              ; Restore line number
 650:	056C  F1      	        POP     AF              ; Restore Carry
 651:	056D  D2FA08  	        JP      NC,EXCUTE       ; No line number - Direct mode
 652:	0570  D5      	        PUSH    DE              ; Save line number
 653:	0571  C5      	        PUSH    BC              ; Save length of tokenised line
 654:	0572  AF      	        XOR     A
 655:	0573  321121  	        LD      (LSTBIN),A      ; Clear last byte input
 656:	0576  CD1A09  	        CALL    GETCHR          ; Get next character
 657:	0579  B7      	        OR      A               ; Set flags
 658:	057A  F5      	        PUSH    AF              ; And save them
 659:	057B  CDE205  	        CALL    SRCHLN          ; Search for line number in DE
 660:	057E  DA8705  	        JP      C,LINFND        ; Jump if line found
 661:	0581  F1      	        POP     AF              ; Get status
 662:	0582  F5      	        PUSH    AF              ; And re-save
 663:	0583  CA870A  	        JP      Z,ULERR         ; Nothing after number - Error
 664:	0586  B7      	        OR      A               ; Clear Carry
 665:	0587  C5      	LINFND: PUSH    BC              ; Save address of line in prog
 666:	0588  D29E05  	        JP      NC,INEWLN       ; Line not found - Insert new
 667:	058B  EB      	        EX      DE,HL           ; Next line address in DE
 668:	058C  2A1B21  	        LD      HL,(PROGND)     ; End of program
 669:	058F  1A      	SFTPRG: LD      A,(DE)          ; Shift rest of program down
 670:	0590  02      	        LD      (BC),A
 671:	0591  03      	        INC     BC              ; Next destination
 672:	0592  13      	        INC     DE              ; Next source
 673:	0593  CD8A07  	        CALL    CPDEHL          ; All done?
 674:	0596  C28F05  	        JP      NZ,SFTPRG       ; More to do
 675:	0599  60      	        LD      H,B             ; HL - New end of program
 676:	059A  69      	        LD      L,C
 677:	059B  221B21  	        LD      (PROGND),HL     ; Update end of program
 678:			
 679:	059E  D1      	INEWLN: POP     DE              ; Get address of line,
 680:	059F  F1      	        POP     AF              ; Get status
 681:	05A0  CAC505  	        JP      Z,SETPTR        ; No text - Set up pointers
 682:	05A3  2A1B21  	        LD      HL,(PROGND)     ; Get end of program
 683:	05A6  E3      	        EX      (SP),HL         ; Get length of input line
 684:	05A7  C1      	        POP     BC              ; End of program to BC
 685:	05A8  09      	        ADD     HL,BC           ; Find new end
 686:	05A9  E5      	        PUSH    HL              ; Save new end
 687:	05AA  CDC204  	        CALL    MOVUP           ; Make space for line
 688:	05AD  E1      	        POP     HL              ; Restore new end
 689:	05AE  221B21  	        LD      (PROGND),HL     ; Update end of program pointer
 690:	05B1  EB      	        EX      DE,HL           ; Get line to move up in HL
 691:	05B2  74      	        LD      (HL),H          ; Save MSB
 692:	05B3  D1      	        POP     DE              ; Get new line number
 693:	05B4  23      	        INC     HL              ; Skip pointer
 694:	05B5  23      	        INC     HL
 695:	05B6  73      	        LD      (HL),E          ; Save LSB of line number
 696:	05B7  23      	        INC     HL
 697:	05B8  72      	        LD      (HL),D          ; Save MSB of line number
 698:	05B9  23      	        INC     HL              ; To first byte in line
 699:	05BA  11A620  	        LD      DE,BUFFER       ; Copy buffer to program
 700:	05BD  1A      	MOVBUF: LD      A,(DE)          ; Get source
 701:	05BE  77      	        LD      (HL),A          ; Save destinations
 702:	05BF  23      	        INC     HL              ; Next source
 703:	05C0  13      	        INC     DE              ; Next destination
 704:	05C1  B7      	        OR      A               ; Done?
 705:	05C2  C2BD05  	        JP      NZ,MOVBUF       ; No - Repeat
 706:	05C5  CD0E06  	SETPTR: CALL    RUNFST          ; Set line pointers
 707:	05C8  23      	        INC     HL              ; To LSB of pointer
 708:	05C9  EB      	        EX      DE,HL           ; Address to DE
 709:	05CA  62      	PTRLP:  LD      H,D             ; Address to HL
 710:	05CB  6B      	        LD      L,E
 711:	05CC  7E      	        LD      A,(HL)          ; Get LSB of pointer
 712:	05CD  23      	        INC     HL              ; To MSB of pointer
 713:	05CE  B6      	        OR      (HL)            ; Compare with MSB pointer
 714:	05CF  CA4E05  	        JP      Z,GETCMD        ; Get command line if end
 715:	05D2  23      	        INC     HL              ; To LSB of line number
 716:	05D3  23      	        INC     HL              ; Skip line number
 717:	05D4  23      	        INC     HL              ; Point to first byte in line
 718:	05D5  AF      	        XOR     A               ; Looking for 00 byte
 719:	05D6  BE      	FNDEND: CP      (HL)            ; Found end of line?
 720:	05D7  23      	        INC     HL              ; Move to next byte
 721:	05D8  C2D605  	        JP      NZ,FNDEND       ; No - Keep looking
 722:	05DB  EB      	        EX      DE,HL           ; Next line address to HL
 723:	05DC  73      	        LD      (HL),E          ; Save LSB of pointer
 724:	05DD  23      	        INC     HL
 725:	05DE  72      	        LD      (HL),D          ; Save MSB of pointer
 726:	05DF  C3CA05  	        JP      PTRLP           ; Do next line
 727:			
 728:	05E2  2AA320  	SRCHLN: LD      HL,(BASTXT)     ; Start of program text
 729:	05E5  44      	SRCHLP: LD      B,H             ; BC = Address to look at
 730:	05E6  4D      	        LD      C,L
 731:	05E7  7E      	        LD      A,(HL)          ; Get address of next line
 732:	05E8  23      	        INC     HL
 733:	05E9  B6      	        OR      (HL)            ; End of program found?
 734:	05EA  2B      	        DEC     HL
 735:	05EB  C8      	        RET     Z               ; Yes - Line not found
 736:	05EC  23      	        INC     HL
 737:	05ED  23      	        INC     HL
 738:	05EE  7E      	        LD      A,(HL)          ; Get LSB of line number
 739:	05EF  23      	        INC     HL
 740:	05F0  66      	        LD      H,(HL)          ; Get MSB of line number
 741:	05F1  6F      	        LD      L,A
 742:	05F2  CD8A07  	        CALL    CPDEHL          ; Compare with line in DE
 743:	05F5  60      	        LD      H,B             ; HL = Start of this line
 744:	05F6  69      	        LD      L,C
 745:	05F7  7E      	        LD      A,(HL)          ; Get LSB of next line address
 746:	05F8  23      	        INC     HL
 747:	05F9  66      	        LD      H,(HL)          ; Get MSB of next line address
 748:	05FA  6F      	        LD      L,A             ; Next line to HL
 749:	05FB  3F      	        CCF
 750:	05FC  C8      	        RET     Z               ; Lines found - Exit
 751:	05FD  3F      	        CCF
 752:	05FE  D0      	        RET     NC              ; Line not found,at line after
 753:	05FF  C3E505  	        JP      SRCHLP          ; Keep looking
 754:			
 755:	0602  C0      	NEW:    RET     NZ              ; Return if any more on line
 756:	0603  2AA320  	CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
 757:	0606  AF      	        XOR     A               ; Set program area to empty
 758:	0607  77      	        LD      (HL),A          ; Save LSB = 00
 759:	0608  23      	        INC     HL
 760:	0609  77      	        LD      (HL),A          ; Save MSB = 00
 761:	060A  23      	        INC     HL
 762:	060B  221B21  	        LD      (PROGND),HL     ; Set program end
 763:			
 764:	060E  2AA320  	RUNFST: LD      HL,(BASTXT)     ; Clear all variables
 765:	0611  2B      	        DEC     HL
 766:			
 767:	0612  221321  	INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
 768:	0615  2AF420  	        LD      HL,(LSTRAM)     ; Get end of RAM
 769:	0618  220821  	        LD      (STRBOT),HL     ; Clear string space
 770:	061B  AF      	        XOR     A
 771:	061C  CD2A09  	        CALL    RESTOR          ; Reset DATA pointers
 772:	061F  2A1B21  	        LD      HL,(PROGND)     ; Get end of program
 773:	0622  221D21  	        LD      (VAREND),HL     ; Clear variables
 774:	0625  221F21  	        LD      (ARREND),HL     ; Clear arrays
 775:			
 776:	0628  C1      	CLREG:  POP     BC              ; Save return address
 777:	0629  2A9F20  	        LD      HL,(STRSPC)     ; Get end of working RAN
 778:	062C  F9      	        LD      SP,HL           ; Set stack
 779:	062D  21F820  	        LD      HL,TMSTPL       ; Temporary string pool
 780:	0630  22F620  	        LD      (TMSTPT),HL     ; Reset temporary string ptr
 781:	0633  AF      	        XOR     A               ; A = 00
 782:	0634  6F      	        LD      L,A             ; HL = 0000
 783:	0635  67      	        LD      H,A
 784:	0636  221921  	        LD      (CONTAD),HL     ; No CONTinue
 785:	0639  321021  	        LD      (FORFLG),A      ; Clear FOR flag
 786:	063C  222321  	        LD      (FNRGNM),HL     ; Clear FN argument
 787:	063F  E5      	        PUSH    HL              ; HL = 0000
 788:	0640  C5      	        PUSH    BC              ; Put back return
 789:	0641  2A1321  	DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
 790:	0644  C9      	        RET                     ; Return to execution driver
 791:			
 792:	0645  3E3F    	PROMPT: LD      A,'?'           ; '?'
 793:	0647  CD9B07  	        CALL    OUTC            ; Output character
 794:	064A  3E20    	        LD      A,' '           ; Space
 795:	064C  CD9B07  	        CALL    OUTC            ; Output character
 796:	064F  C39320  	        JP      RINPUT          ; Get input line
 797:			
 798:	0652  AF      	CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
 799:	0653  32F320  	        LD      (DATFLG),A      ; Reset literal flag
 800:	0656  0E05    	        LD      C,2+3           ; 2 byte number and 3 nulls
 801:	0658  11A620  	        LD      DE,BUFFER       ; Start of input buffer
 802:	065B  7E      	CRNCLP: LD      A,(HL)          ; Get byte
 803:	065C  FE20    	        CP      ' '             ; Is it a space?
 804:	065E  CADA06  	        JP      Z,MOVDIR        ; Yes - Copy direct
 805:	0661  47      	        LD      B,A             ; Save character
 806:	0662  FE22    	        CP      '"'             ; Is it a quote?
 807:	0664  CAFA06  	        JP      Z,CPYLIT        ; Yes - Copy literal string
 808:	0667  B7      	        OR      A               ; Is it end of buffer?
 809:	0668  CA0107  	        JP      Z,ENDBUF        ; Yes - End buffer
 810:	066B  3AF320  	        LD      A,(DATFLG)      ; Get data type
 811:	066E  B7      	        OR      A               ; Literal?
 812:	066F  7E      	        LD      A,(HL)          ; Get byte to copy
 813:	0670  C2DA06  	        JP      NZ,MOVDIR       ; Literal - Copy direct
 814:	0673  FE3F    	        CP      '?'             ; Is it '?' short for PRINT
 815:	0675  3E9E    	        LD      A,ZPRINT        ; "PRINT" token
 816:	0677  CADA06  	        JP      Z,MOVDIR        ; Yes - replace it
 817:	067A  7E      	        LD      A,(HL)          ; Get byte again
 818:	067B  FE30    	        CP      '0'             ; Is it less than '0'
 819:	067D  DA8506  	        JP      C,FNDWRD        ; Yes - Look for reserved words
 820:	0680  FE3C    	        CP      60; ";"+1           ; Is it "0123456789:;" ?
 821:	0682  DADA06  	        JP      C,MOVDIR        ; Yes - copy it direct
 822:	0685  D5      	FNDWRD: PUSH    DE              ; Look for reserved words
 823:	0686  117E02  	        LD      DE,WORDS-1      ; Point to table
 824:	0689  C5      	        PUSH    BC              ; Save count
 825:	068A  01D606  	        LD      BC,RETNAD       ; Where to return to
 826:	068D  C5      	        PUSH    BC              ; Save return address
 827:	068E  067F    	        LD      B,ZEND-1        ; First token value -1
 828:	0690  7E      	        LD      A,(HL)          ; Get byte
 829:	0691  FE61    	        CP      'a'             ; Less than 'a' ?
 830:	0693  DA9E06  	        JP      C,SEARCH        ; Yes - search for words
 831:	0696  FE7B    	        CP      'z'+1           ; Greater than 'z' ?
 832:	0698  D29E06  	        JP      NC,SEARCH       ; Yes - search for words
 833:	069B  E65F    	        AND     01011111B       ; Force upper case
 834:	069D  77      	        LD      (HL),A          ; Replace byte
 835:	069E  4E      	SEARCH: LD      C,(HL)          ; Search for a word
 836:	069F  EB      	        EX      DE,HL
 837:	06A0  23      	GETNXT: INC     HL              ; Get next reserved word
 838:	06A1  B6      	        OR      (HL)            ; Start of word?
 839:	06A2  F2A006  	        JP      P,GETNXT        ; No - move on
 840:	06A5  04      	        INC     B               ; Increment token value
 841:	06A6  7E      	        LD      A, (HL)         ; Get byte from table
 842:	06A7  E67F    	        AND     01111111B       ; Strip bit 7
 843:	06A9  C8      	        RET     Z               ; Return if end of list
 844:	06AA  B9      	        CP      C               ; Same character as in buffer?
 845:	06AB  C2A006  	        JP      NZ,GETNXT       ; No - get next word
 846:	06AE  EB      	        EX      DE,HL
 847:	06AF  E5      	        PUSH    HL              ; Save start of word
 848:			
 849:	06B0  13      	NXTBYT: INC     DE              ; Look through rest of word
 850:	06B1  1A      	        LD      A,(DE)          ; Get byte from table
 851:	06B2  B7      	        OR      A               ; End of word ?
 852:	06B3  FAD206  	        JP      M,MATCH         ; Yes - Match found
 853:	06B6  4F      	        LD      C,A             ; Save it
 854:	06B7  78      	        LD      A,B             ; Get token value
 855:	06B8  FE88    	        CP      ZGOTO           ; Is it "GOTO" token ?
 856:	06BA  C2C106  	        JP      NZ,NOSPC        ; No - Don't allow spaces
 857:	06BD  CD1A09  	        CALL    GETCHR          ; Get next character
 858:	06C0  2B      	        DEC     HL              ; Cancel increment from GETCHR
 859:	06C1  23      	NOSPC:  INC     HL              ; Next byte
 860:	06C2  7E      	        LD      A,(HL)          ; Get byte
 861:	06C3  FE61    	        CP      'a'             ; Less than 'a' ?
 862:	06C5  DACA06  	        JP      C,NOCHNG        ; Yes - don't change
 863:	06C8  E65F    	        AND     01011111B       ; Make upper case
 864:	06CA  B9      	NOCHNG: CP      C               ; Same as in buffer ?
 865:	06CB  CAB006  	        JP      Z,NXTBYT        ; Yes - keep testing
 866:	06CE  E1      	        POP     HL              ; Get back start of word
 867:	06CF  C39E06  	        JP      SEARCH          ; Look at next word
 868:			
 869:	06D2  48      	MATCH:  LD      C,B             ; Word found - Save token value
 870:	06D3  F1      	        POP     AF              ; Throw away return
 871:	06D4  EB      	        EX      DE,HL
 872:	06D5  C9      	        RET                     ; Return to "RETNAD"
 873:	06D6  EB      	RETNAD: EX      DE,HL           ; Get address in string
 874:	06D7  79      	        LD      A,C             ; Get token value
 875:	06D8  C1      	        POP     BC              ; Restore buffer length
 876:	06D9  D1      	        POP     DE              ; Get destination address
 877:	06DA  23      	MOVDIR: INC     HL              ; Next source in buffer
 878:	06DB  12      	        LD      (DE),A          ; Put byte in buffer
 879:	06DC  13      	        INC     DE              ; Move up buffer
 880:	06DD  0C      	        INC     C               ; Increment length of buffer
 881:	06DE  D63A    	        SUB     ':'             ; End of statement?
 882:	06E0  CAE806  	        JP      Z,SETLIT        ; Jump if multi-statement line
 883:	06E3  FE49    	        CP      ZDATA-3AH       ; Is it DATA statement ?
 884:	06E5  C2EB06  	        JP      NZ,TSTREM       ; No - see if REM
 885:	06E8  32F320  	SETLIT: LD      (DATFLG),A      ; Set literal flag
 886:	06EB  D654    	TSTREM: SUB     ZREM-3AH        ; Is it REM?
 887:	06ED  C25B06  	        JP      NZ,CRNCLP       ; No - Leave flag
 888:	06F0  47      	        LD      B,A             ; Copy rest of buffer
 889:	06F1  7E      	NXTCHR: LD      A,(HL)          ; Get byte
 890:	06F2  B7      	        OR      A               ; End of line ?
 891:	06F3  CA0107  	        JP      Z,ENDBUF        ; Yes - Terminate buffer
 892:	06F6  B8      	        CP      B               ; End of statement ?
 893:	06F7  CADA06  	        JP      Z,MOVDIR        ; Yes - Get next one
 894:	06FA  23      	CPYLIT: INC     HL              ; Move up source string
 895:	06FB  12      	        LD      (DE),A          ; Save in destination
 896:	06FC  0C      	        INC     C               ; Increment length
 897:	06FD  13      	        INC     DE              ; Move up destination
 898:	06FE  C3F106  	        JP      NXTCHR          ; Repeat
 899:			
 900:	0701  21A520  	ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
 901:	0704  12      	        LD      (DE),A          ; Mark end of buffer (A = 00)
 902:	0705  13      	        INC     DE
 903:	0706  12      	        LD      (DE),A          ; A = 00
 904:	0707  13      	        INC     DE
 905:	0708  12      	        LD      (DE),A          ; A = 00
 906:	0709  C9      	        RET
 907:			
 908:	0000          	        .if 0
 924:			        .endif
 925:			
 926:	070A  05      	DELCHR: DEC     B               ; Count bytes in buffer
 927:	070B  2B      	        DEC     HL              ; Back space buffer
 928:	070C  3E08    	        LD      A,BKSP
 929:	070E  CD9B07  	        CALL    OUTC            ; Back one char
 930:	0711  3E20    	        LD      A,SPACE
 931:	0713  CD9B07  	        CALL    OUTC            ; Overwrite char
 932:	0716  3E08    	        LD      A,BKSP
 933:	0718  CD9B07  	        CALL    OUTC            ; Back one char
 934:	071B  C22C07  	        JP      NZ,MORINP       ; Not end - Get more
 935:	071E  CD9B07  	OTKLN:  CALL    OUTC            ; Output character in A
 936:	0721  CDC20B  	KILIN:  CALL    PRNTCRLF        ; Output CRLF
 937:	0724  C32707  	        JP      TTYLIN          ; Get line again
 938:			
 939:	0727          	GETLIN:
 940:	0727  21A620  	TTYLIN: LD      HL,BUFFER       ; Get a line by character
 941:	072A  0601    	        LD      B,1             ; Set buffer as empty
 942:			        ;XOR     A
 943:			        ;LD      (NULFLG),A      ; Clear null flag
 944:	072C  CDC507  	MORINP: CALL    CLOTST          ; Get character and test ^O
 945:	072F  4F      	        LD      C,A             ; Save character in C
 946:	0000          	        .if 0
 956:			        .endif
 957:	0730  79      	PROCES: LD      A,C             ; Get character
 958:			;        CP      CTRLG           ; Bell?
 959:			;        JP      Z,PUTCTL        ; Yes - Save it
 960:	0731  FE03    	        CP      CTRLC           ; Is it control "C"?
 961:	0733  CCC20B  	        CALL    Z,PRNTCRLF      ; Yes - Output CRLF
 962:	0736  37      	        SCF                     ; Flag break
 963:	0737  C8      	        RET     Z               ; Return if control "C"
 964:	0738  FE0D    	        CP      CR              ; Is it enter?
 965:	073A  CABD0B  	        JP      Z,ENDINP        ; Yes - Terminate input
 966:	073D  FE15    	        CP      CTRLU           ; Is it control "U"?
 967:	073F  CA2107  	        JP      Z,KILIN         ; Yes - Get another line
 968:	0742  FE18    	        CP      CAN             ; Is it "kill line"?
 969:	0744  CA2107  	        JP      Z,KILIN ;OTKLN         ; Yes - Kill line
 970:	0747  FE7F    	        CP      DEL             ; Is it delete?
 971:	0749  CA0A07  	        JP      Z,DELCHR        ; Yes - Delete character
 972:	074C  FE08    	        CP      BKSP            ; Is it backspace?
 973:	074E  CA0A07  	        JP      Z,DELCHR        ; Yes - Delete character
 974:	0751  FE12    	        CP      CTRLR           ; Is it control "R"?
 975:	0753  C26A07  	        JP      NZ,PUTBUF       ; No - Put in buffer
 976:	0756  C5      	        PUSH    BC              ; Save buffer length
 977:	0757  D5      	        PUSH    DE              ; Save DE
 978:	0758  E5      	        PUSH    HL              ; Save buffer address
 979:	0759  3600    	        LD      (HL),0          ; Mark end of buffer
 980:	075B  CD701D  	        CALL    OUTNCR          ; Output and do CRLF
 981:	075E  21A620  	        LD      HL,BUFFER       ; Point to buffer start
 982:	0761  CD6012  	        CALL    PRS             ; Output buffer
 983:	0764  E1      	        POP     HL              ; Restore buffer address
 984:	0765  D1      	        POP     DE              ; Restore DE
 985:	0766  C1      	        POP     BC              ; Restore buffer length
 986:	0767  C32C07  	        JP      MORINP          ; Get another character
 987:			
 988:	076A  FE20    	PUTBUF: CP      ' '             ; Is it a control code?
 989:	076C  DA2C07  	        JP      C,MORINP        ; Yes - Ignore
 990:	076F  78      	PUTCTL: LD      A,B             ; Get number of bytes in buffer
 991:	0770  FE49    	        CP      72+1            ; Test for line overflow
 992:	0772  DA7D07  	        JP      C,PUTB1         ; No, carry on
 993:	0775  3E07    	        LD      A,CTRLG         ; Set a bell
 994:	0777  CD9B07  	        CALL    OUTC            ; Ring bell if buffer full
 995:	077A  C32C07  	        JP      MORINP          ;
 996:	077D  79      	PUTB1:  LD      A,C             ; Get character
 997:	077E  71      	        LD      (HL),C          ; Save in buffer
 998:	077F  321121  	        LD      (LSTBIN),A      ; Save last input byte
 999:	0782  23      	        INC     HL              ; Move up buffer
1000:	0783  04      	        INC     B               ; Increment length
1001:	0784  CD9B07  	OUTIT:  CALL    OUTC            ; Output the character entered
1002:	0787  C32C07  	        JP      MORINP          ; Get another character
1003:			
1004:			;OUTNBS: CALL    OUTC            ; Output bell and back over it
1005:			;        LD      A,BKSP          ; Set back space
1006:			;        JP      OUTIT           ; Output it and get more
1007:			
1008:	078A  7C      	CPDEHL: LD      A,H             ; Get H
1009:	078B  92      	        SUB     D               ; Compare with D
1010:	078C  C0      	        RET     NZ              ; Different - Exit
1011:	078D  7D      	        LD      A,L             ; Get L
1012:	078E  93      	        SUB     E               ; Compare with E
1013:	078F  C9      	        RET                     ; Return status
1014:			
1015:	0790  7E      	CHKSYN: LD      A,(HL)          ; Check syntax of character
1016:	0791  E3      	        EX      (SP),HL         ; Address of test byte
1017:	0792  BE      	        CP      (HL)            ; Same as in code string?
1018:	0793  23      	        INC     HL              ; Return address
1019:	0794  E3      	        EX      (SP),HL         ; Put it back
1020:	0795  CA1A09  	        JP      Z,GETCHR        ; Yes - Get next character
1021:	0798  C3F604  	        JP      SNERR           ; Different - ?SN Error
1022:			
1023:	079B  F5      	OUTC:   PUSH    AF              ; Save character
1024:	079C  3A8A20  	        LD      A,(CTLOFG)      ; Get control "O" flag
1025:	079F  B7      	        OR      A               ; Is it set?
1026:	07A0  C29512  	        JP      NZ,POPAF        ; Yes - don't output
1027:	07A3  F1      	        POP     AF              ; Restore character
1028:	07A4  C5      	        PUSH    BC              ; Save buffer length
1029:	07A5  F5      	        PUSH    AF              ; Save character
1030:	07A6  FE20    	        CP      ' '             ; Is it a control code?
1031:	07A8  DABF07  	        JP      C,DINPOS        ; Yes - Don't INC POS(X)
1032:	07AB  3A8720  	        LD      A,(LWIDTH)      ; Get line width
1033:	07AE  47      	        LD      B,A             ; To B
1034:	07AF  3AF020  	        LD      A,(CURPOS)      ; Get cursor position
1035:	07B2  04      	        INC     B               ; Width 255?
1036:	07B3  CABB07  	        JP      Z,INCLEN        ; Yes - No width limit
1037:	07B6  05      	        DEC     B               ; Restore width
1038:	07B7  B8      	        CP      B               ; At end of line?
1039:	07B8  CCC20B  	        CALL    Z,PRNTCRLF      ; Yes - output CRLF
1040:	07BB  3C      	INCLEN: INC     A               ; Move on one character
1041:	07BC  32F020  	        LD      (CURPOS),A      ; Save new position
1042:	07BF  F1      	DINPOS: POP     AF              ; Restore character
1043:	07C0  C1      	        POP     BC              ; Restore buffer length
1044:	07C1  CD5B1D  	        CALL    MONOUT          ; Send it
1045:	07C4  C9      	        RET
1046:			
1047:	07C5  CD1F1C  	CLOTST: CALL    GETINP          ; Get input character
1048:	07C8  E67F    	        AND     01111111B       ; Strip bit 7
1049:	07CA  FE0F    	        CP      CTRLO           ; Is it control "O"?
1050:	07CC  C0      	        RET     NZ              ; No don't flip flag
1051:	07CD  3A8A20  	        LD      A,(CTLOFG)      ; Get flag
1052:	07D0  2F      	        CPL                     ; Flip it
1053:	07D1  328A20  	        LD      (CTLOFG),A      ; Put it back
1054:	07D4  AF      	        XOR     A               ; Null character
1055:	07D5  C9      	        RET
1056:			
1057:	07D6  CDE609  	LIST:   CALL    ATOH            ; ASCII number to DE
1058:	07D9  C0      	        RET     NZ              ; Return if anything extra
1059:	07DA  C1      	        POP     BC              ; Rubbish - Not needed
1060:	07DB  CDE205  	        CALL    SRCHLN          ; Search for line number in DE
1061:	07DE  C5      	        PUSH    BC              ; Save address of line
1062:	07DF  CD2C08  	        CALL    SETLIN          ; Set up lines counter
1063:	07E2  E1      	LISTLP: POP     HL              ; Restore address of line
1064:	07E3  4E      	        LD      C,(HL)          ; Get LSB of next line
1065:	07E4  23      	        INC     HL
1066:	07E5  46      	        LD      B,(HL)          ; Get MSB of next line
1067:	07E6  23      	        INC     HL
1068:	07E7  78      	        LD      A,B             ; BC = 0 (End of program)?
1069:	07E8  B1      	        OR      C
1070:	07E9  CA4105  	        JP      Z,PRNTOK        ; Yes - Go to command mode
1071:	07EC  CD3508  	        CALL    COUNT           ; Count lines
1072:	07EF  CD4509  	        CALL    TSTBRK          ; Test for break key
1073:	07F2  C5      	        PUSH    BC              ; Save address of next line
1074:	07F3  CDC20B  	        CALL    PRNTCRLF        ; Output CRLF
1075:	07F6  5E      	        LD      E,(HL)          ; Get LSB of line number
1076:	07F7  23      	        INC     HL
1077:	07F8  56      	        LD      D,(HL)          ; Get MSB of line number
1078:	07F9  23      	        INC     HL
1079:	07FA  E5      	        PUSH    HL              ; Save address of line start
1080:	07FB  EB      	        EX      DE,HL           ; Line number to HL
1081:	07FC  CD0319  	        CALL    PRNTHL          ; Output line number in decimal
1082:	07FF  3E20    	        LD      A,' '           ; Space after line number
1083:	0801  E1      	        POP     HL              ; Restore start of line address
1084:	0802  CD9B07  	LSTLP2: CALL    OUTC            ; Output character in A
1085:	0805  7E      	LSTLP3: LD      A,(HL)          ; Get next byte in line
1086:	0806  B7      	        OR      A               ; End of line?
1087:	0807  23      	        INC     HL              ; To next byte in line
1088:	0808  CAE207  	        JP      Z,LISTLP        ; Yes - get next line
1089:	080B  F20208  	        JP      P,LSTLP2        ; No token - output it
1090:	080E  D67F    	        SUB     ZEND-1          ; Find and output word
1091:	0810  4F      	        LD      C,A             ; Token offset+1 to C
1092:	0811  117F02  	        LD      DE,WORDS        ; Reserved word list
1093:	0814  1A      	FNDTOK: LD      A,(DE)          ; Get character in list
1094:	0815  13      	        INC     DE              ; Move on to next
1095:	0816  B7      	        OR      A               ; Is it start of word?
1096:	0817  F21408  	        JP      P,FNDTOK        ; No - Keep looking for word
1097:	081A  0D      	        DEC     C               ; Count words
1098:	081B  C21408  	        JP      NZ,FNDTOK       ; Not there - keep looking
1099:	081E  E67F    	OUTWRD: AND     01111111B       ; Strip bit 7
1100:	0820  CD9B07  	        CALL    OUTC            ; Output first character
1101:	0823  1A      	        LD      A,(DE)          ; Get next character
1102:	0824  13      	        INC     DE              ; Move on to next
1103:	0825  B7      	        OR      A               ; Is it end of word?
1104:	0826  F21E08  	        JP      P,OUTWRD        ; No - output the rest
1105:	0829  C30508  	        JP      LSTLP3          ; Next byte in line
1106:			
1107:	082C  E5      	SETLIN: PUSH    HL              ; Set up LINES counter
1108:	082D  2A8D20  	        LD      HL,(LINESN)     ; Get LINES number
1109:	0830  228B20  	        LD      (LINESC),HL     ; Save in LINES counter
1110:	0833  E1      	        POP     HL
1111:	0834  C9      	        RET
1112:			
1113:	0835  E5      	COUNT:  PUSH    HL              ; Save code string address
1114:	0836  D5      	        PUSH    DE
1115:	0837  2A8B20  	        LD      HL,(LINESC)     ; Get LINES counter
1116:	083A  11FFFF  	        LD      DE,-1
1117:	083D  ED5A    	        ADC     HL,DE           ; Decrement
1118:	083F  228B20  	        LD      (LINESC),HL     ; Put it back
1119:	0842  D1      	        POP     DE
1120:	0843  E1      	        POP     HL              ; Restore code string address
1121:	0844  F0      	        RET     P               ; Return if more lines to go
1122:	0845  E5      	        PUSH    HL              ; Save code string address
1123:	0846  2A8D20  	        LD      HL,(LINESN)     ; Get LINES number
1124:	0849  228B20  	        LD      (LINESC),HL     ; Reset LINES counter
1125:	084C  CD1F1C  	        CALL    GETINP          ; Get input character
1126:	084F  FE03    	        CP      CTRLC           ; Is it control "C"?
1127:	0851  CA5808  	        JP      Z,RSLNBK        ; Yes - Reset LINES and break
1128:	0854  E1      	        POP     HL              ; Restore code string address
1129:	0855  C33508  	        JP      COUNT           ; Keep on counting
1130:			
1131:	0858  2A8D20  	RSLNBK: LD      HL,(LINESN)     ; Get LINES number
1132:	085B  228B20  	        LD      (LINESC),HL     ; Reset LINES counter
1133:	085E  C3F401  	        JP      BRKRET          ; Go and output "Break"
1134:			
1135:	0861  3E64    	FOR:    LD      A,64H           ; Flag "FOR" assignment
1136:	0863  321021  	        LD      (FORFLG),A      ; Save "FOR" flag
1137:	0866  CDC80A  	        CALL    LET             ; Set up initial index
1138:	0869  C1      	        POP     BC              ; Drop RETurn address
1139:	086A  E5      	        PUSH    HL              ; Save code string address
1140:	086B  CDB10A  	        CALL    DATA            ; Get next statement address
1141:	086E  220C21  	        LD      (LOOPST),HL     ; Save it for start of loop
1142:	0871  210200  	        LD      HL,2            ; Offset for "FOR" block
1143:	0874  39      	        ADD     HL,SP           ; Point to it
1144:	0875  CDA304  	FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
1145:	0878  D1      	        POP     DE              ; Get code string address
1146:	0879  C29108  	        JP      NZ,FORFND       ; No nesting found
1147:	087C  09      	        ADD     HL,BC           ; Move into "FOR" block
1148:	087D  D5      	        PUSH    DE              ; Save code string address
1149:	087E  2B      	        DEC     HL
1150:	087F  56      	        LD      D,(HL)          ; Get MSB of loop statement
1151:	0880  2B      	        DEC     HL
1152:	0881  5E      	        LD      E,(HL)          ; Get LSB of loop statement
1153:	0882  23      	        INC     HL
1154:	0883  23      	        INC     HL
1155:	0884  E5      	        PUSH    HL              ; Save block address
1156:	0885  2A0C21  	        LD      HL,(LOOPST)     ; Get address of loop statement
1157:	0888  CD8A07  	        CALL    CPDEHL          ; Compare the FOR loops
1158:	088B  E1      	        POP     HL              ; Restore block address
1159:	088C  C27508  	        JP      NZ,FORSLP       ; Different FORs - Find another
1160:	088F  D1      	        POP     DE              ; Restore code string address
1161:	0890  F9      	        LD      SP,HL           ; Remove all nested loops
1162:			
1163:	0891  EB      	FORFND: EX      DE,HL           ; Code string address to HL
1164:	0892  0E08    	        LD      C,8
1165:	0894  CDD304  	        CALL    CHKSTK          ; Check for 8 levels of stack
1166:	0897  E5      	        PUSH    HL              ; Save code string address
1167:	0898  2A0C21  	        LD      HL,(LOOPST)     ; Get first statement of loop
1168:	089B  E3      	        EX      (SP),HL         ; Save and restore code string
1169:	089C  E5      	        PUSH    HL              ; Re-save code string address
1170:	089D  2AA120  	        LD      HL,(LINEAT)     ; Get current line number
1171:	08A0  E3      	        EX      (SP),HL         ; Save and restore code string
1172:	08A1  CD8A0D  	        CALL    TSTNUM          ; Make sure it's a number
1173:	08A4  CD9007  	        CALL    CHKSYN          ; Make sure "TO" is next
1174:	08A7  A6      	        .DB     ZTO             ; "TO" token
1175:	08A8  CD870D  	        CALL    GETNUM          ; Get "TO" expression value
1176:	08AB  E5      	        PUSH    HL              ; Save code string address
1177:	08AC  CDB517  	        CALL    BCDEFP          ; Move "TO" value to BCDE
1178:	08AF  E1      	        POP     HL              ; Restore code string address
1179:	08B0  C5      	        PUSH    BC              ; Save "TO" value in block
1180:	08B1  D5      	        PUSH    DE
1181:	08B2  010081  	        LD      BC,8100H        ; BCDE - 1 (default STEP)
1182:	08B5  51      	        LD      D,C             ; C=0
1183:	08B6  5A      	        LD      E,D             ; D=0
1184:	08B7  7E      	        LD      A,(HL)          ; Get next byte in code string
1185:	08B8  FEAB    	        CP      ZSTEP           ; See if "STEP" is stated
1186:	08BA  3E01    	        LD      A,1             ; Sign of step = 1
1187:	08BC  C2CD08  	        JP      NZ,SAVSTP       ; No STEP given - Default to 1
1188:	08BF  CD1A09  	        CALL    GETCHR          ; Jump over "STEP" token
1189:	08C2  CD870D  	        CALL    GETNUM          ; Get step value
1190:	08C5  E5      	        PUSH    HL              ; Save code string address
1191:	08C6  CDB517  	        CALL    BCDEFP          ; Move STEP to BCDE
1192:	08C9  CD6917  	        CALL    TSTSGN          ; Test sign of FPREG
1193:	08CC  E1      	        POP     HL              ; Restore code string address
1194:	08CD  C5      	SAVSTP: PUSH    BC              ; Save the STEP value in block
1195:	08CE  D5      	        PUSH    DE
1196:	08CF  F5      	        PUSH    AF              ; Save sign of STEP
1197:	08D0  33      	        INC     SP              ; Don't save flags
1198:	08D1  E5      	        PUSH    HL              ; Save code string address
1199:	08D2  2A1321  	        LD      HL,(BRKLIN)     ; Get address of index variable
1200:	08D5  E3      	        EX      (SP),HL         ; Save and restore code string
1201:	08D6  0681    	PUTFID: LD      B,ZFOR          ; "FOR" block marker
1202:	08D8  C5      	        PUSH    BC              ; Save it
1203:	08D9  33      	        INC     SP              ; Don't save C
1204:			
1205:	08DA  CD4509  	RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
1206:	08DD  221321  	        LD      (BRKLIN),HL     ; Save code address for break
1207:	08E0  7E      	        LD      A,(HL)          ; Get next byte in code string
1208:	08E1  FE3A    	        CP      ':'             ; Multi statement line?
1209:	08E3  CAFA08  	        JP      Z,EXCUTE        ; Yes - Execute it
1210:	08E6  B7      	        OR      A               ; End of line?
1211:	08E7  C2F604  	        JP      NZ,SNERR        ; No - Syntax error
1212:	08EA  23      	        INC     HL              ; Point to address of next line
1213:	08EB  7E      	        LD      A,(HL)          ; Get LSB of line pointer
1214:	08EC  23      	        INC     HL
1215:	08ED  B6      	        OR      (HL)            ; Is it zero (End of prog)?
1216:	08EE  CA6C09  	        JP      Z,ENDPRG        ; Yes - Terminate execution
1217:	08F1  23      	        INC     HL              ; Point to line number
1218:	08F2  5E      	        LD      E,(HL)          ; Get LSB of line number
1219:	08F3  23      	        INC     HL
1220:	08F4  56      	        LD      D,(HL)          ; Get MSB of line number
1221:	08F5  EB      	        EX      DE,HL           ; Line number to HL
1222:	08F6  22A120  	        LD      (LINEAT),HL     ; Save as current line number
1223:	08F9  EB      	        EX      DE,HL           ; Line number back to DE
1224:	08FA  CD1A09  	EXCUTE: CALL    GETCHR          ; Get key word
1225:	08FD  11DA08  	        LD      DE,RUNCNT       ; Where to RETurn to
1226:	0900  D5      	        PUSH    DE              ; Save for RETurn
1227:	0901  C8      	IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
1228:	0902  D680    	ONJMP:  SUB     ZEND            ; Is it a token?
1229:	0904  DAC80A  	        JP      C,LET           ; No - try to assign it
1230:	0907  FE25    	        CP      ZNEW+1-ZEND     ; END to NEW ?
1231:	0909  D2F604  	        JP      NC,SNERR        ; Not a key word - ?SN Error
1232:	090C  07      	        RLCA                    ; Double it
1233:	090D  4F      	        LD      C,A             ; BC = Offset into table
1234:	090E  0600    	        LD      B,0
1235:	0910  EB      	        EX      DE,HL           ; Save code string address
1236:	0911  219E03  	        LD      HL,WORDTB       ; Keyword address table
1237:	0914  09      	        ADD     HL,BC           ; Point to routine address
1238:	0915  4E      	        LD      C,(HL)          ; Get LSB of routine address
1239:	0916  23      	        INC     HL
1240:	0917  46      	        LD      B,(HL)          ; Get MSB of routine address
1241:	0918  C5      	        PUSH    BC              ; Save routine address
1242:	0919  EB      	        EX      DE,HL           ; Restore code string address
1243:			
1244:	091A  23      	GETCHR: INC     HL              ; Point to next character
1245:	091B  7E      	        LD      A,(HL)          ; Get next code string byte
1246:	091C  FE3A    	        CP      ':'             ; Z if ':'
1247:	091E  D0      	        RET     NC              ; NC if > "9"
1248:	091F  FE20    	        CP      ' '
1249:	0921  CA1A09  	        JP      Z,GETCHR        ; Skip over spaces
1250:	0924  FE30    	        CP      '0'
1251:	0926  3F      	        CCF                     ; NC if < '0'
1252:	0927  3C      	        INC     A               ; Test for zero - Leave carry
1253:	0928  3D      	        DEC     A               ; Z if Null
1254:	0929  C9      	        RET
1255:			
1256:	092A  EB      	RESTOR: EX      DE,HL           ; Save code string address
1257:	092B  2AA320  	        LD      HL,(BASTXT)     ; Point to start of program
1258:	092E  CA3F09  	        JP      Z,RESTNL        ; Just RESTORE - reset pointer
1259:	0931  EB      	        EX      DE,HL           ; Restore code string address
1260:	0932  CDE609  	        CALL    ATOH            ; Get line number to DE
1261:	0935  E5      	        PUSH    HL              ; Save code string address
1262:	0936  CDE205  	        CALL    SRCHLN          ; Search for line number in DE
1263:	0939  60      	        LD      H,B             ; HL = Address of line
1264:	093A  69      	        LD      L,C
1265:	093B  D1      	        POP     DE              ; Restore code string address
1266:	093C  D2870A  	        JP      NC,ULERR        ; ?UL Error if not found
1267:	093F  2B      	RESTNL: DEC     HL              ; Byte before DATA statement
1268:	0940  222121  	UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
1269:	0943  EB      	        EX      DE,HL           ; Restore code string address
1270:	0944  C9      	        RET
1271:			
1272:			
1273:	0945  DF      	TSTBRK: RST     18H             ; Check input status
1274:	0946  C8      	        RET     Z               ; No key, go back
1275:	0947  D7      	        RST     10H             ; Get the key into A
1276:	0948  FE1B    	        CP      ESC             ; Escape key?
1277:	094A  2811    	        JR      Z,BRK           ; Yes, break
1278:	094C  FE03    	        CP      CTRLC           ; <Ctrl-C>
1279:	094E  280D    	        JR      Z,BRK           ; Yes, break
1280:	0950  FE13    	        CP      CTRLS           ; Stop scrolling?
1281:	0952  C0      	        RET     NZ              ; Other key, ignore
1282:			
1283:			
1284:	0953  D7      	STALL:  RST     10H             ; Wait for key
1285:	0954  FE11    	        CP      CTRLQ           ; Resume scrolling?
1286:	0956  C8      	        RET      Z              ; Release the chokehold
1287:	0957  FE03    	        CP      CTRLC           ; Second break?
1288:	0959  2807    	        JR      Z,STOP          ; Break during hold exits prog
1289:	095B  18F6    	        JR      STALL           ; Loop until <Ctrl-Q> or <brk>
1290:			
1291:	095D  3EFF    	BRK     LD      A,0FFH          ; Set BRKFLG
1292:	095F  329220  	        LD      (BRKFLG),A      ; Store it
1293:			
1294:			
1295:	0962  C0      	STOP:   RET     NZ              ; Exit if anything else
1296:	0963  F6      	        .DB     0F6H            ; Flag "STOP"
1297:	0964  C0      	PEND:   RET     NZ              ; Exit if anything else
1298:	0965  221321  	        LD      (BRKLIN),HL     ; Save point of break
1299:	0968  21      	        .DB     21H             ; Skip "OR 11111111B"
1300:	0969  F6FF    	INPBRK: OR      11111111B       ; Flag "Break" wanted
1301:	096B  C1      	        POP     BC              ; Return not needed and more
1302:	096C  2AA120  	ENDPRG: LD      HL,(LINEAT)     ; Get current line number
1303:	096F  F5      	        PUSH    AF              ; Save STOP / END status
1304:	0970  7D      	        LD      A,L             ; Is it direct break?
1305:	0971  A4      	        AND     H
1306:	0972  3C      	        INC     A               ; Line is -1 if direct break
1307:	0973  CA7F09  	        JP      Z,NOLIN         ; Yes - No line number
1308:	0976  221721  	        LD      (ERRLIN),HL     ; Save line of break
1309:	0979  2A1321  	        LD      HL,(BRKLIN)     ; Get point of break
1310:	097C  221921  	        LD      (CONTAD),HL     ; Save point to CONTinue
1311:	097F  AF      	NOLIN:  XOR     A
1312:	0980  328A20  	        LD      (CTLOFG),A      ; Enable output
1313:	0983  CDB50B  	        CALL    STTLIN          ; Start a new line
1314:	0986  F1      	        POP     AF              ; Restore STOP / END status
1315:	0987  219904  	        LD      HL,BRKMSG       ; "Break" message
1316:	098A  C22A05  	        JP      NZ,ERRIN        ; "in line" wanted?
1317:	098D  C34105  	        JP      PRNTOK          ; Go to command mode
1318:			
1319:	0990  2A1921  	CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
1320:	0993  7C      	        LD      A,H             ; Is it zero?
1321:	0994  B5      	        OR      L
1322:	0995  1E20    	        LD      E,CN            ; ?CN Error
1323:	0997  CA0A05  	        JP      Z,ERROR         ; Yes - output "?CN Error"
1324:	099A  EB      	        EX      DE,HL           ; Save code string address
1325:	099B  2A1721  	        LD      HL,(ERRLIN)     ; Get line of last break
1326:	099E  22A120  	        LD      (LINEAT),HL     ; Set up current line number
1327:	09A1  EB      	        EX      DE,HL           ; Restore code string address
1328:	09A2  C9      	        RET                     ; CONTinue where left off
1329:			
1330:	09A3  CDE814  	NULL:   CALL    GETINT          ; Get integer 0-255
1331:	09A6  C0      	        RET     NZ              ; Return if bad value
1332:	09A7  328620  	        LD      (NULLS),A       ; Set nulls number
1333:	09AA  C9      	        RET
1334:			
1335:			
1336:	09AB  E5      	ACCSUM: PUSH    HL              ; Save address in array
1337:	09AC  2A8F20  	        LD      HL,(CHKSUM)     ; Get check sum
1338:	09AF  0600    	        LD      B,0             ; BC - Value of byte
1339:	09B1  4F      	        LD      C,A
1340:	09B2  09      	        ADD     HL,BC           ; Add byte to check sum
1341:	09B3  228F20  	        LD      (CHKSUM),HL     ; Re-save check sum
1342:	09B6  E1      	        POP     HL              ; Restore address in array
1343:	09B7  C9      	        RET
1344:			
1345:	09B8  7E      	CHKLTR: LD      A,(HL)          ; Get byte
1346:	09B9  FE41    	        CP      'A'             ; < 'a' ?
1347:	09BB  D8      	        RET     C               ; Carry set if not letter
1348:	09BC  FE5B    	        CP      'Z'+1           ; > 'z' ?
1349:	09BE  3F      	        CCF
1350:	09BF  C9      	        RET                     ; Carry set if not letter
1351:			
1352:	09C0  CD1A09  	FPSINT: CALL    GETCHR          ; Get next character
1353:	09C3  CD870D  	POSINT: CALL    GETNUM          ; Get integer 0 to 32767
1354:	09C6  CD6917  	DEPINT: CALL    TSTSGN          ; Test sign of FPREG
1355:	09C9  FAE109  	        JP      M,FCERR         ; Negative - ?FC Error
1356:	09CC  3A2C21  	DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
1357:	09CF  FE90    	        CP      80H+16          ; Exponent in range (16 bits)?
1358:	09D1  DA1118  	        JP      C,FPINT         ; Yes - convert it
1359:	09D4  018090  	        LD      BC,9080H        ; BCDE = -32768
1360:	09D7  110000  	        LD      DE,0000
1361:	09DA  E5      	        PUSH    HL              ; Save code string address
1362:	09DB  CDE417  	        CALL    CMPNUM          ; Compare FPREG with BCDE
1363:	09DE  E1      	        POP     HL              ; Restore code string address
1364:	09DF  51      	        LD      D,C             ; MSB to D
1365:	09E0  C8      	        RET     Z               ; Return if in range
1366:	09E1  1E08    	FCERR:  LD      E,FC            ; ?FC Error
1367:	09E3  C30A05  	        JP      ERROR           ; Output error-
1368:			
1369:	09E6  2B      	ATOH:   DEC     HL              ; ASCII number to DE binary
1370:	09E7  110000  	GETLN:  LD      DE,0            ; Get number to DE
1371:	09EA  CD1A09  	GTLNLP: CALL    GETCHR          ; Get next character
1372:	09ED  D0      	        RET     NC              ; Exit if not a digit
1373:	09EE  E5      	        PUSH    HL              ; Save code string address
1374:	09EF  F5      	        PUSH    AF              ; Save digit
1375:	09F0  219819  	        LD      HL,65529/10     ; Largest number 65529
1376:	09F3  CD8A07  	        CALL    CPDEHL          ; Number in range?
1377:	09F6  DAF604  	        JP      C,SNERR         ; No - ?SN Error
1378:	09F9  62      	        LD      H,D             ; HL = Number
1379:	09FA  6B      	        LD      L,E
1380:	09FB  19      	        ADD     HL,DE           ; Times 2
1381:	09FC  29      	        ADD     HL,HL           ; Times 4
1382:	09FD  19      	        ADD     HL,DE           ; Times 5
1383:	09FE  29      	        ADD     HL,HL           ; Times 10
1384:	09FF  F1      	        POP     AF              ; Restore digit
1385:	0A00  D630    	        SUB     '0'             ; Make it 0 to 9
1386:	0A02  5F      	        LD      E,A             ; DE = Value of digit
1387:	0A03  1600    	        LD      D,0
1388:	0A05  19      	        ADD     HL,DE           ; Add to number
1389:	0A06  EB      	        EX      DE,HL           ; Number to DE
1390:	0A07  E1      	        POP     HL              ; Restore code string address
1391:	0A08  C3EA09  	        JP      GTLNLP          ; Go to next character
1392:			
1393:	0A0B  CA1206  	CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
1394:	0A0E  CDC309  	        CALL    POSINT          ; Get integer 0 to 32767 to DE
1395:	0A11  2B      	        DEC     HL              ; Cancel increment
1396:	0A12  CD1A09  	        CALL    GETCHR          ; Get next character
1397:	0A15  E5      	        PUSH    HL              ; Save code string address
1398:	0A16  2AF420  	        LD      HL,(LSTRAM)     ; Get end of RAM
1399:	0A19  CA2E0A  	        JP      Z,STORED        ; No value given - Use stored
1400:	0A1C  E1      	        POP     HL              ; Restore code string address
1401:	0A1D  CD9007  	        CALL    CHKSYN          ; Check for comma
1402:	0A20  2C      	        .DB     ','
1403:	0A21  D5      	        PUSH    DE              ; Save number
1404:	0A22  CDC309  	        CALL    POSINT          ; Get integer 0 to 32767
1405:	0A25  2B      	        DEC     HL              ; Cancel increment
1406:	0A26  CD1A09  	        CALL    GETCHR          ; Get next character
1407:	0A29  C2F604  	        JP      NZ,SNERR        ; ?SN Error if more on line
1408:	0A2C  E3      	        EX      (SP),HL         ; Save code string address
1409:	0A2D  EB      	        EX      DE,HL           ; Number to DE
1410:	0A2E  7D      	STORED: LD      A,L             ; Get LSB of new RAM top
1411:	0A2F  93      	        SUB     E               ; Subtract LSB of string space
1412:	0A30  5F      	        LD      E,A             ; Save LSB
1413:	0A31  7C      	        LD      A,H             ; Get MSB of new RAM top
1414:	0A32  9A      	        SBC     A,D             ; Subtract MSB of string space
1415:	0A33  57      	        LD      D,A             ; Save MSB
1416:	0A34  DAEB04  	        JP      C,OMERR         ; ?OM Error if not enough mem
1417:	0A37  E5      	        PUSH    HL              ; Save RAM top
1418:	0A38  2A1B21  	        LD      HL,(PROGND)     ; Get program end
1419:	0A3B  012800  	        LD      BC,40           ; 40 Bytes minimum working RAM
1420:	0A3E  09      	        ADD     HL,BC           ; Get lowest address
1421:	0A3F  CD8A07  	        CALL    CPDEHL          ; Enough memory?
1422:	0A42  D2EB04  	        JP      NC,OMERR        ; No - ?OM Error
1423:	0A45  EB      	        EX      DE,HL           ; RAM top to HL
1424:	0A46  229F20  	        LD      (STRSPC),HL     ; Set new string space
1425:	0A49  E1      	        POP     HL              ; End of memory to use
1426:	0A4A  22F420  	        LD      (LSTRAM),HL     ; Set new top of RAM
1427:	0A4D  E1      	        POP     HL              ; Restore code string address
1428:	0A4E  C31206  	        JP      INTVAR          ; Initialise variables
1429:			
1430:	0A51  CA0E06  	RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
1431:	0A54  CD1206  	        CALL    INTVAR          ; Initialise variables
1432:	0A57  01DA08  	        LD      BC,RUNCNT       ; Execution driver loop
1433:	0A5A  C36D0A  	        JP      RUNLIN          ; RUN from line number
1434:			
1435:	0A5D  0E03    	GOSUB:  LD      C,3             ; 3 Levels of stack needed
1436:	0A5F  CDD304  	        CALL    CHKSTK          ; Check for 3 levels of stack
1437:	0A62  C1      	        POP     BC              ; Get return address
1438:	0A63  E5      	        PUSH    HL              ; Save code string for RETURN
1439:	0A64  E5      	        PUSH    HL              ; And for GOSUB routine
1440:	0A65  2AA120  	        LD      HL,(LINEAT)     ; Get current line
1441:	0A68  E3      	        EX      (SP),HL         ; Into stack - Code string out
1442:	0A69  3E8C    	        LD      A,ZGOSUB        ; "GOSUB" token
1443:	0A6B  F5      	        PUSH    AF              ; Save token
1444:	0A6C  33      	        INC     SP              ; Don't save flags
1445:			
1446:	0A6D  C5      	RUNLIN: PUSH    BC              ; Save return address
1447:	0A6E  CDE609  	GOTO:   CALL    ATOH            ; ASCII number to DE binary
1448:	0A71  CDB30A  	        CALL    REM             ; Get end of line
1449:	0A74  E5      	        PUSH    HL              ; Save end of line
1450:	0A75  2AA120  	        LD      HL,(LINEAT)     ; Get current line
1451:	0A78  CD8A07  	        CALL    CPDEHL          ; Line after current?
1452:	0A7B  E1      	        POP     HL              ; Restore end of line
1453:	0A7C  23      	        INC     HL              ; Start of next line
1454:	0A7D  DCE505  	        CALL    C,SRCHLP        ; Line is after current line
1455:	0A80  D4E205  	        CALL    NC,SRCHLN       ; Line is before current line
1456:	0A83  60      	        LD      H,B             ; Set up code string address
1457:	0A84  69      	        LD      L,C
1458:	0A85  2B      	        DEC     HL              ; Incremented after
1459:	0A86  D8      	        RET     C               ; Line found
1460:	0A87  1E0E    	ULERR:  LD      E,UL            ; ?UL Error
1461:	0A89  C30A05  	        JP      ERROR           ; Output error message
1462:			
1463:	0A8C  C0      	RETURN: RET     NZ              ; Return if not just RETURN
1464:	0A8D  16FF    	        LD      D,-1            ; Flag "GOSUB" search
1465:	0A8F  CD9F04  	        CALL    BAKSTK          ; Look "GOSUB" block
1466:	0A92  F9      	        LD      SP,HL           ; Kill all FORs in subroutine
1467:	0A93  FE8C    	        CP      ZGOSUB          ; Test for "GOSUB" token
1468:	0A95  1E04    	        LD      E,RG            ; ?RG Error
1469:	0A97  C20A05  	        JP      NZ,ERROR        ; Error if no "GOSUB" found
1470:	0A9A  E1      	        POP     HL              ; Get RETURN line number
1471:	0A9B  22A120  	        LD      (LINEAT),HL     ; Save as current
1472:	0A9E  23      	        INC     HL              ; Was it from direct statement?
1473:	0A9F  7C      	        LD      A,H
1474:	0AA0  B5      	        OR      L               ; Return to line
1475:	0AA1  C2AB0A  	        JP      NZ,RETLIN       ; No - Return to line
1476:	0AA4  3A1121  	        LD      A,(LSTBIN)      ; Any INPUT in subroutine?
1477:	0AA7  B7      	        OR      A               ; If so buffer is corrupted
1478:	0AA8  C24005  	        JP      NZ,POPNOK       ; Yes - Go to command mode
1479:	0AAB  21DA08  	RETLIN: LD      HL,RUNCNT       ; Execution driver loop
1480:	0AAE  E3      	        EX      (SP),HL         ; Into stack - Code string out
1481:	0AAF  3E      	        .DB     3EH             ; Skip "POP HL"
1482:	0AB0  E1      	NXTDTA: POP     HL              ; Restore code string address
1483:			
1484:	0AB1  013A    	DATA:   .DB     01H,3AH         ; ':' End of statement
1485:	0AB3  0E00    	REM:    LD      C,0             ; 00  End of statement
1486:	0AB5  0600    	        LD      B,0
1487:	0AB7  79      	NXTSTL: LD      A,C             ; Statement and byte
1488:	0AB8  48      	        LD      C,B
1489:	0AB9  47      	        LD      B,A             ; Statement end byte
1490:	0ABA  7E      	NXTSTT: LD      A,(HL)          ; Get byte
1491:	0ABB  B7      	        OR      A               ; End of line?
1492:	0ABC  C8      	        RET     Z               ; Yes - Exit
1493:	0ABD  B8      	        CP      B               ; End of statement?
1494:	0ABE  C8      	        RET     Z               ; Yes - Exit
1495:	0ABF  23      	        INC     HL              ; Next byte
1496:	0AC0  FE22    	        CP      '"'             ; Literal string?
1497:	0AC2  CAB70A  	        JP      Z,NXTSTL        ; Yes - Look for another '"'
1498:	0AC5  C3BA0A  	        JP      NXTSTT          ; Keep looking
1499:			
1500:	0AC8  CD7D0F  	LET:    CALL    GETVAR          ; Get variable name
1501:	0ACB  CD9007  	        CALL    CHKSYN          ; Make sure "=" follows
1502:	0ACE  B4      	        .DB     ZEQUAL          ; "=" token
1503:	0ACF  D5      	        PUSH    DE              ; Save address of variable
1504:	0AD0  3AF220  	        LD      A,(TYPE)        ; Get data type
1505:	0AD3  F5      	        PUSH    AF              ; Save type
1506:	0AD4  CD990D  	        CALL    EVAL            ; Evaluate expression
1507:	0AD7  F1      	        POP     AF              ; Restore type
1508:	0AD8  E3      	        EX      (SP),HL         ; Save code - Get var addr
1509:	0AD9  221321  	        LD      (BRKLIN),HL     ; Save address of variable
1510:	0ADC  1F      	        RRA                     ; Adjust type
1511:	0ADD  CD8C0D  	        CALL    CHKTYP          ; Check types are the same
1512:	0AE0  CA1B0B  	        JP      Z,LETNUM        ; Numeric - Move value
1513:	0AE3  E5      	LETSTR: PUSH    HL              ; Save address of string var
1514:	0AE4  2A2921  	        LD      HL,(FPREG)      ; Pointer to string entry
1515:	0AE7  E5      	        PUSH    HL              ; Save it on stack
1516:	0AE8  23      	        INC     HL              ; Skip over length
1517:	0AE9  23      	        INC     HL
1518:	0AEA  5E      	        LD      E,(HL)          ; LSB of string address
1519:	0AEB  23      	        INC     HL
1520:	0AEC  56      	        LD      D,(HL)          ; MSB of string address
1521:	0AED  2AA320  	        LD      HL,(BASTXT)     ; Point to start of program
1522:	0AF0  CD8A07  	        CALL    CPDEHL          ; Is string before program?
1523:	0AF3  D20A0B  	        JP      NC,CRESTR       ; Yes - Create string entry
1524:	0AF6  2A9F20  	        LD      HL,(STRSPC)     ; Point to string space
1525:	0AF9  CD8A07  	        CALL    CPDEHL          ; Is string literal in program?
1526:	0AFC  D1      	        POP     DE              ; Restore address of string
1527:	0AFD  D2120B  	        JP      NC,MVSTPT       ; Yes - Set up pointer
1528:	0B00  210421  	        LD      HL,TMPSTR       ; Temporary string pool
1529:	0B03  CD8A07  	        CALL    CPDEHL          ; Is string in temporary pool?
1530:	0B06  D2120B  	        JP      NC,MVSTPT       ; No - Set up pointer
1531:	0B09  3E      	        .DB     3EH             ; Skip "POP DE"
1532:	0B0A  D1      	CRESTR: POP     DE              ; Restore address of string
1533:	0B0B  CDC113  	        CALL    BAKTMP          ; Back to last tmp-str entry
1534:	0B0E  EB      	        EX      DE,HL           ; Address of string entry
1535:	0B0F  CDFA11  	        CALL    SAVSTR          ; Save string in string area
1536:	0B12  CDC113  	MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
1537:	0B15  E1      	        POP     HL              ; Get string pointer
1538:	0B16  CDC417  	        CALL    DETHL4          ; Move string pointer to var
1539:	0B19  E1      	        POP     HL              ; Restore code string address
1540:	0B1A  C9      	        RET
1541:			
1542:	0B1B  E5      	LETNUM: PUSH    HL              ; Save address of variable
1543:	0B1C  CDC117  	        CALL    FPTHL           ; Move value to variable
1544:	0B1F  D1      	        POP     DE              ; Restore address of variable
1545:	0B20  E1      	        POP     HL              ; Restore code string address
1546:	0B21  C9      	        RET
1547:			
1548:	0B22  CDE814  	ON:     CALL    GETINT          ; Get integer 0-255
1549:	0B25  7E      	        LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
1550:	0B26  47      	        LD      B,A             ; Save in B
1551:	0B27  FE8C    	        CP      ZGOSUB          ; "GOSUB" token?
1552:	0B29  CA310B  	        JP      Z,ONGO          ; Yes - Find line number
1553:	0B2C  CD9007  	        CALL    CHKSYN          ; Make sure it's "GOTO"
1554:	0B2F  88      	        .DB     ZGOTO           ; "GOTO" token
1555:	0B30  2B      	        DEC     HL              ; Cancel increment
1556:	0B31  4B      	ONGO:   LD      C,E             ; Integer of branch value
1557:	0B32  0D      	ONGOLP: DEC     C               ; Count branches
1558:	0B33  78      	        LD      A,B             ; Get "GOTO" or "GOSUB" token
1559:	0B34  CA0209  	        JP      Z,ONJMP         ; Go to that line if right one
1560:	0B37  CDE709  	        CALL    GETLN           ; Get line number to DE
1561:	0B3A  FE2C    	        CP      ','             ; Another line number?
1562:	0B3C  C0      	        RET     NZ              ; No - Drop through
1563:	0B3D  C3320B  	        JP      ONGOLP          ; Yes - loop
1564:			
1565:	0B40  CD990D  	IF:     CALL    EVAL            ; Evaluate expression
1566:	0B43  7E      	        LD      A,(HL)          ; Get token
1567:	0B44  FE88    	        CP      ZGOTO           ; "GOTO" token?
1568:	0B46  CA4E0B  	        JP      Z,IFGO          ; Yes - Get line
1569:	0B49  CD9007  	        CALL    CHKSYN          ; Make sure it's "THEN"
1570:	0B4C  A9      	        .DB     ZTHEN           ; "THEN" token
1571:	0B4D  2B      	        DEC     HL              ; Cancel increment
1572:	0B4E  CD8A0D  	IFGO:   CALL    TSTNUM          ; Make sure it's numeric
1573:	0B51  CD6917  	        CALL    TSTSGN          ; Test state of expression
1574:	0B54  CAB30A  	        JP      Z,REM           ; False - Drop through
1575:	0B57  CD1A09  	        CALL    GETCHR          ; Get next character
1576:	0B5A  DA6E0A  	        JP      C,GOTO          ; Number - GOTO that line
1577:	0B5D  C30109  	        JP      IFJMP           ; Otherwise do statement
1578:			
1579:	0B60  2B      	MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
1580:	0B61  CD1A09  	        CALL    GETCHR          ; Get next character
1581:	0B64  CAC20B  	PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
1582:	0B67  C8      	PRNTLP: RET     Z               ; End of list - Exit
1583:	0B68  FEA5    	        CP      ZTAB            ; "TAB(" token?
1584:	0B6A  CAF50B  	        JP      Z,DOTAB         ; Yes - Do TAB routine
1585:	0B6D  FEA8    	        CP      ZSPC            ; "SPC(" token?
1586:	0B6F  CAF50B  	        JP      Z,DOTAB         ; Yes - Do SPC routine
1587:	0B72  E5      	        PUSH    HL              ; Save code string address
1588:	0B73  FE2C    	        CP      ','             ; Comma?
1589:	0B75  CADE0B  	        JP      Z,DOCOM         ; Yes - Move to next zone
1590:	0B78  FE3B    	        CP      59 ;";"         ; Semi-colon?
1591:	0B7A  CA180C  	        JP      Z,NEXITM        ; Do semi-colon routine
1592:	0B7D  C1      	        POP     BC              ; Code string address to BC
1593:	0B7E  CD990D  	        CALL    EVAL            ; Evaluate expression
1594:	0B81  E5      	        PUSH    HL              ; Save code string address
1595:	0B82  3AF220  	        LD      A,(TYPE)        ; Get variable type
1596:	0B85  B7      	        OR      A               ; Is it a string variable?
1597:	0B86  C2AE0B  	        JP      NZ,PRNTST       ; Yes - Output string contents
1598:	0B89  CD0E19  	        CALL    NUMASC          ; Convert number to text
1599:	0B8C  CD1E12  	        CALL    CRTST           ; Create temporary string
1600:	0B8F  3620    	        LD      (HL),' '        ; Followed by a space
1601:	0B91  2A2921  	        LD      HL,(FPREG)      ; Get length of output
1602:	0B94  34      	        INC     (HL)            ; Plus 1 for the space
1603:	0B95  2A2921  	        LD      HL,(FPREG)      ; < Not needed >
1604:	0B98  3A8720  	        LD      A,(LWIDTH)      ; Get width of line
1605:	0B9B  47      	        LD      B,A             ; To B
1606:	0B9C  04      	        INC     B               ; Width 255 (No limit)?
1607:	0B9D  CAAA0B  	        JP      Z,PRNTNB        ; Yes - Output number string
1608:	0BA0  04      	        INC     B               ; Adjust it
1609:	0BA1  3AF020  	        LD      A,(CURPOS)      ; Get cursor position
1610:	0BA4  86      	        ADD     A,(HL)          ; Add length of string
1611:	0BA5  3D      	        DEC     A               ; Adjust it
1612:	0BA6  B8      	        CP      B               ; Will output fit on this line?
1613:	0BA7  D4C20B  	        CALL    NC,PRNTCRLF     ; No - CRLF first
1614:	0BAA  CD6312  	PRNTNB: CALL    PRS1            ; Output string at (HL)
1615:	0BAD  AF      	        XOR     A               ; Skip CALL by setting 'z' flag
1616:	0BAE  C46312  	PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
1617:	0BB1  E1      	        POP     HL              ; Restore code string address
1618:	0BB2  C3600B  	        JP      MRPRNT          ; See if more to PRINT
1619:			
1620:	0BB5  3AF020  	STTLIN: LD      A,(CURPOS)      ; Make sure on new line
1621:	0BB8  B7      	        OR      A               ; Already at start?
1622:	0BB9  C8      	        RET     Z               ; Yes - Do nothing
1623:	0BBA  C3C20B  	        JP      PRNTCRLF        ; Start a new line
1624:			
1625:	0BBD  3600    	ENDINP: LD      (HL),0          ; Mark end of buffer
1626:	0BBF  21A520  	        LD      HL,BUFFER-1     ; Point to buffer
1627:	0BC2  3E0D    	PRNTCRLF: LD    A,CR            ; Load a CR
1628:	0BC4  CD9B07  	        CALL    OUTC            ; Output character
1629:	0BC7  3E0A    	        LD      A,LF            ; Load a LF
1630:	0BC9  CD9B07  	        CALL    OUTC            ; Output character
1631:	0BCC  AF      	DONULL: XOR     A               ; Set to position 0
1632:	0BCD  32F020  	        LD      (CURPOS),A      ; Store it
1633:	0BD0  3A8620  	        LD      A,(NULLS)       ; Get number of nulls
1634:	0BD3  3D      	NULLP:  DEC     A               ; Count them
1635:	0BD4  C8      	        RET     Z               ; Return if done
1636:	0BD5  F5      	        PUSH    AF              ; Save count
1637:	0BD6  AF      	        XOR     A               ; Load a null
1638:	0BD7  CD9B07  	        CALL    OUTC            ; Output it
1639:	0BDA  F1      	        POP     AF              ; Restore count
1640:	0BDB  C3D30B  	        JP      NULLP           ; Keep counting
1641:			
1642:	0BDE  3A8820  	DOCOM:  LD      A,(COMMAN)      ; Get comma width
1643:	0BE1  47      	        LD      B,A             ; Save in B
1644:	0BE2  3AF020  	        LD      A,(CURPOS)      ; Get current position
1645:	0BE5  B8      	        CP      B               ; Within the limit?
1646:	0BE6  D4C20B  	        CALL    NC,PRNTCRLF     ; No - output CRLF
1647:	0BE9  D2180C  	        JP      NC,NEXITM       ; Get next item
1648:	0BEC  D60E    	ZONELP: SUB     14              ; Next zone of 14 characters
1649:	0BEE  D2EC0B  	        JP      NC,ZONELP       ; Repeat if more zones
1650:	0BF1  2F      	        CPL                     ; Number of spaces to output
1651:	0BF2  C30D0C  	        JP      ASPCS           ; Output them
1652:			
1653:	0BF5  F5      	DOTAB:  PUSH    AF              ; Save token
1654:	0BF6  CDE514  	        CALL    FNDNUM          ; Evaluate expression
1655:	0BF9  CD9007  	        CALL    CHKSYN          ; Make sure ")" follows
1656:	0BFC  29      	        .DB     ")"
1657:	0BFD  2B      	        DEC     HL              ; Back space on to ")"
1658:	0BFE  F1      	        POP     AF              ; Restore token
1659:	0BFF  D6A8    	        SUB     ZSPC            ; Was it "SPC(" ?
1660:	0C01  E5      	        PUSH    HL              ; Save code string address
1661:	0C02  CA080C  	        JP      Z,DOSPC         ; Yes - Do 'E' spaces
1662:	0C05  3AF020  	        LD      A,(CURPOS)      ; Get current position
1663:	0C08  2F      	DOSPC:  CPL                     ; Number of spaces to print to
1664:	0C09  83      	        ADD     A,E             ; Total number to print
1665:	0C0A  D2180C  	        JP      NC,NEXITM       ; TAB < Current POS(X)
1666:	0C0D  3C      	ASPCS:  INC     A               ; Output A spaces
1667:	0C0E  47      	        LD      B,A             ; Save number to print
1668:	0C0F  3E20    	        LD      A,' '           ; Space
1669:	0C11  CD9B07  	SPCLP:  CALL    OUTC            ; Output character in A
1670:	0C14  05      	        DEC     B               ; Count them
1671:	0C15  C2110C  	        JP      NZ,SPCLP        ; Repeat if more
1672:	0C18  E1      	NEXITM: POP     HL              ; Restore code string address
1673:	0C19  CD1A09  	        CALL    GETCHR          ; Get next character
1674:	0C1C  C3670B  	        JP      PRNTLP          ; More to print
1675:			
1676:	0C1F  3F526564	REDO:   .DB     "?Redo from start",CR,LF,0
	      6F206672
	      6F6D2073
	      74617274
	      0D0A00
1677:			
1678:	0C32  3A1221  	BADINP: LD      A,(READFG)      ; READ or INPUT?
1679:	0C35  B7      	        OR      A
1680:	0C36  C2F004  	        JP      NZ,DATSNR       ; READ - ?SN Error
1681:	0C39  C1      	        POP     BC              ; Throw away code string addr
1682:	0C3A  211F0C  	        LD      HL,REDO         ; "Redo from start" message
1683:	0C3D  CD6012  	        CALL    PRS             ; Output string
1684:	0C40  C34106  	        JP      DOAGN           ; Do last INPUT again
1685:			
1686:	0C43  CDCB11  	INPUT:  CALL    IDTEST          ; Test for illegal direct
1687:	0C46  7E      	        LD      A,(HL)          ; Get character after "INPUT"
1688:	0C47  FE22    	        CP      '"'             ; Is there a prompt string?
1689:	0C49  3E00    	        LD      A,0             ; Clear A and leave flags
1690:	0C4B  328A20  	        LD      (CTLOFG),A      ; Enable output
1691:	0C4E  C25D0C  	        JP      NZ,NOPMPT       ; No prompt - get input
1692:	0C51  CD1F12  	        CALL    QTSTR           ; Get string terminated by '"'
1693:	0C54  CD9007  	        CALL    CHKSYN          ; Check for ';' after prompt
1694:	0C57  3B      	        .DB     ';'
1695:	0C58  E5      	        PUSH    HL              ; Save code string address
1696:	0C59  CD6312  	        CALL    PRS1            ; Output prompt string
1697:	0C5C  3E      	        .DB     3EH             ; Skip "PUSH HL"
1698:	0C5D  E5      	NOPMPT: PUSH    HL              ; Save code string address
1699:	0C5E  CD4506  	        CALL    PROMPT          ; Get input with "? " prompt
1700:	0C61  C1      	        POP     BC              ; Restore code string address
1701:	0C62  DA6909  	        JP      C,INPBRK        ; Break pressed - Exit
1702:	0C65  23      	        INC     HL              ; Next byte
1703:	0C66  7E      	        LD      A,(HL)          ; Get it
1704:	0C67  B7      	        OR      A               ; End of line?
1705:	0C68  2B      	        DEC     HL              ; Back again
1706:	0C69  C5      	        PUSH    BC              ; Re-save code string address
1707:	0C6A  CAB00A  	        JP      Z,NXTDTA        ; Yes - Find next DATA stmt
1708:	0C6D  362C    	        LD      (HL),','        ; Store comma as separator
1709:	0C6F  C3770C  	        JP      NXTITM          ; Get next item
1710:			
1711:	0C72  E5      	READ:   PUSH    HL              ; Save code string address
1712:	0C73  2A2121  	        LD      HL,(NXTDAT)     ; Next DATA statement
1713:	0C76  F6      	        .DB     0F6H            ; Flag "READ"
1714:	0C77  AF      	NXTITM: XOR     A               ; Flag "INPUT"
1715:	0C78  321221  	        LD      (READFG),A      ; Save "READ"/"INPUT" flag
1716:	0C7B  E3      	        EX      (SP),HL         ; Get code str' , Save pointer
1717:	0C7C  C3830C  	        JP      GTVLUS          ; Get values
1718:			
1719:	0C7F  CD9007  	NEDMOR: CALL    CHKSYN          ; Check for comma between items
1720:	0C82  2C      	        .DB     ','
1721:	0C83  CD7D0F  	GTVLUS: CALL    GETVAR          ; Get variable name
1722:	0C86  E3      	        EX      (SP),HL         ; Save code str" , Get pointer
1723:	0C87  D5      	        PUSH    DE              ; Save variable address
1724:	0C88  7E      	        LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
1725:	0C89  FE2C    	        CP      ','             ; Comma?
1726:	0C8B  CAAB0C  	        JP      Z,ANTVLU        ; Yes - Get another value
1727:	0C8E  3A1221  	        LD      A,(READFG)      ; Is it READ?
1728:	0C91  B7      	        OR      A
1729:	0C92  C2180D  	        JP      NZ,FDTLP        ; Yes - Find next DATA stmt
1730:	0C95  3E3F    	        LD      A,'?'           ; More INPUT needed
1731:	0C97  CD9B07  	        CALL    OUTC            ; Output character
1732:	0C9A  CD4506  	        CALL    PROMPT          ; Get INPUT with prompt
1733:	0C9D  D1      	        POP     DE              ; Variable address
1734:	0C9E  C1      	        POP     BC              ; Code string address
1735:	0C9F  DA6909  	        JP      C,INPBRK        ; Break pressed
1736:	0CA2  23      	        INC     HL              ; Point to next DATA byte
1737:	0CA3  7E      	        LD      A,(HL)          ; Get byte
1738:	0CA4  B7      	        OR      A               ; Is it zero (No input) ?
1739:	0CA5  2B      	        DEC     HL              ; Back space INPUT pointer
1740:	0CA6  C5      	        PUSH    BC              ; Save code string address
1741:	0CA7  CAB00A  	        JP      Z,NXTDTA        ; Find end of buffer
1742:	0CAA  D5      	        PUSH    DE              ; Save variable address
1743:	0CAB  3AF220  	ANTVLU: LD      A,(TYPE)        ; Check data type
1744:	0CAE  B7      	        OR      A               ; Is it numeric?
1745:	0CAF  CAD50C  	        JP      Z,INPBIN        ; Yes - Convert to binary
1746:	0CB2  CD1A09  	        CALL    GETCHR          ; Get next character
1747:	0CB5  57      	        LD      D,A             ; Save input character
1748:	0CB6  47      	        LD      B,A             ; Again
1749:	0CB7  FE22    	        CP      '"'             ; Start of literal sting?
1750:	0CB9  CAC90C  	        JP      Z,STRENT        ; Yes - Create string entry
1751:	0CBC  3A1221  	        LD      A,(READFG)      ; "READ" or "INPUT" ?
1752:	0CBF  B7      	        OR      A
1753:	0CC0  57      	        LD      D,A             ; Save 00 if "INPUT"
1754:	0CC1  CAC60C  	        JP      Z,ITMSEP        ; "INPUT" - End with 00
1755:	0CC4  163A    	        LD      D,':'           ; "DATA" - End with 00 or ':'
1756:	0CC6  062C    	ITMSEP: LD      B,','           ; Item separator
1757:	0CC8  2B      	        DEC     HL              ; Back space for DTSTR
1758:	0CC9  CD2212  	STRENT: CALL    DTSTR           ; Get string terminated by D
1759:	0CCC  EB      	        EX      DE,HL           ; String address to DE
1760:	0CCD  21E00C  	        LD      HL,LTSTND       ; Where to go after LETSTR
1761:	0CD0  E3      	        EX      (SP),HL         ; Save HL , get input pointer
1762:	0CD1  D5      	        PUSH    DE              ; Save address of string
1763:	0CD2  C3E30A  	        JP      LETSTR          ; Assign string to variable
1764:			
1765:	0CD5  CD1A09  	INPBIN: CALL    GETCHR          ; Get next character
1766:	0CD8  CD7018  	        CALL    ASCTFP          ; Convert ASCII to FP number
1767:	0CDB  E3      	        EX      (SP),HL         ; Save input ptr, Get var addr
1768:	0CDC  CDC117  	        CALL    FPTHL           ; Move FPREG to variable
1769:	0CDF  E1      	        POP     HL              ; Restore input pointer
1770:	0CE0  2B      	LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
1771:	0CE1  CD1A09  	        CALL    GETCHR          ; Get next character
1772:	0CE4  CAEC0C  	        JP      Z,MORDT         ; End of line - More needed?
1773:	0CE7  FE2C    	        CP      ','             ; Another value?
1774:	0CE9  C2320C  	        JP      NZ,BADINP       ; No - Bad input
1775:	0CEC  E3      	MORDT:  EX      (SP),HL         ; Get code string address
1776:	0CED  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
1777:	0CEE  CD1A09  	        CALL    GETCHR          ; Get next character
1778:	0CF1  C27F0C  	        JP      NZ,NEDMOR       ; More needed - Get it
1779:	0CF4  D1      	        POP     DE              ; Restore DATA pointer
1780:	0CF5  3A1221  	        LD      A,(READFG)      ; "READ" or "INPUT" ?
1781:	0CF8  B7      	        OR      A
1782:	0CF9  EB      	        EX      DE,HL           ; DATA pointer to HL
1783:	0CFA  C24009  	        JP      NZ,UPDATA       ; Update DATA pointer if "READ"
1784:	0CFD  D5      	        PUSH    DE              ; Save code string address
1785:	0CFE  B6      	        OR      (HL)            ; More input given?
1786:	0CFF  21070D  	        LD      HL,EXTIG        ; "?Extra ignored" message
1787:	0D02  C46012  	        CALL    NZ,PRS          ; Output string if extra given
1788:	0D05  E1      	        POP     HL              ; Restore code string address
1789:	0D06  C9      	        RET
1790:			
1791:	0D07  3F457874	EXTIG:  .DB     "?Extra ignored",CR,LF,0
	      72612069
	      676E6F72
	      65640D0A
	      00
1792:			
1793:	0D18  CDB10A  	FDTLP:  CALL    DATA            ; Get next statement
1794:	0D1B  B7      	        OR      A               ; End of line?
1795:	0D1C  C2310D  	        JP      NZ,FANDT        ; No - See if DATA statement
1796:	0D1F  23      	        INC     HL
1797:	0D20  7E      	        LD      A,(HL)          ; End of program?
1798:	0D21  23      	        INC     HL
1799:	0D22  B6      	        OR      (HL)            ; 00 00 Ends program
1800:	0D23  1E06    	        LD      E,OD            ; ?OD Error
1801:	0D25  CA0A05  	        JP      Z,ERROR         ; Yes - Out of DATA
1802:	0D28  23      	        INC     HL
1803:	0D29  5E      	        LD      E,(HL)          ; LSB of line number
1804:	0D2A  23      	        INC     HL
1805:	0D2B  56      	        LD      D,(HL)          ; MSB of line number
1806:	0D2C  EB      	        EX      DE,HL
1807:	0D2D  220E21  	        LD      (DATLIN),HL     ; Set line of current DATA item
1808:	0D30  EB      	        EX      DE,HL
1809:	0D31  CD1A09  	FANDT:  CALL    GETCHR          ; Get next character
1810:	0D34  FE83    	        CP      ZDATA           ; "DATA" token
1811:	0D36  C2180D  	        JP      NZ,FDTLP        ; No "DATA" - Keep looking
1812:	0D39  C3AB0C  	        JP      ANTVLU          ; Found - Convert input
1813:			
1814:	0D3C  110000  	NEXT:   LD      DE,0            ; In case no index given
1815:	0D3F  C47D0F  	NEXT1:  CALL    NZ,GETVAR       ; Get index address
1816:	0D42  221321  	        LD      (BRKLIN),HL     ; Save code string address
1817:	0D45  CD9F04  	        CALL    BAKSTK          ; Look for "FOR" block
1818:	0D48  C2FC04  	        JP      NZ,NFERR        ; No "FOR" - ?NF Error
1819:	0D4B  F9      	        LD      SP,HL           ; Clear nested loops
1820:	0D4C  D5      	        PUSH    DE              ; Save index address
1821:	0D4D  7E      	        LD      A,(HL)          ; Get sign of STEP
1822:	0D4E  23      	        INC     HL
1823:	0D4F  F5      	        PUSH    AF              ; Save sign of STEP
1824:	0D50  D5      	        PUSH    DE              ; Save index address
1825:	0D51  CDA717  	        CALL    PHLTFP          ; Move index value to FPREG
1826:	0D54  E3      	        EX      (SP),HL         ; Save address of TO value
1827:	0D55  E5      	        PUSH    HL              ; Save address of index
1828:	0D56  CD1415  	        CALL    ADDPHL          ; Add STEP to index value
1829:	0D59  E1      	        POP     HL              ; Restore address of index
1830:	0D5A  CDC117  	        CALL    FPTHL           ; Move value to index variable
1831:	0D5D  E1      	        POP     HL              ; Restore address of TO value
1832:	0D5E  CDB817  	        CALL    LOADFP          ; Move TO value to BCDE
1833:	0D61  E5      	        PUSH    HL              ; Save address of line of FOR
1834:	0D62  CDE417  	        CALL    CMPNUM          ; Compare index with TO value
1835:	0D65  E1      	        POP     HL              ; Restore address of line num
1836:	0D66  C1      	        POP     BC              ; Address of sign of STEP
1837:	0D67  90      	        SUB     B               ; Compare with expected sign
1838:	0D68  CDB817  	        CALL    LOADFP          ; BC = Loop stmt,DE = Line num
1839:	0D6B  CA770D  	        JP      Z,KILFOR        ; Loop finished - Terminate it
1840:	0D6E  EB      	        EX      DE,HL           ; Loop statement line number
1841:	0D6F  22A120  	        LD      (LINEAT),HL     ; Set loop line number
1842:	0D72  69      	        LD      L,C             ; Set code string to loop
1843:	0D73  60      	        LD      H,B
1844:	0D74  C3D608  	        JP      PUTFID          ; Put back "FOR" and continue
1845:			
1846:	0D77  F9      	KILFOR: LD      SP,HL           ; Remove "FOR" block
1847:	0D78  2A1321  	        LD      HL,(BRKLIN)     ; Code string after "NEXT"
1848:	0D7B  7E      	        LD      A,(HL)          ; Get next byte in code string
1849:	0D7C  FE2C    	        CP      ','             ; More NEXTs ?
1850:	0D7E  C2DA08  	        JP      NZ,RUNCNT       ; No - Do next statement
1851:	0D81  CD1A09  	        CALL    GETCHR          ; Position to index name
1852:	0D84  CD3F0D  	        CALL    NEXT1           ; Re-enter NEXT routine
1853:			; < will not RETurn to here , Exit to RUNCNT or Loop >
1854:			
1855:	0D87  CD990D  	GETNUM: CALL    EVAL            ; Get a numeric expression
1856:	0D8A  F6      	TSTNUM: .DB     0F6H            ; Clear carry (numeric)
1857:	0D8B  37      	TSTSTR: SCF                     ; Set carry (string)
1858:	0D8C  3AF220  	CHKTYP: LD      A,(TYPE)        ; Check types match
1859:	0D8F  8F      	        ADC     A,A             ; Expected + actual
1860:	0D90  B7      	        OR      A               ; Clear carry , set parity
1861:	0D91  E8      	        RET     PE              ; Even parity - Types match
1862:	0D92  C30805  	        JP      TMERR           ; Different types - Error
1863:			
1864:	0D95  CD9007  	OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
1865:	0D98  28      	        .DB  "("
1866:	0D99  2B      	EVAL:   DEC     HL              ; Evaluate expression & save
1867:	0D9A  1600    	        LD      D,0             ; Precedence value
1868:	0D9C  D5      	EVAL1:  PUSH    DE              ; Save precedence
1869:	0D9D  0E01    	        LD      C,1
1870:	0D9F  CDD304  	        CALL    CHKSTK          ; Check for 1 level of stack
1871:	0DA2  CD100E  	        CALL    OPRND           ; Get next expression value
1872:	0DA5  221521  	EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
1873:	0DA8  2A1521  	EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
1874:	0DAB  C1      	        POP     BC              ; Precedence value and operator
1875:	0DAC  78      	        LD      A,B             ; Get precedence value
1876:	0DAD  FE78    	        CP      78H             ; "AND" or "OR" ?
1877:	0DAF  D48A0D  	        CALL    NC,TSTNUM       ; No - Make sure it's a number
1878:	0DB2  7E      	        LD      A,(HL)          ; Get next operator / function
1879:	0DB3  1600    	        LD      D,0             ; Clear Last relation
1880:	0DB5  D6B3    	RLTLP:  SUB     ZGTR            ; ">" Token
1881:	0DB7  DAD10D  	        JP      C,FOPRND        ; + - * / ^ AND OR - Test it
1882:	0DBA  FE03    	        CP      ZLTH+1-ZGTR     ; < = >
1883:	0DBC  D2D10D  	        JP      NC,FOPRND       ; Function - Call it
1884:	0DBF  FE01    	        CP      ZEQUAL-ZGTR     ; "="
1885:	0DC1  17      	        RLA                     ; <- Test for legal
1886:	0DC2  AA      	        XOR     D               ; <- combinations of < = >
1887:	0DC3  BA      	        CP      D               ; <- by combining last token
1888:	0DC4  57      	        LD      D,A             ; <- with current one
1889:	0DC5  DAF604  	        JP      C,SNERR         ; Error if "<<' '==" or ">>"
1890:	0DC8  220A21  	        LD      (CUROPR),HL     ; Save address of current token
1891:	0DCB  CD1A09  	        CALL    GETCHR          ; Get next character
1892:	0DCE  C3B50D  	        JP      RLTLP           ; Treat the two as one
1893:			
1894:	0DD1  7A      	FOPRND: LD      A,D             ; < = > found ?
1895:	0DD2  B7      	        OR      A
1896:	0DD3  C2F80E  	        JP      NZ,TSTRED       ; Yes - Test for reduction
1897:	0DD6  7E      	        LD      A,(HL)          ; Get operator token
1898:	0DD7  220A21  	        LD      (CUROPR),HL     ; Save operator address
1899:	0DDA  D6AC    	        SUB     ZPLUS           ; Operator or function?
1900:	0DDC  D8      	        RET     C               ; Neither - Exit
1901:	0DDD  FE07    	        CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
1902:	0DDF  D0      	        RET     NC              ; No - Exit
1903:	0DE0  5F      	        LD      E,A             ; Coded operator
1904:	0DE1  3AF220  	        LD      A,(TYPE)        ; Get data type
1905:	0DE4  3D      	        DEC     A               ; FF = numeric , 00 = string
1906:	0DE5  B3      	        OR      E               ; Combine with coded operator
1907:	0DE6  7B      	        LD      A,E             ; Get coded operator
1908:	0DE7  CA5613  	        JP      Z,CONCAT        ; String concatenation
1909:	0DEA  07      	        RLCA                    ; Times 2
1910:	0DEB  83      	        ADD     A,E             ; Times 3
1911:	0DEC  5F      	        LD      E,A             ; To DE (D is 0)
1912:	0DED  21E803  	        LD      HL,PRITAB       ; Precedence table
1913:	0DF0  19      	        ADD     HL,DE           ; To the operator concerned
1914:	0DF1  78      	        LD      A,B             ; Last operator precedence
1915:	0DF2  56      	        LD      D,(HL)          ; Get evaluation precedence
1916:	0DF3  BA      	        CP      D               ; Compare with eval precedence
1917:	0DF4  D0      	        RET     NC              ; Exit if higher precedence
1918:	0DF5  23      	        INC     HL              ; Point to routine address
1919:	0DF6  CD8A0D  	        CALL    TSTNUM          ; Make sure it's a number
1920:			
1921:	0DF9  C5      	STKTHS: PUSH    BC              ; Save last precedence & token
1922:	0DFA  01A80D  	        LD      BC,EVAL3        ; Where to go on prec' break
1923:	0DFD  C5      	        PUSH    BC              ; Save on stack for return
1924:	0DFE  43      	        LD      B,E             ; Save operator
1925:	0DFF  4A      	        LD      C,D             ; Save precedence
1926:	0E00  CD9A17  	        CALL    STAKFP          ; Move value to stack
1927:	0E03  58      	        LD      E,B             ; Restore operator
1928:	0E04  51      	        LD      D,C             ; Restore precedence
1929:	0E05  4E      	        LD      C,(HL)          ; Get LSB of routine address
1930:	0E06  23      	        INC     HL
1931:	0E07  46      	        LD      B,(HL)          ; Get MSB of routine address
1932:	0E08  23      	        INC     HL
1933:	0E09  C5      	        PUSH    BC              ; Save routine address
1934:	0E0A  2A0A21  	        LD      HL,(CUROPR)     ; Address of current operator
1935:	0E0D  C39C0D  	        JP      EVAL1           ; Loop until prec' break
1936:			
1937:	0E10  AF      	OPRND:  XOR     A               ; Get operand routine
1938:	0E11  32F220  	        LD      (TYPE),A        ; Set numeric expected
1939:	0E14  CD1A09  	        CALL    GETCHR          ; Get next character
1940:	0E17  1E24    	        LD      E,MO            ; ?MO Error
1941:	0E19  CA0A05  	        JP      Z,ERROR         ; No operand - Error
1942:	0E1C  DA7018  	        JP      C,ASCTFP        ; Number - Get value
1943:	0E1F  CDB809  	        CALL    CHKLTR          ; See if a letter
1944:	0E22  D2770E  	        JP      NC,CONVAR       ; Letter - Find variable
1945:	0E25  FE26    	        CP      '&'             ; &H = HEX, &B = BINARY
1946:	0E27  2012    	        JR      NZ, NOTAMP
1947:	0E29  CD1A09  	        CALL    GETCHR          ; Get next character
1948:	0E2C  FE48    	        CP      'H'             ; Hex number indicated? [function added]
1949:	0E2E  CAB41C  	        JP      Z,HEXTFP        ; Convert Hex to FPREG
1950:	0E31  FE42    	        CP      'B'             ; Binary number indicated? [function added]
1951:	0E33  CA241D  	        JP      Z,BINTFP        ; Convert Bin to FPREG
1952:	0E36  1E02    	        LD      E,SN            ; If neither then a ?SN Error
1953:	0E38  CA0A05  	        JP      Z,ERROR         ; 
1954:	0E3B  FEAC    	NOTAMP: CP      ZPLUS           ; '+' Token ?
1955:	0E3D  CA100E  	        JP      Z,OPRND         ; Yes - Look for operand
1956:	0E40  FE2E    	        CP      '.'             ; '.' ?
1957:	0E42  CA7018  	        JP      Z,ASCTFP        ; Yes - Create FP number
1958:	0E45  FEAD    	        CP      ZMINUS          ; '-' Token ?
1959:	0E47  CA660E  	        JP      Z,MINUS         ; Yes - Do minus
1960:	0E4A  FE22    	        CP      '"'             ; Literal string ?
1961:	0E4C  CA1F12  	        JP      Z,QTSTR         ; Get string terminated by '"'
1962:	0E4F  FEAA    	        CP      ZNOT            ; "NOT" Token ?
1963:	0E51  CA580F  	        JP      Z,EVNOT         ; Yes - Eval NOT expression
1964:	0E54  FEA7    	        CP      ZFN             ; "FN" Token ?
1965:	0E56  CA8311  	        JP      Z,DOFN          ; Yes - Do FN routine
1966:	0E59  D6B6    	        SUB     ZSGN            ; Is it a function?
1967:	0E5B  D2880E  	        JP      NC,FNOFST       ; Yes - Evaluate function
1968:	0E5E  CD950D  	EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
1969:	0E61  CD9007  	        CALL    CHKSYN          ; Make sure ")" follows
1970:	0E64  29      	        .DB     ")"
1971:	0E65  C9      	        RET
1972:			
1973:	0E66  167D    	MINUS:  LD      D,7DH           ; '-' precedence
1974:	0E68  CD9C0D  	        CALL    EVAL1           ; Evaluate until prec' break
1975:	0E6B  2A1521  	        LD      HL,(NXTOPR)     ; Get next operator address
1976:	0E6E  E5      	        PUSH    HL              ; Save next operator address
1977:	0E6F  CD9217  	        CALL    INVSGN          ; Negate value
1978:	0E72  CD8A0D  	RETNUM: CALL    TSTNUM          ; Make sure it's a number
1979:	0E75  E1      	        POP     HL              ; Restore next operator address
1980:	0E76  C9      	        RET
1981:			
1982:	0E77  CD7D0F  	CONVAR: CALL    GETVAR          ; Get variable address to DE
1983:	0E7A  E5      	FRMEVL: PUSH    HL              ; Save code string address
1984:	0E7B  EB      	        EX      DE,HL           ; Variable address to HL
1985:	0E7C  222921  	        LD      (FPREG),HL      ; Save address of variable
1986:	0E7F  3AF220  	        LD      A,(TYPE)        ; Get type
1987:	0E82  B7      	        OR      A               ; Numeric?
1988:	0E83  CCA717  	        CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
1989:	0E86  E1      	        POP     HL              ; Restore code string address
1990:	0E87  C9      	        RET
1991:			
1992:	0E88  0600    	FNOFST: LD      B,0             ; Get address of function
1993:	0E8A  07      	        RLCA                    ; Double function offset
1994:	0E8B  4F      	        LD      C,A             ; BC = Offset in function table
1995:	0E8C  C5      	        PUSH    BC              ; Save adjusted token value
1996:	0E8D  CD1A09  	        CALL    GETCHR          ; Get next character
1997:	0E90  79      	        LD      A,C             ; Get adjusted token value
1998:	0E91  FE31    	        CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
1999:	0E93  DAAF0E  	        JP      C,FNVAL         ; No - Do function
2000:	0E96  CD950D  	        CALL    OPNPAR          ; Evaluate expression  (X,...
2001:	0E99  CD9007  	        CALL    CHKSYN          ; Make sure ',' follows
2002:	0E9C  2C      	        .DB     ','
2003:	0E9D  CD8B0D  	        CALL    TSTSTR          ; Make sure it's a string
2004:	0EA0  EB      	        EX      DE,HL           ; Save code string address
2005:	0EA1  2A2921  	        LD      HL,(FPREG)      ; Get address of string
2006:	0EA4  E3      	        EX      (SP),HL         ; Save address of string
2007:	0EA5  E5      	        PUSH    HL              ; Save adjusted token value
2008:	0EA6  EB      	        EX      DE,HL           ; Restore code string address
2009:	0EA7  CDE814  	        CALL    GETINT          ; Get integer 0-255
2010:	0EAA  EB      	        EX      DE,HL           ; Save code string address
2011:	0EAB  E3      	        EX      (SP),HL         ; Save integer,HL = adj' token
2012:	0EAC  C3B70E  	        JP      GOFUNC          ; Jump to string function
2013:			
2014:	0EAF  CD5E0E  	FNVAL:  CALL    EVLPAR          ; Evaluate expression
2015:	0EB2  E3      	        EX      (SP),HL         ; HL = Adjusted token value
2016:	0EB3  11720E  	        LD      DE,RETNUM       ; Return number from function
2017:	0EB6  D5      	        PUSH    DE              ; Save on stack
2018:	0EB7  014702  	GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
2019:	0EBA  09      	        ADD     HL,BC           ; Point to right address
2020:	0EBB  4E      	        LD      C,(HL)          ; Get LSB of address
2021:	0EBC  23      	        INC     HL              ;
2022:	0EBD  66      	        LD      H,(HL)          ; Get MSB of address
2023:	0EBE  69      	        LD      L,C             ; Address to HL
2024:	0EBF  E9      	        JP      (HL)            ; Jump to function
2025:			
2026:	0EC0  15      	SGNEXP: DEC     D               ; Dee to flag negative exponent
2027:	0EC1  FEAD    	        CP      ZMINUS          ; '-' token ?
2028:	0EC3  C8      	        RET     Z               ; Yes - Return
2029:	0EC4  FE2D    	        CP      '-'             ; '-' ASCII ?
2030:	0EC6  C8      	        RET     Z               ; Yes - Return
2031:	0EC7  14      	        INC     D               ; Inc to flag positive exponent
2032:	0EC8  FE2B    	        CP      '+'             ; '+' ASCII ?
2033:	0ECA  C8      	        RET     Z               ; Yes - Return
2034:	0ECB  FEAC    	        CP      ZPLUS           ; '+' token ?
2035:	0ECD  C8      	        RET     Z               ; Yes - Return
2036:	0ECE  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
2037:	0ECF  C9      	        RET                     ; Return "NZ"
2038:			
2039:	0ED0  F6      	POR:    .DB     0F6H            ; Flag "OR"
2040:	0ED1  AF      	PAND:   XOR     A               ; Flag "AND"
2041:	0ED2  F5      	        PUSH    AF              ; Save "AND" / "OR" flag
2042:	0ED3  CD8A0D  	        CALL    TSTNUM          ; Make sure it's a number
2043:	0ED6  CDCC09  	        CALL    DEINT           ; Get integer -32768 to 32767
2044:	0ED9  F1      	        POP     AF              ; Restore "AND" / "OR" flag
2045:	0EDA  EB      	        EX      DE,HL           ; <- Get last
2046:	0EDB  C1      	        POP     BC              ; <-  value
2047:	0EDC  E3      	        EX      (SP),HL         ; <-  from
2048:	0EDD  EB      	        EX      DE,HL           ; <-  stack
2049:	0EDE  CDAA17  	        CALL    FPBCDE          ; Move last value to FPREG
2050:	0EE1  F5      	        PUSH    AF              ; Save "AND" / "OR" flag
2051:	0EE2  CDCC09  	        CALL    DEINT           ; Get integer -32768 to 32767
2052:	0EE5  F1      	        POP     AF              ; Restore "AND" / "OR" flag
2053:	0EE6  C1      	        POP     BC              ; Get value
2054:	0EE7  79      	        LD      A,C             ; Get LSB
2055:	0EE8  214111  	        LD      HL,ACPASS       ; Address of save AC as current
2056:	0EEB  C2F30E  	        JP      NZ,POR1         ; Jump if OR
2057:	0EEE  A3      	        AND     E               ; "AND" LSBs
2058:	0EEF  4F      	        LD      C,A             ; Save LSB
2059:	0EF0  78      	        LD      A,B             ; Get MBS
2060:	0EF1  A2      	        AND     D               ; "AND" MSBs
2061:	0EF2  E9      	        JP      (HL)            ; Save AC as current (ACPASS)
2062:			
2063:	0EF3  B3      	POR1:   OR      E               ; "OR" LSBs
2064:	0EF4  4F      	        LD      C,A             ; Save LSB
2065:	0EF5  78      	        LD      A,B             ; Get MSB
2066:	0EF6  B2      	        OR      D               ; "OR" MSBs
2067:	0EF7  E9      	        JP      (HL)            ; Save AC as current (ACPASS)
2068:			
2069:	0EF8  210A0F  	TSTRED: LD      HL,CMPLOG       ; Logical compare routine
2070:	0EFB  3AF220  	        LD      A,(TYPE)        ; Get data type
2071:	0EFE  1F      	        RRA                     ; Carry set = string
2072:	0EFF  7A      	        LD      A,D             ; Get last precedence value
2073:	0F00  17      	        RLA                     ; Times 2 plus carry
2074:	0F01  5F      	        LD      E,A             ; To E
2075:	0F02  1664    	        LD      D,64H           ; Relational precedence
2076:	0F04  78      	        LD      A,B             ; Get current precedence
2077:	0F05  BA      	        CP      D               ; Compare with last
2078:	0F06  D0      	        RET     NC              ; Eval if last was rel' or log'
2079:	0F07  C3F90D  	        JP      STKTHS          ; Stack this one and get next
2080:			
2081:	0F0A  0C0F    	CMPLOG: .DW     CMPLG1          ; Compare two values / strings
2082:	0F0C  79      	CMPLG1: LD      A,C             ; Get data type
2083:	0F0D  B7      	        OR      A
2084:	0F0E  1F      	        RRA
2085:	0F0F  C1      	        POP     BC              ; Get last expression to BCDE
2086:	0F10  D1      	        POP     DE
2087:	0F11  F5      	        PUSH    AF              ; Save status
2088:	0F12  CD8C0D  	        CALL    CHKTYP          ; Check that types match
2089:	0F15  214E0F  	        LD      HL,CMPRES       ; Result to comparison
2090:	0F18  E5      	        PUSH    HL              ; Save for RETurn
2091:	0F19  CAE417  	        JP      Z,CMPNUM        ; Compare values if numeric
2092:	0F1C  AF      	        XOR     A               ; Compare two strings
2093:	0F1D  32F220  	        LD      (TYPE),A        ; Set type to numeric
2094:	0F20  D5      	        PUSH    DE              ; Save string name
2095:	0F21  CDA313  	        CALL    GSTRCU          ; Get current string
2096:	0F24  7E      	        LD      A,(HL)          ; Get length of string
2097:	0F25  23      	        INC     HL
2098:	0F26  23      	        INC     HL
2099:	0F27  4E      	        LD      C,(HL)          ; Get LSB of address
2100:	0F28  23      	        INC     HL
2101:	0F29  46      	        LD      B,(HL)          ; Get MSB of address
2102:	0F2A  D1      	        POP     DE              ; Restore string name
2103:	0F2B  C5      	        PUSH    BC              ; Save address of string
2104:	0F2C  F5      	        PUSH    AF              ; Save length of string
2105:	0F2D  CDA713  	        CALL    GSTRDE          ; Get second string
2106:	0F30  CDB817  	        CALL    LOADFP          ; Get address of second string
2107:	0F33  F1      	        POP     AF              ; Restore length of string 1
2108:	0F34  57      	        LD      D,A             ; Length to D
2109:	0F35  E1      	        POP     HL              ; Restore address of string 1
2110:	0F36  7B      	CMPSTR: LD      A,E             ; Bytes of string 2 to do
2111:	0F37  B2      	        OR      D               ; Bytes of string 1 to do
2112:	0F38  C8      	        RET     Z               ; Exit if all bytes compared
2113:	0F39  7A      	        LD      A,D             ; Get bytes of string 1 to do
2114:	0F3A  D601    	        SUB     1
2115:	0F3C  D8      	        RET     C               ; Exit if end of string 1
2116:	0F3D  AF      	        XOR     A
2117:	0F3E  BB      	        CP      E               ; Bytes of string 2 to do
2118:	0F3F  3C      	        INC     A
2119:	0F40  D0      	        RET     NC              ; Exit if end of string 2
2120:	0F41  15      	        DEC     D               ; Count bytes in string 1
2121:	0F42  1D      	        DEC     E               ; Count bytes in string 2
2122:	0F43  0A      	        LD      A,(BC)          ; Byte in string 2
2123:	0F44  BE      	        CP      (HL)            ; Compare to byte in string 1
2124:	0F45  23      	        INC     HL              ; Move up string 1
2125:	0F46  03      	        INC     BC              ; Move up string 2
2126:	0F47  CA360F  	        JP      Z,CMPSTR        ; Same - Try next bytes
2127:	0F4A  3F      	        CCF                     ; Flag difference (">" or "<")
2128:	0F4B  C37417  	        JP      FLGDIF          ; "<" gives -1 , ">" gives +1
2129:			
2130:	0F4E  3C      	CMPRES: INC     A               ; Increment current value
2131:	0F4F  8F      	        ADC     A,A             ; Double plus carry
2132:	0F50  C1      	        POP     BC              ; Get other value
2133:	0F51  A0      	        AND     B               ; Combine them
2134:	0F52  C6FF    	        ADD     A,-1            ; Carry set if different
2135:	0F54  9F      	        SBC     A,A             ; 00 - Equal , FF - Different
2136:	0F55  C37B17  	        JP      FLGREL          ; Set current value & continue
2137:			
2138:	0F58  165A    	EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
2139:	0F5A  CD9C0D  	        CALL    EVAL1           ; Eval until precedence break
2140:	0F5D  CD8A0D  	        CALL    TSTNUM          ; Make sure it's a number
2141:	0F60  CDCC09  	        CALL    DEINT           ; Get integer -32768 - 32767
2142:	0F63  7B      	        LD      A,E             ; Get LSB
2143:	0F64  2F      	        CPL                     ; Invert LSB
2144:	0F65  4F      	        LD      C,A             ; Save "NOT" of LSB
2145:	0F66  7A      	        LD      A,D             ; Get MSB
2146:	0F67  2F      	        CPL                     ; Invert MSB
2147:	0F68  CD4111  	        CALL    ACPASS          ; Save AC as current
2148:	0F6B  C1      	        POP     BC              ; Clean up stack
2149:	0F6C  C3A80D  	        JP      EVAL3           ; Continue evaluation
2150:			
2151:	0F6F  2B      	DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
2152:	0F70  CD1A09  	        CALL    GETCHR          ; Get next character
2153:	0F73  C8      	        RET     Z               ; End of DIM statement
2154:	0F74  CD9007  	        CALL    CHKSYN          ; Make sure ',' follows
2155:	0F77  2C      	        .DB     ','
2156:	0F78  016F0F  	DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
2157:	0F7B  C5      	        PUSH    BC              ; Save on stack
2158:	0F7C  F6      	        .DB     0F6H            ; Flag "Create" variable
2159:	0F7D  AF      	GETVAR: XOR     A               ; Find variable address,to DE
2160:	0F7E  32F120  	        LD      (LCRFLG),A      ; Set locate / create flag
2161:	0F81  46      	        LD      B,(HL)          ; Get First byte of name
2162:	0F82  CDB809  	GTFNAM: CALL    CHKLTR          ; See if a letter
2163:	0F85  DAF604  	        JP      C,SNERR         ; ?SN Error if not a letter
2164:	0F88  AF      	        XOR     A
2165:	0F89  4F      	        LD      C,A             ; Clear second byte of name
2166:	0F8A  32F220  	        LD      (TYPE),A        ; Set type to numeric
2167:	0F8D  CD1A09  	        CALL    GETCHR          ; Get next character
2168:	0F90  DA990F  	        JP      C,SVNAM2        ; Numeric - Save in name
2169:	0F93  CDB809  	        CALL    CHKLTR          ; See if a letter
2170:	0F96  DAA60F  	        JP      C,CHARTY        ; Not a letter - Check type
2171:	0F99  4F      	SVNAM2: LD      C,A             ; Save second byte of name
2172:	0F9A  CD1A09  	ENDNAM: CALL    GETCHR          ; Get next character
2173:	0F9D  DA9A0F  	        JP      C,ENDNAM        ; Numeric - Get another
2174:	0FA0  CDB809  	        CALL    CHKLTR          ; See if a letter
2175:	0FA3  D29A0F  	        JP      NC,ENDNAM       ; Letter - Get another
2176:	0FA6  D624    	CHARTY: SUB     '$'             ; String variable?
2177:	0FA8  C2B50F  	        JP      NZ,NOTSTR       ; No - Numeric variable
2178:	0FAB  3C      	        INC     A               ; A = 1 (string type)
2179:	0FAC  32F220  	        LD      (TYPE),A        ; Set type to string
2180:	0FAF  0F      	        RRCA                    ; A = 80H , Flag for string
2181:	0FB0  81      	        ADD     A,C             ; 2nd byte of name has bit 7 on
2182:	0FB1  4F      	        LD      C,A             ; Resave second byte on name
2183:	0FB2  CD1A09  	        CALL    GETCHR          ; Get next character
2184:	0FB5  3A1021  	NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
2185:	0FB8  3D      	        DEC     A
2186:	0FB9  CA6210  	        JP      Z,ARLDSV        ; Yes - Get array name
2187:	0FBC  F2C50F  	        JP      P,NSCFOR        ; No array with "FOR" or "FN"
2188:	0FBF  7E      	        LD      A,(HL)          ; Get byte again
2189:	0FC0  D628    	        SUB     '('             ; Subscripted variable?
2190:	0FC2  CA3A10  	        JP      Z,SBSCPT        ; Yes - Sort out subscript
2191:			
2192:	0FC5  AF      	NSCFOR: XOR     A               ; Simple variable
2193:	0FC6  321021  	        LD      (FORFLG),A      ; Clear "FOR" flag
2194:	0FC9  E5      	        PUSH    HL              ; Save code string address
2195:	0FCA  50      	        LD      D,B             ; DE = Variable name to find
2196:	0FCB  59      	        LD      E,C
2197:	0FCC  2A2321  	        LD      HL,(FNRGNM)     ; FN argument name
2198:	0FCF  CD8A07  	        CALL    CPDEHL          ; Is it the FN argument?
2199:	0FD2  112521  	        LD      DE,FNARG        ; Point to argument value
2200:	0FD5  CAAA16  	        JP      Z,POPHRT        ; Yes - Return FN argument value
2201:	0FD8  2A1D21  	        LD      HL,(VAREND)     ; End of variables
2202:	0FDB  EB      	        EX      DE,HL           ; Address of end of search
2203:	0FDC  2A1B21  	        LD      HL,(PROGND)     ; Start of variables address
2204:	0FDF  CD8A07  	FNDVAR: CALL    CPDEHL          ; End of variable list table?
2205:	0FE2  CAF80F  	        JP      Z,CFEVAL        ; Yes - Called from EVAL?
2206:	0FE5  79      	        LD      A,C             ; Get second byte of name
2207:	0FE6  96      	        SUB     (HL)            ; Compare with name in list
2208:	0FE7  23      	        INC     HL              ; Move on to first byte
2209:	0FE8  C2ED0F  	        JP      NZ,FNTHR        ; Different - Find another
2210:	0FEB  78      	        LD      A,B             ; Get first byte of name
2211:	0FEC  96      	        SUB     (HL)            ; Compare with name in list
2212:	0FED  23      	FNTHR:  INC     HL              ; Move on to LSB of value
2213:	0FEE  CA2C10  	        JP      Z,RETADR        ; Found - Return address
2214:	0FF1  23      	        INC     HL              ; <- Skip
2215:	0FF2  23      	        INC     HL              ; <- over
2216:	0FF3  23      	        INC     HL              ; <- F.P.
2217:	0FF4  23      	        INC     HL              ; <- value
2218:	0FF5  C3DF0F  	        JP      FNDVAR          ; Keep looking
2219:			
2220:	0FF8  E1      	CFEVAL: POP     HL              ; Restore code string address
2221:	0FF9  E3      	        EX      (SP),HL         ; Get return address
2222:	0FFA  D5      	        PUSH    DE              ; Save address of variable
2223:	0FFB  117A0E  	        LD      DE,FRMEVL       ; Return address in EVAL
2224:	0FFE  CD8A07  	        CALL    CPDEHL          ; Called from EVAL ?
2225:	1001  D1      	        POP     DE              ; Restore address of variable
2226:	1002  CA2F10  	        JP      Z,RETNUL        ; Yes - Return null variable
2227:	1005  E3      	        EX      (SP),HL         ; Put back return
2228:	1006  E5      	        PUSH    HL              ; Save code string address
2229:	1007  C5      	        PUSH    BC              ; Save variable name
2230:	1008  010600  	        LD      BC,6            ; 2 byte name plus 4 byte data
2231:	100B  2A1F21  	        LD      HL,(ARREND)     ; End of arrays
2232:	100E  E5      	        PUSH    HL              ; Save end of arrays
2233:	100F  09      	        ADD     HL,BC           ; Move up 6 bytes
2234:	1010  C1      	        POP     BC              ; Source address in BC
2235:	1011  E5      	        PUSH    HL              ; Save new end address
2236:	1012  CDC204  	        CALL    MOVUP           ; Move arrays up
2237:	1015  E1      	        POP     HL              ; Restore new end address
2238:	1016  221F21  	        LD      (ARREND),HL     ; Set new end address
2239:	1019  60      	        LD      H,B             ; End of variables to HL
2240:	101A  69      	        LD      L,C
2241:	101B  221D21  	        LD      (VAREND),HL     ; Set new end address
2242:			
2243:	101E  2B      	ZEROLP: DEC     HL              ; Back through to zero variable
2244:	101F  3600    	        LD      (HL),0          ; Zero byte in variable
2245:	1021  CD8A07  	        CALL    CPDEHL          ; Done them all?
2246:	1024  C21E10  	        JP      NZ,ZEROLP       ; No - Keep on going
2247:	1027  D1      	        POP     DE              ; Get variable name
2248:	1028  73      	        LD      (HL),E          ; Store second character
2249:	1029  23      	        INC     HL
2250:	102A  72      	        LD      (HL),D          ; Store first character
2251:	102B  23      	        INC     HL
2252:	102C  EB      	RETADR: EX      DE,HL           ; Address of variable in DE
2253:	102D  E1      	        POP     HL              ; Restore code string address
2254:	102E  C9      	        RET
2255:			
2256:	102F  322C21  	RETNUL: LD      (FPEXP),A       ; Set result to zero
2257:	1032  219204  	        LD      HL,ZERBYT       ; Also set a null string
2258:	1035  222921  	        LD      (FPREG),HL      ; Save for EVAL
2259:	1038  E1      	        POP     HL              ; Restore code string address
2260:	1039  C9      	        RET
2261:			
2262:	103A  E5      	SBSCPT: PUSH    HL              ; Save code string address
2263:	103B  2AF120  	        LD      HL,(LCRFLG)     ; Locate/Create and Type
2264:	103E  E3      	        EX      (SP),HL         ; Save and get code string
2265:	103F  57      	        LD      D,A             ; Zero number of dimensions
2266:	1040  D5      	SCPTLP: PUSH    DE              ; Save number of dimensions
2267:	1041  C5      	        PUSH    BC              ; Save array name
2268:	1042  CDC009  	        CALL    FPSINT          ; Get subscript (0-32767)
2269:	1045  C1      	        POP     BC              ; Restore array name
2270:	1046  F1      	        POP     AF              ; Get number of dimensions
2271:	1047  EB      	        EX      DE,HL
2272:	1048  E3      	        EX      (SP),HL         ; Save subscript value
2273:	1049  E5      	        PUSH    HL              ; Save LCRFLG and TYPE
2274:	104A  EB      	        EX      DE,HL
2275:	104B  3C      	        INC     A               ; Count dimensions
2276:	104C  57      	        LD      D,A             ; Save in D
2277:	104D  7E      	        LD      A,(HL)          ; Get next byte in code string
2278:	104E  FE2C    	        CP      ','             ; Comma (more to come)?
2279:	1050  CA4010  	        JP      Z,SCPTLP        ; Yes - More subscripts
2280:	1053  CD9007  	        CALL    CHKSYN          ; Make sure ")" follows
2281:	1056  29      	        .DB     ")"
2282:	1057  221521  	        LD      (NXTOPR),HL     ; Save code string address
2283:	105A  E1      	        POP     HL              ; Get LCRFLG and TYPE
2284:	105B  22F120  	        LD      (LCRFLG),HL     ; Restore Locate/create & type
2285:	105E  1E00    	        LD      E,0             ; Flag not CSAVE* or CLOAD*
2286:	1060  D5      	        PUSH    DE              ; Save number of dimensions (D)
2287:	1061  11      	        .DB     11H             ; Skip "PUSH HL" and "PUSH AF'
2288:			
2289:	1062  E5      	ARLDSV: PUSH    HL              ; Save code string address
2290:	1063  F5      	        PUSH    AF              ; A = 00 , Flags set = Z,N
2291:	1064  2A1D21  	        LD      HL,(VAREND)     ; Start of arrays
2292:	1067  3E      	        .DB     3EH             ; Skip "ADD HL,DE"
2293:	1068  19      	FNDARY: ADD     HL,DE           ; Move to next array start
2294:	1069  EB      	        EX      DE,HL
2295:	106A  2A1F21  	        LD      HL,(ARREND)     ; End of arrays
2296:	106D  EB      	        EX      DE,HL           ; Current array pointer
2297:	106E  CD8A07  	        CALL    CPDEHL          ; End of arrays found?
2298:	1071  CA9A10  	        JP      Z,CREARY        ; Yes - Create array
2299:	1074  7E      	        LD      A,(HL)          ; Get second byte of name
2300:	1075  B9      	        CP      C               ; Compare with name given
2301:	1076  23      	        INC     HL              ; Move on
2302:	1077  C27C10  	        JP      NZ,NXTARY       ; Different - Find next array
2303:	107A  7E      	        LD      A,(HL)          ; Get first byte of name
2304:	107B  B8      	        CP      B               ; Compare with name given
2305:	107C  23      	NXTARY: INC     HL              ; Move on
2306:	107D  5E      	        LD      E,(HL)          ; Get LSB of next array address
2307:	107E  23      	        INC     HL
2308:	107F  56      	        LD      D,(HL)          ; Get MSB of next array address
2309:	1080  23      	        INC     HL
2310:	1081  C26810  	        JP      NZ,FNDARY       ; Not found - Keep looking
2311:	1084  3AF120  	        LD      A,(LCRFLG)      ; Found Locate or Create it?
2312:	1087  B7      	        OR      A
2313:	1088  C2FF04  	        JP      NZ,DDERR        ; Create - ?DD Error
2314:	108B  F1      	        POP     AF              ; Locate - Get number of dim'ns
2315:	108C  44      	        LD      B,H             ; BC Points to array dim'ns
2316:	108D  4D      	        LD      C,L
2317:	108E  CAAA16  	        JP      Z,POPHRT        ; Jump if array load/save
2318:	1091  96      	        SUB     (HL)            ; Same number of dimensions?
2319:	1092  CAF810  	        JP      Z,FINDEL        ; Yes - Find element
2320:	1095  1E10    	BSERR:  LD      E,BS            ; ?BS Error
2321:	1097  C30A05  	        JP      ERROR           ; Output error
2322:			
2323:	109A  110400  	CREARY: LD      DE,4            ; 4 Bytes per entry
2324:	109D  F1      	        POP     AF              ; Array to save or 0 dim'ns?
2325:	109E  CAE109  	        JP      Z,FCERR         ; Yes - ?FC Error
2326:	10A1  71      	        LD      (HL),C          ; Save second byte of name
2327:	10A2  23      	        INC     HL
2328:	10A3  70      	        LD      (HL),B          ; Save first byte of name
2329:	10A4  23      	        INC     HL
2330:	10A5  4F      	        LD      C,A             ; Number of dimensions to C
2331:	10A6  CDD304  	        CALL    CHKSTK          ; Check if enough memory
2332:	10A9  23      	        INC     HL              ; Point to number of dimensions
2333:	10AA  23      	        INC     HL
2334:	10AB  220A21  	        LD      (CUROPR),HL     ; Save address of pointer
2335:	10AE  71      	        LD      (HL),C          ; Set number of dimensions
2336:	10AF  23      	        INC     HL
2337:	10B0  3AF120  	        LD      A,(LCRFLG)      ; Locate of Create?
2338:	10B3  17      	        RLA                     ; Carry set = Create
2339:	10B4  79      	        LD      A,C             ; Get number of dimensions
2340:	10B5  010B00  	CRARLP: LD      BC,10+1         ; Default dimension size 10
2341:	10B8  D2BD10  	        JP      NC,DEFSIZ       ; Locate - Set default size
2342:	10BB  C1      	        POP     BC              ; Get specified dimension size
2343:	10BC  03      	        INC     BC              ; Include zero element
2344:	10BD  71      	DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
2345:	10BE  23      	        INC     HL
2346:	10BF  70      	        LD      (HL),B          ; Save MSB of dimension size
2347:	10C0  23      	        INC     HL
2348:	10C1  F5      	        PUSH    AF              ; Save num' of dim'ns an status
2349:	10C2  E5      	        PUSH    HL              ; Save address of dim'n size
2350:	10C3  CD5518  	        CALL    MLDEBC          ; Multiply DE by BC to find
2351:	10C6  EB      	        EX      DE,HL           ; amount of mem needed (to DE)
2352:	10C7  E1      	        POP     HL              ; Restore address of dimension
2353:	10C8  F1      	        POP     AF              ; Restore number of dimensions
2354:	10C9  3D      	        DEC     A               ; Count them
2355:	10CA  C2B510  	        JP      NZ,CRARLP       ; Do next dimension if more
2356:	10CD  F5      	        PUSH    AF              ; Save locate/create flag
2357:	10CE  42      	        LD      B,D             ; MSB of memory needed
2358:	10CF  4B      	        LD      C,E             ; LSB of memory needed
2359:	10D0  EB      	        EX      DE,HL
2360:	10D1  19      	        ADD     HL,DE           ; Add bytes to array start
2361:	10D2  DAEB04  	        JP      C,OMERR         ; Too big - Error
2362:	10D5  CDDC04  	        CALL    ENFMEM          ; See if enough memory
2363:	10D8  221F21  	        LD      (ARREND),HL     ; Save new end of array
2364:			
2365:	10DB  2B      	ZERARY: DEC     HL              ; Back through array data
2366:	10DC  3600    	        LD      (HL),0          ; Set array element to zero
2367:	10DE  CD8A07  	        CALL    CPDEHL          ; All elements zeroed?
2368:	10E1  C2DB10  	        JP      NZ,ZERARY       ; No - Keep on going
2369:	10E4  03      	        INC     BC              ; Number of bytes + 1
2370:	10E5  57      	        LD      D,A             ; A=0
2371:	10E6  2A0A21  	        LD      HL,(CUROPR)     ; Get address of array
2372:	10E9  5E      	        LD      E,(HL)          ; Number of dimensions
2373:	10EA  EB      	        EX      DE,HL           ; To HL
2374:	10EB  29      	        ADD     HL,HL           ; Two bytes per dimension size
2375:	10EC  09      	        ADD     HL,BC           ; Add number of bytes
2376:	10ED  EB      	        EX      DE,HL           ; Bytes needed to DE
2377:	10EE  2B      	        DEC     HL
2378:	10EF  2B      	        DEC     HL
2379:	10F0  73      	        LD      (HL),E          ; Save LSB of bytes needed
2380:	10F1  23      	        INC     HL
2381:	10F2  72      	        LD      (HL),D          ; Save MSB of bytes needed
2382:	10F3  23      	        INC     HL
2383:	10F4  F1      	        POP     AF              ; Locate / Create?
2384:	10F5  DA1C11  	        JP      C,ENDDIM        ; A is 0 , End if create
2385:	10F8  47      	FINDEL: LD      B,A             ; Find array element
2386:	10F9  4F      	        LD      C,A
2387:	10FA  7E      	        LD      A,(HL)          ; Number of dimensions
2388:	10FB  23      	        INC     HL
2389:	10FC  16      	        .DB     16H             ; Skip "POP HL"
2390:	10FD  E1      	FNDELP: POP     HL              ; Address of next dim' size
2391:	10FE  5E      	        LD      E,(HL)          ; Get LSB of dim'n size
2392:	10FF  23      	        INC     HL
2393:	1100  56      	        LD      D,(HL)          ; Get MSB of dim'n size
2394:	1101  23      	        INC     HL
2395:	1102  E3      	        EX      (SP),HL         ; Save address - Get index
2396:	1103  F5      	        PUSH    AF              ; Save number of dim'ns
2397:	1104  CD8A07  	        CALL    CPDEHL          ; Dimension too large?
2398:	1107  D29510  	        JP      NC,BSERR        ; Yes - ?BS Error
2399:	110A  E5      	        PUSH    HL              ; Save index
2400:	110B  CD5518  	        CALL    MLDEBC          ; Multiply previous by size
2401:	110E  D1      	        POP     DE              ; Index supplied to DE
2402:	110F  19      	        ADD     HL,DE           ; Add index to pointer
2403:	1110  F1      	        POP     AF              ; Number of dimensions
2404:	1111  3D      	        DEC     A               ; Count them
2405:	1112  44      	        LD      B,H             ; MSB of pointer
2406:	1113  4D      	        LD      C,L             ; LSB of pointer
2407:	1114  C2FD10  	        JP      NZ,FNDELP       ; More - Keep going
2408:	1117  29      	        ADD     HL,HL           ; 4 Bytes per element
2409:	1118  29      	        ADD     HL,HL
2410:	1119  C1      	        POP     BC              ; Start of array
2411:	111A  09      	        ADD     HL,BC           ; Point to element
2412:	111B  EB      	        EX      DE,HL           ; Address of element to DE
2413:	111C  2A1521  	ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
2414:	111F  C9      	        RET
2415:			
2416:	1120  2A1F21  	FRE:    LD      HL,(ARREND)     ; Start of free memory
2417:	1123  EB      	        EX      DE,HL           ; To DE
2418:	1124  210000  	        LD      HL,0            ; End of free memory
2419:	1127  39      	        ADD     HL,SP           ; Current stack value
2420:	1128  3AF220  	        LD      A,(TYPE)        ; Dummy argument type
2421:	112B  B7      	        OR      A
2422:	112C  CA3C11  	        JP      Z,FRENUM        ; Numeric - Free variable space
2423:	112F  CDA313  	        CALL    GSTRCU          ; Current string to pool
2424:	1132  CDA312  	        CALL    GARBGE          ; Garbage collection
2425:	1135  2A9F20  	        LD      HL,(STRSPC)     ; Bottom of string space in use
2426:	1138  EB      	        EX      DE,HL           ; To DE
2427:	1139  2A0821  	        LD      HL,(STRBOT)     ; Bottom of string space
2428:	113C  7D      	FRENUM: LD      A,L             ; Get LSB of end
2429:	113D  93      	        SUB     E               ; Subtract LSB of beginning
2430:	113E  4F      	        LD      C,A             ; Save difference if C
2431:	113F  7C      	        LD      A,H             ; Get MSB of end
2432:	1140  9A      	        SBC     A,D             ; Subtract MSB of beginning
2433:	1141  41      	ACPASS: LD      B,C             ; Return integer AC
2434:	1142  50      	ABPASS: LD      D,B             ; Return integer AB
2435:	1143  1E00    	        LD      E,0
2436:	1145  21F220  	        LD      HL,TYPE         ; Point to type
2437:	1148  73      	        LD      (HL),E          ; Set type to numeric
2438:	1149  0690    	        LD      B,80H+16        ; 16 bit integer
2439:	114B  C38017  	        JP      RETINT          ; Return the integr
2440:			
2441:	114E  3AF020  	POS:    LD      A,(CURPOS)      ; Get cursor position
2442:	1151  47      	PASSA:  LD      B,A             ; Put A into AB
2443:	1152  AF      	        XOR     A               ; Zero A
2444:	1153  C34211  	        JP      ABPASS          ; Return integer AB
2445:			
2446:	1156  CDD911  	DEF:    CALL    CHEKFN          ; Get "FN" and name
2447:	1159  CDCB11  	        CALL    IDTEST          ; Test for illegal direct
2448:	115C  01B10A  	        LD      BC,DATA         ; To get next statement
2449:	115F  C5      	        PUSH    BC              ; Save address for RETurn
2450:	1160  D5      	        PUSH    DE              ; Save address of function ptr
2451:	1161  CD9007  	        CALL    CHKSYN          ; Make sure "(" follows
2452:	1164  28      	        .DB     "("
2453:	1165  CD7D0F  	        CALL    GETVAR          ; Get argument variable name
2454:	1168  E5      	        PUSH    HL              ; Save code string address
2455:	1169  EB      	        EX      DE,HL           ; Argument address to HL
2456:	116A  2B      	        DEC     HL
2457:	116B  56      	        LD      D,(HL)          ; Get first byte of arg name
2458:	116C  2B      	        DEC     HL
2459:	116D  5E      	        LD      E,(HL)          ; Get second byte of arg name
2460:	116E  E1      	        POP     HL              ; Restore code string address
2461:	116F  CD8A0D  	        CALL    TSTNUM          ; Make sure numeric argument
2462:	1172  CD9007  	        CALL    CHKSYN          ; Make sure ")" follows
2463:	1175  29      	        .DB     ")"
2464:	1176  CD9007  	        CALL    CHKSYN          ; Make sure "=" follows
2465:	1179  B4      	        .DB     ZEQUAL          ; "=" token
2466:	117A  44      	        LD      B,H             ; Code string address to BC
2467:	117B  4D      	        LD      C,L
2468:	117C  E3      	        EX      (SP),HL         ; Save code str , Get FN ptr
2469:	117D  71      	        LD      (HL),C          ; Save LSB of FN code string
2470:	117E  23      	        INC     HL
2471:	117F  70      	        LD      (HL),B          ; Save MSB of FN code string
2472:	1180  C31812  	        JP      SVSTAD          ; Save address and do function
2473:			
2474:	1183  CDD911  	DOFN:   CALL    CHEKFN          ; Make sure FN follows
2475:	1186  D5      	        PUSH    DE              ; Save function pointer address
2476:	1187  CD5E0E  	        CALL    EVLPAR          ; Evaluate expression in "()"
2477:	118A  CD8A0D  	        CALL    TSTNUM          ; Make sure numeric result
2478:	118D  E3      	        EX      (SP),HL         ; Save code str , Get FN ptr
2479:	118E  5E      	        LD      E,(HL)          ; Get LSB of FN code string
2480:	118F  23      	        INC     HL
2481:	1190  56      	        LD      D,(HL)          ; Get MSB of FN code string
2482:	1191  23      	        INC     HL
2483:	1192  7A      	        LD      A,D             ; And function DEFined?
2484:	1193  B3      	        OR      E
2485:	1194  CA0205  	        JP      Z,UFERR         ; No - ?UF Error
2486:	1197  7E      	        LD      A,(HL)          ; Get LSB of argument address
2487:	1198  23      	        INC     HL
2488:	1199  66      	        LD      H,(HL)          ; Get MSB of argument address
2489:	119A  6F      	        LD      L,A             ; HL = Arg variable address
2490:	119B  E5      	        PUSH    HL              ; Save it
2491:	119C  2A2321  	        LD      HL,(FNRGNM)     ; Get old argument name
2492:	119F  E3      	        EX      (SP),HL ;       ; Save old , Get new
2493:	11A0  222321  	        LD      (FNRGNM),HL     ; Set new argument name
2494:	11A3  2A2721  	        LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2495:	11A6  E5      	        PUSH    HL              ; Save it
2496:	11A7  2A2521  	        LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
2497:	11AA  E5      	        PUSH    HL              ; Save it
2498:	11AB  212521  	        LD      HL,FNARG        ; HL = Value of argument
2499:	11AE  D5      	        PUSH    DE              ; Save FN code string address
2500:	11AF  CDC117  	        CALL    FPTHL           ; Move FPREG to argument
2501:	11B2  E1      	        POP     HL              ; Get FN code string address
2502:	11B3  CD870D  	        CALL    GETNUM          ; Get value from function
2503:	11B6  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
2504:	11B7  CD1A09  	        CALL    GETCHR          ; Get next character
2505:	11BA  C2F604  	        JP      NZ,SNERR        ; Bad character in FN - Error
2506:	11BD  E1      	        POP     HL              ; Get MSB,EXP of old arg
2507:	11BE  222521  	        LD      (FNARG),HL      ; Restore it
2508:	11C1  E1      	        POP     HL              ; Get LSB,NLSB of old arg
2509:	11C2  222721  	        LD      (FNARG+2),HL    ; Restore it
2510:	11C5  E1      	        POP     HL              ; Get name of old arg
2511:	11C6  222321  	        LD      (FNRGNM),HL     ; Restore it
2512:	11C9  E1      	        POP     HL              ; Restore code string address
2513:	11CA  C9      	        RET
2514:			
2515:	11CB  E5      	IDTEST: PUSH    HL              ; Save code string address
2516:	11CC  2AA120  	        LD      HL,(LINEAT)     ; Get current line number
2517:	11CF  23      	        INC     HL              ; -1 means direct statement
2518:	11D0  7C      	        LD      A,H
2519:	11D1  B5      	        OR      L
2520:	11D2  E1      	        POP     HL              ; Restore code string address
2521:	11D3  C0      	        RET     NZ              ; Return if in program
2522:	11D4  1E16    	        LD      E,ID            ; ?ID Error
2523:	11D6  C30A05  	        JP      ERROR
2524:			
2525:	11D9  CD9007  	CHEKFN: CALL    CHKSYN          ; Make sure FN follows
2526:	11DC  A7      	        .DB     ZFN             ; "FN" token
2527:	11DD  3E80    	        LD      A,80H
2528:	11DF  321021  	        LD      (FORFLG),A      ; Flag FN name to find
2529:	11E2  B6      	        OR      (HL)            ; FN name has bit 7 set
2530:	11E3  47      	        LD      B,A             ; in first byte of name
2531:	11E4  CD820F  	        CALL    GTFNAM          ; Get FN name
2532:	11E7  C38A0D  	        JP      TSTNUM          ; Make sure numeric function
2533:			
2534:	11EA  CD8A0D  	STR:    CALL    TSTNUM          ; Make sure it's a number
2535:	11ED  CD0E19  	        CALL    NUMASC          ; Turn number into text
2536:	11F0  CD1E12  	STR1:   CALL    CRTST           ; Create string entry for it
2537:	11F3  CDA313  	        CALL    GSTRCU          ; Current string to pool
2538:	11F6  01FE13  	        LD      BC,TOPOOL       ; Save in string pool
2539:	11F9  C5      	        PUSH    BC              ; Save address on stack
2540:			
2541:	11FA  7E      	SAVSTR: LD      A,(HL)          ; Get string length
2542:	11FB  23      	        INC     HL
2543:	11FC  23      	        INC     HL
2544:	11FD  E5      	        PUSH    HL              ; Save pointer to string
2545:	11FE  CD7912  	        CALL    TESTR           ; See if enough string space
2546:	1201  E1      	        POP     HL              ; Restore pointer to string
2547:	1202  4E      	        LD      C,(HL)          ; Get LSB of address
2548:	1203  23      	        INC     HL
2549:	1204  46      	        LD      B,(HL)          ; Get MSB of address
2550:	1205  CD1212  	        CALL    CRTMST          ; Create string entry
2551:	1208  E5      	        PUSH    HL              ; Save pointer to MSB of addr
2552:	1209  6F      	        LD      L,A             ; Length of string
2553:	120A  CD9613  	        CALL    TOSTRA          ; Move to string area
2554:	120D  D1      	        POP     DE              ; Restore pointer to MSB
2555:	120E  C9      	        RET
2556:			
2557:	120F  CD7912  	MKTMST: CALL    TESTR           ; See if enough string space
2558:	1212  210421  	CRTMST: LD      HL,TMPSTR       ; Temporary string
2559:	1215  E5      	        PUSH    HL              ; Save it
2560:	1216  77      	        LD      (HL),A          ; Save length of string
2561:	1217  23      	        INC     HL
2562:	1218  23      	SVSTAD: INC     HL
2563:	1219  73      	        LD      (HL),E          ; Save LSB of address
2564:	121A  23      	        INC     HL
2565:	121B  72      	        LD      (HL),D          ; Save MSB of address
2566:	121C  E1      	        POP     HL              ; Restore pointer
2567:	121D  C9      	        RET
2568:			
2569:	121E  2B      	CRTST:  DEC     HL              ; DEC - INCed after
2570:	121F  0622    	QTSTR:  LD      B,'"'           ; Terminating quote
2571:	1221  50      	        LD      D,B             ; Quote to D
2572:	1222  E5      	DTSTR:  PUSH    HL              ; Save start
2573:	1223  0EFF    	        LD      C,-1            ; Set counter to -1
2574:	1225  23      	QTSTLP: INC     HL              ; Move on
2575:	1226  7E      	        LD      A,(HL)          ; Get byte
2576:	1227  0C      	        INC     C               ; Count bytes
2577:	1228  B7      	        OR      A               ; End of line?
2578:	1229  CA3412  	        JP      Z,CRTSTE        ; Yes - Create string entry
2579:	122C  BA      	        CP      D               ; Terminator D found?
2580:	122D  CA3412  	        JP      Z,CRTSTE        ; Yes - Create string entry
2581:	1230  B8      	        CP      B               ; Terminator B found?
2582:	1231  C22512  	        JP      NZ,QTSTLP       ; No - Keep looking
2583:	1234  FE22    	CRTSTE: CP      '"'             ; End with '"'?
2584:	1236  CC1A09  	        CALL    Z,GETCHR        ; Yes - Get next character
2585:	1239  E3      	        EX      (SP),HL         ; Starting quote
2586:	123A  23      	        INC     HL              ; First byte of string
2587:	123B  EB      	        EX      DE,HL           ; To DE
2588:	123C  79      	        LD      A,C             ; Get length
2589:	123D  CD1212  	        CALL    CRTMST          ; Create string entry
2590:	1240  110421  	TSTOPL: LD      DE,TMPSTR       ; Temporary string
2591:	1243  2AF620  	        LD      HL,(TMSTPT)     ; Temporary string pool pointer
2592:	1246  222921  	        LD      (FPREG),HL      ; Save address of string ptr
2593:	1249  3E01    	        LD      A,1
2594:	124B  32F220  	        LD      (TYPE),A        ; Set type to string
2595:	124E  CDC417  	        CALL    DETHL4          ; Move string to pool
2596:	1251  CD8A07  	        CALL    CPDEHL          ; Out of string pool?
2597:	1254  22F620  	        LD      (TMSTPT),HL     ; Save new pointer
2598:	1257  E1      	        POP     HL              ; Restore code string address
2599:	1258  7E      	        LD      A,(HL)          ; Get next code byte
2600:	1259  C0      	        RET     NZ              ; Return if pool OK
2601:	125A  1E1E    	        LD      E,ST            ; ?ST Error
2602:	125C  C30A05  	        JP      ERROR           ; String pool overflow
2603:			
2604:	125F  23      	PRNUMS: INC     HL              ; Skip leading space
2605:	1260  CD1E12  	PRS:    CALL    CRTST           ; Create string entry for it
2606:	1263  CDA313  	PRS1:   CALL    GSTRCU          ; Current string to pool
2607:	1266  CDB817  	        CALL    LOADFP          ; Move string block to BCDE
2608:	1269  1C      	        INC     E               ; Length + 1
2609:	126A  1D      	PRSLP:  DEC     E               ; Count characters
2610:	126B  C8      	        RET     Z               ; End of string
2611:	126C  0A      	        LD      A,(BC)          ; Get byte to output
2612:	126D  CD9B07  	        CALL    OUTC            ; Output character in A
2613:	1270  FE0D    	        CP      CR              ; Return?
2614:	1272  CCCC0B  	        CALL    Z,DONULL        ; Yes - Do nulls
2615:	1275  03      	        INC     BC              ; Next byte in string
2616:	1276  C36A12  	        JP      PRSLP           ; More characters to output
2617:			
2618:	1279  B7      	TESTR:  OR      A               ; Test if enough room
2619:	127A  0E      	        .DB     0EH             ; No garbage collection done
2620:	127B  F1      	GRBDON: POP     AF              ; Garbage collection done
2621:	127C  F5      	        PUSH    AF              ; Save status
2622:	127D  2A9F20  	        LD      HL,(STRSPC)     ; Bottom of string space in use
2623:	1280  EB      	        EX      DE,HL           ; To DE
2624:	1281  2A0821  	        LD      HL,(STRBOT)     ; Bottom of string area
2625:	1284  2F      	        CPL                     ; Negate length (Top down)
2626:	1285  4F      	        LD      C,A             ; -Length to BC
2627:	1286  06FF    	        LD      B,-1            ; BC = -ve length of string
2628:	1288  09      	        ADD     HL,BC           ; Add to bottom of space in use
2629:	1289  23      	        INC     HL              ; Plus one for 2's complement
2630:	128A  CD8A07  	        CALL    CPDEHL          ; Below string RAM area?
2631:	128D  DA9712  	        JP      C,TESTOS        ; Tidy up if not done else err
2632:	1290  220821  	        LD      (STRBOT),HL     ; Save new bottom of area
2633:	1293  23      	        INC     HL              ; Point to first byte of string
2634:	1294  EB      	        EX      DE,HL           ; Address to DE
2635:	1295  F1      	POPAF:  POP     AF              ; Throw away status push
2636:	1296  C9      	        RET
2637:			
2638:	1297  F1      	TESTOS: POP     AF              ; Garbage collect been done?
2639:	1298  1E1A    	        LD      E,OS            ; ?OS Error
2640:	129A  CA0A05  	        JP      Z,ERROR         ; Yes - Not enough string apace
2641:	129D  BF      	        CP      A               ; Flag garbage collect done
2642:	129E  F5      	        PUSH    AF              ; Save status
2643:	129F  017B12  	        LD      BC,GRBDON       ; Garbage collection done
2644:	12A2  C5      	        PUSH    BC              ; Save for RETurn
2645:	12A3  2AF420  	GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
2646:	12A6  220821  	GARBLP: LD      (STRBOT),HL     ; Reset string pointer
2647:	12A9  210000  	        LD      HL,0
2648:	12AC  E5      	        PUSH    HL              ; Flag no string found
2649:	12AD  2A9F20  	        LD      HL,(STRSPC)     ; Get bottom of string space
2650:	12B0  E5      	        PUSH    HL              ; Save bottom of string space
2651:	12B1  21F820  	        LD      HL,TMSTPL       ; Temporary string pool
2652:	12B4  EB      	GRBLP:  EX      DE,HL
2653:	12B5  2AF620  	        LD      HL,(TMSTPT)     ; Temporary string pool pointer
2654:	12B8  EB      	        EX      DE,HL
2655:	12B9  CD8A07  	        CALL    CPDEHL          ; Temporary string pool done?
2656:	12BC  01B412  	        LD      BC,GRBLP        ; Loop until string pool done
2657:	12BF  C20813  	        JP      NZ,STPOOL       ; No - See if in string area
2658:	12C2  2A1B21  	        LD      HL,(PROGND)     ; Start of simple variables
2659:	12C5  EB      	SMPVAR: EX      DE,HL
2660:	12C6  2A1D21  	        LD      HL,(VAREND)     ; End of simple variables
2661:	12C9  EB      	        EX      DE,HL
2662:	12CA  CD8A07  	        CALL    CPDEHL          ; All simple strings done?
2663:	12CD  CADB12  	        JP      Z,ARRLP         ; Yes - Do string arrays
2664:	12D0  7E      	        LD      A,(HL)          ; Get type of variable
2665:	12D1  23      	        INC     HL
2666:	12D2  23      	        INC     HL
2667:	12D3  B7      	        OR      A               ; "S" flag set if string
2668:	12D4  CD0B13  	        CALL    STRADD          ; See if string in string area
2669:	12D7  C3C512  	        JP      SMPVAR          ; Loop until simple ones done
2670:			
2671:	12DA  C1      	GNXARY: POP     BC              ; Scrap address of this array
2672:	12DB  EB      	ARRLP:  EX      DE,HL
2673:	12DC  2A1F21  	        LD      HL,(ARREND)     ; End of string arrays
2674:	12DF  EB      	        EX      DE,HL
2675:	12E0  CD8A07  	        CALL    CPDEHL          ; All string arrays done?
2676:	12E3  CA3113  	        JP      Z,SCNEND        ; Yes - Move string if found
2677:	12E6  CDB817  	        CALL    LOADFP          ; Get array name to BCDE
2678:	12E9  7B      	        LD      A,E             ; Get type of array     
2679:	12EA  E5      	        PUSH    HL              ; Save address of num of dim'ns
2680:	12EB  09      	        ADD     HL,BC           ; Start of next array
2681:	12EC  B7      	        OR      A               ; Test type of array
2682:	12ED  F2DA12  	        JP      P,GNXARY        ; Numeric array - Ignore it
2683:	12F0  220A21  	        LD      (CUROPR),HL     ; Save address of next array
2684:	12F3  E1      	        POP     HL              ; Get address of num of dim'ns
2685:	12F4  4E      	        LD      C,(HL)          ; BC = Number of dimensions
2686:	12F5  0600    	        LD      B,0
2687:	12F7  09      	        ADD     HL,BC           ; Two bytes per dimension size
2688:	12F8  09      	        ADD     HL,BC
2689:	12F9  23      	        INC     HL              ; Plus one for number of dim'ns
2690:	12FA  EB      	GRBARY: EX      DE,HL
2691:	12FB  2A0A21  	        LD      HL,(CUROPR)     ; Get address of next array
2692:	12FE  EB      	        EX      DE,HL
2693:	12FF  CD8A07  	        CALL    CPDEHL          ; Is this array finished?
2694:	1302  CADB12  	        JP      Z,ARRLP         ; Yes - Get next one
2695:	1305  01FA12  	        LD      BC,GRBARY       ; Loop until array all done
2696:	1308  C5      	STPOOL: PUSH    BC              ; Save return address
2697:	1309  F680    	        OR      80H             ; Flag string type
2698:	130B  7E      	STRADD: LD      A,(HL)          ; Get string length
2699:	130C  23      	        INC     HL
2700:	130D  23      	        INC     HL
2701:	130E  5E      	        LD      E,(HL)          ; Get LSB of string address
2702:	130F  23      	        INC     HL
2703:	1310  56      	        LD      D,(HL)          ; Get MSB of string address
2704:	1311  23      	        INC     HL
2705:	1312  F0      	        RET     P               ; Not a string - Return
2706:	1313  B7      	        OR      A               ; Set flags on string length
2707:	1314  C8      	        RET     Z               ; Null string - Return
2708:	1315  44      	        LD      B,H             ; Save variable pointer
2709:	1316  4D      	        LD      C,L
2710:	1317  2A0821  	        LD      HL,(STRBOT)     ; Bottom of new area
2711:	131A  CD8A07  	        CALL    CPDEHL          ; String been done?
2712:	131D  60      	        LD      H,B             ; Restore variable pointer
2713:	131E  69      	        LD      L,C
2714:	131F  D8      	        RET     C               ; String done - Ignore
2715:	1320  E1      	        POP     HL              ; Return address
2716:	1321  E3      	        EX      (SP),HL         ; Lowest available string area
2717:	1322  CD8A07  	        CALL    CPDEHL          ; String within string area?
2718:	1325  E3      	        EX      (SP),HL         ; Lowest available string area
2719:	1326  E5      	        PUSH    HL              ; Re-save return address
2720:	1327  60      	        LD      H,B             ; Restore variable pointer
2721:	1328  69      	        LD      L,C
2722:	1329  D0      	        RET     NC              ; Outside string area - Ignore
2723:	132A  C1      	        POP     BC              ; Get return , Throw 2 away
2724:	132B  F1      	        POP     AF              ; 
2725:	132C  F1      	        POP     AF              ; 
2726:	132D  E5      	        PUSH    HL              ; Save variable pointer
2727:	132E  D5      	        PUSH    DE              ; Save address of current
2728:	132F  C5      	        PUSH    BC              ; Put back return address
2729:	1330  C9      	        RET                     ; Go to it
2730:			
2731:	1331  D1      	SCNEND: POP     DE              ; Addresses of strings
2732:	1332  E1      	        POP     HL              ; 
2733:	1333  7D      	        LD      A,L             ; HL = 0 if no more to do
2734:	1334  B4      	        OR      H
2735:	1335  C8      	        RET     Z               ; No more to do - Return
2736:	1336  2B      	        DEC     HL
2737:	1337  46      	        LD      B,(HL)          ; MSB of address of string
2738:	1338  2B      	        DEC     HL
2739:	1339  4E      	        LD      C,(HL)          ; LSB of address of string
2740:	133A  E5      	        PUSH    HL              ; Save variable address
2741:	133B  2B      	        DEC     HL
2742:	133C  2B      	        DEC     HL
2743:	133D  6E      	        LD      L,(HL)          ; HL = Length of string
2744:	133E  2600    	        LD      H,0
2745:	1340  09      	        ADD     HL,BC           ; Address of end of string+1
2746:	1341  50      	        LD      D,B             ; String address to DE
2747:	1342  59      	        LD      E,C
2748:	1343  2B      	        DEC     HL              ; Last byte in string
2749:	1344  44      	        LD      B,H             ; Address to BC
2750:	1345  4D      	        LD      C,L
2751:	1346  2A0821  	        LD      HL,(STRBOT)     ; Current bottom of string area
2752:	1349  CDC504  	        CALL    MOVSTR          ; Move string to new address
2753:	134C  E1      	        POP     HL              ; Restore variable address
2754:	134D  71      	        LD      (HL),C          ; Save new LSB of address
2755:	134E  23      	        INC     HL
2756:	134F  70      	        LD      (HL),B          ; Save new MSB of address
2757:	1350  69      	        LD      L,C             ; Next string area+1 to HL
2758:	1351  60      	        LD      H,B
2759:	1352  2B      	        DEC     HL              ; Next string area address
2760:	1353  C3A612  	        JP      GARBLP          ; Look for more strings
2761:			
2762:	1356  C5      	CONCAT: PUSH    BC              ; Save prec' opr & code string
2763:	1357  E5      	        PUSH    HL              ; 
2764:	1358  2A2921  	        LD      HL,(FPREG)      ; Get first string
2765:	135B  E3      	        EX      (SP),HL         ; Save first string
2766:	135C  CD100E  	        CALL    OPRND           ; Get second string
2767:	135F  E3      	        EX      (SP),HL         ; Restore first string
2768:	1360  CD8B0D  	        CALL    TSTSTR          ; Make sure it's a string
2769:	1363  7E      	        LD      A,(HL)          ; Get length of second string
2770:	1364  E5      	        PUSH    HL              ; Save first string
2771:	1365  2A2921  	        LD      HL,(FPREG)      ; Get second string
2772:	1368  E5      	        PUSH    HL              ; Save second string
2773:	1369  86      	        ADD     A,(HL)          ; Add length of second string
2774:	136A  1E1C    	        LD      E,LS            ; ?LS Error
2775:	136C  DA0A05  	        JP      C,ERROR         ; String too long - Error
2776:	136F  CD0F12  	        CALL    MKTMST          ; Make temporary string
2777:	1372  D1      	        POP     DE              ; Get second string to DE
2778:	1373  CDA713  	        CALL    GSTRDE          ; Move to string pool if needed
2779:	1376  E3      	        EX      (SP),HL         ; Get first string
2780:	1377  CDA613  	        CALL    GSTRHL          ; Move to string pool if needed
2781:	137A  E5      	        PUSH    HL              ; Save first string
2782:	137B  2A0621  	        LD      HL,(TMPSTR+2)   ; Temporary string address
2783:	137E  EB      	        EX      DE,HL           ; To DE
2784:	137F  CD8D13  	        CALL    SSTSA           ; First string to string area
2785:	1382  CD8D13  	        CALL    SSTSA           ; Second string to string area
2786:	1385  21A50D  	        LD      HL,EVAL2        ; Return to evaluation loop
2787:	1388  E3      	        EX      (SP),HL         ; Save return,get code string
2788:	1389  E5      	        PUSH    HL              ; Save code string address
2789:	138A  C34012  	        JP      TSTOPL          ; To temporary string to pool
2790:			
2791:	138D  E1      	SSTSA:  POP     HL              ; Return address
2792:	138E  E3      	        EX      (SP),HL         ; Get string block,save return
2793:	138F  7E      	        LD      A,(HL)          ; Get length of string
2794:	1390  23      	        INC     HL
2795:	1391  23      	        INC     HL
2796:	1392  4E      	        LD      C,(HL)          ; Get LSB of string address
2797:	1393  23      	        INC     HL
2798:	1394  46      	        LD      B,(HL)          ; Get MSB of string address
2799:	1395  6F      	        LD      L,A             ; Length to L
2800:	1396  2C      	TOSTRA: INC     L               ; INC - DECed after
2801:	1397  2D      	TSALP:  DEC     L               ; Count bytes moved
2802:	1398  C8      	        RET     Z               ; End of string - Return
2803:	1399  0A      	        LD      A,(BC)          ; Get source
2804:	139A  12      	        LD      (DE),A          ; Save destination
2805:	139B  03      	        INC     BC              ; Next source
2806:	139C  13      	        INC     DE              ; Next destination
2807:	139D  C39713  	        JP      TSALP           ; Loop until string moved
2808:			
2809:	13A0  CD8B0D  	GETSTR: CALL    TSTSTR          ; Make sure it's a string
2810:	13A3  2A2921  	GSTRCU: LD      HL,(FPREG)      ; Get current string
2811:	13A6  EB      	GSTRHL: EX      DE,HL           ; Save DE
2812:	13A7  CDC113  	GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
2813:	13AA  EB      	        EX      DE,HL           ; Restore DE
2814:	13AB  C0      	        RET     NZ              ; No - Return
2815:	13AC  D5      	        PUSH    DE              ; Save string
2816:	13AD  50      	        LD      D,B             ; String block address to DE
2817:	13AE  59      	        LD      E,C
2818:	13AF  1B      	        DEC     DE              ; Point to length
2819:	13B0  4E      	        LD      C,(HL)          ; Get string length
2820:	13B1  2A0821  	        LD      HL,(STRBOT)     ; Current bottom of string area
2821:	13B4  CD8A07  	        CALL    CPDEHL          ; Last one in string area?
2822:	13B7  C2BF13  	        JP      NZ,POPHL        ; No - Return
2823:	13BA  47      	        LD      B,A             ; Clear B (A=0)
2824:	13BB  09      	        ADD     HL,BC           ; Remove string from str' area
2825:	13BC  220821  	        LD      (STRBOT),HL     ; Save new bottom of str' area
2826:	13BF  E1      	POPHL:  POP     HL              ; Restore string
2827:	13C0  C9      	        RET
2828:			
2829:	13C1  2AF620  	BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
2830:	13C4  2B      	        DEC     HL              ; Back
2831:	13C5  46      	        LD      B,(HL)          ; Get MSB of address
2832:	13C6  2B      	        DEC     HL              ; Back
2833:	13C7  4E      	        LD      C,(HL)          ; Get LSB of address
2834:	13C8  2B      	        DEC     HL              ; Back
2835:	13C9  2B      	        DEC     HL              ; Back
2836:	13CA  CD8A07  	        CALL    CPDEHL          ; String last in string pool?
2837:	13CD  C0      	        RET     NZ              ; Yes - Leave it
2838:	13CE  22F620  	        LD      (TMSTPT),HL     ; Save new string pool top
2839:	13D1  C9      	        RET
2840:			
2841:	13D2  015111  	LEN:    LD      BC,PASSA        ; To return integer A
2842:	13D5  C5      	        PUSH    BC              ; Save address
2843:	13D6  CDA013  	GETLEN: CALL    GETSTR          ; Get string and its length
2844:	13D9  AF      	        XOR     A
2845:	13DA  57      	        LD      D,A             ; Clear D
2846:	13DB  32F220  	        LD      (TYPE),A        ; Set type to numeric
2847:	13DE  7E      	        LD      A,(HL)          ; Get length of string
2848:	13DF  B7      	        OR      A               ; Set status flags
2849:	13E0  C9      	        RET
2850:			
2851:	13E1  015111  	ASC:    LD      BC,PASSA        ; To return integer A
2852:	13E4  C5      	        PUSH    BC              ; Save address
2853:	13E5  CDD613  	GTFLNM: CALL    GETLEN          ; Get length of string
2854:	13E8  CAE109  	        JP      Z,FCERR         ; Null string - Error
2855:	13EB  23      	        INC     HL
2856:	13EC  23      	        INC     HL
2857:	13ED  5E      	        LD      E,(HL)          ; Get LSB of address
2858:	13EE  23      	        INC     HL
2859:	13EF  56      	        LD      D,(HL)          ; Get MSB of address
2860:	13F0  1A      	        LD      A,(DE)          ; Get first byte of string
2861:	13F1  C9      	        RET
2862:			
2863:	13F2  3E01    	CHR:    LD      A,1             ; One character string
2864:	13F4  CD0F12  	        CALL    MKTMST          ; Make a temporary string
2865:	13F7  CDEB14  	        CALL    MAKINT          ; Make it integer A
2866:	13FA  2A0621  	        LD      HL,(TMPSTR+2)   ; Get address of string
2867:	13FD  73      	        LD      (HL),E          ; Save character
2868:	13FE  C1      	TOPOOL: POP     BC              ; Clean up stack
2869:	13FF  C34012  	        JP      TSTOPL          ; Temporary string to pool
2870:			
2871:	1402  CD9B14  	LEFT:   CALL    LFRGNM          ; Get number and ending ")"
2872:	1405  AF      	        XOR     A               ; Start at first byte in string
2873:	1406  E3      	RIGHT1: EX      (SP),HL         ; Save code string,Get string
2874:	1407  4F      	        LD      C,A             ; Starting position in string
2875:	1408  E5      	MID1:   PUSH    HL              ; Save string block address
2876:	1409  7E      	        LD      A,(HL)          ; Get length of string
2877:	140A  B8      	        CP      B               ; Compare with number given
2878:	140B  DA1014  	        JP      C,ALLFOL        ; All following bytes required
2879:	140E  78      	        LD      A,B             ; Get new length
2880:	140F  11      	        .DB     11H             ; Skip "LD C,0"
2881:	1410  0E00    	ALLFOL: LD      C,0             ; First byte of string
2882:	1412  C5      	        PUSH    BC              ; Save position in string
2883:	1413  CD7912  	        CALL    TESTR           ; See if enough string space
2884:	1416  C1      	        POP     BC              ; Get position in string
2885:	1417  E1      	        POP     HL              ; Restore string block address
2886:	1418  E5      	        PUSH    HL              ; And re-save it
2887:	1419  23      	        INC     HL
2888:	141A  23      	        INC     HL
2889:	141B  46      	        LD      B,(HL)          ; Get LSB of address
2890:	141C  23      	        INC     HL
2891:	141D  66      	        LD      H,(HL)          ; Get MSB of address
2892:	141E  68      	        LD      L,B             ; HL = address of string
2893:	141F  0600    	        LD      B,0             ; BC = starting address
2894:	1421  09      	        ADD     HL,BC           ; Point to that byte
2895:	1422  44      	        LD      B,H             ; BC = source string
2896:	1423  4D      	        LD      C,L
2897:	1424  CD1212  	        CALL    CRTMST          ; Create a string entry
2898:	1427  6F      	        LD      L,A             ; Length of new string
2899:	1428  CD9613  	        CALL    TOSTRA          ; Move string to string area
2900:	142B  D1      	        POP     DE              ; Clear stack
2901:	142C  CDA713  	        CALL    GSTRDE          ; Move to string pool if needed
2902:	142F  C34012  	        JP      TSTOPL          ; Temporary string to pool
2903:			
2904:	1432  CD9B14  	RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
2905:	1435  D1      	        POP     DE              ; Get string length
2906:	1436  D5      	        PUSH    DE              ; And re-save
2907:	1437  1A      	        LD      A,(DE)          ; Get length
2908:	1438  90      	        SUB     B               ; Move back N bytes
2909:	1439  C30614  	        JP      RIGHT1          ; Go and get sub-string
2910:			
2911:	143C  EB      	MID:    EX      DE,HL           ; Get code string address
2912:	143D  7E      	        LD      A,(HL)          ; Get next byte ',' or ")"
2913:	143E  CDA014  	        CALL    MIDNUM          ; Get number supplied
2914:	1441  04      	        INC     B               ; Is it character zero?
2915:	1442  05      	        DEC     B
2916:	1443  CAE109  	        JP      Z,FCERR         ; Yes - Error
2917:	1446  C5      	        PUSH    BC              ; Save starting position
2918:	1447  1EFF    	        LD      E,255           ; All of string
2919:	1449  FE29    	        CP      ')'             ; Any length given?
2920:	144B  CA5514  	        JP      Z,RSTSTR        ; No - Rest of string
2921:	144E  CD9007  	        CALL    CHKSYN          ; Make sure ',' follows
2922:	1451  2C      	        .DB     ','
2923:	1452  CDE814  	        CALL    GETINT          ; Get integer 0-255
2924:	1455  CD9007  	RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
2925:	1458  29      	        .DB     ")"
2926:	1459  F1      	        POP     AF              ; Restore starting position
2927:	145A  E3      	        EX      (SP),HL         ; Get string,8ave code string
2928:	145B  010814  	        LD      BC,MID1         ; Continuation of MID$ routine
2929:	145E  C5      	        PUSH    BC              ; Save for return
2930:	145F  3D      	        DEC     A               ; Starting position-1
2931:	1460  BE      	        CP      (HL)            ; Compare with length
2932:	1461  0600    	        LD      B,0             ; Zero bytes length
2933:	1463  D0      	        RET     NC              ; Null string if start past end
2934:	1464  4F      	        LD      C,A             ; Save starting position-1
2935:	1465  7E      	        LD      A,(HL)          ; Get length of string
2936:	1466  91      	        SUB     C               ; Subtract start
2937:	1467  BB      	        CP      E               ; Enough string for it?
2938:	1468  47      	        LD      B,A             ; Save maximum length available
2939:	1469  D8      	        RET     C               ; Truncate string if needed
2940:	146A  43      	        LD      B,E             ; Set specified length
2941:	146B  C9      	        RET                     ; Go and create string
2942:			
2943:	146C  CDD613  	VAL:    CALL    GETLEN          ; Get length of string
2944:	146F  CA8915  	        JP      Z,RESZER        ; Result zero
2945:	1472  5F      	        LD      E,A             ; Save length
2946:	1473  23      	        INC     HL
2947:	1474  23      	        INC     HL
2948:	1475  7E      	        LD      A,(HL)          ; Get LSB of address
2949:	1476  23      	        INC     HL
2950:	1477  66      	        LD      H,(HL)          ; Get MSB of address
2951:	1478  6F      	        LD      L,A             ; HL = String address
2952:	1479  E5      	        PUSH    HL              ; Save string address
2953:	147A  19      	        ADD     HL,DE
2954:	147B  46      	        LD      B,(HL)          ; Get end of string+1 byte
2955:	147C  72      	        LD      (HL),D          ; Zero it to terminate
2956:	147D  E3      	        EX      (SP),HL         ; Save string end,get start
2957:	147E  C5      	        PUSH    BC              ; Save end+1 byte
2958:	147F  7E      	        LD      A,(HL)          ; Get starting byte
2959:	1480  FE24    	        CP      '$'             ; Hex number indicated? [function added]
2960:	1482  C28A14  	        JP      NZ,VAL1
2961:	1485  CDB41C  	        CALL    HEXTFP          ; Convert Hex to FPREG
2962:	1488  180D    	        JR      VAL3
2963:	148A  FE25    	VAL1:   CP	'%'             ; Binary number indicated? [function added]
2964:	148C  C29414  	    JP	NZ,VAL2
2965:	148F  CD241D  	    CALL	BINTFP		; Convert Bin to FPREG
2966:	1492  1803    	    JR	VAL3
2967:	1494  CD7018  	VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
2968:	1497  C1      	VAL3:   POP     BC              ; Restore end+1 byte
2969:	1498  E1      	        POP     HL              ; Restore end+1 address
2970:	1499  70      	        LD      (HL),B          ; Put back original byte
2971:	149A  C9      	        RET
2972:			
2973:	149B  EB      	LFRGNM: EX      DE,HL           ; Code string address to HL
2974:	149C  CD9007  	        CALL    CHKSYN          ; Make sure ")" follows
2975:	149F  29      	        .DB     ")"
2976:	14A0  C1      	MIDNUM: POP     BC              ; Get return address
2977:	14A1  D1      	        POP     DE              ; Get number supplied
2978:	14A2  C5      	        PUSH    BC              ; Re-save return address
2979:	14A3  43      	        LD      B,E             ; Number to B
2980:	14A4  C9      	        RET
2981:			
2982:	14A5  CDEB14  	INP:    CALL    MAKINT          ; Make it integer A
2983:	14A8  328420  	        LD      (INPORT),A      ; Set input port
2984:	14AB  CD8320  	        CALL    INPSUB          ; Get input from port
2985:	14AE  C35111  	        JP      PASSA           ; Return integer A
2986:			
2987:	14B1  CDD514  	POUT:   CALL    SETIO           ; Set up port number
2988:	14B4  C34B20  	        JP      OUTSUB          ; Output data and return
2989:			
2990:	14B7  CDD514  	WAIT:   CALL    SETIO           ; Set up port number
2991:	14BA  F5      	        PUSH    AF              ; Save AND mask
2992:	14BB  1E00    	        LD      E,0             ; Assume zero if none given
2993:	14BD  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
2994:	14BE  CD1A09  	        CALL    GETCHR          ; Get next character
2995:	14C1  CACB14  	        JP      Z,NOXOR         ; No XOR byte given
2996:	14C4  CD9007  	        CALL    CHKSYN          ; Make sure ',' follows
2997:	14C7  2C      	        .DB     ','
2998:	14C8  CDE814  	        CALL    GETINT          ; Get integer 0-255 to XOR with
2999:	14CB  C1      	NOXOR:  POP     BC              ; Restore AND mask
3000:	14CC  CD8320  	WAITLP: CALL    INPSUB          ; Get input
3001:	14CF  AB      	        XOR     E               ; Flip selected bits
3002:	14D0  A0      	        AND     B               ; Result non-zero?
3003:	14D1  CACC14  	        JP      Z,WAITLP        ; No = keep waiting
3004:	14D4  C9      	        RET
3005:			
3006:	14D5  CDE814  	SETIO:  CALL    GETINT          ; Get integer 0-255
3007:	14D8  328420  	        LD      (INPORT),A      ; Set input port
3008:	14DB  324C20  	        LD      (OTPORT),A      ; Set output port
3009:	14DE  CD9007  	        CALL    CHKSYN          ; Make sure ',' follows
3010:	14E1  2C      	        .DB     ','
3011:	14E2  C3E814  	        JP      GETINT          ; Get integer 0-255 and return
3012:			
3013:	14E5  CD1A09  	FNDNUM: CALL    GETCHR          ; Get next character
3014:	14E8  CD870D  	GETINT: CALL    GETNUM          ; Get a number from 0 to 255
3015:	14EB  CDC609  	MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
3016:	14EE  7A      	        LD      A,D             ; Get MSB of number
3017:	14EF  B7      	        OR      A               ; Zero?
3018:	14F0  C2E109  	        JP      NZ,FCERR        ; No - Error
3019:	14F3  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
3020:	14F4  CD1A09  	        CALL    GETCHR          ; Get next character
3021:	14F7  7B      	        LD      A,E             ; Get number to A
3022:	14F8  C9      	        RET
3023:			
3024:	14F9  CDCC09  	PEEK:   CALL    DEINT           ; Get memory address
3025:	14FC  1A      	        LD      A,(DE)          ; Get byte in memory
3026:	14FD  C35111  	        JP      PASSA           ; Return integer A
3027:			
3028:	1500  CD870D  	POKE:   CALL    GETNUM          ; Get memory address
3029:	1503  CDCC09  	        CALL    DEINT           ; Get integer -32768 to 3276
3030:	1506  D5      	        PUSH    DE              ; Save memory address
3031:	1507  CD9007  	        CALL    CHKSYN          ; Make sure ',' follows
3032:	150A  2C      	        .DB     ','
3033:	150B  CDE814  	        CALL    GETINT          ; Get integer 0-255
3034:	150E  D1      	        POP     DE              ; Restore memory address
3035:	150F  12      	        LD      (DE),A          ; Load it into memory
3036:	1510  C9      	        RET
3037:			
3038:	1511  21E719  	ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
3039:	1514  CDB817  	ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
3040:	1517  C32315  	        JP      FPADD           ; Add BCDE to FPREG
3041:			
3042:	151A  CDB817  	SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
3043:	151D  21      	        .DB     21H             ; Skip "POP BC" and "POP DE"
3044:	151E  C1      	PSUB:   POP     BC              ; Get FP number from stack
3045:	151F  D1      	        POP     DE
3046:	1520  CD9217  	SUBCDE: CALL    INVSGN          ; Negate FPREG
3047:	1523  78      	FPADD:  LD      A,B             ; Get FP exponent
3048:	1524  B7      	        OR      A               ; Is number zero?
3049:	1525  C8      	        RET     Z               ; Yes - Nothing to add
3050:	1526  3A2C21  	        LD      A,(FPEXP)       ; Get FPREG exponent
3051:	1529  B7      	        OR      A               ; Is this number zero?
3052:	152A  CAAA17  	        JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3053:	152D  90      	        SUB     B               ; BCDE number larger?
3054:	152E  D23D15  	        JP      NC,NOSWAP       ; No - Don't swap them
3055:	1531  2F      	        CPL                     ; Two's complement
3056:	1532  3C      	        INC     A               ;  FP exponent
3057:	1533  EB      	        EX      DE,HL
3058:	1534  CD9A17  	        CALL    STAKFP          ; Put FPREG on stack
3059:	1537  EB      	        EX      DE,HL
3060:	1538  CDAA17  	        CALL    FPBCDE          ; Move BCDE to FPREG
3061:	153B  C1      	        POP     BC              ; Restore number from stack
3062:	153C  D1      	        POP     DE
3063:	153D  FE19    	NOSWAP: CP      24+1            ; Second number insignificant?
3064:	153F  D0      	        RET     NC              ; Yes - First number is result
3065:	1540  F5      	        PUSH    AF              ; Save number of bits to scale
3066:	1541  CDCF17  	        CALL    SIGNS           ; Set MSBs & sign of result
3067:	1544  67      	        LD      H,A             ; Save sign of result
3068:	1545  F1      	        POP     AF              ; Restore scaling factor
3069:	1546  CDE815  	        CALL    SCALE           ; Scale BCDE to same exponent
3070:	1549  B4      	        OR      H               ; Result to be positive?
3071:	154A  212921  	        LD      HL,FPREG        ; Point to FPREG
3072:	154D  F26315  	        JP      P,MINCDE        ; No - Subtract FPREG from CDE
3073:	1550  CDC815  	        CALL    PLUCDE          ; Add FPREG to CDE
3074:	1553  D2A915  	        JP      NC,RONDUP       ; No overflow - Round it up
3075:	1556  23      	        INC     HL              ; Point to exponent
3076:	1557  34      	        INC     (HL)            ; Increment it
3077:	1558  CA0505  	        JP      Z,OVERR         ; Number overflowed - Error
3078:	155B  2E01    	        LD      L,1             ; 1 bit to shift right
3079:	155D  CDFE15  	        CALL    SHRT1           ; Shift result right
3080:	1560  C3A915  	        JP      RONDUP          ; Round it up
3081:			
3082:	1563  AF      	MINCDE: XOR     A               ; Clear A and carry
3083:	1564  90      	        SUB     B               ; Negate exponent
3084:	1565  47      	        LD      B,A             ; Re-save exponent
3085:	1566  7E      	        LD      A,(HL)          ; Get LSB of FPREG
3086:	1567  9B      	        SBC     A, E            ; Subtract LSB of BCDE
3087:	1568  5F      	        LD      E,A             ; Save LSB of BCDE
3088:	1569  23      	        INC     HL
3089:	156A  7E      	        LD      A,(HL)          ; Get NMSB of FPREG
3090:	156B  9A      	        SBC     A,D             ; Subtract NMSB of BCDE
3091:	156C  57      	        LD      D,A             ; Save NMSB of BCDE
3092:	156D  23      	        INC     HL
3093:	156E  7E      	        LD      A,(HL)          ; Get MSB of FPREG
3094:	156F  99      	        SBC     A,C             ; Subtract MSB of BCDE
3095:	1570  4F      	        LD      C,A             ; Save MSB of BCDE
3096:	1571  DCD415  	CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
3097:			
3098:	1574  68      	BNORM:  LD      L,B             ; L = Exponent
3099:	1575  63      	        LD      H,E             ; H = LSB
3100:	1576  AF      	        XOR     A
3101:	1577  47      	BNRMLP: LD      B,A             ; Save bit count
3102:	1578  79      	        LD      A,C             ; Get MSB
3103:	1579  B7      	        OR      A               ; Is it zero?
3104:	157A  C29615  	        JP      NZ,PNORM        ; No - Do it bit at a time
3105:	157D  4A      	        LD      C,D             ; MSB = NMSB
3106:	157E  54      	        LD      D,H             ; NMSB= LSB
3107:	157F  65      	        LD      H,L             ; LSB = VLSB
3108:	1580  6F      	        LD      L,A             ; VLSB= 0
3109:	1581  78      	        LD      A,B             ; Get exponent
3110:	1582  D608    	        SUB     8               ; Count 8 bits
3111:	1584  FEE0    	        CP      -24-8           ; Was number zero?
3112:	1586  C27715  	        JP      NZ,BNRMLP       ; No - Keep normalising
3113:	1589  AF      	RESZER: XOR     A               ; Result is zero
3114:	158A  322C21  	SAVEXP: LD      (FPEXP),A       ; Save result as zero
3115:	158D  C9      	        RET
3116:			
3117:	158E  05      	NORMAL: DEC     B               ; Count bits
3118:	158F  29      	        ADD     HL,HL           ; Shift HL left
3119:	1590  7A      	        LD      A,D             ; Get NMSB
3120:	1591  17      	        RLA                     ; Shift left with last bit
3121:	1592  57      	        LD      D,A             ; Save NMSB
3122:	1593  79      	        LD      A,C             ; Get MSB
3123:	1594  8F      	        ADC     A,A             ; Shift left with last bit
3124:	1595  4F      	        LD      C,A             ; Save MSB
3125:	1596  F28E15  	PNORM:  JP      P,NORMAL        ; Not done - Keep going
3126:	1599  78      	        LD      A,B             ; Number of bits shifted
3127:	159A  5C      	        LD      E,H             ; Save HL in EB
3128:	159B  45      	        LD      B,L
3129:	159C  B7      	        OR      A               ; Any shifting done?
3130:	159D  CAA915  	        JP      Z,RONDUP        ; No - Round it up
3131:	15A0  212C21  	        LD      HL,FPEXP        ; Point to exponent
3132:	15A3  86      	        ADD     A,(HL)          ; Add shifted bits
3133:	15A4  77      	        LD      (HL),A          ; Re-save exponent
3134:	15A5  D28915  	        JP      NC,RESZER       ; Underflow - Result is zero
3135:	15A8  C8      	        RET     Z               ; Result is zero
3136:	15A9  78      	RONDUP: LD      A,B             ; Get VLSB of number
3137:	15AA  212C21  	RONDB:  LD      HL,FPEXP        ; Point to exponent
3138:	15AD  B7      	        OR      A               ; Any rounding?
3139:	15AE  FCBB15  	        CALL    M,FPROND        ; Yes - Round number up
3140:	15B1  46      	        LD      B,(HL)          ; B = Exponent
3141:	15B2  23      	        INC     HL
3142:	15B3  7E      	        LD      A,(HL)          ; Get sign of result
3143:	15B4  E680    	        AND     10000000B       ; Only bit 7 needed
3144:	15B6  A9      	        XOR     C               ; Set correct sign
3145:	15B7  4F      	        LD      C,A             ; Save correct sign in number
3146:	15B8  C3AA17  	        JP      FPBCDE          ; Move BCDE to FPREG
3147:			
3148:	15BB  1C      	FPROND: INC     E               ; Round LSB
3149:	15BC  C0      	        RET     NZ              ; Return if ok
3150:	15BD  14      	        INC     D               ; Round NMSB
3151:	15BE  C0      	        RET     NZ              ; Return if ok
3152:	15BF  0C      	        INC     C               ; Round MSB
3153:	15C0  C0      	        RET     NZ              ; Return if ok
3154:	15C1  0E80    	        LD      C,80H           ; Set normal value
3155:	15C3  34      	        INC     (HL)            ; Increment exponent
3156:	15C4  C0      	        RET     NZ              ; Return if ok
3157:	15C5  C30505  	        JP      OVERR           ; Overflow error
3158:			
3159:	15C8  7E      	PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
3160:	15C9  83      	        ADD     A,E             ; Add LSB of BCDE
3161:	15CA  5F      	        LD      E,A             ; Save LSB of BCDE
3162:	15CB  23      	        INC     HL
3163:	15CC  7E      	        LD      A,(HL)          ; Get NMSB of FPREG
3164:	15CD  8A      	        ADC     A,D             ; Add NMSB of BCDE
3165:	15CE  57      	        LD      D,A             ; Save NMSB of BCDE
3166:	15CF  23      	        INC     HL
3167:	15D0  7E      	        LD      A,(HL)          ; Get MSB of FPREG
3168:	15D1  89      	        ADC     A,C             ; Add MSB of BCDE
3169:	15D2  4F      	        LD      C,A             ; Save MSB of BCDE
3170:	15D3  C9      	        RET
3171:			
3172:	15D4  212D21  	COMPL:  LD      HL,SGNRES       ; Sign of result
3173:	15D7  7E      	        LD      A,(HL)          ; Get sign of result
3174:	15D8  2F      	        CPL                     ; Negate it
3175:	15D9  77      	        LD      (HL),A          ; Put it back
3176:	15DA  AF      	        XOR     A
3177:	15DB  6F      	        LD      L,A             ; Set L to zero
3178:	15DC  90      	        SUB     B               ; Negate exponent,set carry
3179:	15DD  47      	        LD      B,A             ; Re-save exponent
3180:	15DE  7D      	        LD      A,L             ; Load zero
3181:	15DF  9B      	        SBC     A,E             ; Negate LSB
3182:	15E0  5F      	        LD      E,A             ; Re-save LSB
3183:	15E1  7D      	        LD      A,L             ; Load zero
3184:	15E2  9A      	        SBC     A,D             ; Negate NMSB
3185:	15E3  57      	        LD      D,A             ; Re-save NMSB
3186:	15E4  7D      	        LD      A,L             ; Load zero
3187:	15E5  99      	        SBC     A,C             ; Negate MSB
3188:	15E6  4F      	        LD      C,A             ; Re-save MSB
3189:	15E7  C9      	        RET
3190:			
3191:	15E8  0600    	SCALE:  LD      B,0             ; Clear underflow
3192:	15EA  D608    	SCALLP: SUB     8               ; 8 bits (a whole byte)?
3193:	15EC  DAF715  	        JP      C,SHRITE        ; No - Shift right A bits
3194:	15EF  43      	        LD      B,E             ; <- Shift
3195:	15F0  5A      	        LD      E,D             ; <- right
3196:	15F1  51      	        LD      D,C             ; <- eight
3197:	15F2  0E00    	        LD      C,0             ; <- bits
3198:	15F4  C3EA15  	        JP      SCALLP          ; More bits to shift
3199:			
3200:	15F7  C609    	SHRITE: ADD     A,8+1           ; Adjust count
3201:	15F9  6F      	        LD      L,A             ; Save bits to shift
3202:	15FA  AF      	SHRLP:  XOR     A               ; Flag for all done
3203:	15FB  2D      	        DEC     L               ; All shifting done?
3204:	15FC  C8      	        RET     Z               ; Yes - Return
3205:	15FD  79      	        LD      A,C             ; Get MSB
3206:	15FE  1F      	SHRT1:  RRA                     ; Shift it right
3207:	15FF  4F      	        LD      C,A             ; Re-save
3208:	1600  7A      	        LD      A,D             ; Get NMSB
3209:	1601  1F      	        RRA                     ; Shift right with last bit
3210:	1602  57      	        LD      D,A             ; Re-save it
3211:	1603  7B      	        LD      A,E             ; Get LSB
3212:	1604  1F      	        RRA                     ; Shift right with last bit
3213:	1605  5F      	        LD      E,A             ; Re-save it
3214:	1606  78      	        LD      A,B             ; Get underflow
3215:	1607  1F      	        RRA                     ; Shift right with last bit
3216:	1608  47      	        LD      B,A             ; Re-save underflow
3217:	1609  C3FA15  	        JP      SHRLP           ; More bits to do
3218:			
3219:	160C  00000081	UNITY:  .DB     000H,000H,000H,081H  ; 1.00000
3220:			
3221:	1610  03      	LOGTAB: .DB     3                    ; Table used by LOG
3222:	1611  AA561980	        .DB     0AAH,056H,019H,080H  ; 0.59898
3223:	1615  F1227680	        .DB     0F1H,022H,076H,080H  ; 0.96147
3224:	1619  45AA3882	        .DB     045H,0AAH,038H,082H  ; 2.88539
3225:			
3226:	161D  CD6917  	LOG:    CALL    TSTSGN          ; Test sign of value
3227:	1620  B7      	        OR      A
3228:	1621  EAE109  	        JP      PE,FCERR        ; ?FC Error if <= zero
3229:	1624  212C21  	        LD      HL,FPEXP        ; Point to exponent
3230:	1627  7E      	        LD      A,(HL)          ; Get exponent
3231:	1628  013580  	        LD      BC,8035H        ; BCDE = SQR(1/2)
3232:	162B  11F304  	        LD      DE,04F3H
3233:	162E  90      	        SUB     B               ; Scale value to be < 1
3234:	162F  F5      	        PUSH    AF              ; Save scale factor
3235:	1630  70      	        LD      (HL),B          ; Save new exponent
3236:	1631  D5      	        PUSH    DE              ; Save SQR(1/2)
3237:	1632  C5      	        PUSH    BC
3238:	1633  CD2315  	        CALL    FPADD           ; Add SQR(1/2) to value
3239:	1636  C1      	        POP     BC              ; Restore SQR(1/2)
3240:	1637  D1      	        POP     DE
3241:	1638  04      	        INC     B               ; Make it SQR(2)
3242:	1639  CDBF16  	        CALL    DVBCDE          ; Divide by SQR(2)
3243:	163C  210C16  	        LD      HL,UNITY        ; Point to 1.
3244:	163F  CD1A15  	        CALL    SUBPHL          ; Subtract FPREG from 1
3245:	1642  211016  	        LD      HL,LOGTAB       ; Coefficient table
3246:	1645  CDB11A  	        CALL    SUMSER          ; Evaluate sum of series
3247:	1648  018080  	        LD      BC,8080H        ; BCDE = -0.5
3248:	164B  110000  	        LD      DE,0000H
3249:	164E  CD2315  	        CALL    FPADD           ; Subtract 0.5 from FPREG
3250:	1651  F1      	        POP     AF              ; Restore scale factor
3251:	1652  CDE418  	        CALL    RSCALE          ; Re-scale number
3252:	1655  013180  	MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
3253:	1658  111872  	        LD      DE,7218H
3254:	165B  21      	        .DB     21H             ; Skip "POP BC" and "POP DE"
3255:			
3256:	165C  C1      	MULT:   POP     BC              ; Get number from stack
3257:	165D  D1      	        POP     DE
3258:	165E  CD6917  	FPMULT: CALL    TSTSGN          ; Test sign of FPREG
3259:	1661  C8      	        RET     Z               ; Return zero if zero
3260:	1662  2E00    	        LD      L,0             ; Flag add exponents
3261:	1664  CD2717  	        CALL    ADDEXP          ; Add exponents
3262:	1667  79      	        LD      A,C             ; Get MSB of multiplier
3263:	1668  323B21  	        LD      (MULVAL),A      ; Save MSB of multiplier
3264:	166B  EB      	        EX      DE,HL
3265:	166C  223C21  	        LD      (MULVAL+1),HL   ; Save rest of multiplier
3266:	166F  010000  	        LD      BC,0            ; Partial product (BCDE) = zero
3267:	1672  50      	        LD      D,B
3268:	1673  58      	        LD      E,B
3269:	1674  217415  	        LD      HL,BNORM        ; Address of normalise
3270:	1677  E5      	        PUSH    HL              ; Save for return
3271:	1678  218016  	        LD      HL,MULT8        ; Address of 8 bit multiply
3272:	167B  E5      	        PUSH    HL              ; Save for NMSB,MSB
3273:	167C  E5      	        PUSH    HL              ; 
3274:	167D  212921  	        LD      HL,FPREG        ; Point to number
3275:	1680  7E      	MULT8:  LD      A,(HL)          ; Get LSB of number
3276:	1681  23      	        INC     HL              ; Point to NMSB
3277:	1682  B7      	        OR      A               ; Test LSB
3278:	1683  CAAC16  	        JP      Z,BYTSFT        ; Zero - shift to next byte
3279:	1686  E5      	        PUSH    HL              ; Save address of number
3280:	1687  2E08    	        LD      L,8             ; 8 bits to multiply by
3281:	1689  1F      	MUL8LP: RRA                     ; Shift LSB right
3282:	168A  67      	        LD      H,A             ; Save LSB
3283:	168B  79      	        LD      A,C             ; Get MSB
3284:	168C  D29A16  	        JP      NC,NOMADD       ; Bit was zero - Don't add
3285:	168F  E5      	        PUSH    HL              ; Save LSB and count
3286:	1690  2A3C21  	        LD      HL,(MULVAL+1)   ; Get LSB and NMSB
3287:	1693  19      	        ADD     HL,DE           ; Add NMSB and LSB
3288:	1694  EB      	        EX      DE,HL           ; Leave sum in DE
3289:	1695  E1      	        POP     HL              ; Restore MSB and count
3290:	1696  3A3B21  	        LD      A,(MULVAL)      ; Get MSB of multiplier
3291:	1699  89      	        ADC     A,C             ; Add MSB
3292:	169A  1F      	NOMADD: RRA                     ; Shift MSB right
3293:	169B  4F      	        LD      C,A             ; Re-save MSB
3294:	169C  7A      	        LD      A,D             ; Get NMSB
3295:	169D  1F      	        RRA                     ; Shift NMSB right
3296:	169E  57      	        LD      D,A             ; Re-save NMSB
3297:	169F  7B      	        LD      A,E             ; Get LSB
3298:	16A0  1F      	        RRA                     ; Shift LSB right
3299:	16A1  5F      	        LD      E,A             ; Re-save LSB
3300:	16A2  78      	        LD      A,B             ; Get VLSB
3301:	16A3  1F      	        RRA                     ; Shift VLSB right
3302:	16A4  47      	        LD      B,A             ; Re-save VLSB
3303:	16A5  2D      	        DEC     L               ; Count bits multiplied
3304:	16A6  7C      	        LD      A,H             ; Get LSB of multiplier
3305:	16A7  C28916  	        JP      NZ,MUL8LP       ; More - Do it
3306:	16AA  E1      	POPHRT: POP     HL              ; Restore address of number
3307:	16AB  C9      	        RET
3308:			
3309:	16AC  43      	BYTSFT: LD      B,E             ; Shift partial product left
3310:	16AD  5A      	        LD      E,D
3311:	16AE  51      	        LD      D,C
3312:	16AF  4F      	        LD      C,A
3313:	16B0  C9      	        RET
3314:			
3315:	16B1  CD9A17  	DIV10:  CALL    STAKFP          ; Save FPREG on stack
3316:	16B4  012084  	        LD      BC,8420H        ; BCDE = 10.
3317:	16B7  110000  	        LD      DE,0000H
3318:	16BA  CDAA17  	        CALL    FPBCDE          ; Move 10 to FPREG
3319:			
3320:	16BD  C1      	DIV:    POP     BC              ; Get number from stack
3321:	16BE  D1      	        POP     DE
3322:	16BF  CD6917  	DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
3323:	16C2  CAF904  	        JP      Z,DZERR         ; Error if division by zero
3324:	16C5  2EFF    	        LD      L,-1            ; Flag subtract exponents
3325:	16C7  CD2717  	        CALL    ADDEXP          ; Subtract exponents
3326:	16CA  34      	        INC     (HL)            ; Add 2 to exponent to adjust
3327:	16CB  34      	        INC     (HL)
3328:	16CC  2B      	        DEC     HL              ; Point to MSB
3329:	16CD  7E      	        LD      A,(HL)          ; Get MSB of dividend
3330:	16CE  325720  	        LD      (DIV3),A        ; Save for subtraction
3331:	16D1  2B      	        DEC     HL
3332:	16D2  7E      	        LD      A,(HL)          ; Get NMSB of dividend
3333:	16D3  325320  	        LD      (DIV2),A        ; Save for subtraction
3334:	16D6  2B      	        DEC     HL
3335:	16D7  7E      	        LD      A,(HL)          ; Get MSB of dividend
3336:	16D8  324F20  	        LD      (DIV1),A        ; Save for subtraction
3337:	16DB  41      	        LD      B,C             ; Get MSB
3338:	16DC  EB      	        EX      DE,HL           ; NMSB,LSB to HL
3339:	16DD  AF      	        XOR     A
3340:	16DE  4F      	        LD      C,A             ; Clear MSB of quotient
3341:	16DF  57      	        LD      D,A             ; Clear NMSB of quotient
3342:	16E0  5F      	        LD      E,A             ; Clear LSB of quotient
3343:	16E1  325A20  	        LD      (DIV4),A        ; Clear overflow count
3344:	16E4  E5      	DIVLP:  PUSH    HL              ; Save divisor
3345:	16E5  C5      	        PUSH    BC
3346:	16E6  7D      	        LD      A,L             ; Get LSB of number
3347:	16E7  CD4E20  	        CALL    DIVSUP          ; Subt' divisor from dividend
3348:	16EA  DE00    	        SBC     A,0             ; Count for overflows
3349:	16EC  3F      	        CCF
3350:	16ED  D2F716  	        JP      NC,RESDIV       ; Restore divisor if borrow
3351:	16F0  325A20  	        LD      (DIV4),A        ; Re-save overflow count
3352:	16F3  F1      	        POP     AF              ; Scrap divisor
3353:	16F4  F1      	        POP     AF
3354:	16F5  37      	        SCF                     ; Set carry to
3355:	16F6  D2      	        .DB     0D2H            ; Skip "POP BC" and "POP HL"
3356:			
3357:	16F7  C1      	RESDIV: POP     BC              ; Restore divisor
3358:	16F8  E1      	        POP     HL
3359:	16F9  79      	        LD      A,C             ; Get MSB of quotient
3360:	16FA  3C      	        INC     A
3361:	16FB  3D      	        DEC     A
3362:	16FC  1F      	        RRA                     ; Bit 0 to bit 7
3363:	16FD  FAAA15  	        JP      M,RONDB        ; Done - Normalise result
3364:	1700  17      	        RLA                     ; Restore carry
3365:	1701  7B      	        LD      A,E             ; Get LSB of quotient
3366:	1702  17      	        RLA                     ; Double it
3367:	1703  5F      	        LD      E,A             ; Put it back
3368:	1704  7A      	        LD      A,D             ; Get NMSB of quotient
3369:	1705  17      	        RLA                     ; Double it
3370:	1706  57      	        LD      D,A             ; Put it back
3371:	1707  79      	        LD      A,C             ; Get MSB of quotient
3372:	1708  17      	        RLA                     ; Double it
3373:	1709  4F      	        LD      C,A             ; Put it back
3374:	170A  29      	        ADD     HL,HL           ; Double NMSB,LSB of divisor
3375:	170B  78      	        LD      A,B             ; Get MSB of divisor
3376:	170C  17      	        RLA                     ; Double it
3377:	170D  47      	        LD      B,A             ; Put it back
3378:	170E  3A5A20  	        LD      A,(DIV4)        ; Get VLSB of quotient
3379:	1711  17      	        RLA                     ; Double it
3380:	1712  325A20  	        LD      (DIV4),A        ; Put it back
3381:	1715  79      	        LD      A,C             ; Get MSB of quotient
3382:	1716  B2      	        OR      D               ; Merge NMSB
3383:	1717  B3      	        OR      E               ; Merge LSB
3384:	1718  C2E416  	        JP      NZ,DIVLP        ; Not done - Keep dividing
3385:	171B  E5      	        PUSH    HL              ; Save divisor
3386:	171C  212C21  	        LD      HL,FPEXP        ; Point to exponent
3387:	171F  35      	        DEC     (HL)            ; Divide by 2
3388:	1720  E1      	        POP     HL              ; Restore divisor
3389:	1721  C2E416  	        JP      NZ,DIVLP        ; Ok - Keep going
3390:	1724  C30505  	        JP      OVERR           ; Overflow error
3391:			
3392:	1727  78      	ADDEXP: LD      A,B             ; Get exponent of dividend
3393:	1728  B7      	        OR      A               ; Test it
3394:	1729  CA4B17  	        JP      Z,OVTST3        ; Zero - Result zero
3395:	172C  7D      	        LD      A,L             ; Get add/subtract flag
3396:	172D  212C21  	        LD      HL,FPEXP        ; Point to exponent
3397:	1730  AE      	        XOR     (HL)            ; Add or subtract it
3398:	1731  80      	        ADD     A,B             ; Add the other exponent
3399:	1732  47      	        LD      B,A             ; Save new exponent
3400:	1733  1F      	        RRA                     ; Test exponent for overflow
3401:	1734  A8      	        XOR     B
3402:	1735  78      	        LD      A,B             ; Get exponent
3403:	1736  F24A17  	        JP      P,OVTST2        ; Positive - Test for overflow
3404:	1739  C680    	        ADD     A,80H           ; Add excess 128
3405:	173B  77      	        LD      (HL),A          ; Save new exponent
3406:	173C  CAAA16  	        JP      Z,POPHRT        ; Zero - Result zero
3407:	173F  CDCF17  	        CALL    SIGNS           ; Set MSBs and sign of result
3408:	1742  77      	        LD      (HL),A          ; Save new exponent
3409:	1743  2B      	        DEC     HL              ; Point to MSB
3410:	1744  C9      	        RET
3411:			
3412:	1745  CD6917  	OVTST1: CALL    TSTSGN          ; Test sign of FPREG
3413:	1748  2F      	        CPL                     ; Invert sign
3414:	1749  E1      	        POP     HL              ; Clean up stack
3415:	174A  B7      	OVTST2: OR      A               ; Test if new exponent zero
3416:	174B  E1      	OVTST3: POP     HL              ; Clear off return address
3417:	174C  F28915  	        JP      P,RESZER        ; Result zero
3418:	174F  C30505  	        JP      OVERR           ; Overflow error
3419:			
3420:	1752  CDB517  	MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
3421:	1755  78      	        LD      A,B             ; Get exponent
3422:	1756  B7      	        OR      A               ; Is it zero?
3423:	1757  C8      	        RET     Z               ; Yes - Result is zero
3424:	1758  C602    	        ADD     A,2             ; Multiply by 4
3425:	175A  DA0505  	        JP      C,OVERR         ; Overflow - ?OV Error
3426:	175D  47      	        LD      B,A             ; Re-save exponent
3427:	175E  CD2315  	        CALL    FPADD           ; Add BCDE to FPREG (Times 5)
3428:	1761  212C21  	        LD      HL,FPEXP        ; Point to exponent
3429:	1764  34      	        INC     (HL)            ; Double number (Times 10)
3430:	1765  C0      	        RET     NZ              ; Ok - Return
3431:	1766  C30505  	        JP      OVERR           ; Overflow error
3432:			
3433:	1769  3A2C21  	TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
3434:	176C  B7      	        OR      A
3435:	176D  C8      	        RET     Z               ; RETurn if number is zero
3436:	176E  3A2B21  	        LD      A,(FPREG+2)     ; Get MSB of FPREG
3437:	1771  FE      	        .DB     0FEH            ; Test sign
3438:	1772  2F      	RETREL: CPL                     ; Invert sign
3439:	1773  17      	        RLA                     ; Sign bit to carry
3440:	1774  9F      	FLGDIF: SBC     A,A             ; Carry to all bits of A
3441:	1775  C0      	        RET     NZ              ; Return -1 if negative
3442:	1776  3C      	        INC     A               ; Bump to +1
3443:	1777  C9      	        RET                     ; Positive - Return +1
3444:			
3445:	1778  CD6917  	SGN:    CALL    TSTSGN          ; Test sign of FPREG
3446:	177B  0688    	FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
3447:	177D  110000  	        LD      DE,0            ; Zero NMSB and LSB
3448:	1780  212C21  	RETINT: LD      HL,FPEXP        ; Point to exponent
3449:	1783  4F      	        LD      C,A             ; CDE = MSB,NMSB and LSB
3450:	1784  70      	        LD      (HL),B          ; Save exponent
3451:	1785  0600    	        LD      B,0             ; CDE = integer to normalise
3452:	1787  23      	        INC     HL              ; Point to sign of result
3453:	1788  3680    	        LD      (HL),80H        ; Set sign of result
3454:	178A  17      	        RLA                     ; Carry = sign of integer
3455:	178B  C37115  	        JP      CONPOS          ; Set sign of result
3456:			
3457:	178E  CD6917  	ABS:    CALL    TSTSGN          ; Test sign of FPREG
3458:	1791  F0      	        RET     P               ; Return if positive
3459:	1792  212B21  	INVSGN: LD      HL,FPREG+2      ; Point to MSB
3460:	1795  7E      	        LD      A,(HL)          ; Get sign of mantissa
3461:	1796  EE80    	        XOR     80H             ; Invert sign of mantissa
3462:	1798  77      	        LD      (HL),A          ; Re-save sign of mantissa
3463:	1799  C9      	        RET
3464:			
3465:	179A  EB      	STAKFP: EX      DE,HL           ; Save code string address
3466:	179B  2A2921  	        LD      HL,(FPREG)      ; LSB,NLSB of FPREG
3467:	179E  E3      	        EX      (SP),HL         ; Stack them,get return
3468:	179F  E5      	        PUSH    HL              ; Re-save return
3469:	17A0  2A2B21  	        LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
3470:	17A3  E3      	        EX      (SP),HL         ; Stack them,get return
3471:	17A4  E5      	        PUSH    HL              ; Re-save return
3472:	17A5  EB      	        EX      DE,HL           ; Restore code string address
3473:	17A6  C9      	        RET
3474:			
3475:	17A7  CDB817  	PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
3476:	17AA  EB      	FPBCDE: EX      DE,HL           ; Save code string address
3477:	17AB  222921  	        LD      (FPREG),HL      ; Save LSB,NLSB of number
3478:	17AE  60      	        LD      H,B             ; Exponent of number
3479:	17AF  69      	        LD      L,C             ; MSB of number
3480:	17B0  222B21  	        LD      (FPREG+2),HL    ; Save MSB and exponent
3481:	17B3  EB      	        EX      DE,HL           ; Restore code string address
3482:	17B4  C9      	        RET
3483:			
3484:	17B5  212921  	BCDEFP: LD      HL,FPREG        ; Point to FPREG
3485:	17B8  5E      	LOADFP: LD      E,(HL)          ; Get LSB of number
3486:	17B9  23      	        INC     HL
3487:	17BA  56      	        LD      D,(HL)          ; Get NMSB of number
3488:	17BB  23      	        INC     HL
3489:	17BC  4E      	        LD      C,(HL)          ; Get MSB of number
3490:	17BD  23      	        INC     HL
3491:	17BE  46      	        LD      B,(HL)          ; Get exponent of number
3492:	17BF  23      	INCHL:  INC     HL              ; Used for conditional "INC HL"
3493:	17C0  C9      	        RET
3494:			
3495:	17C1  112921  	FPTHL:  LD      DE,FPREG        ; Point to FPREG
3496:	17C4  0604    	DETHL4: LD      B,4             ; 4 bytes to move
3497:	17C6  1A      	DETHLB: LD      A,(DE)          ; Get source
3498:	17C7  77      	        LD      (HL),A          ; Save destination
3499:	17C8  13      	        INC     DE              ; Next source
3500:	17C9  23      	        INC     HL              ; Next destination
3501:	17CA  05      	        DEC     B               ; Count bytes
3502:	17CB  C2C617  	        JP      NZ,DETHLB       ; Loop if more
3503:	17CE  C9      	        RET
3504:			
3505:	17CF  212B21  	SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
3506:	17D2  7E      	        LD      A,(HL)          ; Get MSB
3507:	17D3  07      	        RLCA                    ; Old sign to carry
3508:	17D4  37      	        SCF                     ; Set MSBit
3509:	17D5  1F      	        RRA                     ; Set MSBit of MSB
3510:	17D6  77      	        LD      (HL),A          ; Save new MSB
3511:	17D7  3F      	        CCF                     ; Complement sign
3512:	17D8  1F      	        RRA                     ; Old sign to carry
3513:	17D9  23      	        INC     HL
3514:	17DA  23      	        INC     HL
3515:	17DB  77      	        LD      (HL),A          ; Set sign of result
3516:	17DC  79      	        LD      A,C             ; Get MSB
3517:	17DD  07      	        RLCA                    ; Old sign to carry
3518:	17DE  37      	        SCF                     ; Set MSBit
3519:	17DF  1F      	        RRA                     ; Set MSBit of MSB
3520:	17E0  4F      	        LD      C,A             ; Save MSB
3521:	17E1  1F      	        RRA
3522:	17E2  AE      	        XOR     (HL)            ; New sign of result
3523:	17E3  C9      	        RET
3524:			
3525:	17E4  78      	CMPNUM: LD      A,B             ; Get exponent of number
3526:	17E5  B7      	        OR      A
3527:	17E6  CA6917  	        JP      Z,TSTSGN        ; Zero - Test sign of FPREG
3528:	17E9  217217  	        LD      HL,RETREL       ; Return relation routine
3529:	17EC  E5      	        PUSH    HL              ; Save for return
3530:	17ED  CD6917  	        CALL    TSTSGN          ; Test sign of FPREG
3531:	17F0  79      	        LD      A,C             ; Get MSB of number
3532:	17F1  C8      	        RET     Z               ; FPREG zero - Number's MSB
3533:	17F2  212B21  	        LD      HL,FPREG+2      ; MSB of FPREG
3534:	17F5  AE      	        XOR     (HL)            ; Combine signs
3535:	17F6  79      	        LD      A,C             ; Get MSB of number
3536:	17F7  F8      	        RET     M               ; Exit if signs different
3537:	17F8  CDFE17  	        CALL    CMPFP           ; Compare FP numbers
3538:	17FB  1F      	        RRA                     ; Get carry to sign
3539:	17FC  A9      	        XOR     C               ; Combine with MSB of number
3540:	17FD  C9      	        RET
3541:			
3542:	17FE  23      	CMPFP:  INC     HL              ; Point to exponent
3543:	17FF  78      	        LD      A,B             ; Get exponent
3544:	1800  BE      	        CP      (HL)            ; Compare exponents
3545:	1801  C0      	        RET     NZ              ; Different
3546:	1802  2B      	        DEC     HL              ; Point to MBS
3547:	1803  79      	        LD      A,C             ; Get MSB
3548:	1804  BE      	        CP      (HL)            ; Compare MSBs
3549:	1805  C0      	        RET     NZ              ; Different
3550:	1806  2B      	        DEC     HL              ; Point to NMSB
3551:	1807  7A      	        LD      A,D             ; Get NMSB
3552:	1808  BE      	        CP      (HL)            ; Compare NMSBs
3553:	1809  C0      	        RET     NZ              ; Different
3554:	180A  2B      	        DEC     HL              ; Point to LSB
3555:	180B  7B      	        LD      A,E             ; Get LSB
3556:	180C  96      	        SUB     (HL)            ; Compare LSBs
3557:	180D  C0      	        RET     NZ              ; Different
3558:	180E  E1      	        POP     HL              ; Drop RETurn
3559:	180F  E1      	        POP     HL              ; Drop another RETurn
3560:	1810  C9      	        RET
3561:			
3562:	1811  47      	FPINT:  LD      B,A             ; <- Move
3563:	1812  4F      	        LD      C,A             ; <- exponent
3564:	1813  57      	        LD      D,A             ; <- to all
3565:	1814  5F      	        LD      E,A             ; <- bits
3566:	1815  B7      	        OR      A               ; Test exponent
3567:	1816  C8      	        RET     Z               ; Zero - Return zero
3568:	1817  E5      	        PUSH    HL              ; Save pointer to number
3569:	1818  CDB517  	        CALL    BCDEFP          ; Move FPREG to BCDE
3570:	181B  CDCF17  	        CALL    SIGNS           ; Set MSBs & sign of result
3571:	181E  AE      	        XOR     (HL)            ; Combine with sign of FPREG
3572:	181F  67      	        LD      H,A             ; Save combined signs
3573:	1820  FC3518  	        CALL    M,DCBCDE        ; Negative - Decrement BCDE
3574:	1823  3E98    	        LD      A,80H+24        ; 24 bits
3575:	1825  90      	        SUB     B               ; Bits to shift
3576:	1826  CDE815  	        CALL    SCALE           ; Shift BCDE
3577:	1829  7C      	        LD      A,H             ; Get combined sign
3578:	182A  17      	        RLA                     ; Sign to carry
3579:	182B  DCBB15  	        CALL    C,FPROND        ; Negative - Round number up
3580:	182E  0600    	        LD      B,0             ; Zero exponent
3581:	1830  DCD415  	        CALL    C,COMPL         ; If negative make positive
3582:	1833  E1      	        POP     HL              ; Restore pointer to number
3583:	1834  C9      	        RET
3584:			
3585:	1835  1B      	DCBCDE: DEC     DE              ; Decrement BCDE
3586:	1836  7A      	        LD      A,D             ; Test LSBs
3587:	1837  A3      	        AND     E
3588:	1838  3C      	        INC     A
3589:	1839  C0      	        RET     NZ              ; Exit if LSBs not FFFF
3590:	183A  0B      	        DEC     BC              ; Decrement MSBs
3591:	183B  C9      	        RET
3592:			
3593:	183C  212C21  	INT:    LD      HL,FPEXP        ; Point to exponent
3594:	183F  7E      	        LD      A,(HL)          ; Get exponent
3595:	1840  FE98    	        CP      80H+24          ; Integer accuracy only?
3596:	1842  3A2921  	        LD      A,(FPREG)       ; Get LSB
3597:	1845  D0      	        RET     NC              ; Yes - Already integer
3598:	1846  7E      	        LD      A,(HL)          ; Get exponent
3599:	1847  CD1118  	        CALL    FPINT           ; F.P to integer
3600:	184A  3698    	        LD      (HL),80H+24     ; Save 24 bit integer
3601:	184C  7B      	        LD      A,E             ; Get LSB of number
3602:	184D  F5      	        PUSH    AF              ; Save LSB
3603:	184E  79      	        LD      A,C             ; Get MSB of number
3604:	184F  17      	        RLA                     ; Sign to carry
3605:	1850  CD7115  	        CALL    CONPOS          ; Set sign of result
3606:	1853  F1      	        POP     AF              ; Restore LSB of number
3607:	1854  C9      	        RET
3608:			
3609:	1855  210000  	MLDEBC: LD      HL,0            ; Clear partial product
3610:	1858  78      	        LD      A,B             ; Test multiplier
3611:	1859  B1      	        OR      C
3612:	185A  C8      	        RET     Z               ; Return zero if zero
3613:	185B  3E10    	        LD      A,16            ; 16 bits
3614:	185D  29      	MLDBLP: ADD     HL,HL           ; Shift P.P left
3615:	185E  DA9510  	        JP      C,BSERR         ; ?BS Error if overflow
3616:	1861  EB      	        EX      DE,HL
3617:	1862  29      	        ADD     HL,HL           ; Shift multiplier left
3618:	1863  EB      	        EX      DE,HL
3619:	1864  D26B18  	        JP      NC,NOMLAD       ; Bit was zero - No add
3620:	1867  09      	        ADD     HL,BC           ; Add multiplicand
3621:	1868  DA9510  	        JP      C,BSERR         ; ?BS Error if overflow
3622:	186B  3D      	NOMLAD: DEC     A               ; Count bits
3623:	186C  C25D18  	        JP      NZ,MLDBLP       ; More
3624:	186F  C9      	        RET
3625:			
3626:	1870  FE2D    	ASCTFP: CP      '-'             ; Negative?
3627:	1872  F5      	        PUSH    AF              ; Save it and flags
3628:	1873  CA7C18  	        JP      Z,CNVNUM        ; Yes - Convert number
3629:	1876  FE2B    	        CP      '+'             ; Positive?
3630:	1878  CA7C18  	        JP      Z,CNVNUM        ; Yes - Convert number
3631:	187B  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
3632:	187C  CD8915  	CNVNUM: CALL    RESZER          ; Set result to zero
3633:	187F  47      	        LD      B,A             ; Digits after point counter
3634:	1880  57      	        LD      D,A             ; Sign of exponent
3635:	1881  5F      	        LD      E,A             ; Exponent of ten
3636:	1882  2F      	        CPL
3637:	1883  4F      	        LD      C,A             ; Before or after point flag
3638:	1884  CD1A09  	MANLP:  CALL    GETCHR          ; Get next character
3639:	1887  DACD18  	        JP      C,ADDIG         ; Digit - Add to number
3640:	188A  FE2E    	        CP      '.'
3641:	188C  CAA818  	        JP      Z,DPOINT        ; '.' - Flag point
3642:	188F  FE45    	        CP      'E'
3643:	1891  C2AC18  	        JP      NZ,CONEXP       ; Not 'E' - Scale number
3644:	1894  CD1A09  	        CALL    GETCHR          ; Get next character
3645:	1897  CDC00E  	        CALL    SGNEXP          ; Get sign of exponent
3646:	189A  CD1A09  	EXPLP:  CALL    GETCHR          ; Get next character
3647:	189D  DAEF18  	        JP      C,EDIGIT        ; Digit - Add to exponent
3648:	18A0  14      	        INC     D               ; Is sign negative?
3649:	18A1  C2AC18  	        JP      NZ,CONEXP       ; No - Scale number
3650:	18A4  AF      	        XOR     A
3651:	18A5  93      	        SUB     E               ; Negate exponent
3652:	18A6  5F      	        LD      E,A             ; And re-save it
3653:	18A7  0C      	        INC     C               ; Flag end of number
3654:	18A8  0C      	DPOINT: INC     C               ; Flag point passed
3655:	18A9  CA8418  	        JP      Z,MANLP         ; Zero - Get another digit
3656:	18AC  E5      	CONEXP: PUSH    HL              ; Save code string address
3657:	18AD  7B      	        LD      A,E             ; Get exponent
3658:	18AE  90      	        SUB     B               ; Subtract digits after point
3659:	18AF  F4C518  	SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
3660:	18B2  F2BB18  	        JP      P,ENDCON        ; Positive - All done
3661:	18B5  F5      	        PUSH    AF              ; Save number of times to /10
3662:	18B6  CDB116  	        CALL    DIV10           ; Divide by 10
3663:	18B9  F1      	        POP     AF              ; Restore count
3664:	18BA  3C      	        INC     A               ; Count divides
3665:			
3666:	18BB  C2AF18  	ENDCON: JP      NZ,SCALMI       ; More to do
3667:	18BE  D1      	        POP     DE              ; Restore code string address
3668:	18BF  F1      	        POP     AF              ; Restore sign of number
3669:	18C0  CC9217  	        CALL    Z,INVSGN        ; Negative - Negate number
3670:	18C3  EB      	        EX      DE,HL           ; Code string address to HL
3671:	18C4  C9      	        RET
3672:			
3673:	18C5  C8      	SCALPL: RET     Z               ; Exit if no scaling needed
3674:	18C6  F5      	MULTEN: PUSH    AF              ; Save count
3675:	18C7  CD5217  	        CALL    MLSP10          ; Multiply number by 10
3676:	18CA  F1      	        POP     AF              ; Restore count
3677:	18CB  3D      	        DEC     A               ; Count multiplies
3678:	18CC  C9      	        RET
3679:			
3680:	18CD  D5      	ADDIG:  PUSH    DE              ; Save sign of exponent
3681:	18CE  57      	        LD      D,A             ; Save digit
3682:	18CF  78      	        LD      A,B             ; Get digits after point
3683:	18D0  89      	        ADC     A,C             ; Add one if after point
3684:	18D1  47      	        LD      B,A             ; Re-save counter
3685:	18D2  C5      	        PUSH    BC              ; Save point flags
3686:	18D3  E5      	        PUSH    HL              ; Save code string address
3687:	18D4  D5      	        PUSH    DE              ; Save digit
3688:	18D5  CD5217  	        CALL    MLSP10          ; Multiply number by 10
3689:	18D8  F1      	        POP     AF              ; Restore digit
3690:	18D9  D630    	        SUB     '0'             ; Make it absolute
3691:	18DB  CDE418  	        CALL    RSCALE          ; Re-scale number
3692:	18DE  E1      	        POP     HL              ; Restore code string address
3693:	18DF  C1      	        POP     BC              ; Restore point flags
3694:	18E0  D1      	        POP     DE              ; Restore sign of exponent
3695:	18E1  C38418  	        JP      MANLP           ; Get another digit
3696:			
3697:	18E4  CD9A17  	RSCALE: CALL    STAKFP          ; Put number on stack
3698:	18E7  CD7B17  	        CALL    FLGREL          ; Digit to add to FPREG
3699:	18EA  C1      	PADD:   POP     BC              ; Restore number
3700:	18EB  D1      	        POP     DE
3701:	18EC  C32315  	        JP      FPADD           ; Add BCDE to FPREG and return
3702:			
3703:	18EF  7B      	EDIGIT: LD      A,E             ; Get digit
3704:	18F0  07      	        RLCA                    ; Times 2
3705:	18F1  07      	        RLCA                    ; Times 4
3706:	18F2  83      	        ADD     A,E             ; Times 5
3707:	18F3  07      	        RLCA                    ; Times 10
3708:	18F4  86      	        ADD     A,(HL)          ; Add next digit
3709:	18F5  D630    	        SUB     '0'             ; Make it absolute
3710:	18F7  5F      	        LD      E,A             ; Save new digit
3711:	18F8  C39A18  	        JP      EXPLP           ; Look for another digit
3712:			
3713:	18FB  E5      	LINEIN: PUSH    HL              ; Save code string address
3714:	18FC  218E04  	        LD      HL,INMSG        ; Output " in "
3715:	18FF  CD6012  	        CALL    PRS             ; Output string at HL
3716:	1902  E1      	        POP     HL              ; Restore code string address
3717:	1903  EB      	PRNTHL: EX      DE,HL           ; Code string address to DE
3718:	1904  AF      	        XOR     A
3719:	1905  0698    	        LD      B,80H+24        ; 24 bits
3720:	1907  CD8017  	        CALL    RETINT          ; Return the integer
3721:	190A  215F12  	        LD      HL,PRNUMS       ; Print number string
3722:	190D  E5      	        PUSH    HL              ; Save for return
3723:	190E  212E21  	NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
3724:	1911  E5      	        PUSH    HL              ; Save for return
3725:	1912  CD6917  	        CALL    TSTSGN          ; Test sign of FPREG
3726:	1915  3620    	        LD      (HL),' '        ; Space at start
3727:	1917  F21C19  	        JP      P,SPCFST        ; Positive - Space to start
3728:	191A  362D    	        LD      (HL),'-'        ; '-' sign at start
3729:	191C  23      	SPCFST: INC     HL              ; First byte of number
3730:	191D  3630    	        LD      (HL),'0'        ; '0' if zero
3731:	191F  CAD219  	        JP      Z,JSTZER        ; Return '0' if zero
3732:	1922  E5      	        PUSH    HL              ; Save buffer address
3733:	1923  FC9217  	        CALL    M,INVSGN        ; Negate FPREG if negative
3734:	1926  AF      	        XOR     A               ; Zero A
3735:	1927  F5      	        PUSH    AF              ; Save it
3736:	1928  CDD819  	        CALL    RNGTST          ; Test number is in range
3737:	192B  014391  	SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
3738:	192E  11F84F  	        LD      DE,4FF8H
3739:	1931  CDE417  	        CALL    CMPNUM          ; Compare numbers
3740:	1934  B7      	        OR      A
3741:	1935  E24919  	        JP      PO,INRNG        ; > 99999.9 - Sort it out
3742:	1938  F1      	        POP     AF              ; Restore count
3743:	1939  CDC618  	        CALL    MULTEN          ; Multiply by ten
3744:	193C  F5      	        PUSH    AF              ; Re-save count
3745:	193D  C32B19  	        JP      SIXDIG          ; Test it again
3746:			
3747:	1940  CDB116  	GTSIXD: CALL    DIV10           ; Divide by 10
3748:	1943  F1      	        POP     AF              ; Get count
3749:	1944  3C      	        INC     A               ; Count divides
3750:	1945  F5      	        PUSH    AF              ; Re-save count
3751:	1946  CDD819  	        CALL    RNGTST          ; Test number is in range
3752:	1949  CD1115  	INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
3753:	194C  3C      	        INC     A
3754:	194D  CD1118  	        CALL    FPINT           ; F.P to integer
3755:	1950  CDAA17  	        CALL    FPBCDE          ; Move BCDE to FPREG
3756:	1953  010603  	        LD      BC,0306H        ; 1E+06 to 1E-03 range
3757:	1956  F1      	        POP     AF              ; Restore count
3758:	1957  81      	        ADD     A,C             ; 6 digits before point
3759:	1958  3C      	        INC     A               ; Add one
3760:	1959  FA6519  	        JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
3761:	195C  FE08    	        CP      6+1+1           ; More than 999999 ?
3762:	195E  D26519  	        JP      NC,MAKNUM       ; Yes - Do it in 'E' form
3763:	1961  3C      	        INC     A               ; Adjust for exponent
3764:	1962  47      	        LD      B,A             ; Exponent of number
3765:	1963  3E02    	        LD      A,2             ; Make it zero after
3766:			
3767:	1965  3D      	MAKNUM: DEC     A               ; Adjust for digits to do
3768:	1966  3D      	        DEC     A
3769:	1967  E1      	        POP     HL              ; Restore buffer address
3770:	1968  F5      	        PUSH    AF              ; Save count
3771:	1969  11EB19  	        LD      DE,POWERS       ; Powers of ten
3772:	196C  05      	        DEC     B               ; Count digits before point
3773:	196D  C27619  	        JP      NZ,DIGTXT       ; Not zero - Do number
3774:	1970  362E    	        LD      (HL),'.'        ; Save point
3775:	1972  23      	        INC     HL              ; Move on
3776:	1973  3630    	        LD      (HL),'0'        ; Save zero
3777:	1975  23      	        INC     HL              ; Move on
3778:	1976  05      	DIGTXT: DEC     B               ; Count digits before point
3779:	1977  362E    	        LD      (HL),'.'        ; Save point in case
3780:	1979  CCBF17  	        CALL    Z,INCHL         ; Last digit - move on
3781:	197C  C5      	        PUSH    BC              ; Save digits before point
3782:	197D  E5      	        PUSH    HL              ; Save buffer address
3783:	197E  D5      	        PUSH    DE              ; Save powers of ten
3784:	197F  CDB517  	        CALL    BCDEFP          ; Move FPREG to BCDE
3785:	1982  E1      	        POP     HL              ; Powers of ten table
3786:	1983  062F    	        LD      B, '0'-1        ; ASCII '0' - 1
3787:	1985  04      	TRYAGN: INC     B               ; Count subtractions
3788:	1986  7B      	        LD      A,E             ; Get LSB
3789:	1987  96      	        SUB     (HL)            ; Subtract LSB
3790:	1988  5F      	        LD      E,A             ; Save LSB
3791:	1989  23      	        INC     HL
3792:	198A  7A      	        LD      A,D             ; Get NMSB
3793:	198B  9E      	        SBC     A,(HL)          ; Subtract NMSB
3794:	198C  57      	        LD      D,A             ; Save NMSB
3795:	198D  23      	        INC     HL
3796:	198E  79      	        LD      A,C             ; Get MSB
3797:	198F  9E      	        SBC     A,(HL)          ; Subtract MSB
3798:	1990  4F      	        LD      C,A             ; Save MSB
3799:	1991  2B      	        DEC     HL              ; Point back to start
3800:	1992  2B      	        DEC     HL
3801:	1993  D28519  	        JP      NC,TRYAGN       ; No overflow - Try again
3802:	1996  CDC815  	        CALL    PLUCDE          ; Restore number
3803:	1999  23      	        INC     HL              ; Start of next number
3804:	199A  CDAA17  	        CALL    FPBCDE          ; Move BCDE to FPREG
3805:	199D  EB      	        EX      DE,HL           ; Save point in table
3806:	199E  E1      	        POP     HL              ; Restore buffer address
3807:	199F  70      	        LD      (HL),B          ; Save digit in buffer
3808:	19A0  23      	        INC     HL              ; And move on
3809:	19A1  C1      	        POP     BC              ; Restore digit count
3810:	19A2  0D      	        DEC     C               ; Count digits
3811:	19A3  C27619  	        JP      NZ,DIGTXT       ; More - Do them
3812:	19A6  05      	        DEC     B               ; Any decimal part?
3813:	19A7  CAB619  	        JP      Z,DOEBIT        ; No - Do 'E' bit
3814:	19AA  2B      	SUPTLZ: DEC     HL              ; Move back through buffer
3815:	19AB  7E      	        LD      A,(HL)          ; Get character
3816:	19AC  FE30    	        CP      '0'             ; '0' character?
3817:	19AE  CAAA19  	        JP      Z,SUPTLZ        ; Yes - Look back for more
3818:	19B1  FE2E    	        CP      '.'             ; A decimal point?
3819:	19B3  C4BF17  	        CALL    NZ,INCHL        ; Move back over digit
3820:			
3821:	19B6  F1      	DOEBIT: POP     AF              ; Get 'E' flag
3822:	19B7  CAD519  	        JP      Z,NOENED        ; No 'E' needed - End buffer
3823:	19BA  3645    	        LD      (HL),'E'        ; Put 'E' in buffer
3824:	19BC  23      	        INC     HL              ; And move on
3825:	19BD  362B    	        LD      (HL),'+'        ; Put '+' in buffer
3826:	19BF  F2C619  	        JP      P,OUTEXP        ; Positive - Output exponent
3827:	19C2  362D    	        LD      (HL),'-'        ; Put '-' in buffer
3828:	19C4  2F      	        CPL                     ; Negate exponent
3829:	19C5  3C      	        INC     A
3830:	19C6  062F    	OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
3831:	19C8  04      	EXPTEN: INC     B               ; Count subtractions
3832:	19C9  D60A    	        SUB     10              ; Tens digit
3833:	19CB  D2C819  	        JP      NC,EXPTEN       ; More to do
3834:	19CE  C63A    	        ADD     A,'0'+10        ; Restore and make ASCII
3835:	19D0  23      	        INC     HL              ; Move on
3836:	19D1  70      	        LD      (HL),B          ; Save MSB of exponent
3837:	19D2  23      	JSTZER: INC     HL              ;
3838:	19D3  77      	        LD      (HL),A          ; Save LSB of exponent
3839:	19D4  23      	        INC     HL
3840:	19D5  71      	NOENED: LD      (HL),C          ; Mark end of buffer
3841:	19D6  E1      	        POP     HL              ; Restore code string address
3842:	19D7  C9      	        RET
3843:			
3844:	19D8  017494  	RNGTST: LD      BC,9474H        ; BCDE = 999999.
3845:	19DB  11F723  	        LD      DE,23F7H
3846:	19DE  CDE417  	        CALL    CMPNUM          ; Compare numbers
3847:	19E1  B7      	        OR      A
3848:	19E2  E1      	        POP     HL              ; Return address to HL
3849:	19E3  E24019  	        JP      PO,GTSIXD       ; Too big - Divide by ten
3850:	19E6  E9      	        JP      (HL)            ; Otherwise return to caller
3851:			
3852:	19E7  00000080	HALF:   .DB     00H,00H,00H,80H ; 0.5
3853:			
3854:	19EB  A08601  	POWERS: .DB     0A0H,086H,001H  ; 100000
3855:	19EE  102700  	        .DB     010H,027H,000H  ;  10000
3856:	19F1  E80300  	        .DB     0E8H,003H,000H  ;   1000
3857:	19F4  640000  	        .DB     064H,000H,000H  ;    100
3858:	19F7  0A0000  	        .DB     00AH,000H,000H  ;     10
3859:	19FA  010000  	        .DB     001H,000H,000H  ;      1
3860:			
3861:	19FD  219217  	NEGAFT: LD      HL,INVSGN       ; Negate result
3862:	1A00  E3      	        EX      (SP),HL         ; To be done after caller
3863:	1A01  E9      	        JP      (HL)            ; Return to caller
3864:			
3865:	1A02  CD9A17  	SQR:    CALL    STAKFP          ; Put value on stack
3866:	1A05  21E719  	        LD      HL,HALF         ; Set power to 1/2
3867:	1A08  CDA717  	        CALL    PHLTFP          ; Move 1/2 to FPREG
3868:			
3869:	1A0B  C1      	POWER:  POP     BC              ; Get base
3870:	1A0C  D1      	        POP     DE
3871:	1A0D  CD6917  	        CALL    TSTSGN          ; Test sign of power
3872:	1A10  78      	        LD      A,B             ; Get exponent of base
3873:	1A11  CA501A  	        JP      Z,EXP           ; Make result 1 if zero
3874:	1A14  F21B1A  	        JP      P,POWER1        ; Positive base - Ok
3875:	1A17  B7      	        OR      A               ; Zero to negative power?
3876:	1A18  CAF904  	        JP      Z,DZERR         ; Yes - ?/0 Error
3877:	1A1B  B7      	POWER1: OR      A               ; Base zero?
3878:	1A1C  CA8A15  	        JP      Z,SAVEXP        ; Yes - Return zero
3879:	1A1F  D5      	        PUSH    DE              ; Save base
3880:	1A20  C5      	        PUSH    BC
3881:	1A21  79      	        LD      A,C             ; Get MSB of base
3882:	1A22  F67F    	        OR      01111111B       ; Get sign status
3883:	1A24  CDB517  	        CALL    BCDEFP          ; Move power to BCDE
3884:	1A27  F2381A  	        JP      P,POWER2        ; Positive base - Ok
3885:	1A2A  D5      	        PUSH    DE              ; Save power
3886:	1A2B  C5      	        PUSH    BC
3887:	1A2C  CD3C18  	        CALL    INT             ; Get integer of power
3888:	1A2F  C1      	        POP     BC              ; Restore power
3889:	1A30  D1      	        POP     DE
3890:	1A31  F5      	        PUSH    AF              ; MSB of base
3891:	1A32  CDE417  	        CALL    CMPNUM          ; Power an integer?
3892:	1A35  E1      	        POP     HL              ; Restore MSB of base
3893:	1A36  7C      	        LD      A,H             ; but don't affect flags
3894:	1A37  1F      	        RRA                     ; Exponent odd or even?
3895:	1A38  E1      	POWER2: POP     HL              ; Restore MSB and exponent
3896:	1A39  222B21  	        LD      (FPREG+2),HL    ; Save base in FPREG
3897:	1A3C  E1      	        POP     HL              ; LSBs of base
3898:	1A3D  222921  	        LD      (FPREG),HL      ; Save in FPREG
3899:	1A40  DCFD19  	        CALL    C,NEGAFT        ; Odd power - Negate result
3900:	1A43  CC9217  	        CALL    Z,INVSGN        ; Negative base - Negate it
3901:	1A46  D5      	        PUSH    DE              ; Save power
3902:	1A47  C5      	        PUSH    BC
3903:	1A48  CD1D16  	        CALL    LOG             ; Get LOG of base
3904:	1A4B  C1      	        POP     BC              ; Restore power
3905:	1A4C  D1      	        POP     DE
3906:	1A4D  CD5E16  	        CALL    FPMULT          ; Multiply LOG by power
3907:			
3908:	1A50  CD9A17  	EXP:    CALL    STAKFP          ; Put value on stack
3909:	1A53  013881  	        LD      BC,08138H       ; BCDE = 1/Ln(2)
3910:	1A56  113BAA  	        LD      DE,0AA3BH
3911:	1A59  CD5E16  	        CALL    FPMULT          ; Multiply value by 1/LN(2)
3912:	1A5C  3A2C21  	        LD      A,(FPEXP)       ; Get exponent
3913:	1A5F  FE88    	        CP      80H+8           ; Is it in range?
3914:	1A61  D24517  	        JP      NC,OVTST1       ; No - Test for overflow
3915:	1A64  CD3C18  	        CALL    INT             ; Get INT of FPREG
3916:	1A67  C680    	        ADD     A,80H           ; For excess 128
3917:	1A69  C602    	        ADD     A,2             ; Exponent > 126?
3918:	1A6B  DA4517  	        JP      C,OVTST1        ; Yes - Test for overflow
3919:	1A6E  F5      	        PUSH    AF              ; Save scaling factor
3920:	1A6F  210C16  	        LD      HL,UNITY        ; Point to 1.
3921:	1A72  CD1415  	        CALL    ADDPHL          ; Add 1 to FPREG
3922:	1A75  CD5516  	        CALL    MULLN2          ; Multiply by LN(2)
3923:	1A78  F1      	        POP     AF              ; Restore scaling factor
3924:	1A79  C1      	        POP     BC              ; Restore exponent
3925:	1A7A  D1      	        POP     DE
3926:	1A7B  F5      	        PUSH    AF              ; Save scaling factor
3927:	1A7C  CD2015  	        CALL    SUBCDE          ; Subtract exponent from FPREG
3928:	1A7F  CD9217  	        CALL    INVSGN          ; Negate result
3929:	1A82  21901A  	        LD      HL,EXPTAB       ; Coefficient table
3930:	1A85  CDC01A  	        CALL    SMSER1          ; Sum the series
3931:	1A88  110000  	        LD      DE,0            ; Zero LSBs
3932:	1A8B  C1      	        POP     BC              ; Scaling factor
3933:	1A8C  4A      	        LD      C,D             ; Zero MSB
3934:	1A8D  C35E16  	        JP      FPMULT          ; Scale result to correct value
3935:			
3936:	1A90  08      	EXPTAB: .DB     8                       ; Table used by EXP
3937:	1A91  402E9474	        .DB     040H,02EH,094H,074H     ; -1/7! (-1/5040)
3938:	1A95  704F2E77	        .DB     070H,04FH,02EH,077H     ;  1/6! ( 1/720)
3939:	1A99  6E02887A	        .DB     06EH,002H,088H,07AH     ; -1/5! (-1/120)
3940:	1A9D  E6A02A7C	        .DB     0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
3941:	1AA1  50AAAA7E	        .DB     050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
3942:	1AA5  FFFF7F7F	        .DB     0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
3943:	1AA9  00008081	        .DB     000H,000H,080H,081H     ; -1/1! (-1/1)
3944:	1AAD  00000081	        .DB     000H,000H,000H,081H     ;  1/0! ( 1/1)
3945:			
3946:	1AB1  CD9A17  	SUMSER: CALL    STAKFP          ; Put FPREG on stack
3947:	1AB4  115C16  	        LD      DE,MULT         ; Multiply by "X"
3948:	1AB7  D5      	        PUSH    DE              ; To be done after
3949:	1AB8  E5      	        PUSH    HL              ; Save address of table
3950:	1AB9  CDB517  	        CALL    BCDEFP          ; Move FPREG to BCDE
3951:	1ABC  CD5E16  	        CALL    FPMULT          ; Square the value
3952:	1ABF  E1      	        POP     HL              ; Restore address of table
3953:	1AC0  CD9A17  	SMSER1: CALL    STAKFP          ; Put value on stack
3954:	1AC3  7E      	        LD      A,(HL)          ; Get number of coefficients
3955:	1AC4  23      	        INC     HL              ; Point to start of table
3956:	1AC5  CDA717  	        CALL    PHLTFP          ; Move coefficient to FPREG
3957:	1AC8  06      	        .DB     06H             ; Skip "POP AF"
3958:	1AC9  F1      	SUMLP:  POP     AF              ; Restore count
3959:	1ACA  C1      	        POP     BC              ; Restore number
3960:	1ACB  D1      	        POP     DE
3961:	1ACC  3D      	        DEC     A               ; Cont coefficients
3962:	1ACD  C8      	        RET     Z               ; All done
3963:	1ACE  D5      	        PUSH    DE              ; Save number
3964:	1ACF  C5      	        PUSH    BC
3965:	1AD0  F5      	        PUSH    AF              ; Save count
3966:	1AD1  E5      	        PUSH    HL              ; Save address in table
3967:	1AD2  CD5E16  	        CALL    FPMULT          ; Multiply FPREG by BCDE
3968:	1AD5  E1      	        POP     HL              ; Restore address in table
3969:	1AD6  CDB817  	        CALL    LOADFP          ; Number at HL to BCDE
3970:	1AD9  E5      	        PUSH    HL              ; Save address in table
3971:	1ADA  CD2315  	        CALL    FPADD           ; Add coefficient to FPREG
3972:	1ADD  E1      	        POP     HL              ; Restore address in table
3973:	1ADE  C3C91A  	        JP      SUMLP           ; More coefficients
3974:			
3975:	1AE1  CD6917  	RND:    CALL    TSTSGN          ; Test sign of FPREG
3976:	1AE4  215E20  	        LD      HL,SEED+2       ; Random number seed
3977:	1AE7  FA421B  	        JP      M,RESEED        ; Negative - Re-seed
3978:	1AEA  217F20  	        LD      HL,LSTRND       ; Last random number
3979:	1AED  CDA717  	        CALL    PHLTFP          ; Move last RND to FPREG
3980:	1AF0  215E20  	        LD      HL,SEED+2       ; Random number seed
3981:	1AF3  C8      	        RET     Z               ; Return if RND(0)
3982:	1AF4  86      	        ADD     A,(HL)          ; Add (SEED)+2)
3983:	1AF5  E607    	        AND     00000111B       ; 0 to 7
3984:	1AF7  0600    	        LD      B,0
3985:	1AF9  77      	        LD      (HL),A          ; Re-save seed
3986:	1AFA  23      	        INC     HL              ; Move to coefficient table
3987:	1AFB  87      	        ADD     A,A             ; 4 bytes
3988:	1AFC  87      	        ADD     A,A             ; per entry
3989:	1AFD  4F      	        LD      C,A             ; BC = Offset into table
3990:	1AFE  09      	        ADD     HL,BC           ; Point to coefficient
3991:	1AFF  CDB817  	        CALL    LOADFP          ; Coefficient to BCDE
3992:	1B02  CD5E16  	        CALL    FPMULT  ;       ; Multiply FPREG by coefficient
3993:	1B05  3A5D20  	        LD      A,(SEED+1)      ; Get (SEED+1)
3994:	1B08  3C      	        INC     A               ; Add 1
3995:	1B09  E603    	        AND     00000011B       ; 0 to 3
3996:	1B0B  0600    	        LD      B,0
3997:	1B0D  FE01    	        CP      1               ; Is it zero?
3998:	1B0F  88      	        ADC     A,B             ; Yes - Make it 1
3999:	1B10  325D20  	        LD      (SEED+1),A      ; Re-save seed
4000:	1B13  21461B  	        LD      HL,RNDTAB-4     ; Addition table
4001:	1B16  87      	        ADD     A,A             ; 4 bytes
4002:	1B17  87      	        ADD     A,A             ; per entry
4003:	1B18  4F      	        LD      C,A             ; BC = Offset into table
4004:	1B19  09      	        ADD     HL,BC           ; Point to value
4005:	1B1A  CD1415  	        CALL    ADDPHL          ; Add value to FPREG
4006:	1B1D  CDB517  	RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
4007:	1B20  7B      	        LD      A,E             ; Get LSB
4008:	1B21  59      	        LD      E,C             ; LSB = MSB
4009:	1B22  EE4F    	        XOR     01001111B       ; Fiddle around
4010:	1B24  4F      	        LD      C,A             ; New MSB
4011:	1B25  3680    	        LD      (HL),80H        ; Set exponent
4012:	1B27  2B      	        DEC     HL              ; Point to MSB
4013:	1B28  46      	        LD      B,(HL)          ; Get MSB
4014:	1B29  3680    	        LD      (HL),80H        ; Make value -0.5
4015:	1B2B  215C20  	        LD      HL,SEED         ; Random number seed
4016:	1B2E  34      	        INC     (HL)            ; Count seed
4017:	1B2F  7E      	        LD      A,(HL)          ; Get seed
4018:	1B30  D6AB    	        SUB     171             ; Do it modulo 171
4019:	1B32  C2391B  	        JP      NZ,RND2         ; Non-zero - Ok
4020:	1B35  77      	        LD      (HL),A          ; Zero seed
4021:	1B36  0C      	        INC     C               ; Fillde about
4022:	1B37  15      	        DEC     D               ; with the
4023:	1B38  1C      	        INC     E               ; number
4024:	1B39  CD7415  	RND2:   CALL    BNORM           ; Normalise number
4025:	1B3C  217F20  	        LD      HL,LSTRND       ; Save random number
4026:	1B3F  C3C117  	        JP      FPTHL           ; Move FPREG to last and return
4027:			
4028:	1B42  77      	RESEED: LD      (HL),A          ; Re-seed random numbers
4029:	1B43  2B      	        DEC     HL
4030:	1B44  77      	        LD      (HL),A
4031:	1B45  2B      	        DEC     HL
4032:	1B46  77      	        LD      (HL),A
4033:	1B47  C31D1B  	        JP      RND1            ; Return RND seed
4034:			
4035:	1B4A  68B14668	RNDTAB: .DB  068H,0B1H,046H,068H     ; Table used by RND
4036:	1B4E  99E99269	        .DB  099H,0E9H,092H,069H
4037:	1B52  10D17568	        .DB  010H,0D1H,075H,068H
4038:			
4039:	1B56  21A01B  	COS:    LD      HL,HALFPI       ; Point to PI/2
4040:	1B59  CD1415  	        CALL    ADDPHL          ; Add it to PPREG
4041:	1B5C  CD9A17  	SIN:    CALL    STAKFP          ; Put angle on stack
4042:	1B5F  014983  	        LD      BC,8349H        ; BCDE = 2 PI
4043:	1B62  11DB0F  	        LD      DE,0FDBH
4044:	1B65  CDAA17  	        CALL    FPBCDE          ; Move 2 PI to FPREG
4045:	1B68  C1      	        POP     BC              ; Restore angle
4046:	1B69  D1      	        POP     DE
4047:	1B6A  CDBF16  	        CALL    DVBCDE          ; Divide angle by 2 PI
4048:	1B6D  CD9A17  	        CALL    STAKFP          ; Put it on stack
4049:	1B70  CD3C18  	        CALL    INT             ; Get INT of result
4050:	1B73  C1      	        POP     BC              ; Restore number
4051:	1B74  D1      	        POP     DE
4052:	1B75  CD2015  	        CALL    SUBCDE          ; Make it 0 <= value < 1
4053:	1B78  21A41B  	        LD      HL,QUARTR       ; Point to 0.25
4054:	1B7B  CD1A15  	        CALL    SUBPHL          ; Subtract value from 0.25
4055:	1B7E  CD6917  	        CALL    TSTSGN          ; Test sign of value
4056:	1B81  37      	        SCF                     ; Flag positive
4057:	1B82  F28C1B  	        JP      P,SIN1          ; Positive - Ok
4058:	1B85  CD1115  	        CALL    ROUND           ; Add 0.5 to value
4059:	1B88  CD6917  	        CALL    TSTSGN          ; Test sign of value
4060:	1B8B  B7      	        OR      A               ; Flag negative
4061:	1B8C  F5      	SIN1:   PUSH    AF              ; Save sign
4062:	1B8D  F49217  	        CALL    P,INVSGN        ; Negate value if positive
4063:	1B90  21A41B  	        LD      HL,QUARTR       ; Point to 0.25
4064:	1B93  CD1415  	        CALL    ADDPHL          ; Add 0.25 to value
4065:	1B96  F1      	        POP     AF              ; Restore sign
4066:	1B97  D49217  	        CALL    NC,INVSGN       ; Negative - Make positive
4067:	1B9A  21A81B  	        LD      HL,SINTAB       ; Coefficient table
4068:	1B9D  C3B11A  	        JP      SUMSER          ; Evaluate sum of series
4069:			
4070:	1BA0  DB0F4981	HALFPI: .DB  0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
4071:			
4072:	1BA4  0000007F	QUARTR: .DB  000H,000H,000H,07FH     ; 0.25
4073:			
4074:	1BA8  05      	SINTAB: .DB  5                       ; Table used by SIN
4075:	1BA9  BAD71E86	        .DB  0BAH,0D7H,01EH,086H     ; 39.711
4076:	1BAD  64269987	        .DB  064H,026H,099H,087H     ;-76.575
4077:	1BB1  58342387	        .DB  058H,034H,023H,087H     ; 81.602
4078:	1BB5  E05DA586	        .DB  0E0H,05DH,0A5H,086H     ;-41.342
4079:	1BB9  DA0F4983	        .DB  0DAH,00FH,049H,083H     ;  6.2832
4080:			
4081:	1BBD  CD9A17  	TAN:    CALL    STAKFP          ; Put angle on stack
4082:	1BC0  CD5C1B  	        CALL    SIN             ; Get SIN of angle
4083:	1BC3  C1      	        POP     BC              ; Restore angle
4084:	1BC4  E1      	        POP     HL
4085:	1BC5  CD9A17  	        CALL    STAKFP          ; Save SIN of angle
4086:	1BC8  EB      	        EX      DE,HL           ; BCDE = Angle
4087:	1BC9  CDAA17  	        CALL    FPBCDE          ; Angle to FPREG
4088:	1BCC  CD561B  	        CALL    COS             ; Get COS of angle
4089:	1BCF  C3BD16  	        JP      DIV             ; TAN = SIN / COS
4090:			
4091:	1BD2  CD6917  	ATN:    CALL    TSTSGN          ; Test sign of value
4092:	1BD5  FCFD19  	        CALL    M,NEGAFT        ; Negate result after if -ve
4093:	1BD8  FC9217  	        CALL    M,INVSGN        ; Negate value if -ve
4094:	1BDB  3A2C21  	        LD      A,(FPEXP)       ; Get exponent
4095:	1BDE  FE81    	        CP      81H             ; Number less than 1?
4096:	1BE0  DAEF1B  	        JP      C,ATN1          ; Yes - Get arc tangnt
4097:	1BE3  010081  	        LD      BC,8100H        ; BCDE = 1
4098:	1BE6  51      	        LD      D,C
4099:	1BE7  59      	        LD      E,C
4100:	1BE8  CDBF16  	        CALL    DVBCDE          ; Get reciprocal of number
4101:	1BEB  211A15  	        LD      HL,SUBPHL       ; Sub angle from PI/2
4102:	1BEE  E5      	        PUSH    HL              ; Save for angle > 1
4103:	1BEF  21F91B  	ATN1:   LD      HL,ATNTAB       ; Coefficient table
4104:	1BF2  CDB11A  	        CALL    SUMSER          ; Evaluate sum of series
4105:	1BF5  21A01B  	        LD      HL,HALFPI       ; PI/2 - angle in case > 1
4106:	1BF8  C9      	        RET                     ; Number > 1 - Sub from PI/2
4107:			
4108:	1BF9  09      	ATNTAB: .DB  9                       ; Table used by ATN
4109:	1BFA  4AD73B78	        .DB  04AH,0D7H,03BH,078H     ; 1/17
4110:	1BFE  026E847B	        .DB  002H,06EH,084H,07BH     ;-1/15
4111:	1C02  FEC12F7C	        .DB  0FEH,0C1H,02FH,07CH     ; 1/13
4112:	1C06  74319A7D	        .DB  074H,031H,09AH,07DH     ;-1/11
4113:	1C0A  843D5A7D	        .DB  084H,03DH,05AH,07DH     ; 1/9
4114:	1C0E  C87F917E	        .DB  0C8H,07FH,091H,07EH     ;-1/7
4115:	1C12  E4BB4C7E	        .DB  0E4H,0BBH,04CH,07EH     ; 1/5
4116:	1C16  6CAAAA7F	        .DB  06CH,0AAH,0AAH,07FH     ;-1/3
4117:	1C1A  00000081	        .DB  000H,000H,000H,081H     ; 1/1
4118:			
4119:			
4120:	1C1E  C9      	ARET:   RET                     ; A RETurn instruction
4121:			
4122:	1C1F  D7      	GETINP: RST     10H             ;input a character
4123:	1C20  C9      	        RET
4124:			
4125:	1C21          	CLS: 
4126:	1C21  3E0C    	        LD      A,CS            ; ASCII Clear screen
4127:	1C23  C35B1D  	        JP      MONOUT          ; Output character
4128:			
4129:	1C26  CDE814  	WIDTH:  CALL    GETINT          ; Get integer 0-255
4130:	1C29  7B      	        LD      A,E             ; Width to A
4131:	1C2A  328720  	        LD      (LWIDTH),A      ; Set width
4132:	1C2D  C9      	        RET
4133:			
4134:	1C2E  CD870D  	LINES:  CALL    GETNUM          ; Get a number
4135:	1C31  CDCC09  	        CALL    DEINT           ; Get integer -32768 to 32767
4136:	1C34  ED538B20	        LD      (LINESC),DE     ; Set lines counter
4137:	1C38  ED538D20	        LD      (LINESN),DE     ; Set lines number
4138:	1C3C  C9      	        RET
4139:			
4140:	1C3D  CDCC09  	DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
4141:	1C40  D5      	        PUSH    DE              ; Save number
4142:	1C41  E1      	        POP     HL              ; Number to HL
4143:	1C42  46      	        LD      B,(HL)          ; Get LSB of contents
4144:	1C43  23      	        INC     HL
4145:	1C44  7E      	        LD      A,(HL)          ; Get MSB of contents
4146:	1C45  C34211  	        JP      ABPASS          ; Return integer AB
4147:			
4148:	1C48  CD870D  	DOKE:   CALL    GETNUM          ; Get a number
4149:	1C4B  CDCC09  	        CALL    DEINT           ; Get integer -32768 to 32767
4150:	1C4E  D5      	        PUSH    DE              ; Save address
4151:	1C4F  CD9007  	        CALL    CHKSYN          ; Make sure ',' follows
4152:	1C52  2C      	        .DB     ','
4153:	1C53  CD870D  	        CALL    GETNUM          ; Get a number
4154:	1C56  CDCC09  	        CALL    DEINT           ; Get integer -32768 to 32767
4155:	1C59  E3      	        EX      (SP),HL         ; Save value,get address
4156:	1C5A  73      	        LD      (HL),E          ; Save LSB of value
4157:	1C5B  23      	        INC     HL
4158:	1C5C  72      	        LD      (HL),D          ; Save MSB of value
4159:	1C5D  E1      	        POP     HL              ; Restore code string address
4160:	1C5E  C9      	        RET
4161:			
4162:			
4163:			; HEX$(nn) Convert 16 bit number to Hexadecimal string
4164:			
4165:	1C5F  CD8A0D  	HEX:    CALL    TSTNUM          ; Verify it's a number
4166:	1C62  CDCC09  	        CALL    DEINT           ; Get integer -32768 to 32767
4167:	1C65  C5      	        PUSH    BC              ; Save contents of BC
4168:	1C66  212E21  	        LD      HL,PBUFF
4169:	1C69  7A      	        LD      A,D             ; Get high order into A
4170:	1C6A  FE00    	        CP      0H
4171:	1C6C  280C    	        JR      Z,HEX2          ; Skip output if both high digits are zero
4172:	1C6E  CD971C  	        CALL    BYT2ASC         ; Convert D to ASCII
4173:	1C71  78      	        LD      A,B
4174:	1C72  FE30    	        CP      '0'
4175:	1C74  2802    	        JR      Z,HEX1          ; Don't store high digit if zero
4176:	1C76  70      	        LD      (HL),B          ; Store it to PBUFF
4177:	1C77  23      	        INC     HL              ; Next location
4178:	1C78  71      	HEX1:   LD      (HL),C          ; Store C to PBUFF+1
4179:	1C79  23      	        INC     HL              ; Next location
4180:	1C7A  7B      	HEX2:   LD      A,E             ; Get lower byte
4181:	1C7B  CD971C  	        CALL    BYT2ASC         ; Convert E to ASCII
4182:	1C7E  7A      	        LD      A,D
4183:	1C7F  FE00    	        CP      0H
4184:	1C81  2005    	        JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
4185:	1C83  78      	        LD      A,B
4186:	1C84  FE30    	        CP      '0'             ; If high digit of lower byte is zero then don't print
4187:	1C86  2802    	        JR      Z,HEX4
4188:	1C88  70      	HEX3:   LD      (HL),B          ; to PBUFF+2
4189:	1C89  23      	        INC     HL              ; Next location
4190:	1C8A  71      	HEX4:   LD      (HL),C          ; to PBUFF+3
4191:	1C8B  23      	        INC     HL              ; PBUFF+4 to zero
4192:	1C8C  AF      	        XOR     A               ; Terminating character
4193:	1C8D  77      	        LD      (HL),A          ; Store zero to terminate
4194:	1C8E  23      	        INC     HL              ; Make sure PBUFF is terminated
4195:	1C8F  77      	        LD      (HL),A          ; Store the double zero there
4196:	1C90  C1      	        POP     BC              ; Get BC back
4197:	1C91  212E21  	        LD      HL,PBUFF        ; Reset to start of PBUFF
4198:	1C94  C3F011  	        JP      STR1            ; Convert the PBUFF to a string and return it
4199:			
4200:	1C97  47      	BYT2ASC LD      B,A             ; Save original value
4201:	1C98  E60F    	        AND     0FH             ; Strip off upper nybble
4202:	1C9A  FE0A    	        CP      0AH             ; 0-9?
4203:	1C9C  3802    	        JR      C,ADD30         ; If A-F, add 7 more
4204:	1C9E  C607    	        ADD     A,07H           ; Bring value up to ASCII A-F
4205:	1CA0  C630    	ADD30   ADD     A,30H           ; And make ASCII
4206:	1CA2  4F      	        LD      C,A             ; Save converted char to C
4207:	1CA3  78      	        LD      A,B             ; Retrieve original value
4208:	1CA4  0F      	        RRCA                    ; and Rotate it right
4209:	1CA5  0F      	        RRCA
4210:	1CA6  0F      	        RRCA
4211:	1CA7  0F      	        RRCA
4212:	1CA8  E60F    	        AND     0FH             ; Mask off upper nybble
4213:	1CAA  FE0A    	        CP      0AH             ; 0-9? < A hex?
4214:	1CAC  3802    	        JR      C,ADD301        ; Skip Add 7
4215:	1CAE  C607    	        ADD     A,07H           ; Bring it up to ASCII A-F
4216:	1CB0  C630    	ADD301  ADD     A,30H           ; And make it full ASCII
4217:	1CB2  47      	        LD      B,A             ; Store high order byte
4218:	1CB3  C9      	        RET
4219:			
4220:			; Convert "&Hnnnn" to FPREG
4221:			; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
4222:			; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
4223:	1CB4  EB      	HEXTFP  EX      DE,HL           ; Move code string pointer to DE
4224:	1CB5  210000  	        LD      HL,0000H        ; Zero out the value
4225:	1CB8  CDCD1C  	        CALL    GETHEX          ; Check the number for valid hex
4226:	1CBB  DAED1C  	        JP      C,HXERR         ; First value wasn't hex, HX error
4227:	1CBE  1805    	        JR      HEXLP1          ; Convert first character
4228:	1CC0  CDCD1C  	HEXLP   CALL    GETHEX          ; Get second and addtional characters
4229:	1CC3  381F    	        JR      C,HEXIT         ; Exit if not a hex character
4230:	1CC5  29      	HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
4231:	1CC6  29      	        ADD     HL,HL
4232:	1CC7  29      	        ADD     HL,HL
4233:	1CC8  29      	        ADD     HL,HL
4234:	1CC9  B5      	        OR      L               ; Add in D0-D3 into L
4235:	1CCA  6F      	        LD      L,A             ; Save new value
4236:	1CCB  18F3    	        JR      HEXLP           ; And continue until all hex characters are in
4237:			
4238:	1CCD  13      	GETHEX  INC     DE              ; Next location
4239:	1CCE  1A      	        LD      A,(DE)          ; Load character at pointer
4240:	1CCF  FE20    	        CP      ' '
4241:	1CD1  CACD1C  	        JP      Z,GETHEX        ; Skip spaces
4242:	1CD4  D630    	        SUB     30H             ; Get absolute value
4243:	1CD6  D8      	        RET     C               ; < "0", error
4244:	1CD7  FE0A    	        CP      0AH
4245:	1CD9  3805    	        JR      C,NOSUB7        ; Is already in the range 0-9
4246:	1CDB  D607    	        SUB     07H             ; Reduce to A-F
4247:	1CDD  FE0A    	        CP      0AH             ; Value should be $0A-$0F at this point
4248:	1CDF  D8      	        RET     C               ; CY set if was :            ; < = > ? @
4249:	1CE0  FE10    	NOSUB7  CP      10H             ; > Greater than "F"?
4250:	1CE2  3F      	        CCF
4251:	1CE3  C9      	        RET                     ; CY set if it wasn't valid hex
4252:			
4253:	1CE4  EB      	HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
4254:	1CE5  7A      	        LD      A,D             ; Load DE into AC
4255:	1CE6  4B      	        LD      C,E             ; For prep to 
4256:	1CE7  E5      	        PUSH    HL
4257:	1CE8  CD4111  	        CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4258:	1CEB  E1      	        POP     HL
4259:	1CEC  C9      	        RET
4260:			
4261:	1CED  1E26    	HXERR:  LD      E,HE            ; ?HEX Error
4262:	1CEF  C30A05  	        JP      ERROR
4263:			
4264:			; BIN$(NN) Convert integer to a 1-16 char binary string
4265:	1CF2  CD8A0D  	BIN:    CALL    TSTNUM          ; Verify it's a number
4266:	1CF5  CDCC09  	        CALL    DEINT           ; Get integer -32768 to 32767
4267:	1CF8  C5      	BIN2:   PUSH    BC              ; Save contents of BC
4268:	1CF9  212E21  	        LD      HL,PBUFF
4269:	1CFC  0611    	        LD      B,17            ; One higher than max char count
4270:	1CFE          	ZEROSUP:                        ; Suppress leading zeros
4271:	1CFE  05      	        DEC     B               ; Max 16 chars
4272:	1CFF  78      	        LD      A,B
4273:	1D00  FE01    	        CP      01H
4274:	1D02  2808    	        JR      Z,BITOUT        ; Always output at least one character
4275:	1D04  CB13    	        RL      E
4276:	1D06  CB12    	        RL      D
4277:	1D08  30F4    	        JR      NC,ZEROSUP
4278:	1D0A  1804    	        JR      BITOUT2
4279:	1D0C          	BITOUT:
4280:	1D0C  CB13    	        RL      E
4281:	1D0E  CB12    	        RL      D               ; Top bit now in carry
4282:	1D10          	BITOUT2:
4283:	1D10  3E30    	        LD      A,'0'           ; Char for '0'
4284:	1D12  CE00    	        ADC     A,0             ; If carry set then '0' --> '1'
4285:	1D14  77      	        LD      (HL),A
4286:	1D15  23      	        INC     HL
4287:	1D16  05      	        DEC     B
4288:	1D17  20F3    	        JR      NZ,BITOUT
4289:	1D19  AF      	        XOR     A               ; Terminating character
4290:	1D1A  77      	        LD      (HL),A          ; Store zero to terminate
4291:	1D1B  23      	        INC     HL              ; Make sure PBUFF is terminated
4292:	1D1C  77      	        LD      (HL),A          ; Store the double zero there
4293:	1D1D  C1      	        POP     BC
4294:	1D1E  212E21  	        LD      HL,PBUFF
4295:	1D21  C3F011  	        JP      STR1
4296:			
4297:			; Convert "&Bnnnn" to FPREG
4298:			; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
4299:	1D24  EB      	BINTFP: EX      DE,HL           ; Move code string pointer to DE
4300:	1D25  210000  	        LD      HL,0000H        ; Zero out the value
4301:	1D28  CD411D  	        CALL    CHKBIN          ; Check the number for valid bin
4302:	1D2B  DA4F1D  	        JP      C,BINERR        ; First value wasn't bin, HX error
4303:	1D2E  D630    	BINIT:  SUB     '0'
4304:	1D30  29      	        ADD     HL,HL           ; Rotate HL left
4305:	1D31  B5      	        OR      L
4306:	1D32  6F      	        LD      L,A
4307:	1D33  CD411D  	        CALL    CHKBIN          ; Get second and addtional characters
4308:	1D36  30F6    	        JR      NC,BINIT        ; Process if a bin character
4309:	1D38  EB      	        EX      DE,HL           ; Value into DE, Code string into HL
4310:	1D39  7A      	        LD      A,D             ; Load DE into AC
4311:	1D3A  4B      	        LD      C,E             ; For prep to 
4312:	1D3B  E5      	        PUSH    HL
4313:	1D3C  CD4111  	        CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4314:	1D3F  E1      	        POP     HL
4315:	1D40  C9      	        RET
4316:			
4317:			; Char is in A, NC if char is 0 or 1
4318:	1D41  13      	CHKBIN: INC     DE
4319:	1D42  1A      	        LD      A,(DE)
4320:	1D43  FE20    	        CP      ' '
4321:	1D45  CA411D  	        JP      Z,CHKBIN        ; Skip spaces
4322:	1D48  FE30    	        CP      '0'             ; Set C if < '0'
4323:	1D4A  D8      	        RET     C
4324:	1D4B  FE32    	        CP      '2'
4325:	1D4D  3F      	        CCF                     ; Set C if > '1'
4326:	1D4E  C9      	        RET
4327:			
4328:	1D4F  1E28    	BINERR: LD      E,BN            ; ?BIN Error
4329:	1D51  C30A05  	        JP      ERROR
4330:			
4331:			
4332:	1D54  DD21FFFF	JJUMP1: LD      IX,-1           ; Flag cold start
4333:	1D58  C35E01  	        JP      CSTART          ; Go and initialise
4334:			
4335:	1D5B  C30800  	MONOUT: JP      0008H           ; output a char
4336:			
4337:			
4338:	1D5E  76      	MONITR: HALT
4339:			        ;JP      0000H           ; Restart (Normally Monitor Start)
4340:			
4341:			
4342:	1D5F  3E00    	INITST: LD      A,0             ; Clear break flag
4343:	1D61  329220  	        LD      (BRKFLG),A
4344:	1D64  C36501  	        JP      INIT
4345:			
4346:	1D67  ED45    	ARETN:  RETN                    ; Return from NMI
4347:			
4348:			
4349:	1D69  F5      	TSTBIT: PUSH    AF              ; Save bit mask
4350:	1D6A  A0      	        AND     B               ; Get common bits
4351:	1D6B  C1      	        POP     BC              ; Restore bit mask
4352:	1D6C  B8      	        CP      B               ; Same bit set?
4353:	1D6D  3E00    	        LD      A,0             ; Return 0 in A
4354:	1D6F  C9      	        RET
4355:			
4356:	1D70  CD9B07  	OUTNCR: CALL    OUTC            ; Output character in A
4357:	1D73  C3C20B  	        JP      PRNTCRLF        ; Output CRLF
4358:			
4359:	1D76          	.end



Statistics:

     4	passes
     0	jr promotions
   635	symbols
  7206	bytes



Symbol Table:

ABPASS          1142      4418
ABS             178E      6030
ACCSUM           9AB      2475
ACPASS          1141      4417
ADD30           1CA0      7328
ADD301          1CB0      7344
ADDEXP          1727      5927
ADDIG           18CD      6349
ADDPHL          1514      5396
ALLFOL          1410      5136
ANTVLU           CAB      3243
ARET            1C1E      7198
ARETN           1D67      7527
ARLDSV          1062      4194
ARREND          211F      8479
ARRLP           12DB      4827
ASC             13E1      5089
ASCTFP          1870      6256
ASPCS            C0D      3085
ATN             1BD2      7122
ATN1            1BEF      7151
ATNTAB          1BF9      7161
ATOH             9E6      2534
BADINP           C32      3122
BAKSTK           49F      1183
BAKTMP          13C1      5057
BASTXT          20A3      8355
BCDEFP          17B5      6069
BFREE            1FA      506
BIN             1CF2      7410
BIN2            1CF8      7416
BINERR          1D4F      7503
BINIT           1D2E      7470
BINTFP          1D24      7460
BITOUT          1D0C      7436
BITOUT2         1D10      7440
BKSP           =08        8
BN             =28        40
BNORM           1574      5492
BNRMLP          1577      5495
BRK              95D      2397
BRKFLG          2092      8338
BRKLIN          2113      8467
BRKMSG           499      1177
BRKRET           1F4      500
BS             =10        16
BSERR           1095      4245
BUFFER          20A6      8358
BYT2ASC         1C97      7319
BYTSFT          16AC      5804
CAN            =18        24
CFEVAL           FF8      4088
CHARTY           FA6      4006
CHEKFN          11D9      4569
CHKBIN          1D41      7489
CHKLTR           9B8      2488
CHKSTK           4D3      1235
CHKSUM          208F      8335
CHKSYN           790      1936
CHKTYP           D8C      3468
CHR             13F2      5106
CLEAR            A0B      2571
CLOTST           7C5      1989
CLREG            628      1576
CLRPTR           603      1539
CLS             1C21      7201
CMPFP           17FE      6142
CMPLG1           F0C      3852
CMPLOG           F0A      3850
CMPNUM          17E4      6116
CMPRES           F4E      3918
CMPSTR           F36      3894
CN             =20        32
CNVNUM          187C      6268
COLD             150      336
COMMAN          2088      8328
COMPL           15D4      5588
CONCAT          1356      4950
CONEXP          18AC      6316
CONPOS          1571      5489
CONT             990      2448
CONTAD          2119      8473
CONVAR           E77      3703
COPY             16D      365
COS             1B56      6998
COUNT            835      2101
CPDEHL           78A      1930
CPYLIT           6FA      1786
CR             =0D        13
CRARLP          10B5      4277
CREARY          109A      4250
CRESTR           B0A      2826
CRNCLP           65B      1627
CRTMST          1212      4626
CRTST           121E      4638
CRTSTE          1234      4660
CRUNCH           652      1618
CS             =0C        12
CSTART           15E      350
CTLOFG          208A      8330
CTRLC          =03        3
CTRLG          =07        7
CTRLO          =0F        15
CTRLQ          =11        17
CTRLR          =12        18
CTRLS          =13        19
CTRLU          =15        21
CUROPR          210A      8458
CURPOS          20F0      8432
DATA             AB1      2737
DATFLG          20F3      8435
DATLIN          210E      8462
DATSNR           4F0      1264
DCBCDE          1835      6197
DD             =12        18
DDERR            4FF      1279
DEEK            1C3D      7229
DEF             1156      4438
DEFSIZ          10BD      4285
DEINT            9CC      2508
DEL            =7F        127
DELCHR           70A      1802
DEPINT           9C6      2502
DETHL4          17C4      6084
DETHLB          17C6      6086
DIGTXT          1976      6518
DIM              F78      3960
DIMRET           F6F      3951
DINPOS           7BF      1983
DIV             16BD      5821
DIV1           =204F      8271
DIV10           16B1      5809
DIV2           =2053      8275
DIV3           =2057      8279
DIV4           =205A      8282
DIVLP           16E4      5860
DIVSUP          204E      8270
DOAGN            641      1601
DOCOM            BDE      3038
DOEBIT          19B6      6582
DOFN            1183      4483
DOKE            1C48      7240
DONULL           BCC      3020
DOSPC            C08      3080
DOTAB            BF5      3061
DPOINT          18A8      6312
DTSTR           1222      4642
DVBCDE          16BF      5823
DZ             =14        20
DZERR            4F9      1273
EDIGIT          18EF      6383
ENDBUF           701      1793
ENDCON          18BB      6331
ENDDIM          111C      4380
ENDINP           BBD      3005
ENDNAM           F9A      3994
ENDPRG           96C      2412
ENFMEM           4DC      1244
ERRIN            52A      1322
ERRLIN          2117      8471
ERRMSG           487      1159
ERROR            50A      1290
ERRORS           3FD      1021
ESC            =1B        27
EVAL             D99      3481
EVAL1            D9C      3484
EVAL2            DA5      3493
EVAL3            DA8      3496
EVLPAR           E5E      3678
EVNOT            F58      3928
EXCUTE           8FA      2298
EXP             1A50      6736
EXPLP           189A      6298
EXPTAB          1A90      6800
EXPTEN          19C8      6600
EXTIG            D07      3335
FANDT            D31      3377
FC             =08        8
FCERR            9E1      2529
FDTLP            D18      3352
FINDEL          10F8      4344
FLGDIF          1774      6004
FLGREL          177B      6011
FNARG           2125      8485
FNCTAB           247      583
FNDARY          1068      4200
FNDELP          10FD      4349
FNDEND           5D6      1494
FNDNUM          14E5      5349
FNDTOK           814      2068
FNDVAR           FDF      4063
FNDWRD           685      1669
FNOFST           E88      3720
FNRGNM          2123      8483
FNTHR            FED      4077
FNVAL            EAF      3759
FOPRND           DD1      3537
FOR              861      2145
FORFLG          2110      8464
FORFND           891      2193
FORSLP           875      2165
FPADD           1523      5411
FPBCDE          17AA      6058
FPEXP          =212C      8492
FPINT           1811      6161
FPMULT          165E      5726
FPREG           2129      8489
FPROND          15BB      5563
FPSINT           9C0      2496
FPTHL           17C1      6081
FRE             1120      4384
FRENUM          113C      4412
FRMEVL           E7A      3706
GARBGE          12A3      4771
GARBLP          12A6      4774
GETCHR           91A      2330
GETCMD           54E      1358
GETHEX          1CCD      7373
GETINP          1C1F      7199
GETINT          14E8      5352
GETLEN          13D6      5078
GETLIN           727      1831
GETLN            9E7      2535
GETNUM           D87      3463
GETNXT           6A0      1696
GETSTR          13A0      5024
GETVAR           F7D      3965
GNXARY          12DA      4826
GOFUNC           EB7      3767
GOSUB            A5D      2653
GOTO             A6E      2670
GRBARY          12FA      4858
GRBDON          127B      4731
GRBLP           12B4      4788
GSTRCU          13A3      5027
GSTRDE          13A7      5031
GSTRHL          13A6      5030
GTFLNM          13E5      5093
GTFNAM           F82      3970
GTLNLP           9EA      2538
GTSIXD          1940      6464
GTVLUS           C83      3203
HALF            19E7      6631
HALFPI          1BA0      7072
HE             =26        38
HEX             1C5F      7263
HEX1            1C78      7288
HEX2            1C7A      7290
HEX3            1C88      7304
HEX4            1C8A      7306
HEXIT           1CE4      7396
HEXLP           1CC0      7360
HEXLP1          1CC5      7365
HEXTFP          1CB4      7348
HXERR           1CED      7405
ID             =16        22
IDTEST          11CB      4555
IF               B40      2880
IFGO             B4E      2894
IFJMP            901      2305
INCHL           17BF      6079
INCLEN           7BB      1979
INDFND           4B9      1209
INEWLN           59E      1438
INIT             165      357
INITAB           427      1063
INITBE           487      1159
INITST          1D5F      7519
INMSG            48E      1166
INP             14A5      5285
INPBIN           CD5      3285
INPBRK           969      2409
INPORT         =2084      8324
INPSUB          2083      8323
INPUT            C43      3139
INRNG           1949      6473
INT             183C      6204
INTVAR           612      1554
INVSGN          1792      6034
ITMSEP           CC6      3270
JJUMP1          1D54      7508
JSTZER          19D2      6610
KILFOR           D77      3447
KILIN            721      1825
LCRFLG          20F1      8433
LEFT            1402      5122
LEN             13D2      5074
LET              AC8      2760
LETNUM           B1B      2843
LETSTR           AE3      2787
LF             =0A        10
LFRGNM          149B      5275
LINEAT          20A1      8353
LINEIN          18FB      6395
LINES           1C2E      7214
LINESC          208B      8331
LINESN          208D      8333
LINFND           587      1415
LIST             7D6      2006
LISTLP           7E2      2018
LOADFP          17B8      6072
LOG             161D      5661
LOGTAB          1610      5648
LOKFOR           4A3      1187
LOOPST          210C      8460
LS             =1C        28
LSTBIN          2111      8465
LSTLP2           802      2050
LSTLP3           805      2053
LSTRAM          20F4      8436
LSTRND          207F      8319
LTSTND           CE0      3296
LWIDTH          2087      8327
MAKINT          14EB      5355
MAKNUM          1965      6501
MANLP           1884      6276
MATCH            6D2      1746
MID             143C      5180
MID1            1408      5128
MIDNUM          14A0      5280
MINCDE          1563      5475
MINUS            E66      3686
MKTMST          120F      4623
MLDBLP          185D      6237
MLDEBC          1855      6229
MLOOP            195      405
MLSP10          1752      5970
MO             =24        36
MONITR          1D5E      7518
MONOUT          1D5B      7515
MORDT            CEC      3308
MORINP           72C      1836
MOVBUF           5BD      1469
MOVDIR           6DA      1754
MOVLP            4C8      1224
MOVSTR           4C5      1221
MOVUP            4C2      1218
MRPRNT           B60      2912
MSIZE            182      386
MUL8LP          1689      5769
MULLN2          1655      5717
MULT            165C      5724
MULT8           1680      5760
MULTEN          18C6      6342
MULVAL          213B      8507
MVSTPT           B12      2834
NEDMOR           C7F      3199
NEGAFT          19FD      6653
NEW              602      1538
NEXITM           C18      3096
NEXT             D3C      3388
NEXT1            D3F      3391
NF             =00        0
NFERR            4FC      1276
NMIFLG          2091      8337
NOCHNG           6CA      1738
NOENED          19D5      6613
NOLIN            97F      2431
NOMADD          169A      5786
NOMLAD          186B      6251
NOPMPT           C5D      3165
NORMAL          158E      5518
NOSPC            6C1      1729
NOSUB7          1CE0      7392
NOSWAP          153D      5437
NOTAMP           E3B      3643
NOTSTR           FB5      4021
NOXOR           14CB      5323
NSCFOR           FC5      4037
NULFLG          2089      8329
NULL             9A3      2467
NULLP            BD3      3027
NULLS           2086      8326
NUMASC          190E      6414
NXTARY          107C      4220
NXTBYT           6B0      1712
NXTCHR           6F1      1777
NXTDAT          2121      8481
NXTDTA           AB0      2736
NXTITM           C77      3191
NXTOPR          2115      8469
NXTSTL           AB7      2743
NXTSTT           ABA      2746
OD             =06        6
OKMSG            493      1171
OM             =0C        12
OMERR            4EB      1259
ON               B22      2850
ONGO             B31      2865
ONGOLP           B32      2866
ONJMP            902      2306
OPNPAR           D95      3477
OPRND            E10      3600
OS             =1A        26
OTKLN            71E      1822
OTPORT         =204C      8268
OUTC             79B      1947
OUTEXP          19C6      6598
OUTIT            784      1924
OUTNCR          1D70      7536
OUTSUB          204B      8267
OUTWRD           81E      2078
OV             =0A        10
OVERR            505      1285
OVTST1          1745      5957
OVTST2          174A      5962
OVTST3          174B      5963
PADD            18EA      6378
PAND             ED1      3793
PASSA           1151      4433
PBUFF           212E      8494
PEEK            14F9      5369
PEND             964      2404
PHLTFP          17A7      6055
PLUCDE          15C8      5576
PNORM           1596      5526
POINT           2096      8342
POKE            1500      5376
POPAF           1295      4757
POPHL           13BF      5055
POPHRT          16AA      5802
POPNOK           540      1344
POR              ED0      3792
POR1             EF3      3827
POS             114E      4430
POSINT           9C3      2499
POUT            14B1      5297
POWER           1A0B      6667
POWER1          1A1B      6683
POWER2          1A38      6712
POWERS          19EB      6635
PRINT            B64      2916
PRITAB           3E8      1000
PRNTCRLF         BC2      3010
PRNTHL          1903      6403
PRNTLP           B67      2919
PRNTNB           BAA      2986
PRNTOK           541      1345
PRNTST           BAE      2990
PRNUMS          125F      4703
PROCES           730      1840
PROGND          211B      8475
PROGST          213E      8510
PROMPT           645      1605
PRS             1260      4704
PRS1            1263      4707
PRSLP           126A      4714
PSET            2099      8345
PSUB            151E      5406
PTRLP            5CA      1482
PUTB1            77D      1917
PUTBUF           76A      1898
PUTCTL           76F      1903
PUTFID           8D6      2262
QTSTLP          1225      4645
QTSTR           121F      4639
QUARTR          1BA4      7076
RAMSTART        2000      8192
READ             C72      3186
READFG          2112      8466
REDO             C1F      3103
REM              AB3      2739
RESDIV          16F7      5879
RESEED          1B42      6978
RESET           209C      8348
RESTNL           93F      2367
RESTOR           92A      2346
RESZER          1589      5513
RETADR          102C      4140
RETINT          1780      6016
RETLIN           AAB      2731
RETNAD           6D6      1750
RETNUL          102F      4143
RETNUM           E72      3698
RETREL          1772      6002
RETURN           A8C      2700
RG             =04        4
RIGHT           1432      5170
RIGHT1          1406      5126
RINPUT          2093      8339
RLTLP            DB5      3509
RND             1AE1      6881
RND1            1B1D      6941
RND2            1B39      6969
RNDTAB          1B4A      6986
RNGTST          19D8      6616
RONDB           15AA      5546
RONDUP          15A9      5545
ROUND           1511      5393
RSCALE          18E4      6372
RSLNBK           858      2136
RSTSTR          1455      5205
RUN              A51      2641
RUNCNT           8DA      2266
RUNFST           60E      1550
RUNLIN           A6D      2669
SAVEXP          158A      5514
SAVSTP           8CD      2253
SAVSTR          11FA      4602
SBSCPT          103A      4154
SCALE           15E8      5608
SCALLP          15EA      5610
SCALMI          18AF      6319
SCALPL          18C5      6341
SCNEND          1331      4913
SCPTLP          1040      4160
SEARCH           69E      1694
SEED            205C      8284
SETIO           14D5      5333
SETLIN           82C      2092
SETLIT           6E8      1768
SETPTR           5C5      1477
SETTOP           1B9      441
SFTPRG           58F      1423
SGN             1778      6008
SGNEXP           EC0      3776
SGNRES          212D      8493
SHRITE          15F7      5623
SHRLP           15FA      5626
SHRT1           15FE      5630
SIGNON           209      521
SIGNS           17CF      6095
SIN             1B5C      7004
SIN1            1B8C      7052
SINTAB          1BA8      7080
SIXDIG          192B      6443
SMPVAR          12C5      4805
SMSER1          1AC0      6848
SN             =02        2
SNERR            4F6      1270
SPACE          =20        32
SPCFST          191C      6428
SPCLP            C11      3089
SQR             1A02      6658
SRCHLN           5E2      1506
SRCHLP           5E5      1509
SSTSA           138D      5005
ST             =1E        30
STACK          =20F0      8432
STAKFP          179A      6042
STALL            953      2387
STARTB           15A      346
STKTHS           DF9      3577
STLOOK         =21A2      8610
STOP             962      2402
STORED           A2E      2606
STPOOL          1308      4872
STR             11EA      4586
STR1            11F0      4592
STRADD          130B      4875
STRBOT          2108      8456
STRENT           CC9      3273
STRSPC          209F      8351
STTLIN           BB5      2997
SUBCDE          1520      5408
SUBPHL          151A      5402
SUMLP           1AC9      6857
SUMSER          1AB1      6833
SUPTLZ          19AA      6570
SVNAM2           F99      3993
SVSTAD          1218      4632
TAN             1BBD      7101
TESTOS          1297      4759
TESTR           1279      4729
TM             =18        24
TMERR            508      1288
TMPSTR          2104      8452
TMSTPL          20F8      8440
TMSTPT          20F6      8438
TOPOOL          13FE      5118
TOSTRA          1396      5014
TRYAGN          1985      6533
TSALP           1397      5015
TSTBIT          1D69      7529
TSTBRK           945      2373
TSTMEM           1A7      423
TSTNUM           D8A      3466
TSTOPL          1240      4672
TSTRED           EF8      3832
TSTREM           6EB      1771
TSTSGN          1769      5993
TSTSTR           D8B      3467
TTYLIN           727      1831
TYPE            20F2      8434
UF             =22        34
UFERR            502      1282
UL             =0E        14
ULERR            A87      2695
UNITY           160C      5644
UPDATA           940      2368
USR             2048      8264
VAL             146C      5228
VAL1            148A      5258
VAL2            1494      5268
VAL3            1497      5271
VAREND          211D      8477
WAIT            14B7      5303
WAITLP          14CC      5324
WARM             153      339
WARMST           1F1      497
WIDTH           1C26      7206
WORDS            27F      639
WORDTB           39E      926
WRKSPC          2045      8261
ZDATA          =83        131
ZDIV           =AF        175
ZEND           =80        128
ZEQUAL         =B4        180
ZERARY          10DB      4315
ZERBYT         = 492      1170
ZEROLP          101E      4126
ZEROSUP         1CFE      7422
ZFN            =A7        167
ZFOR           =81        129
ZGOSUB         =8C        140
ZGOTO          =88        136
ZGTR           =B3        179
ZLEFT          =CF        207
ZLTH           =B5        181
ZMINUS         =AD        173
ZNEW           =A4        164
ZNOT           =AA        170
ZONELP           BEC      3052
ZOR            =B2        178
ZPLUS          =AC        172
ZPOINT         =C7        199
ZPRINT         =9E        158
ZREM           =8E        142
ZSGN           =B6        182
ZSPC           =A8        168
ZSTEP          =AB        171
ZTAB           =A5        165
ZTHEN          =A9        169
ZTIMES         =AE        174
ZTO            =A6        166
