   1:			;==================================================================================
   2:			; The updates to the original BASIC within this file are copyright Grant Searle
   3:			;
   4:			; You have permission to use this for NON COMMERCIAL USE ONLY
   5:			; If you wish to use it elsewhere, please include an acknowledgement to myself.
   6:			;
   7:			; http://searle.hostei.com/grant/index.html
   8:			;
   9:			; eMail: home.micros01@btinternet.com
  10:			;
  11:			; If the above don't work, please perform an Internet search to see if I have
  12:			; updated the web page hosting service.
  13:			;
  14:			;==================================================================================
  15:			
  16:			; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
  17:			; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
  18:			; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
  19:			; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
  20:			; the original ROM code (checksum A934H). PA
  21:			
  22:			; GENERAL EQUATES
  23:			
  24:	0003          	CTRLC   .EQU   03H             ; Control "C"
  25:	0007          	CTRLG   .EQU   07H             ; Control "G"
  26:	0008          	BKSP    .EQU   08H             ; Back space
  27:	000A          	LF      .EQU   0AH             ; Line feed
  28:	000C          	CS      .EQU   0CH             ; Clear screen
  29:	000D          	CR      .EQU   0DH             ; Carriage return
  30:	000F          	CTRLO   .EQU   0FH             ; Control "O"
  31:	0011          	CTRLQ   .EQU   11H             ; Control "Q"
  32:	0012          	CTRLR   .EQU   12H             ; Control "R"
  33:	0013          	CTRLS   .EQU   13H             ; Control "S"
  34:	0015          	CTRLU   .EQU   15H             ; Control "U"
  35:	0018          	CAN     .EQU   18H             ; Cancel Control 'X'
  36:	001B          	ESC     .EQU   1BH             ; Escape
  37:	0020          	SPACE   .EQU   20H             ; Space
  38:	007F          	DEL     .EQU   7FH             ; Delete
  39:			
  40:	2000          	ROMSIZE .EQU    2000H
  41:	2000          	RAMSTRT .EQU    ROMSIZE
  42:	1A00          	RAMSIZE .EQU    1A00H          ; use 6.5K RAM from dongle
  43:	3A00          	RAMEND  .EQU    RAMSTRT + RAMSIZE
  44:			
  45:			
  46:			; BASIC WORK SPACE LOCATIONS
  47:			
  48:	2000          	        .ORG   RAMSTRT
  49:			
  50:	2000          	WRKSPC  .ds     3       ; .EQU   2000H           ; BASIC Work space
  51:	2003          	USRJP   .ds     3       ; .EQU   2003H = 8195    ; "USR (x)" jump
  52:	2006          	OUTSUB  .ds     3       ; .EQU   WRKSPC + 6H     ; "OUT p,n"
  53:	2007          	OTPORT  .equ    OUTSUB+1 ; .EQU   WRKSPC + 7H     ; Port (p)
  54:	2009          	DIVSUP  .ds     14      ; .EQU   WRKSPC + 9H     ; Division support routine
  55:	200A          	DIV1    .equ    DIVSUP+1  ; .EQU   WRKSPC + 0AH    ; <- Values
  56:	200E          	DIV2    .equ    DIVSUP+5  ; .EQU   WRKSPC + 0EH    ; <-   to
  57:	2012          	DIV3    .equ    DIVSUP+9  ; .EQU   WRKSPC + 12H    ; <-   be
  58:	2015          	DIV4    .equ    DIVSUP+12 ; .EQU   WRKSPC + 15H    ; <-inserted
  59:	2017          	SEED    .ds     35       ; .EQU   WRKSPC + 17H    ; Random number seed
  60:	203A          	LSTRND  .ds     4       ; .EQU   WRKSPC + 3AH    ; Last random number
  61:	203E          	INPSUB  .ds     3       ; .EQU   WRKSPC + 3EH    ; #INP (x)" Routine
  62:	203F          	INPORT  .equ    INPSUB+1 ; .EQU   WRKSPC + 3FH    ; PORT (x)
  63:	2041          	NULLS   .ds     1       ; .EQU   WRKSPC + 41H    ; Number of nulls
  64:	2042          	LWIDTH  .ds     1       ; .EQU   WRKSPC + 42H    ; Terminal width
  65:	2043          	COMMAN  .ds     1       ; .EQU   WRKSPC + 43H    ; Width for commas
  66:	2044          	NULFLG  .ds     1       ; .EQU   WRKSPC + 44H    ; Null after input byte flag
  67:	2045          	CTLOFG  .ds     1       ; .EQU   WRKSPC + 45H    ; Control "O" flag
  68:	2046          	LINESC  .ds     2       ; .EQU   WRKSPC + 46H    ; Lines counter
  69:	2048          	LINESN  .ds     2       ; .EQU   WRKSPC + 48H    ; Lines number
  70:	204A          	CHKSUM  .ds     2       ; .EQU   WRKSPC + 4AH    ; Array load/save check sum
  71:	204C          	NMIFLG  .ds     1       ; .EQU   WRKSPC + 4CH    ; Flag for NMI break routine
  72:	204D          	BRKFLG  .ds     1       ; .EQU   WRKSPC + 4DH    ; Break flag
  73:	204E          	RINPUT  .ds     3       ; .EQU   WRKSPC + 4EH    ; Input reflection
  74:	2051          	POINT   .ds     3       ; .EQU   WRKSPC + 51H    ; "POINT" reflection (unused)
  75:	2054          	PSET    .ds     3       ; .EQU   WRKSPC + 54H    ; "SET"   reflection
  76:	2057          	RESET   .ds     3       ; .EQU   WRKSPC + 57H    ; "RESET" reflection
  77:	205A          	STRSPC  .ds     2       ; .EQU   WRKSPC + 5AH    ; Bottom of string space
  78:	205C          	LINEAT  .ds     2       ; .EQU   WRKSPC + 5CH    ; Current line number
  79:	205E          	BASTXT  .ds     2       ; .EQU   WRKSPC + 5EH    ; Pointer to start of program
  80:	2060          	        .ds     1
  81:	2061          	BUFFER  .ds     74      ; .EQU   WRKSPC + 61H    ; Input buffer
  82:	2066          	STACK   .EQU   WRKSPC + 66H    ; Initial stack
  83:	20AB          	CURPOS  .ds     1       ; .EQU   WRKSPC + 0ABH   ; Character position on line
  84:	20AC          	LCRFLG  .ds     1       ; .EQU   WRKSPC + 0ACH   ; Locate/Create flag
  85:	20AD          	TYPE    .ds     1       ; .EQU   WRKSPC + 0ADH   ; Data type flag
  86:	20AE          	DATFLG  .ds     1       ; .EQU   WRKSPC + 0AEH   ; Literal statement flag
  87:	20AF          	LSTRAM  .ds     2       ; .EQU   WRKSPC + 0AFH   ; Last available RAM
  88:	20B1          	TMSTPT  .ds     2       ; .EQU   WRKSPC + 0B1H   ; Temporary string pointer
  89:	20B3          	TMSTPL  .ds     12      ; .EQU   WRKSPC + 0B3H   ; Temporary string pool
  90:	20BF          	TMPSTR  .ds     4       ; .EQU   WRKSPC + 0BFH   ; Temporary string
  91:	20C3          	STRBOT  .ds     2       ; .EQU   WRKSPC + 0C3H   ; Bottom of string space
  92:	20C5          	CUROPR  .ds     2       ; .EQU   WRKSPC + 0C5H   ; Current operator in EVAL
  93:	20C7          	LOOPST  .ds     2       ; .EQU   WRKSPC + 0C7H   ; First statement of loop
  94:	20C9          	DATLIN  .ds     2       ; .EQU   WRKSPC + 0C9H   ; Line of current DATA item
  95:	20CB          	FORFLG  .ds     1       ; .EQU   WRKSPC + 0CBH   ; "FOR" loop flag
  96:	20CC          	LSTBIN  .ds     1       ; .EQU   WRKSPC + 0CCH   ; Last byte entered
  97:	20CD          	READFG  .ds     1       ; .EQU   WRKSPC + 0CDH   ; Read/Input flag
  98:	20CE          	BRKLIN  .ds     2       ; .EQU   WRKSPC + 0CEH   ; Line of break
  99:	20D0          	NXTOPR  .ds     2       ; .EQU   WRKSPC + 0D0H   ; Next operator in EVAL
 100:	20D2          	ERRLIN  .ds     2       ; .EQU   WRKSPC + 0D2H   ; Line of error
 101:	20D4          	CONTAD  .ds     2       ; .EQU   WRKSPC + 0D4H   ; Where to CONTinue
 102:	20D6          	PROGND  .ds     2       ; .EQU   WRKSPC + 0D6H   ; End of program
 103:	20D8          	VAREND  .ds     2       ; .EQU   WRKSPC + 0D8H   ; End of variables
 104:	20DA          	ARREND  .ds     2       ; .EQU   WRKSPC + 0DAH   ; End of arrays
 105:	20DC          	NXTDAT  .ds     2       ; .EQU   WRKSPC + 0DCH   ; Next data item
 106:	20DE          	FNRGNM  .ds     2       ; .EQU   WRKSPC + 0DEH   ; Name of FN argument
 107:	20E0          	FNARG   .ds     4       ; .EQU   WRKSPC + 0E0H   ; FN argument value
 108:	20E4          	FPREG   .ds     4       ; .EQU   WRKSPC + 0E4H   ; Floating point register
 109:	20E7          	FPEXP   .EQU   FPREG + 3       ; Floating point exponent
 110:	20E8          	SGNRES  .ds     1       ; .EQU   WRKSPC + 0E8H   ; Sign of result
 111:	20E9          	PBUFF   .ds     13      ; .EQU   WRKSPC + 0E9H   ; Number print buffer
 112:	20F6          	MULVAL  .ds     3       ; .EQU   WRKSPC + 0F6H   ; Multiplier
 113:	20F9          	PROGST  .ds     1       ; .EQU   WRKSPC + 0F9H   ; Start of program text area
 114:			
 115:	2200          	STLOOK  .EQU   WRKSPC + 0200H   ; Start of memory test
 116:			
 117:			; BASIC ERROR CODE VALUES
 118:			
 119:	0000          	NF      .EQU   00H             ; NEXT without FOR
 120:	0002          	SN      .EQU   02H             ; Syntax error
 121:	0004          	RG      .EQU   04H             ; RETURN without GOSUB
 122:	0006          	OD      .EQU   06H             ; Out of DATA
 123:	0008          	FC      .EQU   08H             ; Function call error
 124:	000A          	OV      .EQU   0AH             ; Overflow
 125:	000C          	OM      .EQU   0CH             ; Out of memory
 126:	000E          	UL      .EQU   0EH             ; Undefined line number
 127:	0010          	BS      .EQU   10H             ; Bad subscript
 128:	0012          	DD      .EQU   12H             ; Re-DIMensioned array
 129:	0014          	DZ      .EQU   14H             ; Division by zero (/0)
 130:	0016          	ID      .EQU   16H             ; Illegal direct
 131:	0018          	TM      .EQU   18H             ; Type miss-match
 132:	001A          	OS      .EQU   1AH             ; Out of string space
 133:	001C          	LS      .EQU   1CH             ; String too long
 134:	001E          	ST      .EQU   1EH             ; String formula too complex
 135:	0020          	CN      .EQU   20H             ; Can't CONTinue
 136:	0022          	UF      .EQU   22H             ; UnDEFined FN function
 137:	0024          	MO      .EQU   24H             ; Missing operand
 138:	0026          	HE      .EQU   26H             ; HEX error
 139:	0028          	BN      .EQU   28H             ; BIN error
 140:			
 141:			
 142:	0100          	        .ORG   0100H
 143:			
 144:	0100  C30C01  	COLD:   JP      CSTART          ; Jump for cold start
 145:	0103  C3A101  	WARM:   JP      WARMST          ; Jump for warm start
 146:			
 147:			; USR(X) at 0x2048 = 8264 is called with a single argument.
 148:			; Get the int16_t argument in DE by calling DEINT.
 149:			; Put return int16_t value in AB and call ABPASS.
 150:			;
 151:	0106  C38709  	        JP     DEINT            ; Get int16_t argument in DE
 152:	0109  C3FD10  	        JP     ABPASS           ; Return int16_t result in AB
 153:			
 154:	010C  216620  	CSTART: LD      HL,STACK        ; End of BUFFER RAM
 155:	010F  F9      	        LD      SP,HL           ; Set up a temporary stack
 156:			
 157:	0110  3E00    	INITST: LD      A,0             ; Clear break flag
 158:	0112  324D20  	        LD      (BRKFLG),A
 159:			
 160:	0115  11E203  	INIT:   LD      DE,INITAB       ; Initialise workspace
 161:	0118  0663    	        LD      B,INITBE-INITAB+3; Bytes to copy
 162:	011A  210020  	        LD      HL,WRKSPC       ; Into workspace RAM
 163:	011D  1A      	COPY:   LD      A,(DE)          ; Get source
 164:	011E  77      	        LD      (HL),A          ; To destination
 165:	011F  23      	        INC     HL              ; Next destination
 166:	0120  13      	        INC     DE              ; Next source
 167:	0121  05      	        DEC     B               ; Count bytes
 168:	0122  C21D01  	        JP      NZ,COPY         ; More to move
 169:	0125  F9      	        LD      SP,HL           ; Temporary stack
 170:	0126  CDE305  	        CALL    CLREG           ; Clear registers and stack
 171:	0129  CD7D0B  	        CALL    PRNTCRLF        ; Output CRLF
 172:	012C  32AA20  	        LD      (BUFFER+72+1),A ; Mark end of buffer
 173:	012F  32F920  	        LD      (PROGST),A      ; Initialise program area
 174:			
 175:	0132  21F701  	MSIZE:  LD      HL,MEMMSG       ; Point to message
 176:	0135  CD1B12  	        CALL    PRS             ; Output "Memory size"
 177:	0138  CD0006  	        CALL    PROMPT          ; Get input with '?'
 178:	013B  CDD508  	        CALL    GETCHR          ; Get next character
 179:	013E  B7      	        OR      A               ; Set flags
 180:	013F  C25701  	        JP      NZ,TSTMEM       ; If number - Test if RAM there
 181:	0142  210021  	        LD      HL,(STLOOK-1)&0FF00H ; Point to start of free
 182:	0145  24      	MLOOP:  INC     H               ; Next 256 byte range
 183:	0146  7C      	        LD      A,H             ; Above address FFFF ?
 184:	0147  B7      	        OR      A
 185:	0148  CA6901  	        JP      Z,SETTOP        ; Yes - 64K RAM
 186:	014B  7E      	        LD      A,(HL)          ; Get contents
 187:	014C  47      	        LD      B,A             ; Save it
 188:	014D  2F      	        CPL                     ; Flip all bits
 189:	014E  77      	        LD      (HL),A          ; Put it back
 190:	014F  BE      	        CP      (HL)            ; RAM there if same
 191:	0150  70      	        LD      (HL),B          ; Restore old contents
 192:	0151  CA4501  	        JP      Z,MLOOP         ; If RAM - test next ram section
 193:	0154  C36901  	        JP      SETTOP          ; Top of RAM found
 194:			
 195:	0157  CDA109  	TSTMEM: CALL    ATOH            ; Get high memory into DE
 196:	015A  B7      	        OR      A               ; Set flags on last byte
 197:	015B  C2B104  	        JP      NZ,SNERR        ; ?SN Error if bad character
 198:	015E  EB      	        EX      DE,HL           ; Address into HL
 199:	015F  2B      	        DEC     HL              ; Back one byte
 200:	0160  3ED9    	        LD      A,11011001B     ; Test byte
 201:	0162  46      	        LD      B,(HL)          ; Get old contents
 202:	0163  77      	        LD      (HL),A          ; Load test byte
 203:	0164  BE      	        CP      (HL)            ; RAM there if same
 204:	0165  70      	        LD      (HL),B          ; Restore old contents
 205:	0166  C23201  	        JP      NZ,MSIZE        ; Ask again if no RAM
 206:			
 207:	0169  2B      	SETTOP: DEC     HL              ; Back one byte
 208:	016A  11FF21  	        LD      DE,STLOOK-1     ; See if enough RAM
 209:	016D  CD4507  	        CALL    CPDEHL          ; Compare DE with HL
 210:	0170  DA3201  	        JP      C,MSIZE         ; Ask again if not enough RAM
 211:	0173  11CEFF  	        LD      DE,0-50         ; 50 Bytes string space
 212:	0176  22AF20  	        LD      (LSTRAM),HL     ; Save last available RAM
 213:	0179  19      	        ADD     HL,DE           ; Allocate string space
 214:	017A  225A20  	        LD      (STRSPC),HL     ; Save string space
 215:	017D  CDBE05  	        CALL    CLRPTR          ; Clear program area
 216:	0180  2A5A20  	        LD      HL,(STRSPC)     ; Get end of memory
 217:	0183  11EFFF  	        LD      DE,0-17         ; Offset for free bytes
 218:	0186  19      	        ADD     HL,DE           ; Adjust HL
 219:	0187  11F920  	        LD      DE,PROGST       ; Start of program text
 220:	018A  7D      	        LD      A,L             ; Get LSB
 221:	018B  93      	        SUB     E               ; Adjust it
 222:	018C  6F      	        LD      L,A             ; Re-save
 223:	018D  7C      	        LD      A,H             ; Get MSB
 224:	018E  9A      	        SBC     A,D             ; Adjust it
 225:	018F  67      	        LD      H,A             ; Re-save
 226:	0190  E5      	        PUSH    HL              ; Save bytes free
 227:	0191  21B901  	        LD      HL,SIGNON       ; Sign-on message
 228:	0194  CD1B12  	        CALL    PRS             ; Output string
 229:	0197  E1      	        POP     HL              ; Get bytes free back
 230:	0198  CDBE18  	        CALL    PRNTHL          ; Output amount of free memory
 231:	019B  21AA01  	        LD      HL,BFREE        ; " Bytes free" message
 232:	019E  CD1B12  	        CALL    PRS             ; Output string
 233:			
 234:	01A1  316620  	WARMST: LD      SP,STACK        ; Temporary stack
 235:	01A4  CDE305  	BRKRET: CALL    CLREG           ; Clear registers and stack
 236:	01A7  C3FC04  	        JP      PRNTOK          ; Go to get command line
 237:			
 238:	01AA  20427974	BFREE:  .DB  " Bytes free",CR,LF,0,0
	      65732066
	      7265650D
	      0A0000
 239:			
 240:	01B9  4E415343	SIGNON: .DB  "NASCOM ROM BASIC Ver 4.7b",CR,LF
	      4F4D2052
	      4F4D2042
	      41534943
	      20566572
	      20342E37
	      620D0A
 241:	01D4  436F7079	        .DB  "Copyright (c) 1978 by Microsoft",CR,LF,0,0
	      72696768
	      74202863
	      29203139
	      37382062
	      79204D69
	      63726F73
	      6F66740D
	      0A0000
 242:			
 243:	01F7  4D656D6F	MEMMSG: .DB  "Memory top",0
	      72792074
	      6F7000
 244:			
 245:			; FUNCTION ADDRESS TABLE
 246:			
 247:	0202  3317    	FNCTAB: .DW     SGN
 248:	0204  F717    	        .DW     INT
 249:	0206  4917    	        .DW     ABS
 250:	0208  221D    	        .DW     USR
 251:	020A  DB10    	        .DW     FRE
 252:	020C  6014    	        .DW     INP
 253:	020E  0911    	        .DW     POS
 254:	0210  BD19    	        .DW     SQR
 255:	0212  9C1A    	        .DW     RND
 256:	0214  D815    	        .DW     LOG
 257:	0216  0B1A    	        .DW     EXP
 258:	0218  111B    	        .DW     COS
 259:	021A  171B    	        .DW     SIN
 260:	021C  781B    	        .DW     TAN
 261:	021E  8D1B    	        .DW     ATN
 262:	0220  B414    	        .DW     PEEK
 263:	0222  F81B    	        .DW     DEEK
 264:	0224  5120    	        .DW     POINT
 265:	0226  8D13    	        .DW     LEN
 266:	0228  A511    	        .DW     STR
 267:	022A  2714    	        .DW     VAL
 268:	022C  9C13    	        .DW     ASC
 269:	022E  AD13    	        .DW     CHR
 270:	0230  1A1C    	        .DW     HEX
 271:	0232  AD1C    	        .DW     BIN
 272:	0234  BD13    	        .DW     LEFT
 273:	0236  ED13    	        .DW     RIGHT
 274:	0238  F713    	        .DW     MID
 275:			
 276:			; RESERVED WORD LIST
 277:			
 278:	023A  C54E44  	WORDS:  .DB     'E' + 80H,"ND"
 279:	023D  C64F52  	        .DB     'F' + 80H,"OR"
 280:	0240  CE455854	        .DB     'N' + 80H,"EXT"
 281:	0244  C4415441	        .DB     'D' + 80H,"ATA"
 282:	0248  C94E5055	        .DB     'I' + 80H,"NPUT"
	      54
 283:	024D  C4494D  	        .DB     'D' + 80H,"IM"
 284:	0250  D2454144	        .DB     'R' + 80H,"EAD"
 285:	0254  CC4554  	        .DB     'L' + 80H,"ET"
 286:	0257  C74F544F	        .DB     'G' + 80H,"OTO"
 287:	025B  D2554E  	        .DB     'R' + 80H,"UN"
 288:	025E  C946    	        .DB     'I' + 80H,"F"
 289:	0260  D2455354	        .DB     'R' + 80H,"ESTORE"
	      4F5245
 290:	0267  C74F5355	        .DB     'G' + 80H,"OSUB"
	      42
 291:	026C  D2455455	        .DB     'R' + 80H,"ETURN"
	      524E
 292:	0272  D2454D  	        .DB     'R' + 80H,"EM"
 293:	0275  D3544F50	        .DB     'S' + 80H,"TOP"
 294:	0279  CF5554  	        .DB     'O' + 80H,"UT"
 295:	027C  CF4E    	        .DB     'O' + 80H,"N"
 296:	027E  CE554C4C	        .DB     'N' + 80H,"ULL"
 297:	0282  D7414954	        .DB     'W' + 80H,"AIT"
 298:	0286  C44546  	        .DB     'D' + 80H,"EF"
 299:	0289  D04F4B45	        .DB     'P' + 80H,"OKE"
 300:	028D  C44F4B45	        .DB     'D' + 80H,"OKE"
 301:	0291  D3435245	        .DB     'S' + 80H,"CREEN"
	      454E
 302:	0297  CC494E45	        .DB     'L' + 80H,"INES"
	      53
 303:	029C  C34C53  	        .DB     'C' + 80H,"LS"
 304:	029F  D7494454	        .DB     'W' + 80H,"IDTH"
	      48
 305:	02A4  CD4F4E49	        .DB     'M' + 80H,"ONITOR"
	      544F52
 306:	02AB  D34554  	        .DB     'S' + 80H,"ET"
 307:	02AE  D2455345	        .DB     'R' + 80H,"ESET"
	      54
 308:	02B3  D052494E	        .DB     'P' + 80H,"RINT"
	      54
 309:	02B8  C34F4E54	        .DB     'C' + 80H,"ONT"
 310:	02BC  CC495354	        .DB     'L' + 80H,"IST"
 311:	02C0  C34C4541	        .DB     'C' + 80H,"LEAR"
	      52
 312:	02C5  C34C4F41	        .DB     'C' + 80H,"LOAD"
	      44
 313:	02CA  C3534156	        .DB     'C' + 80H,"SAVE"
	      45
 314:	02CF  CE4557  	        .DB     'N' + 80H,"EW"
 315:			
 316:	02D2  D4414228	        .DB     'T' + 80H,"AB("
 317:	02D6  D44F    	        .DB     'T' + 80H,"O"
 318:	02D8  C64E    	        .DB     'F' + 80H,"N"
 319:	02DA  D3504328	        .DB     'S' + 80H,"PC("
 320:	02DE  D448454E	        .DB     'T' + 80H,"HEN"
 321:	02E2  CE4F54  	        .DB     'N' + 80H,"OT"
 322:	02E5  D3544550	        .DB     'S' + 80H,"TEP"
 323:			
 324:	02E9  AB      	        .DB     '+' + 80H
 325:	02EA  AD      	        .DB     '-' + 80H
 326:	02EB  AA      	        .DB     '*' + 80H
 327:	02EC  AF      	        .DB     '/' + 80H
 328:	02ED  DE      	        .DB     '^' + 80H
 329:	02EE  C14E44  	        .DB     'A' + 80H,"ND"
 330:	02F1  CF52    	        .DB     'O' + 80H,"R"
 331:	02F3  BE      	        .DB     '>' + 80H
 332:	02F4  BD      	        .DB     '=' + 80H
 333:	02F5  BC      	        .DB     '<' + 80H
 334:			
 335:	02F6  D3474E  	        .DB     'S' + 80H,"GN"
 336:	02F9  C94E54  	        .DB     'I' + 80H,"NT"
 337:	02FC  C14253  	        .DB     'A' + 80H,"BS"
 338:	02FF  D55352  	        .DB     'U' + 80H,"SR"
 339:	0302  C65245  	        .DB     'F' + 80H,"RE"
 340:	0305  C94E50  	        .DB     'I' + 80H,"NP"
 341:	0308  D04F53  	        .DB     'P' + 80H,"OS"
 342:	030B  D35152  	        .DB     'S' + 80H,"QR"
 343:	030E  D24E44  	        .DB     'R' + 80H,"ND"
 344:	0311  CC4F47  	        .DB     'L' + 80H,"OG"
 345:	0314  C55850  	        .DB     'E' + 80H,"XP"
 346:	0317  C34F53  	        .DB     'C' + 80H,"OS"
 347:	031A  D3494E  	        .DB     'S' + 80H,"IN"
 348:	031D  D4414E  	        .DB     'T' + 80H,"AN"
 349:	0320  C1544E  	        .DB     'A' + 80H,"TN"
 350:	0323  D045454B	        .DB     'P' + 80H,"EEK"
 351:	0327  C445454B	        .DB     'D' + 80H,"EEK"
 352:	032B  D04F494E	        .DB     'P' + 80H,"OINT"
	      54
 353:	0330  CC454E  	        .DB     'L' + 80H,"EN"
 354:	0333  D3545224	        .DB     'S' + 80H,"TR$"
 355:	0337  D6414C  	        .DB     'V' + 80H,"AL"
 356:	033A  C15343  	        .DB     'A' + 80H,"SC"
 357:	033D  C3485224	        .DB     'C' + 80H,"HR$"
 358:	0341  C8455824	        .DB     'H' + 80H,"EX$"
 359:	0345  C2494E24	        .DB     'B' + 80H,"IN$"
 360:	0349  CC454654	        .DB     'L' + 80H,"EFT$"
	      24
 361:	034E  D2494748	        .DB     'R' + 80H,"IGHT$"
	      5424
 362:	0354  CD494424	        .DB     'M' + 80H,"ID$"
 363:	0358  80      	        .DB     80H             ; End of list marker
 364:			
 365:			; KEYWORD ADDRESS TABLE
 366:			
 367:	0359  1F09    	WORDTB: .DW     PEND
 368:	035B  1C08    	        .DW     FOR
 369:	035D  F70C    	        .DW     NEXT
 370:	035F  6C0A    	        .DW     DATA
 371:	0361  FE0B    	        .DW     INPUT
 372:	0363  330F    	        .DW     DIM
 373:	0365  2D0C    	        .DW     READ
 374:	0367  830A    	        .DW     LET
 375:	0369  290A    	        .DW     GOTO
 376:	036B  0C0A    	        .DW     RUN
 377:	036D  FB0A    	        .DW     IF
 378:	036F  E508    	        .DW     RESTOR
 379:	0371  180A    	        .DW     GOSUB
 380:	0373  470A    	        .DW     RETURN
 381:	0375  6E0A    	        .DW     REM
 382:	0377  1D09    	        .DW     STOP
 383:	0379  6C14    	        .DW     POUT
 384:	037B  DD0A    	        .DW     ON
 385:	037D  5E09    	        .DW     NULL
 386:	037F  7214    	        .DW     WAIT
 387:	0381  1111    	        .DW     DEF
 388:	0383  BB14    	        .DW     POKE
 389:	0385  031C    	        .DW     DOKE
 390:	0387  6E0A    	        .DW     REM             ;SCREEN
 391:	0389  E91B    	        .DW     LINES
 392:	038B  DC1B    	        .DW     CLS
 393:	038D  E11B    	        .DW     WIDTH
 394:	038F  121D    	        .DW     MONITR
 395:	0391  5420    	        .DW     PSET
 396:	0393  5720    	        .DW     RESET
 397:	0395  1F0B    	        .DW     PRINT
 398:	0397  4B09    	        .DW     CONT
 399:	0399  9107    	        .DW     LIST
 400:	039B  C609    	        .DW     CLEAR
 401:	039D  6E0A    	        .DW     REM             ;CLOAD
 402:	039F  6E0A    	        .DW     REM             ;CSAVE
 403:	03A1  BD05    	        .DW     NEW
 404:			
 405:			; RESERVED WORD TOKEN VALUES
 406:			
 407:	0080          	ZEND    .EQU    080H            ; END
 408:	0081          	ZFOR    .EQU    081H            ; FOR
 409:	0083          	ZDATA   .EQU    083H            ; DATA
 410:	0088          	ZGOTO   .EQU    088H            ; GOTO
 411:	008C          	ZGOSUB  .EQU    08CH            ; GOSUB
 412:	008E          	ZREM    .EQU    08EH            ; REM
 413:	009E          	ZPRINT  .EQU    09EH            ; PRINT
 414:	00A4          	ZNEW    .EQU    0A4H            ; NEW
 415:			
 416:	00A5          	ZTAB    .EQU    0A5H            ; TAB
 417:	00A6          	ZTO     .EQU    0A6H            ; TO
 418:	00A7          	ZFN     .EQU    0A7H            ; FN
 419:	00A8          	ZSPC    .EQU    0A8H            ; SPC
 420:	00A9          	ZTHEN   .EQU    0A9H            ; THEN
 421:	00AA          	ZNOT    .EQU    0AAH            ; NOT
 422:	00AB          	ZSTEP   .EQU    0ABH            ; STEP
 423:			
 424:	00AC          	ZPLUS   .EQU    0ACH            ; +
 425:	00AD          	ZMINUS  .EQU    0ADH            ; -
 426:	00AE          	ZTIMES  .EQU    0AEH            ; *
 427:	00AF          	ZDIV    .EQU    0AFH            ; /
 428:	00B2          	ZOR     .EQU    0B2H            ; OR
 429:	00B3          	ZGTR    .EQU    0B3H            ; >
 430:	00B4          	ZEQUAL  .EQU    0B4H            ; M
 431:	00B5          	ZLTH    .EQU    0B5H            ; <
 432:	00B6          	ZSGN    .EQU    0B6H            ; SGN
 433:	00C7          	ZPOINT  .EQU    0C7H            ; POINT
 434:	00CF          	ZLEFT   .EQU    0CDH +2         ; LEFT$
 435:			
 436:			; ARITHMETIC PRECEDENCE TABLE
 437:			
 438:	03A3  79      	PRITAB: .DB     79H             ; Precedence value
 439:	03A4  A518    	        .DW     PADD            ; FPREG = <last> + FPREG
 440:			
 441:	03A6  79      	        .DB     79H             ; Precedence value
 442:	03A7  D914    	        .DW     PSUB            ; FPREG = <last> - FPREG
 443:			
 444:	03A9  7C      	        .DB     7CH             ; Precedence value
 445:	03AA  1716    	        .DW     MULT            ; PPREG = <last> * FPREG
 446:			
 447:	03AC  7C      	        .DB     7CH             ; Precedence value
 448:	03AD  7816    	        .DW     DIV             ; FPREG = <last> / FPREG
 449:			
 450:	03AF  7F      	        .DB     7FH             ; Precedence value
 451:	03B0  C619    	        .DW     POWER           ; FPREG = <last> ^ FPREG
 452:			
 453:	03B2  50      	        .DB     50H             ; Precedence value
 454:	03B3  8C0E    	        .DW     PAND            ; FPREG = <last> AND FPREG
 455:			
 456:	03B5  46      	        .DB     46H             ; Precedence value
 457:	03B6  8B0E    	        .DW     POR             ; FPREG = <last> OR FPREG
 458:			
 459:			; BASIC ERROR CODE LIST
 460:			
 461:	03B8  4E46    	ERRORS: .DB     "NF"            ; NEXT without FOR
 462:	03BA  534E    	        .DB     "SN"            ; Syntax error
 463:	03BC  5247    	        .DB     "RG"            ; RETURN without GOSUB
 464:	03BE  4F44    	        .DB     "OD"            ; Out of DATA
 465:	03C0  4643    	        .DB     "FC"            ; Illegal function call
 466:	03C2  4F56    	        .DB     "OV"            ; Overflow error
 467:	03C4  4F4D    	        .DB     "OM"            ; Out of memory
 468:	03C6  554C    	        .DB     "UL"            ; Undefined line
 469:	03C8  4253    	        .DB     "BS"            ; Bad subscript
 470:	03CA  4444    	        .DB     "DD"            ; Re-DIMensioned array
 471:	03CC  2F30    	        .DB     "/0"            ; Division by zero
 472:	03CE  4944    	        .DB     "ID"            ; Illegal direct
 473:	03D0  544D    	        .DB     "TM"            ; Type mis-match
 474:	03D2  4F53    	        .DB     "OS"            ; Out of string space
 475:	03D4  4C53    	        .DB     "LS"            ; String too long
 476:	03D6  5354    	        .DB     "ST"            ; String formula too complex
 477:	03D8  434E    	        .DB     "CN"            ; Can't CONTinue
 478:	03DA  5546    	        .DB     "UF"            ; Undefined FN function
 479:	03DC  4D4F    	        .DB     "MO"            ; Missing operand
 480:	03DE  4858    	        .DB     "HX"            ; HEX error
 481:	03E0  424E    	        .DB     "BN"            ; BIN error
 482:			
 483:			; INITIALISATION TABLE -------------------------------------------------------
 484:			
 485:	03E2  C3A101  	INITAB: JP      WARMST          ; Warm start jump
 486:	03E5  C3EA03  	        JP      ITBRET          ; "USR (X)" jump -> RET
 487:	03E8  D300    	        OUT     (0),A           ; "OUT p,n" skeleton
 488:	03EA  C9      	ITBRET: RET
 489:	03EB  D600    	        SUB     0               ; Division support routine
 490:	03ED  6F      	        LD      L,A
 491:	03EE  7C      	        LD      A,H
 492:	03EF  DE00    	        SBC     A,0
 493:	03F1  67      	        LD      H,A
 494:	03F2  78      	        LD      A,B
 495:	03F3  DE00    	        SBC     A,0
 496:	03F5  47      	        LD      B,A
 497:	03F6  3E00    	        LD      A,0
 498:	03F8  C9      	        RET
 499:	03F9  000000  	        .DB     0,0,0                   ; Random number seed table used by RND
 500:	03FC  354ACA99	        .DB     035H,04AH,0CAH,099H     ;-2.65145E+07
 501:	0400  391C7698	        .DB     039H,01CH,076H,098H     ; 1.61291E+07
 502:	0404  2295B398	        .DB     022H,095H,0B3H,098H     ;-1.17691E+07
 503:	0408  0ADD4798	        .DB     00AH,0DDH,047H,098H     ; 1.30983E+07
 504:	040C  53D19999	        .DB     053H,0D1H,099H,099H     ;-2-01612E+07
 505:	0410  0A1A9F98	        .DB     00AH,01AH,09FH,098H     ;-1.04269E+07
 506:	0414  65BCCD98	        .DB     065H,0BCH,0CDH,098H     ;-1.34831E+07
 507:	0418  D6773E98	        .DB     0D6H,077H,03EH,098H     ; 1.24825E+07
 508:	041C  52C74F80	        .DB     052H,0C7H,04FH,080H     ; Last random number
 509:	0420  DB00    	        IN      A,(0)           ; INP (x) skeleton
 510:	0422  C9      	        RET
 511:	0423  01      	        .DB     1               ; NULLS number (1)
 512:	0424  FF      	        .DB     255             ; Terminal width (255 = no auto CRLF)
 513:	0425  64      	        .DB     100             ; Width for commas -> 8 columns
 514:	0426  00      	        .DB     0               ; No nulls after input bytes
 515:	0427  00      	        .DB     0               ; Output enabled (^O off)
 516:	0428  1400    	        .DW     20              ; Initial lines counter
 517:	042A  1400    	        .DW     20              ; Initial lines number
 518:	042C  0000    	        .DW     0               ; Array load/save check sum
 519:	042E  00      	        .DB     0               ; Break not by NMI
 520:	042F  00      	        .DB     0               ; Break flag
 521:	0430  C3E206  	        JP      TTYLIN          ; Input reflection (set to TTY)
 522:	0433  C30000  	        JP      0000H           ; POINT(X) reflection unused
 523:	0436  C30000  	        JP      0000H           ; SET reflection
 524:	0439  C30000  	        JP      0000H          	; RESET reflection
 525:	043C  0022    	        .DW     STLOOK          ; Temp string space
 526:	043E  FEFF    	        .DW     -2              ; Current line number (cold)
 527:	0440  FA20    	        .DW     PROGST+1        ; Start of program text
 528:	0442          	INITBE:
 529:			
 530:			; END OF INITIALISATION TABLE ---------------------------------------------------
 531:			
 532:	0442  20457272	ERRMSG: .DB     " Error",0
	      6F7200
 533:	0449  20696E20	INMSG:  .DB     " in ",0
	      00
 534:	044D          	ZERBYT  .EQU    $-1             ; A zero byte
 535:	044E  4F6B0D0A	OKMSG:  .DB     "Ok",CR,LF,0,0
	      0000
 536:	0454  42726561	BRKMSG: .DB     "Break",0
	      6B00
 537:			
 538:	045A  210400  	BAKSTK: LD      HL,4            ; Look for "FOR" block with
 539:	045D  39      	        ADD     HL,SP           ; same index as specified
 540:	045E  7E      	LOKFOR: LD      A,(HL)          ; Get block ID
 541:	045F  23      	        INC     HL              ; Point to index address
 542:	0460  FE81    	        CP      ZFOR            ; Is it a "FOR" token
 543:	0462  C0      	        RET     NZ              ; No - exit
 544:	0463  4E      	        LD      C,(HL)          ; BC = Address of "FOR" index
 545:	0464  23      	        INC     HL
 546:	0465  46      	        LD      B,(HL)
 547:	0466  23      	        INC     HL              ; Point to sign of STEP
 548:	0467  E5      	        PUSH    HL              ; Save pointer to sign
 549:	0468  69      	        LD      L,C             ; HL = address of "FOR" index
 550:	0469  60      	        LD      H,B
 551:	046A  7A      	        LD      A,D             ; See if an index was specified
 552:	046B  B3      	        OR      E               ; DE = 0 if no index specified
 553:	046C  EB      	        EX      DE,HL           ; Specified index into HL
 554:	046D  CA7404  	        JP      Z,INDFND        ; Skip if no index given
 555:	0470  EB      	        EX      DE,HL           ; Index back into DE
 556:	0471  CD4507  	        CALL    CPDEHL          ; Compare index with one given
 557:	0474  010D00  	INDFND: LD      BC,16-3         ; Offset to next block
 558:	0477  E1      	        POP     HL              ; Restore pointer to sign
 559:	0478  C8      	        RET     Z               ; Return if block found
 560:	0479  09      	        ADD     HL,BC           ; Point to next block
 561:	047A  C35E04  	        JP      LOKFOR          ; Keep on looking
 562:			
 563:	047D  CD9704  	MOVUP:  CALL    ENFMEM          ; See if enough memory
 564:	0480  C5      	MOVSTR: PUSH    BC              ; Save end of source
 565:	0481  E3      	        EX      (SP),HL         ; Swap source and dest" end
 566:	0482  C1      	        POP     BC              ; Get end of destination
 567:	0483  CD4507  	MOVLP:  CALL    CPDEHL          ; See if list moved
 568:	0486  7E      	        LD      A,(HL)          ; Get byte
 569:	0487  02      	        LD      (BC),A          ; Move it
 570:	0488  C8      	        RET     Z               ; Exit if all done
 571:	0489  0B      	        DEC     BC              ; Next byte to move to
 572:	048A  2B      	        DEC     HL              ; Next byte to move
 573:	048B  C38304  	        JP      MOVLP           ; Loop until all bytes moved
 574:			
 575:	048E  E5      	CHKSTK: PUSH    HL              ; Save code string address
 576:	048F  2ADA20  	        LD      HL,(ARREND)     ; Lowest free memory
 577:	0492  0600    	        LD      B,0             ; BC = Number of levels to test
 578:	0494  09      	        ADD     HL,BC           ; 2 Bytes for each level
 579:	0495  09      	        ADD     HL,BC
 580:	0496  3E      	        .DB     3EH             ; Skip "PUSH HL"
 581:	0497  E5      	ENFMEM: PUSH    HL              ; Save code string address
 582:	0498  3ED0    	        LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
 583:	049A  95      	        SUB     L
 584:	049B  6F      	        LD      L,A
 585:	049C  3EFF    	        LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
 586:	049E  9C      	        SBC     A,H
 587:	049F  DAA604  	        JP      C,OMERR         ; Not enough - ?OM Error
 588:	04A2  67      	        LD      H,A
 589:	04A3  39      	        ADD     HL,SP           ; Test if stack is overflowed
 590:	04A4  E1      	        POP     HL              ; Restore code string address
 591:	04A5  D8      	        RET     C               ; Return if enough mmory
 592:	04A6  1E0C    	OMERR:  LD      E,OM            ; ?OM Error
 593:	04A8  C3C504  	        JP      ERROR
 594:			
 595:	04AB  2AC920  	DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
 596:	04AE  225C20  	        LD      (LINEAT),HL     ; Save as current line
 597:	04B1  1E02    	SNERR:  LD      E,SN            ; ?SN Error
 598:	04B3  01      	        .DB     01H             ; Skip "LD E,DZ"
 599:	04B4  1E14    	DZERR:  LD      E,DZ            ; ?/0 Error
 600:	04B6  01      	        .DB     01H             ; Skip "LD E,NF"
 601:	04B7  1E00    	NFERR:  LD      E,NF            ; ?NF Error
 602:	04B9  01      	        .DB     01H             ; Skip "LD E,DD"
 603:	04BA  1E12    	DDERR:  LD      E,DD            ; ?DD Error
 604:	04BC  01      	        .DB     01H             ; Skip "LD E,UF"
 605:	04BD  1E22    	UFERR:  LD      E,UF            ; ?UF Error
 606:	04BF  01      	        .DB     01H             ; Skip "LD E,OV
 607:	04C0  1E0A    	OVERR:  LD      E,OV            ; ?OV Error
 608:	04C2  01      	        .DB     01H             ; Skip "LD E,TM"
 609:	04C3  1E18    	TMERR:  LD      E,TM            ; ?TM Error
 610:			
 611:	04C5  CDE305  	ERROR:  CALL    CLREG           ; Clear registers and stack
 612:	04C8  324520  	        LD      (CTLOFG),A      ; Enable output (A is 0)
 613:	04CB  CD700B  	        CALL    STTLIN          ; Start new line
 614:	04CE  21B803  	        LD      HL,ERRORS       ; Point to error codes
 615:	04D1  57      	        LD      D,A             ; D = 0 (A is 0)
 616:	04D2  3E3F    	        LD      A,'?'
 617:	04D4  CD5607  	        CALL    OUTC            ; Output '?'
 618:	04D7  19      	        ADD     HL,DE           ; Offset to correct error code
 619:	04D8  7E      	        LD      A,(HL)          ; First character
 620:	04D9  CD5607  	        CALL    OUTC            ; Output it
 621:	04DC  CDD508  	        CALL    GETCHR          ; Get next character
 622:	04DF  CD5607  	        CALL    OUTC            ; Output it
 623:	04E2  214204  	        LD      HL,ERRMSG       ; "Error" message
 624:	04E5  CD1B12  	ERRIN:  CALL    PRS             ; Output message
 625:	04E8  2A5C20  	        LD      HL,(LINEAT)     ; Get line of error
 626:	04EB  11FEFF  	        LD      DE,-2           ; Cold start error if -2
 627:	04EE  CD4507  	        CALL    CPDEHL          ; See if cold start error
 628:	04F1  CA0C01  	        JP      Z,CSTART        ; Cold start error - Restart
 629:	04F4  7C      	        LD      A,H             ; Was it a direct error?
 630:	04F5  A5      	        AND     L               ; Line = -1 if direct error
 631:	04F6  3C      	        INC     A
 632:	04F7  C4B618  	        CALL    NZ,LINEIN       ; No - output line of error
 633:	04FA  3E      	        .DB     3EH             ; Skip "POP BC"
 634:	04FB  C1      	POPNOK: POP     BC              ; Drop address in input buffer
 635:			
 636:	04FC  AF      	PRNTOK: XOR     A               ; Output "Ok" and get command
 637:	04FD  324520  	        LD      (CTLOFG),A      ; Enable output
 638:	0500  CD700B  	        CALL    STTLIN          ; Start new line
 639:	0503  214E04  	        LD      HL,OKMSG        ; "Ok" message
 640:	0506  CD1B12  	        CALL    PRS             ; Output "Ok"
 641:	0509  21FFFF  	GETCMD: LD      HL,-1           ; Flag direct mode
 642:	050C  225C20  	        LD      (LINEAT),HL     ; Save as current line
 643:	050F  CDE206  	        CALL    GETLIN          ; Get an input line
 644:	0512  DA0905  	        JP      C,GETCMD        ; Get line again if break
 645:	0515  CDD508  	        CALL    GETCHR          ; Get first character
 646:	0518  3C      	        INC     A               ; Test if end of line
 647:	0519  3D      	        DEC     A               ; Without affecting Carry
 648:	051A  CA0905  	        JP      Z,GETCMD        ; Nothing entered - Get another
 649:	051D  F5      	        PUSH    AF              ; Save Carry status
 650:	051E  CDA109  	        CALL    ATOH            ; Get line number into DE
 651:	0521  D5      	        PUSH    DE              ; Save line number
 652:	0522  CD0D06  	        CALL    CRUNCH          ; Tokenise rest of line
 653:	0525  47      	        LD      B,A             ; Length of tokenised line
 654:	0526  D1      	        POP     DE              ; Restore line number
 655:	0527  F1      	        POP     AF              ; Restore Carry
 656:	0528  D2B508  	        JP      NC,EXCUTE       ; No line number - Direct mode
 657:	052B  D5      	        PUSH    DE              ; Save line number
 658:	052C  C5      	        PUSH    BC              ; Save length of tokenised line
 659:	052D  AF      	        XOR     A
 660:	052E  32CC20  	        LD      (LSTBIN),A      ; Clear last byte input
 661:	0531  CDD508  	        CALL    GETCHR          ; Get next character
 662:	0534  B7      	        OR      A               ; Set flags
 663:	0535  F5      	        PUSH    AF              ; And save them
 664:	0536  CD9D05  	        CALL    SRCHLN          ; Search for line number in DE
 665:	0539  DA4205  	        JP      C,LINFND        ; Jump if line found
 666:	053C  F1      	        POP     AF              ; Get status
 667:	053D  F5      	        PUSH    AF              ; And re-save
 668:	053E  CA420A  	        JP      Z,ULERR         ; Nothing after number - Error
 669:	0541  B7      	        OR      A               ; Clear Carry
 670:	0542  C5      	LINFND: PUSH    BC              ; Save address of line in prog
 671:	0543  D25905  	        JP      NC,INEWLN       ; Line not found - Insert new
 672:	0546  EB      	        EX      DE,HL           ; Next line address in DE
 673:	0547  2AD620  	        LD      HL,(PROGND)     ; End of program
 674:	054A  1A      	SFTPRG: LD      A,(DE)          ; Shift rest of program down
 675:	054B  02      	        LD      (BC),A
 676:	054C  03      	        INC     BC              ; Next destination
 677:	054D  13      	        INC     DE              ; Next source
 678:	054E  CD4507  	        CALL    CPDEHL          ; All done?
 679:	0551  C24A05  	        JP      NZ,SFTPRG       ; More to do
 680:	0554  60      	        LD      H,B             ; HL - New end of program
 681:	0555  69      	        LD      L,C
 682:	0556  22D620  	        LD      (PROGND),HL     ; Update end of program
 683:			
 684:	0559  D1      	INEWLN: POP     DE              ; Get address of line,
 685:	055A  F1      	        POP     AF              ; Get status
 686:	055B  CA8005  	        JP      Z,SETPTR        ; No text - Set up pointers
 687:	055E  2AD620  	        LD      HL,(PROGND)     ; Get end of program
 688:	0561  E3      	        EX      (SP),HL         ; Get length of input line
 689:	0562  C1      	        POP     BC              ; End of program to BC
 690:	0563  09      	        ADD     HL,BC           ; Find new end
 691:	0564  E5      	        PUSH    HL              ; Save new end
 692:	0565  CD7D04  	        CALL    MOVUP           ; Make space for line
 693:	0568  E1      	        POP     HL              ; Restore new end
 694:	0569  22D620  	        LD      (PROGND),HL     ; Update end of program pointer
 695:	056C  EB      	        EX      DE,HL           ; Get line to move up in HL
 696:	056D  74      	        LD      (HL),H          ; Save MSB
 697:	056E  D1      	        POP     DE              ; Get new line number
 698:	056F  23      	        INC     HL              ; Skip pointer
 699:	0570  23      	        INC     HL
 700:	0571  73      	        LD      (HL),E          ; Save LSB of line number
 701:	0572  23      	        INC     HL
 702:	0573  72      	        LD      (HL),D          ; Save MSB of line number
 703:	0574  23      	        INC     HL              ; To first byte in line
 704:	0575  116120  	        LD      DE,BUFFER       ; Copy buffer to program
 705:	0578  1A      	MOVBUF: LD      A,(DE)          ; Get source
 706:	0579  77      	        LD      (HL),A          ; Save destinations
 707:	057A  23      	        INC     HL              ; Next source
 708:	057B  13      	        INC     DE              ; Next destination
 709:	057C  B7      	        OR      A               ; Done?
 710:	057D  C27805  	        JP      NZ,MOVBUF       ; No - Repeat
 711:	0580  CDC905  	SETPTR: CALL    RUNFST          ; Set line pointers
 712:	0583  23      	        INC     HL              ; To LSB of pointer
 713:	0584  EB      	        EX      DE,HL           ; Address to DE
 714:	0585  62      	PTRLP:  LD      H,D             ; Address to HL
 715:	0586  6B      	        LD      L,E
 716:	0587  7E      	        LD      A,(HL)          ; Get LSB of pointer
 717:	0588  23      	        INC     HL              ; To MSB of pointer
 718:	0589  B6      	        OR      (HL)            ; Compare with MSB pointer
 719:	058A  CA0905  	        JP      Z,GETCMD        ; Get command line if end
 720:	058D  23      	        INC     HL              ; To LSB of line number
 721:	058E  23      	        INC     HL              ; Skip line number
 722:	058F  23      	        INC     HL              ; Point to first byte in line
 723:	0590  AF      	        XOR     A               ; Looking for 00 byte
 724:	0591  BE      	FNDEND: CP      (HL)            ; Found end of line?
 725:	0592  23      	        INC     HL              ; Move to next byte
 726:	0593  C29105  	        JP      NZ,FNDEND       ; No - Keep looking
 727:	0596  EB      	        EX      DE,HL           ; Next line address to HL
 728:	0597  73      	        LD      (HL),E          ; Save LSB of pointer
 729:	0598  23      	        INC     HL
 730:	0599  72      	        LD      (HL),D          ; Save MSB of pointer
 731:	059A  C38505  	        JP      PTRLP           ; Do next line
 732:			
 733:	059D  2A5E20  	SRCHLN: LD      HL,(BASTXT)     ; Start of program text
 734:	05A0  44      	SRCHLP: LD      B,H             ; BC = Address to look at
 735:	05A1  4D      	        LD      C,L
 736:	05A2  7E      	        LD      A,(HL)          ; Get address of next line
 737:	05A3  23      	        INC     HL
 738:	05A4  B6      	        OR      (HL)            ; End of program found?
 739:	05A5  2B      	        DEC     HL
 740:	05A6  C8      	        RET     Z               ; Yes - Line not found
 741:	05A7  23      	        INC     HL
 742:	05A8  23      	        INC     HL
 743:	05A9  7E      	        LD      A,(HL)          ; Get LSB of line number
 744:	05AA  23      	        INC     HL
 745:	05AB  66      	        LD      H,(HL)          ; Get MSB of line number
 746:	05AC  6F      	        LD      L,A
 747:	05AD  CD4507  	        CALL    CPDEHL          ; Compare with line in DE
 748:	05B0  60      	        LD      H,B             ; HL = Start of this line
 749:	05B1  69      	        LD      L,C
 750:	05B2  7E      	        LD      A,(HL)          ; Get LSB of next line address
 751:	05B3  23      	        INC     HL
 752:	05B4  66      	        LD      H,(HL)          ; Get MSB of next line address
 753:	05B5  6F      	        LD      L,A             ; Next line to HL
 754:	05B6  3F      	        CCF
 755:	05B7  C8      	        RET     Z               ; Lines found - Exit
 756:	05B8  3F      	        CCF
 757:	05B9  D0      	        RET     NC              ; Line not found,at line after
 758:	05BA  C3A005  	        JP      SRCHLP          ; Keep looking
 759:			
 760:	05BD  C0      	NEW:    RET     NZ              ; Return if any more on line
 761:	05BE  2A5E20  	CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
 762:	05C1  AF      	        XOR     A               ; Set program area to empty
 763:	05C2  77      	        LD      (HL),A          ; Save LSB = 00
 764:	05C3  23      	        INC     HL
 765:	05C4  77      	        LD      (HL),A          ; Save MSB = 00
 766:	05C5  23      	        INC     HL
 767:	05C6  22D620  	        LD      (PROGND),HL     ; Set program end
 768:			
 769:	05C9  2A5E20  	RUNFST: LD      HL,(BASTXT)     ; Clear all variables
 770:	05CC  2B      	        DEC     HL
 771:			
 772:	05CD  22CE20  	INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
 773:	05D0  2AAF20  	        LD      HL,(LSTRAM)     ; Get end of RAM
 774:	05D3  22C320  	        LD      (STRBOT),HL     ; Clear string space
 775:	05D6  AF      	        XOR     A
 776:	05D7  CDE508  	        CALL    RESTOR          ; Reset DATA pointers
 777:	05DA  2AD620  	        LD      HL,(PROGND)     ; Get end of program
 778:	05DD  22D820  	        LD      (VAREND),HL     ; Clear variables
 779:	05E0  22DA20  	        LD      (ARREND),HL     ; Clear arrays
 780:			
 781:	05E3  C1      	CLREG:  POP     BC              ; Save return address
 782:	05E4  2A5A20  	        LD      HL,(STRSPC)     ; Get end of working RAN
 783:	05E7  F9      	        LD      SP,HL           ; Set stack
 784:	05E8  21B320  	        LD      HL,TMSTPL       ; Temporary string pool
 785:	05EB  22B120  	        LD      (TMSTPT),HL     ; Reset temporary string ptr
 786:	05EE  AF      	        XOR     A               ; A = 00
 787:	05EF  6F      	        LD      L,A             ; HL = 0000
 788:	05F0  67      	        LD      H,A
 789:	05F1  22D420  	        LD      (CONTAD),HL     ; No CONTinue
 790:	05F4  32CB20  	        LD      (FORFLG),A      ; Clear FOR flag
 791:	05F7  22DE20  	        LD      (FNRGNM),HL     ; Clear FN argument
 792:	05FA  E5      	        PUSH    HL              ; HL = 0000
 793:	05FB  C5      	        PUSH    BC              ; Put back return
 794:	05FC  2ACE20  	DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
 795:	05FF  C9      	        RET                     ; Return to execution driver
 796:			
 797:	0600  3E3F    	PROMPT: LD      A,'?'           ; '?'
 798:	0602  CD5607  	        CALL    OUTC            ; Output character
 799:	0605  3E20    	        LD      A,' '           ; Space
 800:	0607  CD5607  	        CALL    OUTC            ; Output character
 801:	060A  C34E20  	        JP      RINPUT          ; Get input line
 802:			
 803:	060D  AF      	CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
 804:	060E  32AE20  	        LD      (DATFLG),A      ; Reset literal flag
 805:	0611  0E05    	        LD      C,2+3           ; 2 byte number and 3 nulls
 806:	0613  116120  	        LD      DE,BUFFER       ; Start of input buffer
 807:	0616  7E      	CRNCLP: LD      A,(HL)          ; Get byte
 808:	0617  FE20    	        CP      ' '             ; Is it a space?
 809:	0619  CA9506  	        JP      Z,MOVDIR        ; Yes - Copy direct
 810:	061C  47      	        LD      B,A             ; Save character
 811:	061D  FE22    	        CP      '"'             ; Is it a quote?
 812:	061F  CAB506  	        JP      Z,CPYLIT        ; Yes - Copy literal string
 813:	0622  B7      	        OR      A               ; Is it end of buffer?
 814:	0623  CABC06  	        JP      Z,ENDBUF        ; Yes - End buffer
 815:	0626  3AAE20  	        LD      A,(DATFLG)      ; Get data type
 816:	0629  B7      	        OR      A               ; Literal?
 817:	062A  7E      	        LD      A,(HL)          ; Get byte to copy
 818:	062B  C29506  	        JP      NZ,MOVDIR       ; Literal - Copy direct
 819:	062E  FE3F    	        CP      '?'             ; Is it '?' short for PRINT
 820:	0630  3E9E    	        LD      A,ZPRINT        ; "PRINT" token
 821:	0632  CA9506  	        JP      Z,MOVDIR        ; Yes - replace it
 822:	0635  7E      	        LD      A,(HL)          ; Get byte again
 823:	0636  FE30    	        CP      '0'             ; Is it less than '0'
 824:	0638  DA4006  	        JP      C,FNDWRD        ; Yes - Look for reserved words
 825:	063B  FE3C    	        CP      60; ";"+1           ; Is it "0123456789:;" ?
 826:	063D  DA9506  	        JP      C,MOVDIR        ; Yes - copy it direct
 827:	0640  D5      	FNDWRD: PUSH    DE              ; Look for reserved words
 828:	0641  113902  	        LD      DE,WORDS-1      ; Point to table
 829:	0644  C5      	        PUSH    BC              ; Save count
 830:	0645  019106  	        LD      BC,RETNAD       ; Where to return to
 831:	0648  C5      	        PUSH    BC              ; Save return address
 832:	0649  067F    	        LD      B,ZEND-1        ; First token value -1
 833:	064B  7E      	        LD      A,(HL)          ; Get byte
 834:	064C  FE61    	        CP      'a'             ; Less than 'a' ?
 835:	064E  DA5906  	        JP      C,SEARCH        ; Yes - search for words
 836:	0651  FE7B    	        CP      'z'+1           ; Greater than 'z' ?
 837:	0653  D25906  	        JP      NC,SEARCH       ; Yes - search for words
 838:	0656  E65F    	        AND     01011111B       ; Force upper case
 839:	0658  77      	        LD      (HL),A          ; Replace byte
 840:	0659  4E      	SEARCH: LD      C,(HL)          ; Search for a word
 841:	065A  EB      	        EX      DE,HL
 842:	065B  23      	GETNXT: INC     HL              ; Get next reserved word
 843:	065C  B6      	        OR      (HL)            ; Start of word?
 844:	065D  F25B06  	        JP      P,GETNXT        ; No - move on
 845:	0660  04      	        INC     B               ; Increment token value
 846:	0661  7E      	        LD      A, (HL)         ; Get byte from table
 847:	0662  E67F    	        AND     01111111B       ; Strip bit 7
 848:	0664  C8      	        RET     Z               ; Return if end of list
 849:	0665  B9      	        CP      C               ; Same character as in buffer?
 850:	0666  C25B06  	        JP      NZ,GETNXT       ; No - get next word
 851:	0669  EB      	        EX      DE,HL
 852:	066A  E5      	        PUSH    HL              ; Save start of word
 853:			
 854:	066B  13      	NXTBYT: INC     DE              ; Look through rest of word
 855:	066C  1A      	        LD      A,(DE)          ; Get byte from table
 856:	066D  B7      	        OR      A               ; End of word ?
 857:	066E  FA8D06  	        JP      M,MATCH         ; Yes - Match found
 858:	0671  4F      	        LD      C,A             ; Save it
 859:	0672  78      	        LD      A,B             ; Get token value
 860:	0673  FE88    	        CP      ZGOTO           ; Is it "GOTO" token ?
 861:	0675  C27C06  	        JP      NZ,NOSPC        ; No - Don't allow spaces
 862:	0678  CDD508  	        CALL    GETCHR          ; Get next character
 863:	067B  2B      	        DEC     HL              ; Cancel increment from GETCHR
 864:	067C  23      	NOSPC:  INC     HL              ; Next byte
 865:	067D  7E      	        LD      A,(HL)          ; Get byte
 866:	067E  FE61    	        CP      'a'             ; Less than 'a' ?
 867:	0680  DA8506  	        JP      C,NOCHNG        ; Yes - don't change
 868:	0683  E65F    	        AND     01011111B       ; Make upper case
 869:	0685  B9      	NOCHNG: CP      C               ; Same as in buffer ?
 870:	0686  CA6B06  	        JP      Z,NXTBYT        ; Yes - keep testing
 871:	0689  E1      	        POP     HL              ; Get back start of word
 872:	068A  C35906  	        JP      SEARCH          ; Look at next word
 873:			
 874:	068D  48      	MATCH:  LD      C,B             ; Word found - Save token value
 875:	068E  F1      	        POP     AF              ; Throw away return
 876:	068F  EB      	        EX      DE,HL
 877:	0690  C9      	        RET                     ; Return to "RETNAD"
 878:	0691  EB      	RETNAD: EX      DE,HL           ; Get address in string
 879:	0692  79      	        LD      A,C             ; Get token value
 880:	0693  C1      	        POP     BC              ; Restore buffer length
 881:	0694  D1      	        POP     DE              ; Get destination address
 882:	0695  23      	MOVDIR: INC     HL              ; Next source in buffer
 883:	0696  12      	        LD      (DE),A          ; Put byte in buffer
 884:	0697  13      	        INC     DE              ; Move up buffer
 885:	0698  0C      	        INC     C               ; Increment length of buffer
 886:	0699  D63A    	        SUB     ':'             ; End of statement?
 887:	069B  CAA306  	        JP      Z,SETLIT        ; Jump if multi-statement line
 888:	069E  FE49    	        CP      ZDATA-3AH       ; Is it DATA statement ?
 889:	06A0  C2A606  	        JP      NZ,TSTREM       ; No - see if REM
 890:	06A3  32AE20  	SETLIT: LD      (DATFLG),A      ; Set literal flag
 891:	06A6  D654    	TSTREM: SUB     ZREM-3AH        ; Is it REM?
 892:	06A8  C21606  	        JP      NZ,CRNCLP       ; No - Leave flag
 893:	06AB  47      	        LD      B,A             ; Copy rest of buffer
 894:	06AC  7E      	NXTCHR: LD      A,(HL)          ; Get byte
 895:	06AD  B7      	        OR      A               ; End of line ?
 896:	06AE  CABC06  	        JP      Z,ENDBUF        ; Yes - Terminate buffer
 897:	06B1  B8      	        CP      B               ; End of statement ?
 898:	06B2  CA9506  	        JP      Z,MOVDIR        ; Yes - Get next one
 899:	06B5  23      	CPYLIT: INC     HL              ; Move up source string
 900:	06B6  12      	        LD      (DE),A          ; Save in destination
 901:	06B7  0C      	        INC     C               ; Increment length
 902:	06B8  13      	        INC     DE              ; Move up destination
 903:	06B9  C3AC06  	        JP      NXTCHR          ; Repeat
 904:			
 905:	06BC  216020  	ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
 906:	06BF  12      	        LD      (DE),A          ; Mark end of buffer (A = 00)
 907:	06C0  13      	        INC     DE
 908:	06C1  12      	        LD      (DE),A          ; A = 00
 909:	06C2  13      	        INC     DE
 910:	06C3  12      	        LD      (DE),A          ; A = 00
 911:	06C4  C9      	        RET
 912:			
 913:	06C5  05      	DELCHR: DEC     B               ; Count bytes in buffer
 914:	06C6  2B      	        DEC     HL              ; Back space buffer
 915:	06C7  3E08    	        LD      A,BKSP
 916:	06C9  CD5607  	        CALL    OUTC            ; Back one char
 917:	06CC  3E20    	        LD      A,SPACE
 918:	06CE  CD5607  	        CALL    OUTC            ; Overwrite char
 919:	06D1  3E08    	        LD      A,BKSP
 920:	06D3  CD5607  	        CALL    OUTC            ; Back one char
 921:	06D6  C2E706  	        JP      NZ,MORINP       ; Not end - Get more
 922:	06D9  CD5607  	OTKLN:  CALL    OUTC            ; Output character in A
 923:	06DC  CD7D0B  	KILIN:  CALL    PRNTCRLF        ; Output CRLF
 924:	06DF  C3E206  	        JP      TTYLIN          ; Get line again
 925:			
 926:	06E2          	GETLIN:
 927:	06E2  216120  	TTYLIN: LD      HL,BUFFER       ; Get a line by character
 928:	06E5  0601    	        LD      B,1             ; Set buffer as empty
 929:	06E7  CD8007  	MORINP: CALL    CLOTST          ; Get character and test ^O
 930:	06EA  4F      	        LD      C,A             ; Save character in C
 931:	06EB  79      	PROCES: LD      A,C             ; Get character
 932:	06EC  FE03    	        CP      CTRLC           ; Is it control "C"?
 933:	06EE  CC7D0B  	        CALL    Z,PRNTCRLF      ; Yes - Output CRLF
 934:	06F1  37      	        SCF                     ; Flag break
 935:	06F2  C8      	        RET     Z               ; Return if control "C"
 936:	06F3  FE0D    	        CP      CR              ; Is it enter?
 937:	06F5  CA780B  	        JP      Z,ENDINP        ; Yes - Terminate input
 938:	06F8  FE15    	        CP      CTRLU           ; Is it control "U"?
 939:	06FA  CADC06  	        JP      Z,KILIN         ; Yes - Get another line
 940:	06FD  FE18    	        CP      CAN             ; Is it "kill line"?
 941:	06FF  CADC06  	        JP      Z,KILIN ;OTKLN         ; Yes - Kill line
 942:	0702  FE7F    	        CP      DEL             ; Is it delete?
 943:	0704  CAC506  	        JP      Z,DELCHR        ; Yes - Delete character
 944:	0707  FE08    	        CP      BKSP            ; Is it backspace?
 945:	0709  CAC506  	        JP      Z,DELCHR        ; Yes - Delete character
 946:	070C  FE12    	        CP      CTRLR           ; Is it control "R"?
 947:	070E  C22507  	        JP      NZ,PUTBUF       ; No - Put in buffer
 948:	0711  C5      	        PUSH    BC              ; Save buffer length
 949:	0712  D5      	        PUSH    DE              ; Save DE
 950:	0713  E5      	        PUSH    HL              ; Save buffer address
 951:	0714  3600    	        LD      (HL),0          ; Mark end of buffer
 952:	0716  CD1C1D  	        CALL    OUTNCR          ; Output and do CRLF
 953:	0719  216120  	        LD      HL,BUFFER       ; Point to buffer start
 954:	071C  CD1B12  	        CALL    PRS             ; Output buffer
 955:	071F  E1      	        POP     HL              ; Restore buffer address
 956:	0720  D1      	        POP     DE              ; Restore DE
 957:	0721  C1      	        POP     BC              ; Restore buffer length
 958:	0722  C3E706  	        JP      MORINP          ; Get another character
 959:			
 960:	0725  FE20    	PUTBUF: CP      ' '             ; Is it a control code?
 961:	0727  DAE706  	        JP      C,MORINP        ; Yes - Ignore
 962:	072A  78      	PUTCTL: LD      A,B             ; Get number of bytes in buffer
 963:	072B  FE49    	        CP      72+1            ; Test for line overflow
 964:	072D  DA3807  	        JP      C,PUTB1         ; No, carry on
 965:	0730  3E07    	        LD      A,CTRLG         ; Set a bell
 966:	0732  CD5607  	        CALL    OUTC            ; Ring bell if buffer full
 967:	0735  C3E706  	        JP      MORINP          ;
 968:	0738  79      	PUTB1:  LD      A,C             ; Get character
 969:	0739  71      	        LD      (HL),C          ; Save in buffer
 970:	073A  32CC20  	        LD      (LSTBIN),A      ; Save last input byte
 971:	073D  23      	        INC     HL              ; Move up buffer
 972:	073E  04      	        INC     B               ; Increment length
 973:	073F  CD5607  	OUTIT:  CALL    OUTC            ; Output the character entered
 974:	0742  C3E706  	        JP      MORINP          ; Get another character
 975:			
 976:	0745  7C      	CPDEHL: LD      A,H             ; Get H
 977:	0746  92      	        SUB     D               ; Compare with D
 978:	0747  C0      	        RET     NZ              ; Different - Exit
 979:	0748  7D      	        LD      A,L             ; Get L
 980:	0749  93      	        SUB     E               ; Compare with E
 981:	074A  C9      	        RET                     ; Return status
 982:			
 983:	074B  7E      	CHKSYN: LD      A,(HL)          ; Check syntax of character
 984:	074C  E3      	        EX      (SP),HL         ; Address of test byte
 985:	074D  BE      	        CP      (HL)            ; Same as in code string?
 986:	074E  23      	        INC     HL              ; Return address
 987:	074F  E3      	        EX      (SP),HL         ; Put it back
 988:	0750  CAD508  	        JP      Z,GETCHR        ; Yes - Get next character
 989:	0753  C3B104  	        JP      SNERR           ; Different - ?SN Error
 990:			
 991:	0756  F5      	OUTC:   PUSH    AF              ; Save character
 992:	0757  3A4520  	        LD      A,(CTLOFG)      ; Get control "O" flag
 993:	075A  B7      	        OR      A               ; Is it set?
 994:	075B  C25012  	        JP      NZ,POPAF        ; Yes - don't output
 995:	075E  F1      	        POP     AF              ; Restore character
 996:	075F  C5      	        PUSH    BC              ; Save buffer length
 997:	0760  F5      	        PUSH    AF              ; Save character
 998:	0761  FE20    	        CP      ' '             ; Is it a control code?
 999:	0763  DA7A07  	        JP      C,DINPOS        ; Yes - Don't INC POS(X)
1000:	0766  3A4220  	        LD      A,(LWIDTH)      ; Get line width
1001:	0769  47      	        LD      B,A             ; To B
1002:	076A  3AAB20  	        LD      A,(CURPOS)      ; Get cursor position
1003:	076D  04      	        INC     B               ; Width 255?
1004:	076E  CA7607  	        JP      Z,INCLEN        ; Yes - No width limit
1005:	0771  05      	        DEC     B               ; Restore width
1006:	0772  B8      	        CP      B               ; At end of line?
1007:	0773  CC7D0B  	        CALL    Z,PRNTCRLF      ; Yes - output CRLF
1008:	0776  3C      	INCLEN: INC     A               ; Move on one character
1009:	0777  32AB20  	        LD      (CURPOS),A      ; Save new position
1010:	077A  F1      	DINPOS: POP     AF              ; Restore character
1011:	077B  C1      	        POP     BC              ; Restore buffer length
1012:	077C  CD0F1D  	        CALL    MONOUT          ; Send it
1013:	077F  C9      	        RET
1014:			
1015:	0780  CDDA1B  	CLOTST: CALL    GETINP          ; Get input character
1016:	0783  E67F    	        AND     01111111B       ; Strip bit 7
1017:	0785  FE0F    	        CP      CTRLO           ; Is it control "O"?
1018:	0787  C0      	        RET     NZ              ; No don't flip flag
1019:	0788  3A4520  	        LD      A,(CTLOFG)      ; Get flag
1020:	078B  2F      	        CPL                     ; Flip it
1021:	078C  324520  	        LD      (CTLOFG),A      ; Put it back
1022:	078F  AF      	        XOR     A               ; Null character
1023:	0790  C9      	        RET
1024:			
1025:	0791  CDA109  	LIST:   CALL    ATOH            ; ASCII number to DE
1026:	0794  C0      	        RET     NZ              ; Return if anything extra
1027:	0795  C1      	        POP     BC              ; Rubbish - Not needed
1028:	0796  CD9D05  	        CALL    SRCHLN          ; Search for line number in DE
1029:	0799  C5      	        PUSH    BC              ; Save address of line
1030:	079A  CDE707  	        CALL    SETLIN          ; Set up lines counter
1031:	079D  E1      	LISTLP: POP     HL              ; Restore address of line
1032:	079E  4E      	        LD      C,(HL)          ; Get LSB of next line
1033:	079F  23      	        INC     HL
1034:	07A0  46      	        LD      B,(HL)          ; Get MSB of next line
1035:	07A1  23      	        INC     HL
1036:	07A2  78      	        LD      A,B             ; BC = 0 (End of program)?
1037:	07A3  B1      	        OR      C
1038:	07A4  CAFC04  	        JP      Z,PRNTOK        ; Yes - Go to command mode
1039:	07A7  CDF007  	        CALL    COUNT           ; Count lines
1040:	07AA  CD0009  	        CALL    TSTBRK          ; Test for break key
1041:	07AD  C5      	        PUSH    BC              ; Save address of next line
1042:	07AE  CD7D0B  	        CALL    PRNTCRLF        ; Output CRLF
1043:	07B1  5E      	        LD      E,(HL)          ; Get LSB of line number
1044:	07B2  23      	        INC     HL
1045:	07B3  56      	        LD      D,(HL)          ; Get MSB of line number
1046:	07B4  23      	        INC     HL
1047:	07B5  E5      	        PUSH    HL              ; Save address of line start
1048:	07B6  EB      	        EX      DE,HL           ; Line number to HL
1049:	07B7  CDBE18  	        CALL    PRNTHL          ; Output line number in decimal
1050:	07BA  3E20    	        LD      A,' '           ; Space after line number
1051:	07BC  E1      	        POP     HL              ; Restore start of line address
1052:	07BD  CD5607  	LSTLP2: CALL    OUTC            ; Output character in A
1053:	07C0  7E      	LSTLP3: LD      A,(HL)          ; Get next byte in line
1054:	07C1  B7      	        OR      A               ; End of line?
1055:	07C2  23      	        INC     HL              ; To next byte in line
1056:	07C3  CA9D07  	        JP      Z,LISTLP        ; Yes - get next line
1057:	07C6  F2BD07  	        JP      P,LSTLP2        ; No token - output it
1058:	07C9  D67F    	        SUB     ZEND-1          ; Find and output word
1059:	07CB  4F      	        LD      C,A             ; Token offset+1 to C
1060:	07CC  113A02  	        LD      DE,WORDS        ; Reserved word list
1061:	07CF  1A      	FNDTOK: LD      A,(DE)          ; Get character in list
1062:	07D0  13      	        INC     DE              ; Move on to next
1063:	07D1  B7      	        OR      A               ; Is it start of word?
1064:	07D2  F2CF07  	        JP      P,FNDTOK        ; No - Keep looking for word
1065:	07D5  0D      	        DEC     C               ; Count words
1066:	07D6  C2CF07  	        JP      NZ,FNDTOK       ; Not there - keep looking
1067:	07D9  E67F    	OUTWRD: AND     01111111B       ; Strip bit 7
1068:	07DB  CD5607  	        CALL    OUTC            ; Output first character
1069:	07DE  1A      	        LD      A,(DE)          ; Get next character
1070:	07DF  13      	        INC     DE              ; Move on to next
1071:	07E0  B7      	        OR      A               ; Is it end of word?
1072:	07E1  F2D907  	        JP      P,OUTWRD        ; No - output the rest
1073:	07E4  C3C007  	        JP      LSTLP3          ; Next byte in line
1074:			
1075:	07E7  E5      	SETLIN: PUSH    HL              ; Set up LINES counter
1076:	07E8  2A4820  	        LD      HL,(LINESN)     ; Get LINES number
1077:	07EB  224620  	        LD      (LINESC),HL     ; Save in LINES counter
1078:	07EE  E1      	        POP     HL
1079:	07EF  C9      	        RET
1080:			
1081:	07F0  E5      	COUNT:  PUSH    HL              ; Save code string address
1082:	07F1  D5      	        PUSH    DE
1083:	07F2  2A4620  	        LD      HL,(LINESC)     ; Get LINES counter
1084:	07F5  11FFFF  	        LD      DE,-1
1085:	07F8  ED5A    	        ADC     HL,DE           ; Decrement
1086:	07FA  224620  	        LD      (LINESC),HL     ; Put it back
1087:	07FD  D1      	        POP     DE
1088:	07FE  E1      	        POP     HL              ; Restore code string address
1089:	07FF  F0      	        RET     P               ; Return if more lines to go
1090:	0800  E5      	        PUSH    HL              ; Save code string address
1091:	0801  2A4820  	        LD      HL,(LINESN)     ; Get LINES number
1092:	0804  224620  	        LD      (LINESC),HL     ; Reset LINES counter
1093:	0807  CDDA1B  	        CALL    GETINP          ; Get input character
1094:	080A  FE03    	        CP      CTRLC           ; Is it control "C"?
1095:	080C  CA1308  	        JP      Z,RSLNBK        ; Yes - Reset LINES and break
1096:	080F  E1      	        POP     HL              ; Restore code string address
1097:	0810  C3F007  	        JP      COUNT           ; Keep on counting
1098:			
1099:	0813  2A4820  	RSLNBK: LD      HL,(LINESN)     ; Get LINES number
1100:	0816  224620  	        LD      (LINESC),HL     ; Reset LINES counter
1101:	0819  C3A401  	        JP      BRKRET          ; Go and output "Break"
1102:			
1103:	081C  3E64    	FOR:    LD      A,64H           ; Flag "FOR" assignment
1104:	081E  32CB20  	        LD      (FORFLG),A      ; Save "FOR" flag
1105:	0821  CD830A  	        CALL    LET             ; Set up initial index
1106:	0824  C1      	        POP     BC              ; Drop RETurn address
1107:	0825  E5      	        PUSH    HL              ; Save code string address
1108:	0826  CD6C0A  	        CALL    DATA            ; Get next statement address
1109:	0829  22C720  	        LD      (LOOPST),HL     ; Save it for start of loop
1110:	082C  210200  	        LD      HL,2            ; Offset for "FOR" block
1111:	082F  39      	        ADD     HL,SP           ; Point to it
1112:	0830  CD5E04  	FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
1113:	0833  D1      	        POP     DE              ; Get code string address
1114:	0834  C24C08  	        JP      NZ,FORFND       ; No nesting found
1115:	0837  09      	        ADD     HL,BC           ; Move into "FOR" block
1116:	0838  D5      	        PUSH    DE              ; Save code string address
1117:	0839  2B      	        DEC     HL
1118:	083A  56      	        LD      D,(HL)          ; Get MSB of loop statement
1119:	083B  2B      	        DEC     HL
1120:	083C  5E      	        LD      E,(HL)          ; Get LSB of loop statement
1121:	083D  23      	        INC     HL
1122:	083E  23      	        INC     HL
1123:	083F  E5      	        PUSH    HL              ; Save block address
1124:	0840  2AC720  	        LD      HL,(LOOPST)     ; Get address of loop statement
1125:	0843  CD4507  	        CALL    CPDEHL          ; Compare the FOR loops
1126:	0846  E1      	        POP     HL              ; Restore block address
1127:	0847  C23008  	        JP      NZ,FORSLP       ; Different FORs - Find another
1128:	084A  D1      	        POP     DE              ; Restore code string address
1129:	084B  F9      	        LD      SP,HL           ; Remove all nested loops
1130:			
1131:	084C  EB      	FORFND: EX      DE,HL           ; Code string address to HL
1132:	084D  0E08    	        LD      C,8
1133:	084F  CD8E04  	        CALL    CHKSTK          ; Check for 8 levels of stack
1134:	0852  E5      	        PUSH    HL              ; Save code string address
1135:	0853  2AC720  	        LD      HL,(LOOPST)     ; Get first statement of loop
1136:	0856  E3      	        EX      (SP),HL         ; Save and restore code string
1137:	0857  E5      	        PUSH    HL              ; Re-save code string address
1138:	0858  2A5C20  	        LD      HL,(LINEAT)     ; Get current line number
1139:	085B  E3      	        EX      (SP),HL         ; Save and restore code string
1140:	085C  CD450D  	        CALL    TSTNUM          ; Make sure it's a number
1141:	085F  CD4B07  	        CALL    CHKSYN          ; Make sure "TO" is next
1142:	0862  A6      	        .DB     ZTO             ; "TO" token
1143:	0863  CD420D  	        CALL    GETNUM          ; Get "TO" expression value
1144:	0866  E5      	        PUSH    HL              ; Save code string address
1145:	0867  CD7017  	        CALL    BCDEFP          ; Move "TO" value to BCDE
1146:	086A  E1      	        POP     HL              ; Restore code string address
1147:	086B  C5      	        PUSH    BC              ; Save "TO" value in block
1148:	086C  D5      	        PUSH    DE
1149:	086D  010081  	        LD      BC,8100H        ; BCDE - 1 (default STEP)
1150:	0870  51      	        LD      D,C             ; C=0
1151:	0871  5A      	        LD      E,D             ; D=0
1152:	0872  7E      	        LD      A,(HL)          ; Get next byte in code string
1153:	0873  FEAB    	        CP      ZSTEP           ; See if "STEP" is stated
1154:	0875  3E01    	        LD      A,1             ; Sign of step = 1
1155:	0877  C28808  	        JP      NZ,SAVSTP       ; No STEP given - Default to 1
1156:	087A  CDD508  	        CALL    GETCHR          ; Jump over "STEP" token
1157:	087D  CD420D  	        CALL    GETNUM          ; Get step value
1158:	0880  E5      	        PUSH    HL              ; Save code string address
1159:	0881  CD7017  	        CALL    BCDEFP          ; Move STEP to BCDE
1160:	0884  CD2417  	        CALL    TSTSGN          ; Test sign of FPREG
1161:	0887  E1      	        POP     HL              ; Restore code string address
1162:	0888  C5      	SAVSTP: PUSH    BC              ; Save the STEP value in block
1163:	0889  D5      	        PUSH    DE
1164:	088A  F5      	        PUSH    AF              ; Save sign of STEP
1165:	088B  33      	        INC     SP              ; Don't save flags
1166:	088C  E5      	        PUSH    HL              ; Save code string address
1167:	088D  2ACE20  	        LD      HL,(BRKLIN)     ; Get address of index variable
1168:	0890  E3      	        EX      (SP),HL         ; Save and restore code string
1169:	0891  0681    	PUTFID: LD      B,ZFOR          ; "FOR" block marker
1170:	0893  C5      	        PUSH    BC              ; Save it
1171:	0894  33      	        INC     SP              ; Don't save C
1172:			
1173:	0895  CD0009  	RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
1174:	0898  22CE20  	        LD      (BRKLIN),HL     ; Save code address for break
1175:	089B  7E      	        LD      A,(HL)          ; Get next byte in code string
1176:	089C  FE3A    	        CP      ':'             ; Multi statement line?
1177:	089E  CAB508  	        JP      Z,EXCUTE        ; Yes - Execute it
1178:	08A1  B7      	        OR      A               ; End of line?
1179:	08A2  C2B104  	        JP      NZ,SNERR        ; No - Syntax error
1180:	08A5  23      	        INC     HL              ; Point to address of next line
1181:	08A6  7E      	        LD      A,(HL)          ; Get LSB of line pointer
1182:	08A7  23      	        INC     HL
1183:	08A8  B6      	        OR      (HL)            ; Is it zero (End of prog)?
1184:	08A9  CA2709  	        JP      Z,ENDPRG        ; Yes - Terminate execution
1185:	08AC  23      	        INC     HL              ; Point to line number
1186:	08AD  5E      	        LD      E,(HL)          ; Get LSB of line number
1187:	08AE  23      	        INC     HL
1188:	08AF  56      	        LD      D,(HL)          ; Get MSB of line number
1189:	08B0  EB      	        EX      DE,HL           ; Line number to HL
1190:	08B1  225C20  	        LD      (LINEAT),HL     ; Save as current line number
1191:	08B4  EB      	        EX      DE,HL           ; Line number back to DE
1192:	08B5  CDD508  	EXCUTE: CALL    GETCHR          ; Get key word
1193:	08B8  119508  	        LD      DE,RUNCNT       ; Where to RETurn to
1194:	08BB  D5      	        PUSH    DE              ; Save for RETurn
1195:	08BC  C8      	IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
1196:	08BD  D680    	ONJMP:  SUB     ZEND            ; Is it a token?
1197:	08BF  DA830A  	        JP      C,LET           ; No - try to assign it
1198:	08C2  FE25    	        CP      ZNEW+1-ZEND     ; END to NEW ?
1199:	08C4  D2B104  	        JP      NC,SNERR        ; Not a key word - ?SN Error
1200:	08C7  07      	        RLCA                    ; Double it
1201:	08C8  4F      	        LD      C,A             ; BC = Offset into table
1202:	08C9  0600    	        LD      B,0
1203:	08CB  EB      	        EX      DE,HL           ; Save code string address
1204:	08CC  215903  	        LD      HL,WORDTB       ; Keyword address table
1205:	08CF  09      	        ADD     HL,BC           ; Point to routine address
1206:	08D0  4E      	        LD      C,(HL)          ; Get LSB of routine address
1207:	08D1  23      	        INC     HL
1208:	08D2  46      	        LD      B,(HL)          ; Get MSB of routine address
1209:	08D3  C5      	        PUSH    BC              ; Save routine address
1210:	08D4  EB      	        EX      DE,HL           ; Restore code string address
1211:			
1212:	08D5  23      	GETCHR: INC     HL              ; Point to next character
1213:	08D6  7E      	        LD      A,(HL)          ; Get next code string byte
1214:	08D7  FE3A    	        CP      ':'             ; Z if ':'
1215:	08D9  D0      	        RET     NC              ; NC if > "9"
1216:	08DA  FE20    	        CP      ' '
1217:	08DC  CAD508  	        JP      Z,GETCHR        ; Skip over spaces
1218:	08DF  FE30    	        CP      '0'
1219:	08E1  3F      	        CCF                     ; NC if < '0'
1220:	08E2  3C      	        INC     A               ; Test for zero - Leave carry
1221:	08E3  3D      	        DEC     A               ; Z if Null
1222:	08E4  C9      	        RET
1223:			
1224:	08E5  EB      	RESTOR: EX      DE,HL           ; Save code string address
1225:	08E6  2A5E20  	        LD      HL,(BASTXT)     ; Point to start of program
1226:	08E9  CAFA08  	        JP      Z,RESTNL        ; Just RESTORE - reset pointer
1227:	08EC  EB      	        EX      DE,HL           ; Restore code string address
1228:	08ED  CDA109  	        CALL    ATOH            ; Get line number to DE
1229:	08F0  E5      	        PUSH    HL              ; Save code string address
1230:	08F1  CD9D05  	        CALL    SRCHLN          ; Search for line number in DE
1231:	08F4  60      	        LD      H,B             ; HL = Address of line
1232:	08F5  69      	        LD      L,C
1233:	08F6  D1      	        POP     DE              ; Restore code string address
1234:	08F7  D2420A  	        JP      NC,ULERR        ; ?UL Error if not found
1235:	08FA  2B      	RESTNL: DEC     HL              ; Byte before DATA statement
1236:	08FB  22DC20  	UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
1237:	08FE  EB      	        EX      DE,HL           ; Restore code string address
1238:	08FF  C9      	        RET
1239:			
1240:			
1241:	0900  DF      	TSTBRK: RST     18H             ; Check input status
1242:	0901  C8      	        RET     Z               ; No key, go back
1243:	0902  D7      	        RST     10H             ; Get the key into A
1244:	0903  FE1B    	        CP      ESC             ; Escape key?
1245:	0905  2811    	        JR      Z,BRK           ; Yes, break
1246:	0907  FE03    	        CP      CTRLC           ; <Ctrl-C>
1247:	0909  280D    	        JR      Z,BRK           ; Yes, break
1248:	090B  FE13    	        CP      CTRLS           ; Stop scrolling?
1249:	090D  C0      	        RET     NZ              ; Other key, ignore
1250:			
1251:			
1252:	090E  D7      	STALL:  RST     10H             ; Wait for key
1253:	090F  FE11    	        CP      CTRLQ           ; Resume scrolling?
1254:	0911  C8      	        RET      Z              ; Release the chokehold
1255:	0912  FE03    	        CP      CTRLC           ; Second break?
1256:	0914  2807    	        JR      Z,STOP          ; Break during hold exits prog
1257:	0916  18F6    	        JR      STALL           ; Loop until <Ctrl-Q> or <brk>
1258:			
1259:	0918  3EFF    	BRK     LD      A,0FFH          ; Set BRKFLG
1260:	091A  324D20  	        LD      (BRKFLG),A      ; Store it
1261:			
1262:			
1263:	091D  C0      	STOP:   RET     NZ              ; Exit if anything else
1264:	091E  F6      	        .DB     0F6H            ; Flag "STOP"
1265:	091F  C0      	PEND:   RET     NZ              ; Exit if anything else
1266:	0920  22CE20  	        LD      (BRKLIN),HL     ; Save point of break
1267:	0923  21      	        .DB     21H             ; Skip "OR 11111111B"
1268:	0924  F6FF    	INPBRK: OR      11111111B       ; Flag "Break" wanted
1269:	0926  C1      	        POP     BC              ; Return not needed and more
1270:	0927  2A5C20  	ENDPRG: LD      HL,(LINEAT)     ; Get current line number
1271:	092A  F5      	        PUSH    AF              ; Save STOP / END status
1272:	092B  7D      	        LD      A,L             ; Is it direct break?
1273:	092C  A4      	        AND     H
1274:	092D  3C      	        INC     A               ; Line is -1 if direct break
1275:	092E  CA3A09  	        JP      Z,NOLIN         ; Yes - No line number
1276:	0931  22D220  	        LD      (ERRLIN),HL     ; Save line of break
1277:	0934  2ACE20  	        LD      HL,(BRKLIN)     ; Get point of break
1278:	0937  22D420  	        LD      (CONTAD),HL     ; Save point to CONTinue
1279:	093A  AF      	NOLIN:  XOR     A
1280:	093B  324520  	        LD      (CTLOFG),A      ; Enable output
1281:	093E  CD700B  	        CALL    STTLIN          ; Start a new line
1282:	0941  F1      	        POP     AF              ; Restore STOP / END status
1283:	0942  215404  	        LD      HL,BRKMSG       ; "Break" message
1284:	0945  C2E504  	        JP      NZ,ERRIN        ; "in line" wanted?
1285:	0948  C3FC04  	        JP      PRNTOK          ; Go to command mode
1286:			
1287:	094B  2AD420  	CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
1288:	094E  7C      	        LD      A,H             ; Is it zero?
1289:	094F  B5      	        OR      L
1290:	0950  1E20    	        LD      E,CN            ; ?CN Error
1291:	0952  CAC504  	        JP      Z,ERROR         ; Yes - output "?CN Error"
1292:	0955  EB      	        EX      DE,HL           ; Save code string address
1293:	0956  2AD220  	        LD      HL,(ERRLIN)     ; Get line of last break
1294:	0959  225C20  	        LD      (LINEAT),HL     ; Set up current line number
1295:	095C  EB      	        EX      DE,HL           ; Restore code string address
1296:	095D  C9      	        RET                     ; CONTinue where left off
1297:			
1298:	095E  CDA314  	NULL:   CALL    GETINT          ; Get integer 0-255
1299:	0961  C0      	        RET     NZ              ; Return if bad value
1300:	0962  324120  	        LD      (NULLS),A       ; Set nulls number
1301:	0965  C9      	        RET
1302:			
1303:			
1304:	0966  E5      	ACCSUM: PUSH    HL              ; Save address in array
1305:	0967  2A4A20  	        LD      HL,(CHKSUM)     ; Get check sum
1306:	096A  0600    	        LD      B,0             ; BC - Value of byte
1307:	096C  4F      	        LD      C,A
1308:	096D  09      	        ADD     HL,BC           ; Add byte to check sum
1309:	096E  224A20  	        LD      (CHKSUM),HL     ; Re-save check sum
1310:	0971  E1      	        POP     HL              ; Restore address in array
1311:	0972  C9      	        RET
1312:			
1313:	0973  7E      	CHKLTR: LD      A,(HL)          ; Get byte
1314:	0974  FE41    	        CP      'A'             ; < 'a' ?
1315:	0976  D8      	        RET     C               ; Carry set if not letter
1316:	0977  FE5B    	        CP      'Z'+1           ; > 'z' ?
1317:	0979  3F      	        CCF
1318:	097A  C9      	        RET                     ; Carry set if not letter
1319:			
1320:	097B  CDD508  	FPSINT: CALL    GETCHR          ; Get next character
1321:	097E  CD420D  	POSINT: CALL    GETNUM          ; Get integer 0 to 32767
1322:	0981  CD2417  	DEPINT: CALL    TSTSGN          ; Test sign of FPREG
1323:	0984  FA9C09  	        JP      M,FCERR         ; Negative - ?FC Error
1324:	0987  3AE720  	DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
1325:	098A  FE90    	        CP      80H+16          ; Exponent in range (16 bits)?
1326:	098C  DACC17  	        JP      C,FPINT         ; Yes - convert it
1327:	098F  018090  	        LD      BC,9080H        ; BCDE = -32768
1328:	0992  110000  	        LD      DE,0000
1329:	0995  E5      	        PUSH    HL              ; Save code string address
1330:	0996  CD9F17  	        CALL    CMPNUM          ; Compare FPREG with BCDE
1331:	0999  E1      	        POP     HL              ; Restore code string address
1332:	099A  51      	        LD      D,C             ; MSB to D
1333:	099B  C8      	        RET     Z               ; Return if in range
1334:	099C  1E08    	FCERR:  LD      E,FC            ; ?FC Error
1335:	099E  C3C504  	        JP      ERROR           ; Output error-
1336:			
1337:	09A1  2B      	ATOH:   DEC     HL              ; ASCII number to DE binary
1338:	09A2  110000  	GETLN:  LD      DE,0            ; Get number to DE
1339:	09A5  CDD508  	GTLNLP: CALL    GETCHR          ; Get next character
1340:	09A8  D0      	        RET     NC              ; Exit if not a digit
1341:	09A9  E5      	        PUSH    HL              ; Save code string address
1342:	09AA  F5      	        PUSH    AF              ; Save digit
1343:	09AB  219819  	        LD      HL,65529/10     ; Largest number 65529
1344:	09AE  CD4507  	        CALL    CPDEHL          ; Number in range?
1345:	09B1  DAB104  	        JP      C,SNERR         ; No - ?SN Error
1346:	09B4  62      	        LD      H,D             ; HL = Number
1347:	09B5  6B      	        LD      L,E
1348:	09B6  19      	        ADD     HL,DE           ; Times 2
1349:	09B7  29      	        ADD     HL,HL           ; Times 4
1350:	09B8  19      	        ADD     HL,DE           ; Times 5
1351:	09B9  29      	        ADD     HL,HL           ; Times 10
1352:	09BA  F1      	        POP     AF              ; Restore digit
1353:	09BB  D630    	        SUB     '0'             ; Make it 0 to 9
1354:	09BD  5F      	        LD      E,A             ; DE = Value of digit
1355:	09BE  1600    	        LD      D,0
1356:	09C0  19      	        ADD     HL,DE           ; Add to number
1357:	09C1  EB      	        EX      DE,HL           ; Number to DE
1358:	09C2  E1      	        POP     HL              ; Restore code string address
1359:	09C3  C3A509  	        JP      GTLNLP          ; Go to next character
1360:			
1361:	09C6  CACD05  	CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
1362:	09C9  CD7E09  	        CALL    POSINT          ; Get integer 0 to 32767 to DE
1363:	09CC  2B      	        DEC     HL              ; Cancel increment
1364:	09CD  CDD508  	        CALL    GETCHR          ; Get next character
1365:	09D0  E5      	        PUSH    HL              ; Save code string address
1366:	09D1  2AAF20  	        LD      HL,(LSTRAM)     ; Get end of RAM
1367:	09D4  CAE909  	        JP      Z,STORED        ; No value given - Use stored
1368:	09D7  E1      	        POP     HL              ; Restore code string address
1369:	09D8  CD4B07  	        CALL    CHKSYN          ; Check for comma
1370:	09DB  2C      	        .DB     ','
1371:	09DC  D5      	        PUSH    DE              ; Save number
1372:	09DD  CD7E09  	        CALL    POSINT          ; Get integer 0 to 32767
1373:	09E0  2B      	        DEC     HL              ; Cancel increment
1374:	09E1  CDD508  	        CALL    GETCHR          ; Get next character
1375:	09E4  C2B104  	        JP      NZ,SNERR        ; ?SN Error if more on line
1376:	09E7  E3      	        EX      (SP),HL         ; Save code string address
1377:	09E8  EB      	        EX      DE,HL           ; Number to DE
1378:	09E9  7D      	STORED: LD      A,L             ; Get LSB of new RAM top
1379:	09EA  93      	        SUB     E               ; Subtract LSB of string space
1380:	09EB  5F      	        LD      E,A             ; Save LSB
1381:	09EC  7C      	        LD      A,H             ; Get MSB of new RAM top
1382:	09ED  9A      	        SBC     A,D             ; Subtract MSB of string space
1383:	09EE  57      	        LD      D,A             ; Save MSB
1384:	09EF  DAA604  	        JP      C,OMERR         ; ?OM Error if not enough mem
1385:	09F2  E5      	        PUSH    HL              ; Save RAM top
1386:	09F3  2AD620  	        LD      HL,(PROGND)     ; Get program end
1387:	09F6  012800  	        LD      BC,40           ; 40 Bytes minimum working RAM
1388:	09F9  09      	        ADD     HL,BC           ; Get lowest address
1389:	09FA  CD4507  	        CALL    CPDEHL          ; Enough memory?
1390:	09FD  D2A604  	        JP      NC,OMERR        ; No - ?OM Error
1391:	0A00  EB      	        EX      DE,HL           ; RAM top to HL
1392:	0A01  225A20  	        LD      (STRSPC),HL     ; Set new string space
1393:	0A04  E1      	        POP     HL              ; End of memory to use
1394:	0A05  22AF20  	        LD      (LSTRAM),HL     ; Set new top of RAM
1395:	0A08  E1      	        POP     HL              ; Restore code string address
1396:	0A09  C3CD05  	        JP      INTVAR          ; Initialise variables
1397:			
1398:	0A0C  CAC905  	RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
1399:	0A0F  CDCD05  	        CALL    INTVAR          ; Initialise variables
1400:	0A12  019508  	        LD      BC,RUNCNT       ; Execution driver loop
1401:	0A15  C3280A  	        JP      RUNLIN          ; RUN from line number
1402:			
1403:	0A18  0E03    	GOSUB:  LD      C,3             ; 3 Levels of stack needed
1404:	0A1A  CD8E04  	        CALL    CHKSTK          ; Check for 3 levels of stack
1405:	0A1D  C1      	        POP     BC              ; Get return address
1406:	0A1E  E5      	        PUSH    HL              ; Save code string for RETURN
1407:	0A1F  E5      	        PUSH    HL              ; And for GOSUB routine
1408:	0A20  2A5C20  	        LD      HL,(LINEAT)     ; Get current line
1409:	0A23  E3      	        EX      (SP),HL         ; Into stack - Code string out
1410:	0A24  3E8C    	        LD      A,ZGOSUB        ; "GOSUB" token
1411:	0A26  F5      	        PUSH    AF              ; Save token
1412:	0A27  33      	        INC     SP              ; Don't save flags
1413:			
1414:	0A28  C5      	RUNLIN: PUSH    BC              ; Save return address
1415:	0A29  CDA109  	GOTO:   CALL    ATOH            ; ASCII number to DE binary
1416:	0A2C  CD6E0A  	        CALL    REM             ; Get end of line
1417:	0A2F  E5      	        PUSH    HL              ; Save end of line
1418:	0A30  2A5C20  	        LD      HL,(LINEAT)     ; Get current line
1419:	0A33  CD4507  	        CALL    CPDEHL          ; Line after current?
1420:	0A36  E1      	        POP     HL              ; Restore end of line
1421:	0A37  23      	        INC     HL              ; Start of next line
1422:	0A38  DCA005  	        CALL    C,SRCHLP        ; Line is after current line
1423:	0A3B  D49D05  	        CALL    NC,SRCHLN       ; Line is before current line
1424:	0A3E  60      	        LD      H,B             ; Set up code string address
1425:	0A3F  69      	        LD      L,C
1426:	0A40  2B      	        DEC     HL              ; Incremented after
1427:	0A41  D8      	        RET     C               ; Line found
1428:	0A42  1E0E    	ULERR:  LD      E,UL            ; ?UL Error
1429:	0A44  C3C504  	        JP      ERROR           ; Output error message
1430:			
1431:	0A47  C0      	RETURN: RET     NZ              ; Return if not just RETURN
1432:	0A48  16FF    	        LD      D,-1            ; Flag "GOSUB" search
1433:	0A4A  CD5A04  	        CALL    BAKSTK          ; Look "GOSUB" block
1434:	0A4D  F9      	        LD      SP,HL           ; Kill all FORs in subroutine
1435:	0A4E  FE8C    	        CP      ZGOSUB          ; Test for "GOSUB" token
1436:	0A50  1E04    	        LD      E,RG            ; ?RG Error
1437:	0A52  C2C504  	        JP      NZ,ERROR        ; Error if no "GOSUB" found
1438:	0A55  E1      	        POP     HL              ; Get RETURN line number
1439:	0A56  225C20  	        LD      (LINEAT),HL     ; Save as current
1440:	0A59  23      	        INC     HL              ; Was it from direct statement?
1441:	0A5A  7C      	        LD      A,H
1442:	0A5B  B5      	        OR      L               ; Return to line
1443:	0A5C  C2660A  	        JP      NZ,RETLIN       ; No - Return to line
1444:	0A5F  3ACC20  	        LD      A,(LSTBIN)      ; Any INPUT in subroutine?
1445:	0A62  B7      	        OR      A               ; If so buffer is corrupted
1446:	0A63  C2FB04  	        JP      NZ,POPNOK       ; Yes - Go to command mode
1447:	0A66  219508  	RETLIN: LD      HL,RUNCNT       ; Execution driver loop
1448:	0A69  E3      	        EX      (SP),HL         ; Into stack - Code string out
1449:	0A6A  3E      	        .DB     3EH             ; Skip "POP HL"
1450:	0A6B  E1      	NXTDTA: POP     HL              ; Restore code string address
1451:			
1452:	0A6C  013A    	DATA:   .DB     01H,3AH         ; ':' End of statement
1453:	0A6E  0E00    	REM:    LD      C,0             ; 00  End of statement
1454:	0A70  0600    	        LD      B,0
1455:	0A72  79      	NXTSTL: LD      A,C             ; Statement and byte
1456:	0A73  48      	        LD      C,B
1457:	0A74  47      	        LD      B,A             ; Statement end byte
1458:	0A75  7E      	NXTSTT: LD      A,(HL)          ; Get byte
1459:	0A76  B7      	        OR      A               ; End of line?
1460:	0A77  C8      	        RET     Z               ; Yes - Exit
1461:	0A78  B8      	        CP      B               ; End of statement?
1462:	0A79  C8      	        RET     Z               ; Yes - Exit
1463:	0A7A  23      	        INC     HL              ; Next byte
1464:	0A7B  FE22    	        CP      '"'             ; Literal string?
1465:	0A7D  CA720A  	        JP      Z,NXTSTL        ; Yes - Look for another '"'
1466:	0A80  C3750A  	        JP      NXTSTT          ; Keep looking
1467:			
1468:	0A83  CD380F  	LET:    CALL    GETVAR          ; Get variable name
1469:	0A86  CD4B07  	        CALL    CHKSYN          ; Make sure "=" follows
1470:	0A89  B4      	        .DB     ZEQUAL          ; "=" token
1471:	0A8A  D5      	        PUSH    DE              ; Save address of variable
1472:	0A8B  3AAD20  	        LD      A,(TYPE)        ; Get data type
1473:	0A8E  F5      	        PUSH    AF              ; Save type
1474:	0A8F  CD540D  	        CALL    EVAL            ; Evaluate expression
1475:	0A92  F1      	        POP     AF              ; Restore type
1476:	0A93  E3      	        EX      (SP),HL         ; Save code - Get var addr
1477:	0A94  22CE20  	        LD      (BRKLIN),HL     ; Save address of variable
1478:	0A97  1F      	        RRA                     ; Adjust type
1479:	0A98  CD470D  	        CALL    CHKTYP          ; Check types are the same
1480:	0A9B  CAD60A  	        JP      Z,LETNUM        ; Numeric - Move value
1481:	0A9E  E5      	LETSTR: PUSH    HL              ; Save address of string var
1482:	0A9F  2AE420  	        LD      HL,(FPREG)      ; Pointer to string entry
1483:	0AA2  E5      	        PUSH    HL              ; Save it on stack
1484:	0AA3  23      	        INC     HL              ; Skip over length
1485:	0AA4  23      	        INC     HL
1486:	0AA5  5E      	        LD      E,(HL)          ; LSB of string address
1487:	0AA6  23      	        INC     HL
1488:	0AA7  56      	        LD      D,(HL)          ; MSB of string address
1489:	0AA8  2A5E20  	        LD      HL,(BASTXT)     ; Point to start of program
1490:	0AAB  CD4507  	        CALL    CPDEHL          ; Is string before program?
1491:	0AAE  D2C50A  	        JP      NC,CRESTR       ; Yes - Create string entry
1492:	0AB1  2A5A20  	        LD      HL,(STRSPC)     ; Point to string space
1493:	0AB4  CD4507  	        CALL    CPDEHL          ; Is string literal in program?
1494:	0AB7  D1      	        POP     DE              ; Restore address of string
1495:	0AB8  D2CD0A  	        JP      NC,MVSTPT       ; Yes - Set up pointer
1496:	0ABB  21BF20  	        LD      HL,TMPSTR       ; Temporary string pool
1497:	0ABE  CD4507  	        CALL    CPDEHL          ; Is string in temporary pool?
1498:	0AC1  D2CD0A  	        JP      NC,MVSTPT       ; No - Set up pointer
1499:	0AC4  3E      	        .DB     3EH             ; Skip "POP DE"
1500:	0AC5  D1      	CRESTR: POP     DE              ; Restore address of string
1501:	0AC6  CD7C13  	        CALL    BAKTMP          ; Back to last tmp-str entry
1502:	0AC9  EB      	        EX      DE,HL           ; Address of string entry
1503:	0ACA  CDB511  	        CALL    SAVSTR          ; Save string in string area
1504:	0ACD  CD7C13  	MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
1505:	0AD0  E1      	        POP     HL              ; Get string pointer
1506:	0AD1  CD7F17  	        CALL    DETHL4          ; Move string pointer to var
1507:	0AD4  E1      	        POP     HL              ; Restore code string address
1508:	0AD5  C9      	        RET
1509:			
1510:	0AD6  E5      	LETNUM: PUSH    HL              ; Save address of variable
1511:	0AD7  CD7C17  	        CALL    FPTHL           ; Move value to variable
1512:	0ADA  D1      	        POP     DE              ; Restore address of variable
1513:	0ADB  E1      	        POP     HL              ; Restore code string address
1514:	0ADC  C9      	        RET
1515:			
1516:	0ADD  CDA314  	ON:     CALL    GETINT          ; Get integer 0-255
1517:	0AE0  7E      	        LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
1518:	0AE1  47      	        LD      B,A             ; Save in B
1519:	0AE2  FE8C    	        CP      ZGOSUB          ; "GOSUB" token?
1520:	0AE4  CAEC0A  	        JP      Z,ONGO          ; Yes - Find line number
1521:	0AE7  CD4B07  	        CALL    CHKSYN          ; Make sure it's "GOTO"
1522:	0AEA  88      	        .DB     ZGOTO           ; "GOTO" token
1523:	0AEB  2B      	        DEC     HL              ; Cancel increment
1524:	0AEC  4B      	ONGO:   LD      C,E             ; Integer of branch value
1525:	0AED  0D      	ONGOLP: DEC     C               ; Count branches
1526:	0AEE  78      	        LD      A,B             ; Get "GOTO" or "GOSUB" token
1527:	0AEF  CABD08  	        JP      Z,ONJMP         ; Go to that line if right one
1528:	0AF2  CDA209  	        CALL    GETLN           ; Get line number to DE
1529:	0AF5  FE2C    	        CP      ','             ; Another line number?
1530:	0AF7  C0      	        RET     NZ              ; No - Drop through
1531:	0AF8  C3ED0A  	        JP      ONGOLP          ; Yes - loop
1532:			
1533:	0AFB  CD540D  	IF:     CALL    EVAL            ; Evaluate expression
1534:	0AFE  7E      	        LD      A,(HL)          ; Get token
1535:	0AFF  FE88    	        CP      ZGOTO           ; "GOTO" token?
1536:	0B01  CA090B  	        JP      Z,IFGO          ; Yes - Get line
1537:	0B04  CD4B07  	        CALL    CHKSYN          ; Make sure it's "THEN"
1538:	0B07  A9      	        .DB     ZTHEN           ; "THEN" token
1539:	0B08  2B      	        DEC     HL              ; Cancel increment
1540:	0B09  CD450D  	IFGO:   CALL    TSTNUM          ; Make sure it's numeric
1541:	0B0C  CD2417  	        CALL    TSTSGN          ; Test state of expression
1542:	0B0F  CA6E0A  	        JP      Z,REM           ; False - Drop through
1543:	0B12  CDD508  	        CALL    GETCHR          ; Get next character
1544:	0B15  DA290A  	        JP      C,GOTO          ; Number - GOTO that line
1545:	0B18  C3BC08  	        JP      IFJMP           ; Otherwise do statement
1546:			
1547:	0B1B  2B      	MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
1548:	0B1C  CDD508  	        CALL    GETCHR          ; Get next character
1549:	0B1F  CA7D0B  	PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
1550:	0B22  C8      	PRNTLP: RET     Z               ; End of list - Exit
1551:	0B23  FEA5    	        CP      ZTAB            ; "TAB(" token?
1552:	0B25  CAB00B  	        JP      Z,DOTAB         ; Yes - Do TAB routine
1553:	0B28  FEA8    	        CP      ZSPC            ; "SPC(" token?
1554:	0B2A  CAB00B  	        JP      Z,DOTAB         ; Yes - Do SPC routine
1555:	0B2D  E5      	        PUSH    HL              ; Save code string address
1556:	0B2E  FE2C    	        CP      ','             ; Comma?
1557:	0B30  CA990B  	        JP      Z,DOCOM         ; Yes - Move to next zone
1558:	0B33  FE3B    	        CP      59 ;";"         ; Semi-colon?
1559:	0B35  CAD30B  	        JP      Z,NEXITM        ; Do semi-colon routine
1560:	0B38  C1      	        POP     BC              ; Code string address to BC
1561:	0B39  CD540D  	        CALL    EVAL            ; Evaluate expression
1562:	0B3C  E5      	        PUSH    HL              ; Save code string address
1563:	0B3D  3AAD20  	        LD      A,(TYPE)        ; Get variable type
1564:	0B40  B7      	        OR      A               ; Is it a string variable?
1565:	0B41  C2690B  	        JP      NZ,PRNTST       ; Yes - Output string contents
1566:	0B44  CDC918  	        CALL    NUMASC          ; Convert number to text
1567:	0B47  CDD911  	        CALL    CRTST           ; Create temporary string
1568:	0B4A  3620    	        LD      (HL),' '        ; Followed by a space
1569:	0B4C  2AE420  	        LD      HL,(FPREG)      ; Get length of output
1570:	0B4F  34      	        INC     (HL)            ; Plus 1 for the space
1571:	0B50  2AE420  	        LD      HL,(FPREG)      ; < Not needed >
1572:	0B53  3A4220  	        LD      A,(LWIDTH)      ; Get width of line
1573:	0B56  47      	        LD      B,A             ; To B
1574:	0B57  04      	        INC     B               ; Width 255 (No limit)?
1575:	0B58  CA650B  	        JP      Z,PRNTNB        ; Yes - Output number string
1576:	0B5B  04      	        INC     B               ; Adjust it
1577:	0B5C  3AAB20  	        LD      A,(CURPOS)      ; Get cursor position
1578:	0B5F  86      	        ADD     A,(HL)          ; Add length of string
1579:	0B60  3D      	        DEC     A               ; Adjust it
1580:	0B61  B8      	        CP      B               ; Will output fit on this line?
1581:	0B62  D47D0B  	        CALL    NC,PRNTCRLF     ; No - CRLF first
1582:	0B65  CD1E12  	PRNTNB: CALL    PRS1            ; Output string at (HL)
1583:	0B68  AF      	        XOR     A               ; Skip CALL by setting 'z' flag
1584:	0B69  C41E12  	PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
1585:	0B6C  E1      	        POP     HL              ; Restore code string address
1586:	0B6D  C31B0B  	        JP      MRPRNT          ; See if more to PRINT
1587:			
1588:	0B70  3AAB20  	STTLIN: LD      A,(CURPOS)      ; Make sure on new line
1589:	0B73  B7      	        OR      A               ; Already at start?
1590:	0B74  C8      	        RET     Z               ; Yes - Do nothing
1591:	0B75  C37D0B  	        JP      PRNTCRLF        ; Start a new line
1592:			
1593:	0B78  3600    	ENDINP: LD      (HL),0          ; Mark end of buffer
1594:	0B7A  216020  	        LD      HL,BUFFER-1     ; Point to buffer
1595:	0B7D  3E0D    	PRNTCRLF: LD    A,CR            ; Load a CR
1596:	0B7F  CD5607  	        CALL    OUTC            ; Output character
1597:	0B82  3E0A    	        LD      A,LF            ; Load a LF
1598:	0B84  CD5607  	        CALL    OUTC            ; Output character
1599:	0B87  AF      	DONULL: XOR     A               ; Set to position 0
1600:	0B88  32AB20  	        LD      (CURPOS),A      ; Store it
1601:	0B8B  3A4120  	        LD      A,(NULLS)       ; Get number of nulls
1602:	0B8E  3D      	NULLP:  DEC     A               ; Count them
1603:	0B8F  C8      	        RET     Z               ; Return if done
1604:	0B90  F5      	        PUSH    AF              ; Save count
1605:	0B91  AF      	        XOR     A               ; Load a null
1606:	0B92  CD5607  	        CALL    OUTC            ; Output it
1607:	0B95  F1      	        POP     AF              ; Restore count
1608:	0B96  C38E0B  	        JP      NULLP           ; Keep counting
1609:			
1610:	0B99  3A4320  	DOCOM:  LD      A,(COMMAN)      ; Get comma width
1611:	0B9C  47      	        LD      B,A             ; Save in B
1612:	0B9D  3AAB20  	        LD      A,(CURPOS)      ; Get current position
1613:	0BA0  B8      	        CP      B               ; Within the limit?
1614:	0BA1  D47D0B  	        CALL    NC,PRNTCRLF     ; No - output CRLF
1615:	0BA4  D2D30B  	        JP      NC,NEXITM       ; Get next item
1616:	0BA7  D60E    	ZONELP: SUB     14              ; Next zone of 14 characters
1617:	0BA9  D2A70B  	        JP      NC,ZONELP       ; Repeat if more zones
1618:	0BAC  2F      	        CPL                     ; Number of spaces to output
1619:	0BAD  C3C80B  	        JP      ASPCS           ; Output them
1620:			
1621:	0BB0  F5      	DOTAB:  PUSH    AF              ; Save token
1622:	0BB1  CDA014  	        CALL    FNDNUM          ; Evaluate expression
1623:	0BB4  CD4B07  	        CALL    CHKSYN          ; Make sure ")" follows
1624:	0BB7  29      	        .DB     ")"
1625:	0BB8  2B      	        DEC     HL              ; Back space on to ")"
1626:	0BB9  F1      	        POP     AF              ; Restore token
1627:	0BBA  D6A8    	        SUB     ZSPC            ; Was it "SPC(" ?
1628:	0BBC  E5      	        PUSH    HL              ; Save code string address
1629:	0BBD  CAC30B  	        JP      Z,DOSPC         ; Yes - Do 'E' spaces
1630:	0BC0  3AAB20  	        LD      A,(CURPOS)      ; Get current position
1631:	0BC3  2F      	DOSPC:  CPL                     ; Number of spaces to print to
1632:	0BC4  83      	        ADD     A,E             ; Total number to print
1633:	0BC5  D2D30B  	        JP      NC,NEXITM       ; TAB < Current POS(X)
1634:	0BC8  3C      	ASPCS:  INC     A               ; Output A spaces
1635:	0BC9  47      	        LD      B,A             ; Save number to print
1636:	0BCA  3E20    	        LD      A,' '           ; Space
1637:	0BCC  CD5607  	SPCLP:  CALL    OUTC            ; Output character in A
1638:	0BCF  05      	        DEC     B               ; Count them
1639:	0BD0  C2CC0B  	        JP      NZ,SPCLP        ; Repeat if more
1640:	0BD3  E1      	NEXITM: POP     HL              ; Restore code string address
1641:	0BD4  CDD508  	        CALL    GETCHR          ; Get next character
1642:	0BD7  C3220B  	        JP      PRNTLP          ; More to print
1643:			
1644:	0BDA  3F526564	REDO:   .DB     "?Redo from start",CR,LF,0
	      6F206672
	      6F6D2073
	      74617274
	      0D0A00
1645:			
1646:	0BED  3ACD20  	BADINP: LD      A,(READFG)      ; READ or INPUT?
1647:	0BF0  B7      	        OR      A
1648:	0BF1  C2AB04  	        JP      NZ,DATSNR       ; READ - ?SN Error
1649:	0BF4  C1      	        POP     BC              ; Throw away code string addr
1650:	0BF5  21DA0B  	        LD      HL,REDO         ; "Redo from start" message
1651:	0BF8  CD1B12  	        CALL    PRS             ; Output string
1652:	0BFB  C3FC05  	        JP      DOAGN           ; Do last INPUT again
1653:			
1654:	0BFE  CD8611  	INPUT:  CALL    IDTEST          ; Test for illegal direct
1655:	0C01  7E      	        LD      A,(HL)          ; Get character after "INPUT"
1656:	0C02  FE22    	        CP      '"'             ; Is there a prompt string?
1657:	0C04  3E00    	        LD      A,0             ; Clear A and leave flags
1658:	0C06  324520  	        LD      (CTLOFG),A      ; Enable output
1659:	0C09  C2180C  	        JP      NZ,NOPMPT       ; No prompt - get input
1660:	0C0C  CDDA11  	        CALL    QTSTR           ; Get string terminated by '"'
1661:	0C0F  CD4B07  	        CALL    CHKSYN          ; Check for ';' after prompt
1662:	0C12  3B      	        .DB     ';'
1663:	0C13  E5      	        PUSH    HL              ; Save code string address
1664:	0C14  CD1E12  	        CALL    PRS1            ; Output prompt string
1665:	0C17  3E      	        .DB     3EH             ; Skip "PUSH HL"
1666:	0C18  E5      	NOPMPT: PUSH    HL              ; Save code string address
1667:	0C19  CD0006  	        CALL    PROMPT          ; Get input with "? " prompt
1668:	0C1C  C1      	        POP     BC              ; Restore code string address
1669:	0C1D  DA2409  	        JP      C,INPBRK        ; Break pressed - Exit
1670:	0C20  23      	        INC     HL              ; Next byte
1671:	0C21  7E      	        LD      A,(HL)          ; Get it
1672:	0C22  B7      	        OR      A               ; End of line?
1673:	0C23  2B      	        DEC     HL              ; Back again
1674:	0C24  C5      	        PUSH    BC              ; Re-save code string address
1675:	0C25  CA6B0A  	        JP      Z,NXTDTA        ; Yes - Find next DATA stmt
1676:	0C28  362C    	        LD      (HL),','        ; Store comma as separator
1677:	0C2A  C3320C  	        JP      NXTITM          ; Get next item
1678:			
1679:	0C2D  E5      	READ:   PUSH    HL              ; Save code string address
1680:	0C2E  2ADC20  	        LD      HL,(NXTDAT)     ; Next DATA statement
1681:	0C31  F6      	        .DB     0F6H            ; Flag "READ"
1682:	0C32  AF      	NXTITM: XOR     A               ; Flag "INPUT"
1683:	0C33  32CD20  	        LD      (READFG),A      ; Save "READ"/"INPUT" flag
1684:	0C36  E3      	        EX      (SP),HL         ; Get code str' , Save pointer
1685:	0C37  C33E0C  	        JP      GTVLUS          ; Get values
1686:			
1687:	0C3A  CD4B07  	NEDMOR: CALL    CHKSYN          ; Check for comma between items
1688:	0C3D  2C      	        .DB     ','
1689:	0C3E  CD380F  	GTVLUS: CALL    GETVAR          ; Get variable name
1690:	0C41  E3      	        EX      (SP),HL         ; Save code str" , Get pointer
1691:	0C42  D5      	        PUSH    DE              ; Save variable address
1692:	0C43  7E      	        LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
1693:	0C44  FE2C    	        CP      ','             ; Comma?
1694:	0C46  CA660C  	        JP      Z,ANTVLU        ; Yes - Get another value
1695:	0C49  3ACD20  	        LD      A,(READFG)      ; Is it READ?
1696:	0C4C  B7      	        OR      A
1697:	0C4D  C2D30C  	        JP      NZ,FDTLP        ; Yes - Find next DATA stmt
1698:	0C50  3E3F    	        LD      A,'?'           ; More INPUT needed
1699:	0C52  CD5607  	        CALL    OUTC            ; Output character
1700:	0C55  CD0006  	        CALL    PROMPT          ; Get INPUT with prompt
1701:	0C58  D1      	        POP     DE              ; Variable address
1702:	0C59  C1      	        POP     BC              ; Code string address
1703:	0C5A  DA2409  	        JP      C,INPBRK        ; Break pressed
1704:	0C5D  23      	        INC     HL              ; Point to next DATA byte
1705:	0C5E  7E      	        LD      A,(HL)          ; Get byte
1706:	0C5F  B7      	        OR      A               ; Is it zero (No input) ?
1707:	0C60  2B      	        DEC     HL              ; Back space INPUT pointer
1708:	0C61  C5      	        PUSH    BC              ; Save code string address
1709:	0C62  CA6B0A  	        JP      Z,NXTDTA        ; Find end of buffer
1710:	0C65  D5      	        PUSH    DE              ; Save variable address
1711:	0C66  3AAD20  	ANTVLU: LD      A,(TYPE)        ; Check data type
1712:	0C69  B7      	        OR      A               ; Is it numeric?
1713:	0C6A  CA900C  	        JP      Z,INPBIN        ; Yes - Convert to binary
1714:	0C6D  CDD508  	        CALL    GETCHR          ; Get next character
1715:	0C70  57      	        LD      D,A             ; Save input character
1716:	0C71  47      	        LD      B,A             ; Again
1717:	0C72  FE22    	        CP      '"'             ; Start of literal sting?
1718:	0C74  CA840C  	        JP      Z,STRENT        ; Yes - Create string entry
1719:	0C77  3ACD20  	        LD      A,(READFG)      ; "READ" or "INPUT" ?
1720:	0C7A  B7      	        OR      A
1721:	0C7B  57      	        LD      D,A             ; Save 00 if "INPUT"
1722:	0C7C  CA810C  	        JP      Z,ITMSEP        ; "INPUT" - End with 00
1723:	0C7F  163A    	        LD      D,':'           ; "DATA" - End with 00 or ':'
1724:	0C81  062C    	ITMSEP: LD      B,','           ; Item separator
1725:	0C83  2B      	        DEC     HL              ; Back space for DTSTR
1726:	0C84  CDDD11  	STRENT: CALL    DTSTR           ; Get string terminated by D
1727:	0C87  EB      	        EX      DE,HL           ; String address to DE
1728:	0C88  219B0C  	        LD      HL,LTSTND       ; Where to go after LETSTR
1729:	0C8B  E3      	        EX      (SP),HL         ; Save HL , get input pointer
1730:	0C8C  D5      	        PUSH    DE              ; Save address of string
1731:	0C8D  C39E0A  	        JP      LETSTR          ; Assign string to variable
1732:			
1733:	0C90  CDD508  	INPBIN: CALL    GETCHR          ; Get next character
1734:	0C93  CD2B18  	        CALL    ASCTFP          ; Convert ASCII to FP number
1735:	0C96  E3      	        EX      (SP),HL         ; Save input ptr, Get var addr
1736:	0C97  CD7C17  	        CALL    FPTHL           ; Move FPREG to variable
1737:	0C9A  E1      	        POP     HL              ; Restore input pointer
1738:	0C9B  2B      	LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
1739:	0C9C  CDD508  	        CALL    GETCHR          ; Get next character
1740:	0C9F  CAA70C  	        JP      Z,MORDT         ; End of line - More needed?
1741:	0CA2  FE2C    	        CP      ','             ; Another value?
1742:	0CA4  C2ED0B  	        JP      NZ,BADINP       ; No - Bad input
1743:	0CA7  E3      	MORDT:  EX      (SP),HL         ; Get code string address
1744:	0CA8  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
1745:	0CA9  CDD508  	        CALL    GETCHR          ; Get next character
1746:	0CAC  C23A0C  	        JP      NZ,NEDMOR       ; More needed - Get it
1747:	0CAF  D1      	        POP     DE              ; Restore DATA pointer
1748:	0CB0  3ACD20  	        LD      A,(READFG)      ; "READ" or "INPUT" ?
1749:	0CB3  B7      	        OR      A
1750:	0CB4  EB      	        EX      DE,HL           ; DATA pointer to HL
1751:	0CB5  C2FB08  	        JP      NZ,UPDATA       ; Update DATA pointer if "READ"
1752:	0CB8  D5      	        PUSH    DE              ; Save code string address
1753:	0CB9  B6      	        OR      (HL)            ; More input given?
1754:	0CBA  21C20C  	        LD      HL,EXTIG        ; "?Extra ignored" message
1755:	0CBD  C41B12  	        CALL    NZ,PRS          ; Output string if extra given
1756:	0CC0  E1      	        POP     HL              ; Restore code string address
1757:	0CC1  C9      	        RET
1758:			
1759:	0CC2  3F457874	EXTIG:  .DB     "?Extra ignored",CR,LF,0
	      72612069
	      676E6F72
	      65640D0A
	      00
1760:			
1761:	0CD3  CD6C0A  	FDTLP:  CALL    DATA            ; Get next statement
1762:	0CD6  B7      	        OR      A               ; End of line?
1763:	0CD7  C2EC0C  	        JP      NZ,FANDT        ; No - See if DATA statement
1764:	0CDA  23      	        INC     HL
1765:	0CDB  7E      	        LD      A,(HL)          ; End of program?
1766:	0CDC  23      	        INC     HL
1767:	0CDD  B6      	        OR      (HL)            ; 00 00 Ends program
1768:	0CDE  1E06    	        LD      E,OD            ; ?OD Error
1769:	0CE0  CAC504  	        JP      Z,ERROR         ; Yes - Out of DATA
1770:	0CE3  23      	        INC     HL
1771:	0CE4  5E      	        LD      E,(HL)          ; LSB of line number
1772:	0CE5  23      	        INC     HL
1773:	0CE6  56      	        LD      D,(HL)          ; MSB of line number
1774:	0CE7  EB      	        EX      DE,HL
1775:	0CE8  22C920  	        LD      (DATLIN),HL     ; Set line of current DATA item
1776:	0CEB  EB      	        EX      DE,HL
1777:	0CEC  CDD508  	FANDT:  CALL    GETCHR          ; Get next character
1778:	0CEF  FE83    	        CP      ZDATA           ; "DATA" token
1779:	0CF1  C2D30C  	        JP      NZ,FDTLP        ; No "DATA" - Keep looking
1780:	0CF4  C3660C  	        JP      ANTVLU          ; Found - Convert input
1781:			
1782:	0CF7  110000  	NEXT:   LD      DE,0            ; In case no index given
1783:	0CFA  C4380F  	NEXT1:  CALL    NZ,GETVAR       ; Get index address
1784:	0CFD  22CE20  	        LD      (BRKLIN),HL     ; Save code string address
1785:	0D00  CD5A04  	        CALL    BAKSTK          ; Look for "FOR" block
1786:	0D03  C2B704  	        JP      NZ,NFERR        ; No "FOR" - ?NF Error
1787:	0D06  F9      	        LD      SP,HL           ; Clear nested loops
1788:	0D07  D5      	        PUSH    DE              ; Save index address
1789:	0D08  7E      	        LD      A,(HL)          ; Get sign of STEP
1790:	0D09  23      	        INC     HL
1791:	0D0A  F5      	        PUSH    AF              ; Save sign of STEP
1792:	0D0B  D5      	        PUSH    DE              ; Save index address
1793:	0D0C  CD6217  	        CALL    PHLTFP          ; Move index value to FPREG
1794:	0D0F  E3      	        EX      (SP),HL         ; Save address of TO value
1795:	0D10  E5      	        PUSH    HL              ; Save address of index
1796:	0D11  CDCF14  	        CALL    ADDPHL          ; Add STEP to index value
1797:	0D14  E1      	        POP     HL              ; Restore address of index
1798:	0D15  CD7C17  	        CALL    FPTHL           ; Move value to index variable
1799:	0D18  E1      	        POP     HL              ; Restore address of TO value
1800:	0D19  CD7317  	        CALL    LOADFP          ; Move TO value to BCDE
1801:	0D1C  E5      	        PUSH    HL              ; Save address of line of FOR
1802:	0D1D  CD9F17  	        CALL    CMPNUM          ; Compare index with TO value
1803:	0D20  E1      	        POP     HL              ; Restore address of line num
1804:	0D21  C1      	        POP     BC              ; Address of sign of STEP
1805:	0D22  90      	        SUB     B               ; Compare with expected sign
1806:	0D23  CD7317  	        CALL    LOADFP          ; BC = Loop stmt,DE = Line num
1807:	0D26  CA320D  	        JP      Z,KILFOR        ; Loop finished - Terminate it
1808:	0D29  EB      	        EX      DE,HL           ; Loop statement line number
1809:	0D2A  225C20  	        LD      (LINEAT),HL     ; Set loop line number
1810:	0D2D  69      	        LD      L,C             ; Set code string to loop
1811:	0D2E  60      	        LD      H,B
1812:	0D2F  C39108  	        JP      PUTFID          ; Put back "FOR" and continue
1813:			
1814:	0D32  F9      	KILFOR: LD      SP,HL           ; Remove "FOR" block
1815:	0D33  2ACE20  	        LD      HL,(BRKLIN)     ; Code string after "NEXT"
1816:	0D36  7E      	        LD      A,(HL)          ; Get next byte in code string
1817:	0D37  FE2C    	        CP      ','             ; More NEXTs ?
1818:	0D39  C29508  	        JP      NZ,RUNCNT       ; No - Do next statement
1819:	0D3C  CDD508  	        CALL    GETCHR          ; Position to index name
1820:	0D3F  CDFA0C  	        CALL    NEXT1           ; Re-enter NEXT routine
1821:			; < will not RETurn to here , Exit to RUNCNT or Loop >
1822:			
1823:	0D42  CD540D  	GETNUM: CALL    EVAL            ; Get a numeric expression
1824:	0D45  F6      	TSTNUM: .DB     0F6H            ; Clear carry (numeric)
1825:	0D46  37      	TSTSTR: SCF                     ; Set carry (string)
1826:	0D47  3AAD20  	CHKTYP: LD      A,(TYPE)        ; Check types match
1827:	0D4A  8F      	        ADC     A,A             ; Expected + actual
1828:	0D4B  B7      	        OR      A               ; Clear carry , set parity
1829:	0D4C  E8      	        RET     PE              ; Even parity - Types match
1830:	0D4D  C3C304  	        JP      TMERR           ; Different types - Error
1831:			
1832:	0D50  CD4B07  	OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
1833:	0D53  28      	        .DB  "("
1834:	0D54  2B      	EVAL:   DEC     HL              ; Evaluate expression & save
1835:	0D55  1600    	        LD      D,0             ; Precedence value
1836:	0D57  D5      	EVAL1:  PUSH    DE              ; Save precedence
1837:	0D58  0E01    	        LD      C,1
1838:	0D5A  CD8E04  	        CALL    CHKSTK          ; Check for 1 level of stack
1839:	0D5D  CDCB0D  	        CALL    OPRND           ; Get next expression value
1840:	0D60  22D020  	EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
1841:	0D63  2AD020  	EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
1842:	0D66  C1      	        POP     BC              ; Precedence value and operator
1843:	0D67  78      	        LD      A,B             ; Get precedence value
1844:	0D68  FE78    	        CP      78H             ; "AND" or "OR" ?
1845:	0D6A  D4450D  	        CALL    NC,TSTNUM       ; No - Make sure it's a number
1846:	0D6D  7E      	        LD      A,(HL)          ; Get next operator / function
1847:	0D6E  1600    	        LD      D,0             ; Clear Last relation
1848:	0D70  D6B3    	RLTLP:  SUB     ZGTR            ; ">" Token
1849:	0D72  DA8C0D  	        JP      C,FOPRND        ; + - * / ^ AND OR - Test it
1850:	0D75  FE03    	        CP      ZLTH+1-ZGTR     ; < = >
1851:	0D77  D28C0D  	        JP      NC,FOPRND       ; Function - Call it
1852:	0D7A  FE01    	        CP      ZEQUAL-ZGTR     ; "="
1853:	0D7C  17      	        RLA                     ; <- Test for legal
1854:	0D7D  AA      	        XOR     D               ; <- combinations of < = >
1855:	0D7E  BA      	        CP      D               ; <- by combining last token
1856:	0D7F  57      	        LD      D,A             ; <- with current one
1857:	0D80  DAB104  	        JP      C,SNERR         ; Error if "<<' '==" or ">>"
1858:	0D83  22C520  	        LD      (CUROPR),HL     ; Save address of current token
1859:	0D86  CDD508  	        CALL    GETCHR          ; Get next character
1860:	0D89  C3700D  	        JP      RLTLP           ; Treat the two as one
1861:			
1862:	0D8C  7A      	FOPRND: LD      A,D             ; < = > found ?
1863:	0D8D  B7      	        OR      A
1864:	0D8E  C2B30E  	        JP      NZ,TSTRED       ; Yes - Test for reduction
1865:	0D91  7E      	        LD      A,(HL)          ; Get operator token
1866:	0D92  22C520  	        LD      (CUROPR),HL     ; Save operator address
1867:	0D95  D6AC    	        SUB     ZPLUS           ; Operator or function?
1868:	0D97  D8      	        RET     C               ; Neither - Exit
1869:	0D98  FE07    	        CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
1870:	0D9A  D0      	        RET     NC              ; No - Exit
1871:	0D9B  5F      	        LD      E,A             ; Coded operator
1872:	0D9C  3AAD20  	        LD      A,(TYPE)        ; Get data type
1873:	0D9F  3D      	        DEC     A               ; FF = numeric , 00 = string
1874:	0DA0  B3      	        OR      E               ; Combine with coded operator
1875:	0DA1  7B      	        LD      A,E             ; Get coded operator
1876:	0DA2  CA1113  	        JP      Z,CONCAT        ; String concatenation
1877:	0DA5  07      	        RLCA                    ; Times 2
1878:	0DA6  83      	        ADD     A,E             ; Times 3
1879:	0DA7  5F      	        LD      E,A             ; To DE (D is 0)
1880:	0DA8  21A303  	        LD      HL,PRITAB       ; Precedence table
1881:	0DAB  19      	        ADD     HL,DE           ; To the operator concerned
1882:	0DAC  78      	        LD      A,B             ; Last operator precedence
1883:	0DAD  56      	        LD      D,(HL)          ; Get evaluation precedence
1884:	0DAE  BA      	        CP      D               ; Compare with eval precedence
1885:	0DAF  D0      	        RET     NC              ; Exit if higher precedence
1886:	0DB0  23      	        INC     HL              ; Point to routine address
1887:	0DB1  CD450D  	        CALL    TSTNUM          ; Make sure it's a number
1888:			
1889:	0DB4  C5      	STKTHS: PUSH    BC              ; Save last precedence & token
1890:	0DB5  01630D  	        LD      BC,EVAL3        ; Where to go on prec' break
1891:	0DB8  C5      	        PUSH    BC              ; Save on stack for return
1892:	0DB9  43      	        LD      B,E             ; Save operator
1893:	0DBA  4A      	        LD      C,D             ; Save precedence
1894:	0DBB  CD5517  	        CALL    STAKFP          ; Move value to stack
1895:	0DBE  58      	        LD      E,B             ; Restore operator
1896:	0DBF  51      	        LD      D,C             ; Restore precedence
1897:	0DC0  4E      	        LD      C,(HL)          ; Get LSB of routine address
1898:	0DC1  23      	        INC     HL
1899:	0DC2  46      	        LD      B,(HL)          ; Get MSB of routine address
1900:	0DC3  23      	        INC     HL
1901:	0DC4  C5      	        PUSH    BC              ; Save routine address
1902:	0DC5  2AC520  	        LD      HL,(CUROPR)     ; Address of current operator
1903:	0DC8  C3570D  	        JP      EVAL1           ; Loop until prec' break
1904:			
1905:	0DCB  AF      	OPRND:  XOR     A               ; Get operand routine
1906:	0DCC  32AD20  	        LD      (TYPE),A        ; Set numeric expected
1907:	0DCF  CDD508  	        CALL    GETCHR          ; Get next character
1908:	0DD2  1E24    	        LD      E,MO            ; ?MO Error
1909:	0DD4  CAC504  	        JP      Z,ERROR         ; No operand - Error
1910:	0DD7  DA2B18  	        JP      C,ASCTFP        ; Number - Get value
1911:	0DDA  CD7309  	        CALL    CHKLTR          ; See if a letter
1912:	0DDD  D2320E  	        JP      NC,CONVAR       ; Letter - Find variable
1913:	0DE0  FE26    	        CP      '&'             ; &H = HEX, &B = BINARY
1914:	0DE2  2012    	        JR      NZ, NOTAMP
1915:	0DE4  CDD508  	        CALL    GETCHR          ; Get next character
1916:	0DE7  FE48    	        CP      'H'             ; Hex number indicated? [function added]
1917:	0DE9  CA6F1C  	        JP      Z,HEXTFP        ; Convert Hex to FPREG
1918:	0DEC  FE42    	        CP      'B'             ; Binary number indicated? [function added]
1919:	0DEE  CADF1C  	        JP      Z,BINTFP        ; Convert Bin to FPREG
1920:	0DF1  1E02    	        LD      E,SN            ; If neither then a ?SN Error
1921:	0DF3  CAC504  	        JP      Z,ERROR         ; 
1922:	0DF6  FEAC    	NOTAMP: CP      ZPLUS           ; '+' Token ?
1923:	0DF8  CACB0D  	        JP      Z,OPRND         ; Yes - Look for operand
1924:	0DFB  FE2E    	        CP      '.'             ; '.' ?
1925:	0DFD  CA2B18  	        JP      Z,ASCTFP        ; Yes - Create FP number
1926:	0E00  FEAD    	        CP      ZMINUS          ; '-' Token ?
1927:	0E02  CA210E  	        JP      Z,MINUS         ; Yes - Do minus
1928:	0E05  FE22    	        CP      '"'             ; Literal string ?
1929:	0E07  CADA11  	        JP      Z,QTSTR         ; Get string terminated by '"'
1930:	0E0A  FEAA    	        CP      ZNOT            ; "NOT" Token ?
1931:	0E0C  CA130F  	        JP      Z,EVNOT         ; Yes - Eval NOT expression
1932:	0E0F  FEA7    	        CP      ZFN             ; "FN" Token ?
1933:	0E11  CA3E11  	        JP      Z,DOFN          ; Yes - Do FN routine
1934:	0E14  D6B6    	        SUB     ZSGN            ; Is it a function?
1935:	0E16  D2430E  	        JP      NC,FNOFST       ; Yes - Evaluate function
1936:	0E19  CD500D  	EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
1937:	0E1C  CD4B07  	        CALL    CHKSYN          ; Make sure ")" follows
1938:	0E1F  29      	        .DB     ")"
1939:	0E20  C9      	        RET
1940:			
1941:	0E21  167D    	MINUS:  LD      D,7DH           ; '-' precedence
1942:	0E23  CD570D  	        CALL    EVAL1           ; Evaluate until prec' break
1943:	0E26  2AD020  	        LD      HL,(NXTOPR)     ; Get next operator address
1944:	0E29  E5      	        PUSH    HL              ; Save next operator address
1945:	0E2A  CD4D17  	        CALL    INVSGN          ; Negate value
1946:	0E2D  CD450D  	RETNUM: CALL    TSTNUM          ; Make sure it's a number
1947:	0E30  E1      	        POP     HL              ; Restore next operator address
1948:	0E31  C9      	        RET
1949:			
1950:	0E32  CD380F  	CONVAR: CALL    GETVAR          ; Get variable address to DE
1951:	0E35  E5      	FRMEVL: PUSH    HL              ; Save code string address
1952:	0E36  EB      	        EX      DE,HL           ; Variable address to HL
1953:	0E37  22E420  	        LD      (FPREG),HL      ; Save address of variable
1954:	0E3A  3AAD20  	        LD      A,(TYPE)        ; Get type
1955:	0E3D  B7      	        OR      A               ; Numeric?
1956:	0E3E  CC6217  	        CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
1957:	0E41  E1      	        POP     HL              ; Restore code string address
1958:	0E42  C9      	        RET
1959:			
1960:	0E43  0600    	FNOFST: LD      B,0             ; Get address of function
1961:	0E45  07      	        RLCA                    ; Double function offset
1962:	0E46  4F      	        LD      C,A             ; BC = Offset in function table
1963:	0E47  C5      	        PUSH    BC              ; Save adjusted token value
1964:	0E48  CDD508  	        CALL    GETCHR          ; Get next character
1965:	0E4B  79      	        LD      A,C             ; Get adjusted token value
1966:	0E4C  FE31    	        CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
1967:	0E4E  DA6A0E  	        JP      C,FNVAL         ; No - Do function
1968:	0E51  CD500D  	        CALL    OPNPAR          ; Evaluate expression  (X,...
1969:	0E54  CD4B07  	        CALL    CHKSYN          ; Make sure ',' follows
1970:	0E57  2C      	        .DB     ','
1971:	0E58  CD460D  	        CALL    TSTSTR          ; Make sure it's a string
1972:	0E5B  EB      	        EX      DE,HL           ; Save code string address
1973:	0E5C  2AE420  	        LD      HL,(FPREG)      ; Get address of string
1974:	0E5F  E3      	        EX      (SP),HL         ; Save address of string
1975:	0E60  E5      	        PUSH    HL              ; Save adjusted token value
1976:	0E61  EB      	        EX      DE,HL           ; Restore code string address
1977:	0E62  CDA314  	        CALL    GETINT          ; Get integer 0-255
1978:	0E65  EB      	        EX      DE,HL           ; Save code string address
1979:	0E66  E3      	        EX      (SP),HL         ; Save integer,HL = adj' token
1980:	0E67  C3720E  	        JP      GOFUNC          ; Jump to string function
1981:			
1982:	0E6A  CD190E  	FNVAL:  CALL    EVLPAR          ; Evaluate expression
1983:	0E6D  E3      	        EX      (SP),HL         ; HL = Adjusted token value
1984:	0E6E  112D0E  	        LD      DE,RETNUM       ; Return number from function
1985:	0E71  D5      	        PUSH    DE              ; Save on stack
1986:	0E72  010202  	GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
1987:	0E75  09      	        ADD     HL,BC           ; Point to right address
1988:	0E76  4E      	        LD      C,(HL)          ; Get LSB of address
1989:	0E77  23      	        INC     HL              ;
1990:	0E78  66      	        LD      H,(HL)          ; Get MSB of address
1991:	0E79  69      	        LD      L,C             ; Address to HL
1992:	0E7A  E9      	        JP      (HL)            ; Jump to function
1993:			
1994:	0E7B  15      	SGNEXP: DEC     D               ; Dee to flag negative exponent
1995:	0E7C  FEAD    	        CP      ZMINUS          ; '-' token ?
1996:	0E7E  C8      	        RET     Z               ; Yes - Return
1997:	0E7F  FE2D    	        CP      '-'             ; '-' ASCII ?
1998:	0E81  C8      	        RET     Z               ; Yes - Return
1999:	0E82  14      	        INC     D               ; Inc to flag positive exponent
2000:	0E83  FE2B    	        CP      '+'             ; '+' ASCII ?
2001:	0E85  C8      	        RET     Z               ; Yes - Return
2002:	0E86  FEAC    	        CP      ZPLUS           ; '+' token ?
2003:	0E88  C8      	        RET     Z               ; Yes - Return
2004:	0E89  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
2005:	0E8A  C9      	        RET                     ; Return "NZ"
2006:			
2007:	0E8B  F6      	POR:    .DB     0F6H            ; Flag "OR"
2008:	0E8C  AF      	PAND:   XOR     A               ; Flag "AND"
2009:	0E8D  F5      	        PUSH    AF              ; Save "AND" / "OR" flag
2010:	0E8E  CD450D  	        CALL    TSTNUM          ; Make sure it's a number
2011:	0E91  CD8709  	        CALL    DEINT           ; Get integer -32768 to 32767
2012:	0E94  F1      	        POP     AF              ; Restore "AND" / "OR" flag
2013:	0E95  EB      	        EX      DE,HL           ; <- Get last
2014:	0E96  C1      	        POP     BC              ; <-  value
2015:	0E97  E3      	        EX      (SP),HL         ; <-  from
2016:	0E98  EB      	        EX      DE,HL           ; <-  stack
2017:	0E99  CD6517  	        CALL    FPBCDE          ; Move last value to FPREG
2018:	0E9C  F5      	        PUSH    AF              ; Save "AND" / "OR" flag
2019:	0E9D  CD8709  	        CALL    DEINT           ; Get integer -32768 to 32767
2020:	0EA0  F1      	        POP     AF              ; Restore "AND" / "OR" flag
2021:	0EA1  C1      	        POP     BC              ; Get value
2022:	0EA2  79      	        LD      A,C             ; Get LSB
2023:	0EA3  21FC10  	        LD      HL,ACPASS       ; Address of save AC as current
2024:	0EA6  C2AE0E  	        JP      NZ,POR1         ; Jump if OR
2025:	0EA9  A3      	        AND     E               ; "AND" LSBs
2026:	0EAA  4F      	        LD      C,A             ; Save LSB
2027:	0EAB  78      	        LD      A,B             ; Get MBS
2028:	0EAC  A2      	        AND     D               ; "AND" MSBs
2029:	0EAD  E9      	        JP      (HL)            ; Save AC as current (ACPASS)
2030:			
2031:	0EAE  B3      	POR1:   OR      E               ; "OR" LSBs
2032:	0EAF  4F      	        LD      C,A             ; Save LSB
2033:	0EB0  78      	        LD      A,B             ; Get MSB
2034:	0EB1  B2      	        OR      D               ; "OR" MSBs
2035:	0EB2  E9      	        JP      (HL)            ; Save AC as current (ACPASS)
2036:			
2037:	0EB3  21C50E  	TSTRED: LD      HL,CMPLOG       ; Logical compare routine
2038:	0EB6  3AAD20  	        LD      A,(TYPE)        ; Get data type
2039:	0EB9  1F      	        RRA                     ; Carry set = string
2040:	0EBA  7A      	        LD      A,D             ; Get last precedence value
2041:	0EBB  17      	        RLA                     ; Times 2 plus carry
2042:	0EBC  5F      	        LD      E,A             ; To E
2043:	0EBD  1664    	        LD      D,64H           ; Relational precedence
2044:	0EBF  78      	        LD      A,B             ; Get current precedence
2045:	0EC0  BA      	        CP      D               ; Compare with last
2046:	0EC1  D0      	        RET     NC              ; Eval if last was rel' or log'
2047:	0EC2  C3B40D  	        JP      STKTHS          ; Stack this one and get next
2048:			
2049:	0EC5  C70E    	CMPLOG: .DW     CMPLG1          ; Compare two values / strings
2050:	0EC7  79      	CMPLG1: LD      A,C             ; Get data type
2051:	0EC8  B7      	        OR      A
2052:	0EC9  1F      	        RRA
2053:	0ECA  C1      	        POP     BC              ; Get last expression to BCDE
2054:	0ECB  D1      	        POP     DE
2055:	0ECC  F5      	        PUSH    AF              ; Save status
2056:	0ECD  CD470D  	        CALL    CHKTYP          ; Check that types match
2057:	0ED0  21090F  	        LD      HL,CMPRES       ; Result to comparison
2058:	0ED3  E5      	        PUSH    HL              ; Save for RETurn
2059:	0ED4  CA9F17  	        JP      Z,CMPNUM        ; Compare values if numeric
2060:	0ED7  AF      	        XOR     A               ; Compare two strings
2061:	0ED8  32AD20  	        LD      (TYPE),A        ; Set type to numeric
2062:	0EDB  D5      	        PUSH    DE              ; Save string name
2063:	0EDC  CD5E13  	        CALL    GSTRCU          ; Get current string
2064:	0EDF  7E      	        LD      A,(HL)          ; Get length of string
2065:	0EE0  23      	        INC     HL
2066:	0EE1  23      	        INC     HL
2067:	0EE2  4E      	        LD      C,(HL)          ; Get LSB of address
2068:	0EE3  23      	        INC     HL
2069:	0EE4  46      	        LD      B,(HL)          ; Get MSB of address
2070:	0EE5  D1      	        POP     DE              ; Restore string name
2071:	0EE6  C5      	        PUSH    BC              ; Save address of string
2072:	0EE7  F5      	        PUSH    AF              ; Save length of string
2073:	0EE8  CD6213  	        CALL    GSTRDE          ; Get second string
2074:	0EEB  CD7317  	        CALL    LOADFP          ; Get address of second string
2075:	0EEE  F1      	        POP     AF              ; Restore length of string 1
2076:	0EEF  57      	        LD      D,A             ; Length to D
2077:	0EF0  E1      	        POP     HL              ; Restore address of string 1
2078:	0EF1  7B      	CMPSTR: LD      A,E             ; Bytes of string 2 to do
2079:	0EF2  B2      	        OR      D               ; Bytes of string 1 to do
2080:	0EF3  C8      	        RET     Z               ; Exit if all bytes compared
2081:	0EF4  7A      	        LD      A,D             ; Get bytes of string 1 to do
2082:	0EF5  D601    	        SUB     1
2083:	0EF7  D8      	        RET     C               ; Exit if end of string 1
2084:	0EF8  AF      	        XOR     A
2085:	0EF9  BB      	        CP      E               ; Bytes of string 2 to do
2086:	0EFA  3C      	        INC     A
2087:	0EFB  D0      	        RET     NC              ; Exit if end of string 2
2088:	0EFC  15      	        DEC     D               ; Count bytes in string 1
2089:	0EFD  1D      	        DEC     E               ; Count bytes in string 2
2090:	0EFE  0A      	        LD      A,(BC)          ; Byte in string 2
2091:	0EFF  BE      	        CP      (HL)            ; Compare to byte in string 1
2092:	0F00  23      	        INC     HL              ; Move up string 1
2093:	0F01  03      	        INC     BC              ; Move up string 2
2094:	0F02  CAF10E  	        JP      Z,CMPSTR        ; Same - Try next bytes
2095:	0F05  3F      	        CCF                     ; Flag difference (">" or "<")
2096:	0F06  C32F17  	        JP      FLGDIF          ; "<" gives -1 , ">" gives +1
2097:			
2098:	0F09  3C      	CMPRES: INC     A               ; Increment current value
2099:	0F0A  8F      	        ADC     A,A             ; Double plus carry
2100:	0F0B  C1      	        POP     BC              ; Get other value
2101:	0F0C  A0      	        AND     B               ; Combine them
2102:	0F0D  C6FF    	        ADD     A,-1            ; Carry set if different
2103:	0F0F  9F      	        SBC     A,A             ; 00 - Equal , FF - Different
2104:	0F10  C33617  	        JP      FLGREL          ; Set current value & continue
2105:			
2106:	0F13  165A    	EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
2107:	0F15  CD570D  	        CALL    EVAL1           ; Eval until precedence break
2108:	0F18  CD450D  	        CALL    TSTNUM          ; Make sure it's a number
2109:	0F1B  CD8709  	        CALL    DEINT           ; Get integer -32768 - 32767
2110:	0F1E  7B      	        LD      A,E             ; Get LSB
2111:	0F1F  2F      	        CPL                     ; Invert LSB
2112:	0F20  4F      	        LD      C,A             ; Save "NOT" of LSB
2113:	0F21  7A      	        LD      A,D             ; Get MSB
2114:	0F22  2F      	        CPL                     ; Invert MSB
2115:	0F23  CDFC10  	        CALL    ACPASS          ; Save AC as current
2116:	0F26  C1      	        POP     BC              ; Clean up stack
2117:	0F27  C3630D  	        JP      EVAL3           ; Continue evaluation
2118:			
2119:	0F2A  2B      	DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
2120:	0F2B  CDD508  	        CALL    GETCHR          ; Get next character
2121:	0F2E  C8      	        RET     Z               ; End of DIM statement
2122:	0F2F  CD4B07  	        CALL    CHKSYN          ; Make sure ',' follows
2123:	0F32  2C      	        .DB     ','
2124:	0F33  012A0F  	DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
2125:	0F36  C5      	        PUSH    BC              ; Save on stack
2126:	0F37  F6      	        .DB     0F6H            ; Flag "Create" variable
2127:	0F38  AF      	GETVAR: XOR     A               ; Find variable address,to DE
2128:	0F39  32AC20  	        LD      (LCRFLG),A      ; Set locate / create flag
2129:	0F3C  46      	        LD      B,(HL)          ; Get First byte of name
2130:	0F3D  CD7309  	GTFNAM: CALL    CHKLTR          ; See if a letter
2131:	0F40  DAB104  	        JP      C,SNERR         ; ?SN Error if not a letter
2132:	0F43  AF      	        XOR     A
2133:	0F44  4F      	        LD      C,A             ; Clear second byte of name
2134:	0F45  32AD20  	        LD      (TYPE),A        ; Set type to numeric
2135:	0F48  CDD508  	        CALL    GETCHR          ; Get next character
2136:	0F4B  DA540F  	        JP      C,SVNAM2        ; Numeric - Save in name
2137:	0F4E  CD7309  	        CALL    CHKLTR          ; See if a letter
2138:	0F51  DA610F  	        JP      C,CHARTY        ; Not a letter - Check type
2139:	0F54  4F      	SVNAM2: LD      C,A             ; Save second byte of name
2140:	0F55  CDD508  	ENDNAM: CALL    GETCHR          ; Get next character
2141:	0F58  DA550F  	        JP      C,ENDNAM        ; Numeric - Get another
2142:	0F5B  CD7309  	        CALL    CHKLTR          ; See if a letter
2143:	0F5E  D2550F  	        JP      NC,ENDNAM       ; Letter - Get another
2144:	0F61  D624    	CHARTY: SUB     '$'             ; String variable?
2145:	0F63  C2700F  	        JP      NZ,NOTSTR       ; No - Numeric variable
2146:	0F66  3C      	        INC     A               ; A = 1 (string type)
2147:	0F67  32AD20  	        LD      (TYPE),A        ; Set type to string
2148:	0F6A  0F      	        RRCA                    ; A = 80H , Flag for string
2149:	0F6B  81      	        ADD     A,C             ; 2nd byte of name has bit 7 on
2150:	0F6C  4F      	        LD      C,A             ; Resave second byte on name
2151:	0F6D  CDD508  	        CALL    GETCHR          ; Get next character
2152:	0F70  3ACB20  	NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
2153:	0F73  3D      	        DEC     A
2154:	0F74  CA1D10  	        JP      Z,ARLDSV        ; Yes - Get array name
2155:	0F77  F2800F  	        JP      P,NSCFOR        ; No array with "FOR" or "FN"
2156:	0F7A  7E      	        LD      A,(HL)          ; Get byte again
2157:	0F7B  D628    	        SUB     '('             ; Subscripted variable?
2158:	0F7D  CAF50F  	        JP      Z,SBSCPT        ; Yes - Sort out subscript
2159:			
2160:	0F80  AF      	NSCFOR: XOR     A               ; Simple variable
2161:	0F81  32CB20  	        LD      (FORFLG),A      ; Clear "FOR" flag
2162:	0F84  E5      	        PUSH    HL              ; Save code string address
2163:	0F85  50      	        LD      D,B             ; DE = Variable name to find
2164:	0F86  59      	        LD      E,C
2165:	0F87  2ADE20  	        LD      HL,(FNRGNM)     ; FN argument name
2166:	0F8A  CD4507  	        CALL    CPDEHL          ; Is it the FN argument?
2167:	0F8D  11E020  	        LD      DE,FNARG        ; Point to argument value
2168:	0F90  CA6516  	        JP      Z,POPHRT        ; Yes - Return FN argument value
2169:	0F93  2AD820  	        LD      HL,(VAREND)     ; End of variables
2170:	0F96  EB      	        EX      DE,HL           ; Address of end of search
2171:	0F97  2AD620  	        LD      HL,(PROGND)     ; Start of variables address
2172:	0F9A  CD4507  	FNDVAR: CALL    CPDEHL          ; End of variable list table?
2173:	0F9D  CAB30F  	        JP      Z,CFEVAL        ; Yes - Called from EVAL?
2174:	0FA0  79      	        LD      A,C             ; Get second byte of name
2175:	0FA1  96      	        SUB     (HL)            ; Compare with name in list
2176:	0FA2  23      	        INC     HL              ; Move on to first byte
2177:	0FA3  C2A80F  	        JP      NZ,FNTHR        ; Different - Find another
2178:	0FA6  78      	        LD      A,B             ; Get first byte of name
2179:	0FA7  96      	        SUB     (HL)            ; Compare with name in list
2180:	0FA8  23      	FNTHR:  INC     HL              ; Move on to LSB of value
2181:	0FA9  CAE70F  	        JP      Z,RETADR        ; Found - Return address
2182:	0FAC  23      	        INC     HL              ; <- Skip
2183:	0FAD  23      	        INC     HL              ; <- over
2184:	0FAE  23      	        INC     HL              ; <- F.P.
2185:	0FAF  23      	        INC     HL              ; <- value
2186:	0FB0  C39A0F  	        JP      FNDVAR          ; Keep looking
2187:			
2188:	0FB3  E1      	CFEVAL: POP     HL              ; Restore code string address
2189:	0FB4  E3      	        EX      (SP),HL         ; Get return address
2190:	0FB5  D5      	        PUSH    DE              ; Save address of variable
2191:	0FB6  11350E  	        LD      DE,FRMEVL       ; Return address in EVAL
2192:	0FB9  CD4507  	        CALL    CPDEHL          ; Called from EVAL ?
2193:	0FBC  D1      	        POP     DE              ; Restore address of variable
2194:	0FBD  CAEA0F  	        JP      Z,RETNUL        ; Yes - Return null variable
2195:	0FC0  E3      	        EX      (SP),HL         ; Put back return
2196:	0FC1  E5      	        PUSH    HL              ; Save code string address
2197:	0FC2  C5      	        PUSH    BC              ; Save variable name
2198:	0FC3  010600  	        LD      BC,6            ; 2 byte name plus 4 byte data
2199:	0FC6  2ADA20  	        LD      HL,(ARREND)     ; End of arrays
2200:	0FC9  E5      	        PUSH    HL              ; Save end of arrays
2201:	0FCA  09      	        ADD     HL,BC           ; Move up 6 bytes
2202:	0FCB  C1      	        POP     BC              ; Source address in BC
2203:	0FCC  E5      	        PUSH    HL              ; Save new end address
2204:	0FCD  CD7D04  	        CALL    MOVUP           ; Move arrays up
2205:	0FD0  E1      	        POP     HL              ; Restore new end address
2206:	0FD1  22DA20  	        LD      (ARREND),HL     ; Set new end address
2207:	0FD4  60      	        LD      H,B             ; End of variables to HL
2208:	0FD5  69      	        LD      L,C
2209:	0FD6  22D820  	        LD      (VAREND),HL     ; Set new end address
2210:			
2211:	0FD9  2B      	ZEROLP: DEC     HL              ; Back through to zero variable
2212:	0FDA  3600    	        LD      (HL),0          ; Zero byte in variable
2213:	0FDC  CD4507  	        CALL    CPDEHL          ; Done them all?
2214:	0FDF  C2D90F  	        JP      NZ,ZEROLP       ; No - Keep on going
2215:	0FE2  D1      	        POP     DE              ; Get variable name
2216:	0FE3  73      	        LD      (HL),E          ; Store second character
2217:	0FE4  23      	        INC     HL
2218:	0FE5  72      	        LD      (HL),D          ; Store first character
2219:	0FE6  23      	        INC     HL
2220:	0FE7  EB      	RETADR: EX      DE,HL           ; Address of variable in DE
2221:	0FE8  E1      	        POP     HL              ; Restore code string address
2222:	0FE9  C9      	        RET
2223:			
2224:	0FEA  32E720  	RETNUL: LD      (FPEXP),A       ; Set result to zero
2225:	0FED  214D04  	        LD      HL,ZERBYT       ; Also set a null string
2226:	0FF0  22E420  	        LD      (FPREG),HL      ; Save for EVAL
2227:	0FF3  E1      	        POP     HL              ; Restore code string address
2228:	0FF4  C9      	        RET
2229:			
2230:	0FF5  E5      	SBSCPT: PUSH    HL              ; Save code string address
2231:	0FF6  2AAC20  	        LD      HL,(LCRFLG)     ; Locate/Create and Type
2232:	0FF9  E3      	        EX      (SP),HL         ; Save and get code string
2233:	0FFA  57      	        LD      D,A             ; Zero number of dimensions
2234:	0FFB  D5      	SCPTLP: PUSH    DE              ; Save number of dimensions
2235:	0FFC  C5      	        PUSH    BC              ; Save array name
2236:	0FFD  CD7B09  	        CALL    FPSINT          ; Get subscript (0-32767)
2237:	1000  C1      	        POP     BC              ; Restore array name
2238:	1001  F1      	        POP     AF              ; Get number of dimensions
2239:	1002  EB      	        EX      DE,HL
2240:	1003  E3      	        EX      (SP),HL         ; Save subscript value
2241:	1004  E5      	        PUSH    HL              ; Save LCRFLG and TYPE
2242:	1005  EB      	        EX      DE,HL
2243:	1006  3C      	        INC     A               ; Count dimensions
2244:	1007  57      	        LD      D,A             ; Save in D
2245:	1008  7E      	        LD      A,(HL)          ; Get next byte in code string
2246:	1009  FE2C    	        CP      ','             ; Comma (more to come)?
2247:	100B  CAFB0F  	        JP      Z,SCPTLP        ; Yes - More subscripts
2248:	100E  CD4B07  	        CALL    CHKSYN          ; Make sure ")" follows
2249:	1011  29      	        .DB     ")"
2250:	1012  22D020  	        LD      (NXTOPR),HL     ; Save code string address
2251:	1015  E1      	        POP     HL              ; Get LCRFLG and TYPE
2252:	1016  22AC20  	        LD      (LCRFLG),HL     ; Restore Locate/create & type
2253:	1019  1E00    	        LD      E,0             ; Flag not CSAVE* or CLOAD*
2254:	101B  D5      	        PUSH    DE              ; Save number of dimensions (D)
2255:	101C  11      	        .DB     11H             ; Skip "PUSH HL" and "PUSH AF'
2256:			
2257:	101D  E5      	ARLDSV: PUSH    HL              ; Save code string address
2258:	101E  F5      	        PUSH    AF              ; A = 00 , Flags set = Z,N
2259:	101F  2AD820  	        LD      HL,(VAREND)     ; Start of arrays
2260:	1022  3E      	        .DB     3EH             ; Skip "ADD HL,DE"
2261:	1023  19      	FNDARY: ADD     HL,DE           ; Move to next array start
2262:	1024  EB      	        EX      DE,HL
2263:	1025  2ADA20  	        LD      HL,(ARREND)     ; End of arrays
2264:	1028  EB      	        EX      DE,HL           ; Current array pointer
2265:	1029  CD4507  	        CALL    CPDEHL          ; End of arrays found?
2266:	102C  CA5510  	        JP      Z,CREARY        ; Yes - Create array
2267:	102F  7E      	        LD      A,(HL)          ; Get second byte of name
2268:	1030  B9      	        CP      C               ; Compare with name given
2269:	1031  23      	        INC     HL              ; Move on
2270:	1032  C23710  	        JP      NZ,NXTARY       ; Different - Find next array
2271:	1035  7E      	        LD      A,(HL)          ; Get first byte of name
2272:	1036  B8      	        CP      B               ; Compare with name given
2273:	1037  23      	NXTARY: INC     HL              ; Move on
2274:	1038  5E      	        LD      E,(HL)          ; Get LSB of next array address
2275:	1039  23      	        INC     HL
2276:	103A  56      	        LD      D,(HL)          ; Get MSB of next array address
2277:	103B  23      	        INC     HL
2278:	103C  C22310  	        JP      NZ,FNDARY       ; Not found - Keep looking
2279:	103F  3AAC20  	        LD      A,(LCRFLG)      ; Found Locate or Create it?
2280:	1042  B7      	        OR      A
2281:	1043  C2BA04  	        JP      NZ,DDERR        ; Create - ?DD Error
2282:	1046  F1      	        POP     AF              ; Locate - Get number of dim'ns
2283:	1047  44      	        LD      B,H             ; BC Points to array dim'ns
2284:	1048  4D      	        LD      C,L
2285:	1049  CA6516  	        JP      Z,POPHRT        ; Jump if array load/save
2286:	104C  96      	        SUB     (HL)            ; Same number of dimensions?
2287:	104D  CAB310  	        JP      Z,FINDEL        ; Yes - Find element
2288:	1050  1E10    	BSERR:  LD      E,BS            ; ?BS Error
2289:	1052  C3C504  	        JP      ERROR           ; Output error
2290:			
2291:	1055  110400  	CREARY: LD      DE,4            ; 4 Bytes per entry
2292:	1058  F1      	        POP     AF              ; Array to save or 0 dim'ns?
2293:	1059  CA9C09  	        JP      Z,FCERR         ; Yes - ?FC Error
2294:	105C  71      	        LD      (HL),C          ; Save second byte of name
2295:	105D  23      	        INC     HL
2296:	105E  70      	        LD      (HL),B          ; Save first byte of name
2297:	105F  23      	        INC     HL
2298:	1060  4F      	        LD      C,A             ; Number of dimensions to C
2299:	1061  CD8E04  	        CALL    CHKSTK          ; Check if enough memory
2300:	1064  23      	        INC     HL              ; Point to number of dimensions
2301:	1065  23      	        INC     HL
2302:	1066  22C520  	        LD      (CUROPR),HL     ; Save address of pointer
2303:	1069  71      	        LD      (HL),C          ; Set number of dimensions
2304:	106A  23      	        INC     HL
2305:	106B  3AAC20  	        LD      A,(LCRFLG)      ; Locate of Create?
2306:	106E  17      	        RLA                     ; Carry set = Create
2307:	106F  79      	        LD      A,C             ; Get number of dimensions
2308:	1070  010B00  	CRARLP: LD      BC,10+1         ; Default dimension size 10
2309:	1073  D27810  	        JP      NC,DEFSIZ       ; Locate - Set default size
2310:	1076  C1      	        POP     BC              ; Get specified dimension size
2311:	1077  03      	        INC     BC              ; Include zero element
2312:	1078  71      	DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
2313:	1079  23      	        INC     HL
2314:	107A  70      	        LD      (HL),B          ; Save MSB of dimension size
2315:	107B  23      	        INC     HL
2316:	107C  F5      	        PUSH    AF              ; Save num' of dim'ns an status
2317:	107D  E5      	        PUSH    HL              ; Save address of dim'n size
2318:	107E  CD1018  	        CALL    MLDEBC          ; Multiply DE by BC to find
2319:	1081  EB      	        EX      DE,HL           ; amount of mem needed (to DE)
2320:	1082  E1      	        POP     HL              ; Restore address of dimension
2321:	1083  F1      	        POP     AF              ; Restore number of dimensions
2322:	1084  3D      	        DEC     A               ; Count them
2323:	1085  C27010  	        JP      NZ,CRARLP       ; Do next dimension if more
2324:	1088  F5      	        PUSH    AF              ; Save locate/create flag
2325:	1089  42      	        LD      B,D             ; MSB of memory needed
2326:	108A  4B      	        LD      C,E             ; LSB of memory needed
2327:	108B  EB      	        EX      DE,HL
2328:	108C  19      	        ADD     HL,DE           ; Add bytes to array start
2329:	108D  DAA604  	        JP      C,OMERR         ; Too big - Error
2330:	1090  CD9704  	        CALL    ENFMEM          ; See if enough memory
2331:	1093  22DA20  	        LD      (ARREND),HL     ; Save new end of array
2332:			
2333:	1096  2B      	ZERARY: DEC     HL              ; Back through array data
2334:	1097  3600    	        LD      (HL),0          ; Set array element to zero
2335:	1099  CD4507  	        CALL    CPDEHL          ; All elements zeroed?
2336:	109C  C29610  	        JP      NZ,ZERARY       ; No - Keep on going
2337:	109F  03      	        INC     BC              ; Number of bytes + 1
2338:	10A0  57      	        LD      D,A             ; A=0
2339:	10A1  2AC520  	        LD      HL,(CUROPR)     ; Get address of array
2340:	10A4  5E      	        LD      E,(HL)          ; Number of dimensions
2341:	10A5  EB      	        EX      DE,HL           ; To HL
2342:	10A6  29      	        ADD     HL,HL           ; Two bytes per dimension size
2343:	10A7  09      	        ADD     HL,BC           ; Add number of bytes
2344:	10A8  EB      	        EX      DE,HL           ; Bytes needed to DE
2345:	10A9  2B      	        DEC     HL
2346:	10AA  2B      	        DEC     HL
2347:	10AB  73      	        LD      (HL),E          ; Save LSB of bytes needed
2348:	10AC  23      	        INC     HL
2349:	10AD  72      	        LD      (HL),D          ; Save MSB of bytes needed
2350:	10AE  23      	        INC     HL
2351:	10AF  F1      	        POP     AF              ; Locate / Create?
2352:	10B0  DAD710  	        JP      C,ENDDIM        ; A is 0 , End if create
2353:	10B3  47      	FINDEL: LD      B,A             ; Find array element
2354:	10B4  4F      	        LD      C,A
2355:	10B5  7E      	        LD      A,(HL)          ; Number of dimensions
2356:	10B6  23      	        INC     HL
2357:	10B7  16      	        .DB     16H             ; Skip "POP HL"
2358:	10B8  E1      	FNDELP: POP     HL              ; Address of next dim' size
2359:	10B9  5E      	        LD      E,(HL)          ; Get LSB of dim'n size
2360:	10BA  23      	        INC     HL
2361:	10BB  56      	        LD      D,(HL)          ; Get MSB of dim'n size
2362:	10BC  23      	        INC     HL
2363:	10BD  E3      	        EX      (SP),HL         ; Save address - Get index
2364:	10BE  F5      	        PUSH    AF              ; Save number of dim'ns
2365:	10BF  CD4507  	        CALL    CPDEHL          ; Dimension too large?
2366:	10C2  D25010  	        JP      NC,BSERR        ; Yes - ?BS Error
2367:	10C5  E5      	        PUSH    HL              ; Save index
2368:	10C6  CD1018  	        CALL    MLDEBC          ; Multiply previous by size
2369:	10C9  D1      	        POP     DE              ; Index supplied to DE
2370:	10CA  19      	        ADD     HL,DE           ; Add index to pointer
2371:	10CB  F1      	        POP     AF              ; Number of dimensions
2372:	10CC  3D      	        DEC     A               ; Count them
2373:	10CD  44      	        LD      B,H             ; MSB of pointer
2374:	10CE  4D      	        LD      C,L             ; LSB of pointer
2375:	10CF  C2B810  	        JP      NZ,FNDELP       ; More - Keep going
2376:	10D2  29      	        ADD     HL,HL           ; 4 Bytes per element
2377:	10D3  29      	        ADD     HL,HL
2378:	10D4  C1      	        POP     BC              ; Start of array
2379:	10D5  09      	        ADD     HL,BC           ; Point to element
2380:	10D6  EB      	        EX      DE,HL           ; Address of element to DE
2381:	10D7  2AD020  	ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
2382:	10DA  C9      	        RET
2383:			
2384:	10DB  2ADA20  	FRE:    LD      HL,(ARREND)     ; Start of free memory
2385:	10DE  EB      	        EX      DE,HL           ; To DE
2386:	10DF  210000  	        LD      HL,0            ; End of free memory
2387:	10E2  39      	        ADD     HL,SP           ; Current stack value
2388:	10E3  3AAD20  	        LD      A,(TYPE)        ; Dummy argument type
2389:	10E6  B7      	        OR      A
2390:	10E7  CAF710  	        JP      Z,FRENUM        ; Numeric - Free variable space
2391:	10EA  CD5E13  	        CALL    GSTRCU          ; Current string to pool
2392:	10ED  CD5E12  	        CALL    GARBGE          ; Garbage collection
2393:	10F0  2A5A20  	        LD      HL,(STRSPC)     ; Bottom of string space in use
2394:	10F3  EB      	        EX      DE,HL           ; To DE
2395:	10F4  2AC320  	        LD      HL,(STRBOT)     ; Bottom of string space
2396:	10F7  7D      	FRENUM: LD      A,L             ; Get LSB of end
2397:	10F8  93      	        SUB     E               ; Subtract LSB of beginning
2398:	10F9  4F      	        LD      C,A             ; Save difference if C
2399:	10FA  7C      	        LD      A,H             ; Get MSB of end
2400:	10FB  9A      	        SBC     A,D             ; Subtract MSB of beginning
2401:	10FC  41      	ACPASS: LD      B,C             ; Return integer AC
2402:	10FD  50      	ABPASS: LD      D,B             ; Return integer AB
2403:	10FE  1E00    	        LD      E,0
2404:	1100  21AD20  	        LD      HL,TYPE         ; Point to type
2405:	1103  73      	        LD      (HL),E          ; Set type to numeric
2406:	1104  0690    	        LD      B,80H+16        ; 16 bit integer
2407:	1106  C33B17  	        JP      RETINT          ; Return the integr
2408:			
2409:	1109  3AAB20  	POS:    LD      A,(CURPOS)      ; Get cursor position
2410:	110C  47      	PASSA:  LD      B,A             ; Put A into AB
2411:	110D  AF      	        XOR     A               ; Zero A
2412:	110E  C3FD10  	        JP      ABPASS          ; Return integer AB
2413:			
2414:	1111  CD9411  	DEF:    CALL    CHEKFN          ; Get "FN" and name
2415:	1114  CD8611  	        CALL    IDTEST          ; Test for illegal direct
2416:	1117  016C0A  	        LD      BC,DATA         ; To get next statement
2417:	111A  C5      	        PUSH    BC              ; Save address for RETurn
2418:	111B  D5      	        PUSH    DE              ; Save address of function ptr
2419:	111C  CD4B07  	        CALL    CHKSYN          ; Make sure "(" follows
2420:	111F  28      	        .DB     "("
2421:	1120  CD380F  	        CALL    GETVAR          ; Get argument variable name
2422:	1123  E5      	        PUSH    HL              ; Save code string address
2423:	1124  EB      	        EX      DE,HL           ; Argument address to HL
2424:	1125  2B      	        DEC     HL
2425:	1126  56      	        LD      D,(HL)          ; Get first byte of arg name
2426:	1127  2B      	        DEC     HL
2427:	1128  5E      	        LD      E,(HL)          ; Get second byte of arg name
2428:	1129  E1      	        POP     HL              ; Restore code string address
2429:	112A  CD450D  	        CALL    TSTNUM          ; Make sure numeric argument
2430:	112D  CD4B07  	        CALL    CHKSYN          ; Make sure ")" follows
2431:	1130  29      	        .DB     ")"
2432:	1131  CD4B07  	        CALL    CHKSYN          ; Make sure "=" follows
2433:	1134  B4      	        .DB     ZEQUAL          ; "=" token
2434:	1135  44      	        LD      B,H             ; Code string address to BC
2435:	1136  4D      	        LD      C,L
2436:	1137  E3      	        EX      (SP),HL         ; Save code str , Get FN ptr
2437:	1138  71      	        LD      (HL),C          ; Save LSB of FN code string
2438:	1139  23      	        INC     HL
2439:	113A  70      	        LD      (HL),B          ; Save MSB of FN code string
2440:	113B  C3D311  	        JP      SVSTAD          ; Save address and do function
2441:			
2442:	113E  CD9411  	DOFN:   CALL    CHEKFN          ; Make sure FN follows
2443:	1141  D5      	        PUSH    DE              ; Save function pointer address
2444:	1142  CD190E  	        CALL    EVLPAR          ; Evaluate expression in "()"
2445:	1145  CD450D  	        CALL    TSTNUM          ; Make sure numeric result
2446:	1148  E3      	        EX      (SP),HL         ; Save code str , Get FN ptr
2447:	1149  5E      	        LD      E,(HL)          ; Get LSB of FN code string
2448:	114A  23      	        INC     HL
2449:	114B  56      	        LD      D,(HL)          ; Get MSB of FN code string
2450:	114C  23      	        INC     HL
2451:	114D  7A      	        LD      A,D             ; And function DEFined?
2452:	114E  B3      	        OR      E
2453:	114F  CABD04  	        JP      Z,UFERR         ; No - ?UF Error
2454:	1152  7E      	        LD      A,(HL)          ; Get LSB of argument address
2455:	1153  23      	        INC     HL
2456:	1154  66      	        LD      H,(HL)          ; Get MSB of argument address
2457:	1155  6F      	        LD      L,A             ; HL = Arg variable address
2458:	1156  E5      	        PUSH    HL              ; Save it
2459:	1157  2ADE20  	        LD      HL,(FNRGNM)     ; Get old argument name
2460:	115A  E3      	        EX      (SP),HL ;       ; Save old , Get new
2461:	115B  22DE20  	        LD      (FNRGNM),HL     ; Set new argument name
2462:	115E  2AE220  	        LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2463:	1161  E5      	        PUSH    HL              ; Save it
2464:	1162  2AE020  	        LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
2465:	1165  E5      	        PUSH    HL              ; Save it
2466:	1166  21E020  	        LD      HL,FNARG        ; HL = Value of argument
2467:	1169  D5      	        PUSH    DE              ; Save FN code string address
2468:	116A  CD7C17  	        CALL    FPTHL           ; Move FPREG to argument
2469:	116D  E1      	        POP     HL              ; Get FN code string address
2470:	116E  CD420D  	        CALL    GETNUM          ; Get value from function
2471:	1171  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
2472:	1172  CDD508  	        CALL    GETCHR          ; Get next character
2473:	1175  C2B104  	        JP      NZ,SNERR        ; Bad character in FN - Error
2474:	1178  E1      	        POP     HL              ; Get MSB,EXP of old arg
2475:	1179  22E020  	        LD      (FNARG),HL      ; Restore it
2476:	117C  E1      	        POP     HL              ; Get LSB,NLSB of old arg
2477:	117D  22E220  	        LD      (FNARG+2),HL    ; Restore it
2478:	1180  E1      	        POP     HL              ; Get name of old arg
2479:	1181  22DE20  	        LD      (FNRGNM),HL     ; Restore it
2480:	1184  E1      	        POP     HL              ; Restore code string address
2481:	1185  C9      	        RET
2482:			
2483:	1186  E5      	IDTEST: PUSH    HL              ; Save code string address
2484:	1187  2A5C20  	        LD      HL,(LINEAT)     ; Get current line number
2485:	118A  23      	        INC     HL              ; -1 means direct statement
2486:	118B  7C      	        LD      A,H
2487:	118C  B5      	        OR      L
2488:	118D  E1      	        POP     HL              ; Restore code string address
2489:	118E  C0      	        RET     NZ              ; Return if in program
2490:	118F  1E16    	        LD      E,ID            ; ?ID Error
2491:	1191  C3C504  	        JP      ERROR
2492:			
2493:	1194  CD4B07  	CHEKFN: CALL    CHKSYN          ; Make sure FN follows
2494:	1197  A7      	        .DB     ZFN             ; "FN" token
2495:	1198  3E80    	        LD      A,80H
2496:	119A  32CB20  	        LD      (FORFLG),A      ; Flag FN name to find
2497:	119D  B6      	        OR      (HL)            ; FN name has bit 7 set
2498:	119E  47      	        LD      B,A             ; in first byte of name
2499:	119F  CD3D0F  	        CALL    GTFNAM          ; Get FN name
2500:	11A2  C3450D  	        JP      TSTNUM          ; Make sure numeric function
2501:			
2502:	11A5  CD450D  	STR:    CALL    TSTNUM          ; Make sure it's a number
2503:	11A8  CDC918  	        CALL    NUMASC          ; Turn number into text
2504:	11AB  CDD911  	STR1:   CALL    CRTST           ; Create string entry for it
2505:	11AE  CD5E13  	        CALL    GSTRCU          ; Current string to pool
2506:	11B1  01B913  	        LD      BC,TOPOOL       ; Save in string pool
2507:	11B4  C5      	        PUSH    BC              ; Save address on stack
2508:			
2509:	11B5  7E      	SAVSTR: LD      A,(HL)          ; Get string length
2510:	11B6  23      	        INC     HL
2511:	11B7  23      	        INC     HL
2512:	11B8  E5      	        PUSH    HL              ; Save pointer to string
2513:	11B9  CD3412  	        CALL    TESTR           ; See if enough string space
2514:	11BC  E1      	        POP     HL              ; Restore pointer to string
2515:	11BD  4E      	        LD      C,(HL)          ; Get LSB of address
2516:	11BE  23      	        INC     HL
2517:	11BF  46      	        LD      B,(HL)          ; Get MSB of address
2518:	11C0  CDCD11  	        CALL    CRTMST          ; Create string entry
2519:	11C3  E5      	        PUSH    HL              ; Save pointer to MSB of addr
2520:	11C4  6F      	        LD      L,A             ; Length of string
2521:	11C5  CD5113  	        CALL    TOSTRA          ; Move to string area
2522:	11C8  D1      	        POP     DE              ; Restore pointer to MSB
2523:	11C9  C9      	        RET
2524:			
2525:	11CA  CD3412  	MKTMST: CALL    TESTR           ; See if enough string space
2526:	11CD  21BF20  	CRTMST: LD      HL,TMPSTR       ; Temporary string
2527:	11D0  E5      	        PUSH    HL              ; Save it
2528:	11D1  77      	        LD      (HL),A          ; Save length of string
2529:	11D2  23      	        INC     HL
2530:	11D3  23      	SVSTAD: INC     HL
2531:	11D4  73      	        LD      (HL),E          ; Save LSB of address
2532:	11D5  23      	        INC     HL
2533:	11D6  72      	        LD      (HL),D          ; Save MSB of address
2534:	11D7  E1      	        POP     HL              ; Restore pointer
2535:	11D8  C9      	        RET
2536:			
2537:	11D9  2B      	CRTST:  DEC     HL              ; DEC - INCed after
2538:	11DA  0622    	QTSTR:  LD      B,'"'           ; Terminating quote
2539:	11DC  50      	        LD      D,B             ; Quote to D
2540:	11DD  E5      	DTSTR:  PUSH    HL              ; Save start
2541:	11DE  0EFF    	        LD      C,-1            ; Set counter to -1
2542:	11E0  23      	QTSTLP: INC     HL              ; Move on
2543:	11E1  7E      	        LD      A,(HL)          ; Get byte
2544:	11E2  0C      	        INC     C               ; Count bytes
2545:	11E3  B7      	        OR      A               ; End of line?
2546:	11E4  CAEF11  	        JP      Z,CRTSTE        ; Yes - Create string entry
2547:	11E7  BA      	        CP      D               ; Terminator D found?
2548:	11E8  CAEF11  	        JP      Z,CRTSTE        ; Yes - Create string entry
2549:	11EB  B8      	        CP      B               ; Terminator B found?
2550:	11EC  C2E011  	        JP      NZ,QTSTLP       ; No - Keep looking
2551:	11EF  FE22    	CRTSTE: CP      '"'             ; End with '"'?
2552:	11F1  CCD508  	        CALL    Z,GETCHR        ; Yes - Get next character
2553:	11F4  E3      	        EX      (SP),HL         ; Starting quote
2554:	11F5  23      	        INC     HL              ; First byte of string
2555:	11F6  EB      	        EX      DE,HL           ; To DE
2556:	11F7  79      	        LD      A,C             ; Get length
2557:	11F8  CDCD11  	        CALL    CRTMST          ; Create string entry
2558:	11FB  11BF20  	TSTOPL: LD      DE,TMPSTR       ; Temporary string
2559:	11FE  2AB120  	        LD      HL,(TMSTPT)     ; Temporary string pool pointer
2560:	1201  22E420  	        LD      (FPREG),HL      ; Save address of string ptr
2561:	1204  3E01    	        LD      A,1
2562:	1206  32AD20  	        LD      (TYPE),A        ; Set type to string
2563:	1209  CD7F17  	        CALL    DETHL4          ; Move string to pool
2564:	120C  CD4507  	        CALL    CPDEHL          ; Out of string pool?
2565:	120F  22B120  	        LD      (TMSTPT),HL     ; Save new pointer
2566:	1212  E1      	        POP     HL              ; Restore code string address
2567:	1213  7E      	        LD      A,(HL)          ; Get next code byte
2568:	1214  C0      	        RET     NZ              ; Return if pool OK
2569:	1215  1E1E    	        LD      E,ST            ; ?ST Error
2570:	1217  C3C504  	        JP      ERROR           ; String pool overflow
2571:			
2572:	121A  23      	PRNUMS: INC     HL              ; Skip leading space
2573:	121B  CDD911  	PRS:    CALL    CRTST           ; Create string entry for it
2574:	121E  CD5E13  	PRS1:   CALL    GSTRCU          ; Current string to pool
2575:	1221  CD7317  	        CALL    LOADFP          ; Move string block to BCDE
2576:	1224  1C      	        INC     E               ; Length + 1
2577:	1225  1D      	PRSLP:  DEC     E               ; Count characters
2578:	1226  C8      	        RET     Z               ; End of string
2579:	1227  0A      	        LD      A,(BC)          ; Get byte to output
2580:	1228  CD5607  	        CALL    OUTC            ; Output character in A
2581:	122B  FE0D    	        CP      CR              ; Return?
2582:	122D  CC870B  	        CALL    Z,DONULL        ; Yes - Do nulls
2583:	1230  03      	        INC     BC              ; Next byte in string
2584:	1231  C32512  	        JP      PRSLP           ; More characters to output
2585:			
2586:	1234  B7      	TESTR:  OR      A               ; Test if enough room
2587:	1235  0E      	        .DB     0EH             ; No garbage collection done
2588:	1236  F1      	GRBDON: POP     AF              ; Garbage collection done
2589:	1237  F5      	        PUSH    AF              ; Save status
2590:	1238  2A5A20  	        LD      HL,(STRSPC)     ; Bottom of string space in use
2591:	123B  EB      	        EX      DE,HL           ; To DE
2592:	123C  2AC320  	        LD      HL,(STRBOT)     ; Bottom of string area
2593:	123F  2F      	        CPL                     ; Negate length (Top down)
2594:	1240  4F      	        LD      C,A             ; -Length to BC
2595:	1241  06FF    	        LD      B,-1            ; BC = -ve length of string
2596:	1243  09      	        ADD     HL,BC           ; Add to bottom of space in use
2597:	1244  23      	        INC     HL              ; Plus one for 2's complement
2598:	1245  CD4507  	        CALL    CPDEHL          ; Below string RAM area?
2599:	1248  DA5212  	        JP      C,TESTOS        ; Tidy up if not done else err
2600:	124B  22C320  	        LD      (STRBOT),HL     ; Save new bottom of area
2601:	124E  23      	        INC     HL              ; Point to first byte of string
2602:	124F  EB      	        EX      DE,HL           ; Address to DE
2603:	1250  F1      	POPAF:  POP     AF              ; Throw away status push
2604:	1251  C9      	        RET
2605:			
2606:	1252  F1      	TESTOS: POP     AF              ; Garbage collect been done?
2607:	1253  1E1A    	        LD      E,OS            ; ?OS Error
2608:	1255  CAC504  	        JP      Z,ERROR         ; Yes - Not enough string apace
2609:	1258  BF      	        CP      A               ; Flag garbage collect done
2610:	1259  F5      	        PUSH    AF              ; Save status
2611:	125A  013612  	        LD      BC,GRBDON       ; Garbage collection done
2612:	125D  C5      	        PUSH    BC              ; Save for RETurn
2613:	125E  2AAF20  	GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
2614:	1261  22C320  	GARBLP: LD      (STRBOT),HL     ; Reset string pointer
2615:	1264  210000  	        LD      HL,0
2616:	1267  E5      	        PUSH    HL              ; Flag no string found
2617:	1268  2A5A20  	        LD      HL,(STRSPC)     ; Get bottom of string space
2618:	126B  E5      	        PUSH    HL              ; Save bottom of string space
2619:	126C  21B320  	        LD      HL,TMSTPL       ; Temporary string pool
2620:	126F  EB      	GRBLP:  EX      DE,HL
2621:	1270  2AB120  	        LD      HL,(TMSTPT)     ; Temporary string pool pointer
2622:	1273  EB      	        EX      DE,HL
2623:	1274  CD4507  	        CALL    CPDEHL          ; Temporary string pool done?
2624:	1277  016F12  	        LD      BC,GRBLP        ; Loop until string pool done
2625:	127A  C2C312  	        JP      NZ,STPOOL       ; No - See if in string area
2626:	127D  2AD620  	        LD      HL,(PROGND)     ; Start of simple variables
2627:	1280  EB      	SMPVAR: EX      DE,HL
2628:	1281  2AD820  	        LD      HL,(VAREND)     ; End of simple variables
2629:	1284  EB      	        EX      DE,HL
2630:	1285  CD4507  	        CALL    CPDEHL          ; All simple strings done?
2631:	1288  CA9612  	        JP      Z,ARRLP         ; Yes - Do string arrays
2632:	128B  7E      	        LD      A,(HL)          ; Get type of variable
2633:	128C  23      	        INC     HL
2634:	128D  23      	        INC     HL
2635:	128E  B7      	        OR      A               ; "S" flag set if string
2636:	128F  CDC612  	        CALL    STRADD          ; See if string in string area
2637:	1292  C38012  	        JP      SMPVAR          ; Loop until simple ones done
2638:			
2639:	1295  C1      	GNXARY: POP     BC              ; Scrap address of this array
2640:	1296  EB      	ARRLP:  EX      DE,HL
2641:	1297  2ADA20  	        LD      HL,(ARREND)     ; End of string arrays
2642:	129A  EB      	        EX      DE,HL
2643:	129B  CD4507  	        CALL    CPDEHL          ; All string arrays done?
2644:	129E  CAEC12  	        JP      Z,SCNEND        ; Yes - Move string if found
2645:	12A1  CD7317  	        CALL    LOADFP          ; Get array name to BCDE
2646:	12A4  7B      	        LD      A,E             ; Get type of array     
2647:	12A5  E5      	        PUSH    HL              ; Save address of num of dim'ns
2648:	12A6  09      	        ADD     HL,BC           ; Start of next array
2649:	12A7  B7      	        OR      A               ; Test type of array
2650:	12A8  F29512  	        JP      P,GNXARY        ; Numeric array - Ignore it
2651:	12AB  22C520  	        LD      (CUROPR),HL     ; Save address of next array
2652:	12AE  E1      	        POP     HL              ; Get address of num of dim'ns
2653:	12AF  4E      	        LD      C,(HL)          ; BC = Number of dimensions
2654:	12B0  0600    	        LD      B,0
2655:	12B2  09      	        ADD     HL,BC           ; Two bytes per dimension size
2656:	12B3  09      	        ADD     HL,BC
2657:	12B4  23      	        INC     HL              ; Plus one for number of dim'ns
2658:	12B5  EB      	GRBARY: EX      DE,HL
2659:	12B6  2AC520  	        LD      HL,(CUROPR)     ; Get address of next array
2660:	12B9  EB      	        EX      DE,HL
2661:	12BA  CD4507  	        CALL    CPDEHL          ; Is this array finished?
2662:	12BD  CA9612  	        JP      Z,ARRLP         ; Yes - Get next one
2663:	12C0  01B512  	        LD      BC,GRBARY       ; Loop until array all done
2664:	12C3  C5      	STPOOL: PUSH    BC              ; Save return address
2665:	12C4  F680    	        OR      80H             ; Flag string type
2666:	12C6  7E      	STRADD: LD      A,(HL)          ; Get string length
2667:	12C7  23      	        INC     HL
2668:	12C8  23      	        INC     HL
2669:	12C9  5E      	        LD      E,(HL)          ; Get LSB of string address
2670:	12CA  23      	        INC     HL
2671:	12CB  56      	        LD      D,(HL)          ; Get MSB of string address
2672:	12CC  23      	        INC     HL
2673:	12CD  F0      	        RET     P               ; Not a string - Return
2674:	12CE  B7      	        OR      A               ; Set flags on string length
2675:	12CF  C8      	        RET     Z               ; Null string - Return
2676:	12D0  44      	        LD      B,H             ; Save variable pointer
2677:	12D1  4D      	        LD      C,L
2678:	12D2  2AC320  	        LD      HL,(STRBOT)     ; Bottom of new area
2679:	12D5  CD4507  	        CALL    CPDEHL          ; String been done?
2680:	12D8  60      	        LD      H,B             ; Restore variable pointer
2681:	12D9  69      	        LD      L,C
2682:	12DA  D8      	        RET     C               ; String done - Ignore
2683:	12DB  E1      	        POP     HL              ; Return address
2684:	12DC  E3      	        EX      (SP),HL         ; Lowest available string area
2685:	12DD  CD4507  	        CALL    CPDEHL          ; String within string area?
2686:	12E0  E3      	        EX      (SP),HL         ; Lowest available string area
2687:	12E1  E5      	        PUSH    HL              ; Re-save return address
2688:	12E2  60      	        LD      H,B             ; Restore variable pointer
2689:	12E3  69      	        LD      L,C
2690:	12E4  D0      	        RET     NC              ; Outside string area - Ignore
2691:	12E5  C1      	        POP     BC              ; Get return , Throw 2 away
2692:	12E6  F1      	        POP     AF              ; 
2693:	12E7  F1      	        POP     AF              ; 
2694:	12E8  E5      	        PUSH    HL              ; Save variable pointer
2695:	12E9  D5      	        PUSH    DE              ; Save address of current
2696:	12EA  C5      	        PUSH    BC              ; Put back return address
2697:	12EB  C9      	        RET                     ; Go to it
2698:			
2699:	12EC  D1      	SCNEND: POP     DE              ; Addresses of strings
2700:	12ED  E1      	        POP     HL              ; 
2701:	12EE  7D      	        LD      A,L             ; HL = 0 if no more to do
2702:	12EF  B4      	        OR      H
2703:	12F0  C8      	        RET     Z               ; No more to do - Return
2704:	12F1  2B      	        DEC     HL
2705:	12F2  46      	        LD      B,(HL)          ; MSB of address of string
2706:	12F3  2B      	        DEC     HL
2707:	12F4  4E      	        LD      C,(HL)          ; LSB of address of string
2708:	12F5  E5      	        PUSH    HL              ; Save variable address
2709:	12F6  2B      	        DEC     HL
2710:	12F7  2B      	        DEC     HL
2711:	12F8  6E      	        LD      L,(HL)          ; HL = Length of string
2712:	12F9  2600    	        LD      H,0
2713:	12FB  09      	        ADD     HL,BC           ; Address of end of string+1
2714:	12FC  50      	        LD      D,B             ; String address to DE
2715:	12FD  59      	        LD      E,C
2716:	12FE  2B      	        DEC     HL              ; Last byte in string
2717:	12FF  44      	        LD      B,H             ; Address to BC
2718:	1300  4D      	        LD      C,L
2719:	1301  2AC320  	        LD      HL,(STRBOT)     ; Current bottom of string area
2720:	1304  CD8004  	        CALL    MOVSTR          ; Move string to new address
2721:	1307  E1      	        POP     HL              ; Restore variable address
2722:	1308  71      	        LD      (HL),C          ; Save new LSB of address
2723:	1309  23      	        INC     HL
2724:	130A  70      	        LD      (HL),B          ; Save new MSB of address
2725:	130B  69      	        LD      L,C             ; Next string area+1 to HL
2726:	130C  60      	        LD      H,B
2727:	130D  2B      	        DEC     HL              ; Next string area address
2728:	130E  C36112  	        JP      GARBLP          ; Look for more strings
2729:			
2730:	1311  C5      	CONCAT: PUSH    BC              ; Save prec' opr & code string
2731:	1312  E5      	        PUSH    HL              ; 
2732:	1313  2AE420  	        LD      HL,(FPREG)      ; Get first string
2733:	1316  E3      	        EX      (SP),HL         ; Save first string
2734:	1317  CDCB0D  	        CALL    OPRND           ; Get second string
2735:	131A  E3      	        EX      (SP),HL         ; Restore first string
2736:	131B  CD460D  	        CALL    TSTSTR          ; Make sure it's a string
2737:	131E  7E      	        LD      A,(HL)          ; Get length of second string
2738:	131F  E5      	        PUSH    HL              ; Save first string
2739:	1320  2AE420  	        LD      HL,(FPREG)      ; Get second string
2740:	1323  E5      	        PUSH    HL              ; Save second string
2741:	1324  86      	        ADD     A,(HL)          ; Add length of second string
2742:	1325  1E1C    	        LD      E,LS            ; ?LS Error
2743:	1327  DAC504  	        JP      C,ERROR         ; String too long - Error
2744:	132A  CDCA11  	        CALL    MKTMST          ; Make temporary string
2745:	132D  D1      	        POP     DE              ; Get second string to DE
2746:	132E  CD6213  	        CALL    GSTRDE          ; Move to string pool if needed
2747:	1331  E3      	        EX      (SP),HL         ; Get first string
2748:	1332  CD6113  	        CALL    GSTRHL          ; Move to string pool if needed
2749:	1335  E5      	        PUSH    HL              ; Save first string
2750:	1336  2AC120  	        LD      HL,(TMPSTR+2)   ; Temporary string address
2751:	1339  EB      	        EX      DE,HL           ; To DE
2752:	133A  CD4813  	        CALL    SSTSA           ; First string to string area
2753:	133D  CD4813  	        CALL    SSTSA           ; Second string to string area
2754:	1340  21600D  	        LD      HL,EVAL2        ; Return to evaluation loop
2755:	1343  E3      	        EX      (SP),HL         ; Save return,get code string
2756:	1344  E5      	        PUSH    HL              ; Save code string address
2757:	1345  C3FB11  	        JP      TSTOPL          ; To temporary string to pool
2758:			
2759:	1348  E1      	SSTSA:  POP     HL              ; Return address
2760:	1349  E3      	        EX      (SP),HL         ; Get string block,save return
2761:	134A  7E      	        LD      A,(HL)          ; Get length of string
2762:	134B  23      	        INC     HL
2763:	134C  23      	        INC     HL
2764:	134D  4E      	        LD      C,(HL)          ; Get LSB of string address
2765:	134E  23      	        INC     HL
2766:	134F  46      	        LD      B,(HL)          ; Get MSB of string address
2767:	1350  6F      	        LD      L,A             ; Length to L
2768:	1351  2C      	TOSTRA: INC     L               ; INC - DECed after
2769:	1352  2D      	TSALP:  DEC     L               ; Count bytes moved
2770:	1353  C8      	        RET     Z               ; End of string - Return
2771:	1354  0A      	        LD      A,(BC)          ; Get source
2772:	1355  12      	        LD      (DE),A          ; Save destination
2773:	1356  03      	        INC     BC              ; Next source
2774:	1357  13      	        INC     DE              ; Next destination
2775:	1358  C35213  	        JP      TSALP           ; Loop until string moved
2776:			
2777:	135B  CD460D  	GETSTR: CALL    TSTSTR          ; Make sure it's a string
2778:	135E  2AE420  	GSTRCU: LD      HL,(FPREG)      ; Get current string
2779:	1361  EB      	GSTRHL: EX      DE,HL           ; Save DE
2780:	1362  CD7C13  	GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
2781:	1365  EB      	        EX      DE,HL           ; Restore DE
2782:	1366  C0      	        RET     NZ              ; No - Return
2783:	1367  D5      	        PUSH    DE              ; Save string
2784:	1368  50      	        LD      D,B             ; String block address to DE
2785:	1369  59      	        LD      E,C
2786:	136A  1B      	        DEC     DE              ; Point to length
2787:	136B  4E      	        LD      C,(HL)          ; Get string length
2788:	136C  2AC320  	        LD      HL,(STRBOT)     ; Current bottom of string area
2789:	136F  CD4507  	        CALL    CPDEHL          ; Last one in string area?
2790:	1372  C27A13  	        JP      NZ,POPHL        ; No - Return
2791:	1375  47      	        LD      B,A             ; Clear B (A=0)
2792:	1376  09      	        ADD     HL,BC           ; Remove string from str' area
2793:	1377  22C320  	        LD      (STRBOT),HL     ; Save new bottom of str' area
2794:	137A  E1      	POPHL:  POP     HL              ; Restore string
2795:	137B  C9      	        RET
2796:			
2797:	137C  2AB120  	BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
2798:	137F  2B      	        DEC     HL              ; Back
2799:	1380  46      	        LD      B,(HL)          ; Get MSB of address
2800:	1381  2B      	        DEC     HL              ; Back
2801:	1382  4E      	        LD      C,(HL)          ; Get LSB of address
2802:	1383  2B      	        DEC     HL              ; Back
2803:	1384  2B      	        DEC     HL              ; Back
2804:	1385  CD4507  	        CALL    CPDEHL          ; String last in string pool?
2805:	1388  C0      	        RET     NZ              ; Yes - Leave it
2806:	1389  22B120  	        LD      (TMSTPT),HL     ; Save new string pool top
2807:	138C  C9      	        RET
2808:			
2809:	138D  010C11  	LEN:    LD      BC,PASSA        ; To return integer A
2810:	1390  C5      	        PUSH    BC              ; Save address
2811:	1391  CD5B13  	GETLEN: CALL    GETSTR          ; Get string and its length
2812:	1394  AF      	        XOR     A
2813:	1395  57      	        LD      D,A             ; Clear D
2814:	1396  32AD20  	        LD      (TYPE),A        ; Set type to numeric
2815:	1399  7E      	        LD      A,(HL)          ; Get length of string
2816:	139A  B7      	        OR      A               ; Set status flags
2817:	139B  C9      	        RET
2818:			
2819:	139C  010C11  	ASC:    LD      BC,PASSA        ; To return integer A
2820:	139F  C5      	        PUSH    BC              ; Save address
2821:	13A0  CD9113  	GTFLNM: CALL    GETLEN          ; Get length of string
2822:	13A3  CA9C09  	        JP      Z,FCERR         ; Null string - Error
2823:	13A6  23      	        INC     HL
2824:	13A7  23      	        INC     HL
2825:	13A8  5E      	        LD      E,(HL)          ; Get LSB of address
2826:	13A9  23      	        INC     HL
2827:	13AA  56      	        LD      D,(HL)          ; Get MSB of address
2828:	13AB  1A      	        LD      A,(DE)          ; Get first byte of string
2829:	13AC  C9      	        RET
2830:			
2831:	13AD  3E01    	CHR:    LD      A,1             ; One character string
2832:	13AF  CDCA11  	        CALL    MKTMST          ; Make a temporary string
2833:	13B2  CDA614  	        CALL    MAKINT          ; Make it integer A
2834:	13B5  2AC120  	        LD      HL,(TMPSTR+2)   ; Get address of string
2835:	13B8  73      	        LD      (HL),E          ; Save character
2836:	13B9  C1      	TOPOOL: POP     BC              ; Clean up stack
2837:	13BA  C3FB11  	        JP      TSTOPL          ; Temporary string to pool
2838:			
2839:	13BD  CD5614  	LEFT:   CALL    LFRGNM          ; Get number and ending ")"
2840:	13C0  AF      	        XOR     A               ; Start at first byte in string
2841:	13C1  E3      	RIGHT1: EX      (SP),HL         ; Save code string,Get string
2842:	13C2  4F      	        LD      C,A             ; Starting position in string
2843:	13C3  E5      	MID1:   PUSH    HL              ; Save string block address
2844:	13C4  7E      	        LD      A,(HL)          ; Get length of string
2845:	13C5  B8      	        CP      B               ; Compare with number given
2846:	13C6  DACB13  	        JP      C,ALLFOL        ; All following bytes required
2847:	13C9  78      	        LD      A,B             ; Get new length
2848:	13CA  11      	        .DB     11H             ; Skip "LD C,0"
2849:	13CB  0E00    	ALLFOL: LD      C,0             ; First byte of string
2850:	13CD  C5      	        PUSH    BC              ; Save position in string
2851:	13CE  CD3412  	        CALL    TESTR           ; See if enough string space
2852:	13D1  C1      	        POP     BC              ; Get position in string
2853:	13D2  E1      	        POP     HL              ; Restore string block address
2854:	13D3  E5      	        PUSH    HL              ; And re-save it
2855:	13D4  23      	        INC     HL
2856:	13D5  23      	        INC     HL
2857:	13D6  46      	        LD      B,(HL)          ; Get LSB of address
2858:	13D7  23      	        INC     HL
2859:	13D8  66      	        LD      H,(HL)          ; Get MSB of address
2860:	13D9  68      	        LD      L,B             ; HL = address of string
2861:	13DA  0600    	        LD      B,0             ; BC = starting address
2862:	13DC  09      	        ADD     HL,BC           ; Point to that byte
2863:	13DD  44      	        LD      B,H             ; BC = source string
2864:	13DE  4D      	        LD      C,L
2865:	13DF  CDCD11  	        CALL    CRTMST          ; Create a string entry
2866:	13E2  6F      	        LD      L,A             ; Length of new string
2867:	13E3  CD5113  	        CALL    TOSTRA          ; Move string to string area
2868:	13E6  D1      	        POP     DE              ; Clear stack
2869:	13E7  CD6213  	        CALL    GSTRDE          ; Move to string pool if needed
2870:	13EA  C3FB11  	        JP      TSTOPL          ; Temporary string to pool
2871:			
2872:	13ED  CD5614  	RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
2873:	13F0  D1      	        POP     DE              ; Get string length
2874:	13F1  D5      	        PUSH    DE              ; And re-save
2875:	13F2  1A      	        LD      A,(DE)          ; Get length
2876:	13F3  90      	        SUB     B               ; Move back N bytes
2877:	13F4  C3C113  	        JP      RIGHT1          ; Go and get sub-string
2878:			
2879:	13F7  EB      	MID:    EX      DE,HL           ; Get code string address
2880:	13F8  7E      	        LD      A,(HL)          ; Get next byte ',' or ")"
2881:	13F9  CD5B14  	        CALL    MIDNUM          ; Get number supplied
2882:	13FC  04      	        INC     B               ; Is it character zero?
2883:	13FD  05      	        DEC     B
2884:	13FE  CA9C09  	        JP      Z,FCERR         ; Yes - Error
2885:	1401  C5      	        PUSH    BC              ; Save starting position
2886:	1402  1EFF    	        LD      E,255           ; All of string
2887:	1404  FE29    	        CP      ')'             ; Any length given?
2888:	1406  CA1014  	        JP      Z,RSTSTR        ; No - Rest of string
2889:	1409  CD4B07  	        CALL    CHKSYN          ; Make sure ',' follows
2890:	140C  2C      	        .DB     ','
2891:	140D  CDA314  	        CALL    GETINT          ; Get integer 0-255
2892:	1410  CD4B07  	RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
2893:	1413  29      	        .DB     ")"
2894:	1414  F1      	        POP     AF              ; Restore starting position
2895:	1415  E3      	        EX      (SP),HL         ; Get string,8ave code string
2896:	1416  01C313  	        LD      BC,MID1         ; Continuation of MID$ routine
2897:	1419  C5      	        PUSH    BC              ; Save for return
2898:	141A  3D      	        DEC     A               ; Starting position-1
2899:	141B  BE      	        CP      (HL)            ; Compare with length
2900:	141C  0600    	        LD      B,0             ; Zero bytes length
2901:	141E  D0      	        RET     NC              ; Null string if start past end
2902:	141F  4F      	        LD      C,A             ; Save starting position-1
2903:	1420  7E      	        LD      A,(HL)          ; Get length of string
2904:	1421  91      	        SUB     C               ; Subtract start
2905:	1422  BB      	        CP      E               ; Enough string for it?
2906:	1423  47      	        LD      B,A             ; Save maximum length available
2907:	1424  D8      	        RET     C               ; Truncate string if needed
2908:	1425  43      	        LD      B,E             ; Set specified length
2909:	1426  C9      	        RET                     ; Go and create string
2910:			
2911:	1427  CD9113  	VAL:    CALL    GETLEN          ; Get length of string
2912:	142A  CA4415  	        JP      Z,RESZER        ; Result zero
2913:	142D  5F      	        LD      E,A             ; Save length
2914:	142E  23      	        INC     HL
2915:	142F  23      	        INC     HL
2916:	1430  7E      	        LD      A,(HL)          ; Get LSB of address
2917:	1431  23      	        INC     HL
2918:	1432  66      	        LD      H,(HL)          ; Get MSB of address
2919:	1433  6F      	        LD      L,A             ; HL = String address
2920:	1434  E5      	        PUSH    HL              ; Save string address
2921:	1435  19      	        ADD     HL,DE
2922:	1436  46      	        LD      B,(HL)          ; Get end of string+1 byte
2923:	1437  72      	        LD      (HL),D          ; Zero it to terminate
2924:	1438  E3      	        EX      (SP),HL         ; Save string end,get start
2925:	1439  C5      	        PUSH    BC              ; Save end+1 byte
2926:	143A  7E      	        LD      A,(HL)          ; Get starting byte
2927:	143B  FE24    	        CP      '$'             ; Hex number indicated? [function added]
2928:	143D  C24514  	        JP      NZ,VAL1
2929:	1440  CD6F1C  	        CALL    HEXTFP          ; Convert Hex to FPREG
2930:	1443  180D    	        JR      VAL3
2931:	1445  FE25    	VAL1:   CP	'%'             ; Binary number indicated? [function added]
2932:	1447  C24F14  	    JP	NZ,VAL2
2933:	144A  CDDF1C  	    CALL	BINTFP		; Convert Bin to FPREG
2934:	144D  1803    	    JR	VAL3
2935:	144F  CD2B18  	VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
2936:	1452  C1      	VAL3:   POP     BC              ; Restore end+1 byte
2937:	1453  E1      	        POP     HL              ; Restore end+1 address
2938:	1454  70      	        LD      (HL),B          ; Put back original byte
2939:	1455  C9      	        RET
2940:			
2941:	1456  EB      	LFRGNM: EX      DE,HL           ; Code string address to HL
2942:	1457  CD4B07  	        CALL    CHKSYN          ; Make sure ")" follows
2943:	145A  29      	        .DB     ")"
2944:	145B  C1      	MIDNUM: POP     BC              ; Get return address
2945:	145C  D1      	        POP     DE              ; Get number supplied
2946:	145D  C5      	        PUSH    BC              ; Re-save return address
2947:	145E  43      	        LD      B,E             ; Number to B
2948:	145F  C9      	        RET
2949:			
2950:	1460  CDA614  	INP:    CALL    MAKINT          ; Make it integer A
2951:	1463  323F20  	        LD      (INPORT),A      ; Set input port
2952:	1466  CD3E20  	        CALL    INPSUB          ; Get input from port
2953:	1469  C30C11  	        JP      PASSA           ; Return integer A
2954:			
2955:	146C  CD9014  	POUT:   CALL    SETIO           ; Set up port number
2956:	146F  C30620  	        JP      OUTSUB          ; Output data and return
2957:			
2958:	1472  CD9014  	WAIT:   CALL    SETIO           ; Set up port number
2959:	1475  F5      	        PUSH    AF              ; Save AND mask
2960:	1476  1E00    	        LD      E,0             ; Assume zero if none given
2961:	1478  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
2962:	1479  CDD508  	        CALL    GETCHR          ; Get next character
2963:	147C  CA8614  	        JP      Z,NOXOR         ; No XOR byte given
2964:	147F  CD4B07  	        CALL    CHKSYN          ; Make sure ',' follows
2965:	1482  2C      	        .DB     ','
2966:	1483  CDA314  	        CALL    GETINT          ; Get integer 0-255 to XOR with
2967:	1486  C1      	NOXOR:  POP     BC              ; Restore AND mask
2968:	1487  CD3E20  	WAITLP: CALL    INPSUB          ; Get input
2969:	148A  AB      	        XOR     E               ; Flip selected bits
2970:	148B  A0      	        AND     B               ; Result non-zero?
2971:	148C  CA8714  	        JP      Z,WAITLP        ; No = keep waiting
2972:	148F  C9      	        RET
2973:			
2974:	1490  CDA314  	SETIO:  CALL    GETINT          ; Get integer 0-255
2975:	1493  323F20  	        LD      (INPORT),A      ; Set input port
2976:	1496  320720  	        LD      (OTPORT),A      ; Set output port
2977:	1499  CD4B07  	        CALL    CHKSYN          ; Make sure ',' follows
2978:	149C  2C      	        .DB     ','
2979:	149D  C3A314  	        JP      GETINT          ; Get integer 0-255 and return
2980:			
2981:	14A0  CDD508  	FNDNUM: CALL    GETCHR          ; Get next character
2982:	14A3  CD420D  	GETINT: CALL    GETNUM          ; Get a number from 0 to 255
2983:	14A6  CD8109  	MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
2984:	14A9  7A      	        LD      A,D             ; Get MSB of number
2985:	14AA  B7      	        OR      A               ; Zero?
2986:	14AB  C29C09  	        JP      NZ,FCERR        ; No - Error
2987:	14AE  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
2988:	14AF  CDD508  	        CALL    GETCHR          ; Get next character
2989:	14B2  7B      	        LD      A,E             ; Get number to A
2990:	14B3  C9      	        RET
2991:			
2992:	14B4  CD8709  	PEEK:   CALL    DEINT           ; Get memory address
2993:	14B7  1A      	        LD      A,(DE)          ; Get byte in memory
2994:	14B8  C30C11  	        JP      PASSA           ; Return integer A
2995:			
2996:	14BB  CD420D  	POKE:   CALL    GETNUM          ; Get memory address
2997:	14BE  CD8709  	        CALL    DEINT           ; Get integer -32768 to 3276
2998:	14C1  D5      	        PUSH    DE              ; Save memory address
2999:	14C2  CD4B07  	        CALL    CHKSYN          ; Make sure ',' follows
3000:	14C5  2C      	        .DB     ','
3001:	14C6  CDA314  	        CALL    GETINT          ; Get integer 0-255
3002:	14C9  D1      	        POP     DE              ; Restore memory address
3003:	14CA  12      	        LD      (DE),A          ; Load it into memory
3004:	14CB  C9      	        RET
3005:			
3006:	14CC  21A219  	ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
3007:	14CF  CD7317  	ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
3008:	14D2  C3DE14  	        JP      FPADD           ; Add BCDE to FPREG
3009:			
3010:	14D5  CD7317  	SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
3011:	14D8  21      	        .DB     21H             ; Skip "POP BC" and "POP DE"
3012:	14D9  C1      	PSUB:   POP     BC              ; Get FP number from stack
3013:	14DA  D1      	        POP     DE
3014:	14DB  CD4D17  	SUBCDE: CALL    INVSGN          ; Negate FPREG
3015:	14DE  78      	FPADD:  LD      A,B             ; Get FP exponent
3016:	14DF  B7      	        OR      A               ; Is number zero?
3017:	14E0  C8      	        RET     Z               ; Yes - Nothing to add
3018:	14E1  3AE720  	        LD      A,(FPEXP)       ; Get FPREG exponent
3019:	14E4  B7      	        OR      A               ; Is this number zero?
3020:	14E5  CA6517  	        JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3021:	14E8  90      	        SUB     B               ; BCDE number larger?
3022:	14E9  D2F814  	        JP      NC,NOSWAP       ; No - Don't swap them
3023:	14EC  2F      	        CPL                     ; Two's complement
3024:	14ED  3C      	        INC     A               ;  FP exponent
3025:	14EE  EB      	        EX      DE,HL
3026:	14EF  CD5517  	        CALL    STAKFP          ; Put FPREG on stack
3027:	14F2  EB      	        EX      DE,HL
3028:	14F3  CD6517  	        CALL    FPBCDE          ; Move BCDE to FPREG
3029:	14F6  C1      	        POP     BC              ; Restore number from stack
3030:	14F7  D1      	        POP     DE
3031:	14F8  FE19    	NOSWAP: CP      24+1            ; Second number insignificant?
3032:	14FA  D0      	        RET     NC              ; Yes - First number is result
3033:	14FB  F5      	        PUSH    AF              ; Save number of bits to scale
3034:	14FC  CD8A17  	        CALL    SIGNS           ; Set MSBs & sign of result
3035:	14FF  67      	        LD      H,A             ; Save sign of result
3036:	1500  F1      	        POP     AF              ; Restore scaling factor
3037:	1501  CDA315  	        CALL    SCALE           ; Scale BCDE to same exponent
3038:	1504  B4      	        OR      H               ; Result to be positive?
3039:	1505  21E420  	        LD      HL,FPREG        ; Point to FPREG
3040:	1508  F21E15  	        JP      P,MINCDE        ; No - Subtract FPREG from CDE
3041:	150B  CD8315  	        CALL    PLUCDE          ; Add FPREG to CDE
3042:	150E  D26415  	        JP      NC,RONDUP       ; No overflow - Round it up
3043:	1511  23      	        INC     HL              ; Point to exponent
3044:	1512  34      	        INC     (HL)            ; Increment it
3045:	1513  CAC004  	        JP      Z,OVERR         ; Number overflowed - Error
3046:	1516  2E01    	        LD      L,1             ; 1 bit to shift right
3047:	1518  CDB915  	        CALL    SHRT1           ; Shift result right
3048:	151B  C36415  	        JP      RONDUP          ; Round it up
3049:			
3050:	151E  AF      	MINCDE: XOR     A               ; Clear A and carry
3051:	151F  90      	        SUB     B               ; Negate exponent
3052:	1520  47      	        LD      B,A             ; Re-save exponent
3053:	1521  7E      	        LD      A,(HL)          ; Get LSB of FPREG
3054:	1522  9B      	        SBC     A, E            ; Subtract LSB of BCDE
3055:	1523  5F      	        LD      E,A             ; Save LSB of BCDE
3056:	1524  23      	        INC     HL
3057:	1525  7E      	        LD      A,(HL)          ; Get NMSB of FPREG
3058:	1526  9A      	        SBC     A,D             ; Subtract NMSB of BCDE
3059:	1527  57      	        LD      D,A             ; Save NMSB of BCDE
3060:	1528  23      	        INC     HL
3061:	1529  7E      	        LD      A,(HL)          ; Get MSB of FPREG
3062:	152A  99      	        SBC     A,C             ; Subtract MSB of BCDE
3063:	152B  4F      	        LD      C,A             ; Save MSB of BCDE
3064:	152C  DC8F15  	CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
3065:			
3066:	152F  68      	BNORM:  LD      L,B             ; L = Exponent
3067:	1530  63      	        LD      H,E             ; H = LSB
3068:	1531  AF      	        XOR     A
3069:	1532  47      	BNRMLP: LD      B,A             ; Save bit count
3070:	1533  79      	        LD      A,C             ; Get MSB
3071:	1534  B7      	        OR      A               ; Is it zero?
3072:	1535  C25115  	        JP      NZ,PNORM        ; No - Do it bit at a time
3073:	1538  4A      	        LD      C,D             ; MSB = NMSB
3074:	1539  54      	        LD      D,H             ; NMSB= LSB
3075:	153A  65      	        LD      H,L             ; LSB = VLSB
3076:	153B  6F      	        LD      L,A             ; VLSB= 0
3077:	153C  78      	        LD      A,B             ; Get exponent
3078:	153D  D608    	        SUB     8               ; Count 8 bits
3079:	153F  FEE0    	        CP      -24-8           ; Was number zero?
3080:	1541  C23215  	        JP      NZ,BNRMLP       ; No - Keep normalising
3081:	1544  AF      	RESZER: XOR     A               ; Result is zero
3082:	1545  32E720  	SAVEXP: LD      (FPEXP),A       ; Save result as zero
3083:	1548  C9      	        RET
3084:			
3085:	1549  05      	NORMAL: DEC     B               ; Count bits
3086:	154A  29      	        ADD     HL,HL           ; Shift HL left
3087:	154B  7A      	        LD      A,D             ; Get NMSB
3088:	154C  17      	        RLA                     ; Shift left with last bit
3089:	154D  57      	        LD      D,A             ; Save NMSB
3090:	154E  79      	        LD      A,C             ; Get MSB
3091:	154F  8F      	        ADC     A,A             ; Shift left with last bit
3092:	1550  4F      	        LD      C,A             ; Save MSB
3093:	1551  F24915  	PNORM:  JP      P,NORMAL        ; Not done - Keep going
3094:	1554  78      	        LD      A,B             ; Number of bits shifted
3095:	1555  5C      	        LD      E,H             ; Save HL in EB
3096:	1556  45      	        LD      B,L
3097:	1557  B7      	        OR      A               ; Any shifting done?
3098:	1558  CA6415  	        JP      Z,RONDUP        ; No - Round it up
3099:	155B  21E720  	        LD      HL,FPEXP        ; Point to exponent
3100:	155E  86      	        ADD     A,(HL)          ; Add shifted bits
3101:	155F  77      	        LD      (HL),A          ; Re-save exponent
3102:	1560  D24415  	        JP      NC,RESZER       ; Underflow - Result is zero
3103:	1563  C8      	        RET     Z               ; Result is zero
3104:	1564  78      	RONDUP: LD      A,B             ; Get VLSB of number
3105:	1565  21E720  	RONDB:  LD      HL,FPEXP        ; Point to exponent
3106:	1568  B7      	        OR      A               ; Any rounding?
3107:	1569  FC7615  	        CALL    M,FPROND        ; Yes - Round number up
3108:	156C  46      	        LD      B,(HL)          ; B = Exponent
3109:	156D  23      	        INC     HL
3110:	156E  7E      	        LD      A,(HL)          ; Get sign of result
3111:	156F  E680    	        AND     10000000B       ; Only bit 7 needed
3112:	1571  A9      	        XOR     C               ; Set correct sign
3113:	1572  4F      	        LD      C,A             ; Save correct sign in number
3114:	1573  C36517  	        JP      FPBCDE          ; Move BCDE to FPREG
3115:			
3116:	1576  1C      	FPROND: INC     E               ; Round LSB
3117:	1577  C0      	        RET     NZ              ; Return if ok
3118:	1578  14      	        INC     D               ; Round NMSB
3119:	1579  C0      	        RET     NZ              ; Return if ok
3120:	157A  0C      	        INC     C               ; Round MSB
3121:	157B  C0      	        RET     NZ              ; Return if ok
3122:	157C  0E80    	        LD      C,80H           ; Set normal value
3123:	157E  34      	        INC     (HL)            ; Increment exponent
3124:	157F  C0      	        RET     NZ              ; Return if ok
3125:	1580  C3C004  	        JP      OVERR           ; Overflow error
3126:			
3127:	1583  7E      	PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
3128:	1584  83      	        ADD     A,E             ; Add LSB of BCDE
3129:	1585  5F      	        LD      E,A             ; Save LSB of BCDE
3130:	1586  23      	        INC     HL
3131:	1587  7E      	        LD      A,(HL)          ; Get NMSB of FPREG
3132:	1588  8A      	        ADC     A,D             ; Add NMSB of BCDE
3133:	1589  57      	        LD      D,A             ; Save NMSB of BCDE
3134:	158A  23      	        INC     HL
3135:	158B  7E      	        LD      A,(HL)          ; Get MSB of FPREG
3136:	158C  89      	        ADC     A,C             ; Add MSB of BCDE
3137:	158D  4F      	        LD      C,A             ; Save MSB of BCDE
3138:	158E  C9      	        RET
3139:			
3140:	158F  21E820  	COMPL:  LD      HL,SGNRES       ; Sign of result
3141:	1592  7E      	        LD      A,(HL)          ; Get sign of result
3142:	1593  2F      	        CPL                     ; Negate it
3143:	1594  77      	        LD      (HL),A          ; Put it back
3144:	1595  AF      	        XOR     A
3145:	1596  6F      	        LD      L,A             ; Set L to zero
3146:	1597  90      	        SUB     B               ; Negate exponent,set carry
3147:	1598  47      	        LD      B,A             ; Re-save exponent
3148:	1599  7D      	        LD      A,L             ; Load zero
3149:	159A  9B      	        SBC     A,E             ; Negate LSB
3150:	159B  5F      	        LD      E,A             ; Re-save LSB
3151:	159C  7D      	        LD      A,L             ; Load zero
3152:	159D  9A      	        SBC     A,D             ; Negate NMSB
3153:	159E  57      	        LD      D,A             ; Re-save NMSB
3154:	159F  7D      	        LD      A,L             ; Load zero
3155:	15A0  99      	        SBC     A,C             ; Negate MSB
3156:	15A1  4F      	        LD      C,A             ; Re-save MSB
3157:	15A2  C9      	        RET
3158:			
3159:	15A3  0600    	SCALE:  LD      B,0             ; Clear underflow
3160:	15A5  D608    	SCALLP: SUB     8               ; 8 bits (a whole byte)?
3161:	15A7  DAB215  	        JP      C,SHRITE        ; No - Shift right A bits
3162:	15AA  43      	        LD      B,E             ; <- Shift
3163:	15AB  5A      	        LD      E,D             ; <- right
3164:	15AC  51      	        LD      D,C             ; <- eight
3165:	15AD  0E00    	        LD      C,0             ; <- bits
3166:	15AF  C3A515  	        JP      SCALLP          ; More bits to shift
3167:			
3168:	15B2  C609    	SHRITE: ADD     A,8+1           ; Adjust count
3169:	15B4  6F      	        LD      L,A             ; Save bits to shift
3170:	15B5  AF      	SHRLP:  XOR     A               ; Flag for all done
3171:	15B6  2D      	        DEC     L               ; All shifting done?
3172:	15B7  C8      	        RET     Z               ; Yes - Return
3173:	15B8  79      	        LD      A,C             ; Get MSB
3174:	15B9  1F      	SHRT1:  RRA                     ; Shift it right
3175:	15BA  4F      	        LD      C,A             ; Re-save
3176:	15BB  7A      	        LD      A,D             ; Get NMSB
3177:	15BC  1F      	        RRA                     ; Shift right with last bit
3178:	15BD  57      	        LD      D,A             ; Re-save it
3179:	15BE  7B      	        LD      A,E             ; Get LSB
3180:	15BF  1F      	        RRA                     ; Shift right with last bit
3181:	15C0  5F      	        LD      E,A             ; Re-save it
3182:	15C1  78      	        LD      A,B             ; Get underflow
3183:	15C2  1F      	        RRA                     ; Shift right with last bit
3184:	15C3  47      	        LD      B,A             ; Re-save underflow
3185:	15C4  C3B515  	        JP      SHRLP           ; More bits to do
3186:			
3187:	15C7  00000081	UNITY:  .DB     000H,000H,000H,081H  ; 1.00000
3188:			
3189:	15CB  03      	LOGTAB: .DB     3                    ; Table used by LOG
3190:	15CC  AA561980	        .DB     0AAH,056H,019H,080H  ; 0.59898
3191:	15D0  F1227680	        .DB     0F1H,022H,076H,080H  ; 0.96147
3192:	15D4  45AA3882	        .DB     045H,0AAH,038H,082H  ; 2.88539
3193:			
3194:	15D8  CD2417  	LOG:    CALL    TSTSGN          ; Test sign of value
3195:	15DB  B7      	        OR      A
3196:	15DC  EA9C09  	        JP      PE,FCERR        ; ?FC Error if <= zero
3197:	15DF  21E720  	        LD      HL,FPEXP        ; Point to exponent
3198:	15E2  7E      	        LD      A,(HL)          ; Get exponent
3199:	15E3  013580  	        LD      BC,8035H        ; BCDE = SQR(1/2)
3200:	15E6  11F304  	        LD      DE,04F3H
3201:	15E9  90      	        SUB     B               ; Scale value to be < 1
3202:	15EA  F5      	        PUSH    AF              ; Save scale factor
3203:	15EB  70      	        LD      (HL),B          ; Save new exponent
3204:	15EC  D5      	        PUSH    DE              ; Save SQR(1/2)
3205:	15ED  C5      	        PUSH    BC
3206:	15EE  CDDE14  	        CALL    FPADD           ; Add SQR(1/2) to value
3207:	15F1  C1      	        POP     BC              ; Restore SQR(1/2)
3208:	15F2  D1      	        POP     DE
3209:	15F3  04      	        INC     B               ; Make it SQR(2)
3210:	15F4  CD7A16  	        CALL    DVBCDE          ; Divide by SQR(2)
3211:	15F7  21C715  	        LD      HL,UNITY        ; Point to 1.
3212:	15FA  CDD514  	        CALL    SUBPHL          ; Subtract FPREG from 1
3213:	15FD  21CB15  	        LD      HL,LOGTAB       ; Coefficient table
3214:	1600  CD6C1A  	        CALL    SUMSER          ; Evaluate sum of series
3215:	1603  018080  	        LD      BC,8080H        ; BCDE = -0.5
3216:	1606  110000  	        LD      DE,0000H
3217:	1609  CDDE14  	        CALL    FPADD           ; Subtract 0.5 from FPREG
3218:	160C  F1      	        POP     AF              ; Restore scale factor
3219:	160D  CD9F18  	        CALL    RSCALE          ; Re-scale number
3220:	1610  013180  	MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
3221:	1613  111872  	        LD      DE,7218H
3222:	1616  21      	        .DB     21H             ; Skip "POP BC" and "POP DE"
3223:			
3224:	1617  C1      	MULT:   POP     BC              ; Get number from stack
3225:	1618  D1      	        POP     DE
3226:	1619  CD2417  	FPMULT: CALL    TSTSGN          ; Test sign of FPREG
3227:	161C  C8      	        RET     Z               ; Return zero if zero
3228:	161D  2E00    	        LD      L,0             ; Flag add exponents
3229:	161F  CDE216  	        CALL    ADDEXP          ; Add exponents
3230:	1622  79      	        LD      A,C             ; Get MSB of multiplier
3231:	1623  32F620  	        LD      (MULVAL),A      ; Save MSB of multiplier
3232:	1626  EB      	        EX      DE,HL
3233:	1627  22F720  	        LD      (MULVAL+1),HL   ; Save rest of multiplier
3234:	162A  010000  	        LD      BC,0            ; Partial product (BCDE) = zero
3235:	162D  50      	        LD      D,B
3236:	162E  58      	        LD      E,B
3237:	162F  212F15  	        LD      HL,BNORM        ; Address of normalise
3238:	1632  E5      	        PUSH    HL              ; Save for return
3239:	1633  213B16  	        LD      HL,MULT8        ; Address of 8 bit multiply
3240:	1636  E5      	        PUSH    HL              ; Save for NMSB,MSB
3241:	1637  E5      	        PUSH    HL              ; 
3242:	1638  21E420  	        LD      HL,FPREG        ; Point to number
3243:	163B  7E      	MULT8:  LD      A,(HL)          ; Get LSB of number
3244:	163C  23      	        INC     HL              ; Point to NMSB
3245:	163D  B7      	        OR      A               ; Test LSB
3246:	163E  CA6716  	        JP      Z,BYTSFT        ; Zero - shift to next byte
3247:	1641  E5      	        PUSH    HL              ; Save address of number
3248:	1642  2E08    	        LD      L,8             ; 8 bits to multiply by
3249:	1644  1F      	MUL8LP: RRA                     ; Shift LSB right
3250:	1645  67      	        LD      H,A             ; Save LSB
3251:	1646  79      	        LD      A,C             ; Get MSB
3252:	1647  D25516  	        JP      NC,NOMADD       ; Bit was zero - Don't add
3253:	164A  E5      	        PUSH    HL              ; Save LSB and count
3254:	164B  2AF720  	        LD      HL,(MULVAL+1)   ; Get LSB and NMSB
3255:	164E  19      	        ADD     HL,DE           ; Add NMSB and LSB
3256:	164F  EB      	        EX      DE,HL           ; Leave sum in DE
3257:	1650  E1      	        POP     HL              ; Restore MSB and count
3258:	1651  3AF620  	        LD      A,(MULVAL)      ; Get MSB of multiplier
3259:	1654  89      	        ADC     A,C             ; Add MSB
3260:	1655  1F      	NOMADD: RRA                     ; Shift MSB right
3261:	1656  4F      	        LD      C,A             ; Re-save MSB
3262:	1657  7A      	        LD      A,D             ; Get NMSB
3263:	1658  1F      	        RRA                     ; Shift NMSB right
3264:	1659  57      	        LD      D,A             ; Re-save NMSB
3265:	165A  7B      	        LD      A,E             ; Get LSB
3266:	165B  1F      	        RRA                     ; Shift LSB right
3267:	165C  5F      	        LD      E,A             ; Re-save LSB
3268:	165D  78      	        LD      A,B             ; Get VLSB
3269:	165E  1F      	        RRA                     ; Shift VLSB right
3270:	165F  47      	        LD      B,A             ; Re-save VLSB
3271:	1660  2D      	        DEC     L               ; Count bits multiplied
3272:	1661  7C      	        LD      A,H             ; Get LSB of multiplier
3273:	1662  C24416  	        JP      NZ,MUL8LP       ; More - Do it
3274:	1665  E1      	POPHRT: POP     HL              ; Restore address of number
3275:	1666  C9      	        RET
3276:			
3277:	1667  43      	BYTSFT: LD      B,E             ; Shift partial product left
3278:	1668  5A      	        LD      E,D
3279:	1669  51      	        LD      D,C
3280:	166A  4F      	        LD      C,A
3281:	166B  C9      	        RET
3282:			
3283:	166C  CD5517  	DIV10:  CALL    STAKFP          ; Save FPREG on stack
3284:	166F  012084  	        LD      BC,8420H        ; BCDE = 10.
3285:	1672  110000  	        LD      DE,0000H
3286:	1675  CD6517  	        CALL    FPBCDE          ; Move 10 to FPREG
3287:			
3288:	1678  C1      	DIV:    POP     BC              ; Get number from stack
3289:	1679  D1      	        POP     DE
3290:	167A  CD2417  	DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
3291:	167D  CAB404  	        JP      Z,DZERR         ; Error if division by zero
3292:	1680  2EFF    	        LD      L,-1            ; Flag subtract exponents
3293:	1682  CDE216  	        CALL    ADDEXP          ; Subtract exponents
3294:	1685  34      	        INC     (HL)            ; Add 2 to exponent to adjust
3295:	1686  34      	        INC     (HL)
3296:	1687  2B      	        DEC     HL              ; Point to MSB
3297:	1688  7E      	        LD      A,(HL)          ; Get MSB of dividend
3298:	1689  321220  	        LD      (DIV3),A        ; Save for subtraction
3299:	168C  2B      	        DEC     HL
3300:	168D  7E      	        LD      A,(HL)          ; Get NMSB of dividend
3301:	168E  320E20  	        LD      (DIV2),A        ; Save for subtraction
3302:	1691  2B      	        DEC     HL
3303:	1692  7E      	        LD      A,(HL)          ; Get MSB of dividend
3304:	1693  320A20  	        LD      (DIV1),A        ; Save for subtraction
3305:	1696  41      	        LD      B,C             ; Get MSB
3306:	1697  EB      	        EX      DE,HL           ; NMSB,LSB to HL
3307:	1698  AF      	        XOR     A
3308:	1699  4F      	        LD      C,A             ; Clear MSB of quotient
3309:	169A  57      	        LD      D,A             ; Clear NMSB of quotient
3310:	169B  5F      	        LD      E,A             ; Clear LSB of quotient
3311:	169C  321520  	        LD      (DIV4),A        ; Clear overflow count
3312:	169F  E5      	DIVLP:  PUSH    HL              ; Save divisor
3313:	16A0  C5      	        PUSH    BC
3314:	16A1  7D      	        LD      A,L             ; Get LSB of number
3315:	16A2  CD0920  	        CALL    DIVSUP          ; Subt' divisor from dividend
3316:	16A5  DE00    	        SBC     A,0             ; Count for overflows
3317:	16A7  3F      	        CCF
3318:	16A8  D2B216  	        JP      NC,RESDIV       ; Restore divisor if borrow
3319:	16AB  321520  	        LD      (DIV4),A        ; Re-save overflow count
3320:	16AE  F1      	        POP     AF              ; Scrap divisor
3321:	16AF  F1      	        POP     AF
3322:	16B0  37      	        SCF                     ; Set carry to
3323:	16B1  D2      	        .DB     0D2H            ; Skip "POP BC" and "POP HL"
3324:			
3325:	16B2  C1      	RESDIV: POP     BC              ; Restore divisor
3326:	16B3  E1      	        POP     HL
3327:	16B4  79      	        LD      A,C             ; Get MSB of quotient
3328:	16B5  3C      	        INC     A
3329:	16B6  3D      	        DEC     A
3330:	16B7  1F      	        RRA                     ; Bit 0 to bit 7
3331:	16B8  FA6515  	        JP      M,RONDB        ; Done - Normalise result
3332:	16BB  17      	        RLA                     ; Restore carry
3333:	16BC  7B      	        LD      A,E             ; Get LSB of quotient
3334:	16BD  17      	        RLA                     ; Double it
3335:	16BE  5F      	        LD      E,A             ; Put it back
3336:	16BF  7A      	        LD      A,D             ; Get NMSB of quotient
3337:	16C0  17      	        RLA                     ; Double it
3338:	16C1  57      	        LD      D,A             ; Put it back
3339:	16C2  79      	        LD      A,C             ; Get MSB of quotient
3340:	16C3  17      	        RLA                     ; Double it
3341:	16C4  4F      	        LD      C,A             ; Put it back
3342:	16C5  29      	        ADD     HL,HL           ; Double NMSB,LSB of divisor
3343:	16C6  78      	        LD      A,B             ; Get MSB of divisor
3344:	16C7  17      	        RLA                     ; Double it
3345:	16C8  47      	        LD      B,A             ; Put it back
3346:	16C9  3A1520  	        LD      A,(DIV4)        ; Get VLSB of quotient
3347:	16CC  17      	        RLA                     ; Double it
3348:	16CD  321520  	        LD      (DIV4),A        ; Put it back
3349:	16D0  79      	        LD      A,C             ; Get MSB of quotient
3350:	16D1  B2      	        OR      D               ; Merge NMSB
3351:	16D2  B3      	        OR      E               ; Merge LSB
3352:	16D3  C29F16  	        JP      NZ,DIVLP        ; Not done - Keep dividing
3353:	16D6  E5      	        PUSH    HL              ; Save divisor
3354:	16D7  21E720  	        LD      HL,FPEXP        ; Point to exponent
3355:	16DA  35      	        DEC     (HL)            ; Divide by 2
3356:	16DB  E1      	        POP     HL              ; Restore divisor
3357:	16DC  C29F16  	        JP      NZ,DIVLP        ; Ok - Keep going
3358:	16DF  C3C004  	        JP      OVERR           ; Overflow error
3359:			
3360:	16E2  78      	ADDEXP: LD      A,B             ; Get exponent of dividend
3361:	16E3  B7      	        OR      A               ; Test it
3362:	16E4  CA0617  	        JP      Z,OVTST3        ; Zero - Result zero
3363:	16E7  7D      	        LD      A,L             ; Get add/subtract flag
3364:	16E8  21E720  	        LD      HL,FPEXP        ; Point to exponent
3365:	16EB  AE      	        XOR     (HL)            ; Add or subtract it
3366:	16EC  80      	        ADD     A,B             ; Add the other exponent
3367:	16ED  47      	        LD      B,A             ; Save new exponent
3368:	16EE  1F      	        RRA                     ; Test exponent for overflow
3369:	16EF  A8      	        XOR     B
3370:	16F0  78      	        LD      A,B             ; Get exponent
3371:	16F1  F20517  	        JP      P,OVTST2        ; Positive - Test for overflow
3372:	16F4  C680    	        ADD     A,80H           ; Add excess 128
3373:	16F6  77      	        LD      (HL),A          ; Save new exponent
3374:	16F7  CA6516  	        JP      Z,POPHRT        ; Zero - Result zero
3375:	16FA  CD8A17  	        CALL    SIGNS           ; Set MSBs and sign of result
3376:	16FD  77      	        LD      (HL),A          ; Save new exponent
3377:	16FE  2B      	        DEC     HL              ; Point to MSB
3378:	16FF  C9      	        RET
3379:			
3380:	1700  CD2417  	OVTST1: CALL    TSTSGN          ; Test sign of FPREG
3381:	1703  2F      	        CPL                     ; Invert sign
3382:	1704  E1      	        POP     HL              ; Clean up stack
3383:	1705  B7      	OVTST2: OR      A               ; Test if new exponent zero
3384:	1706  E1      	OVTST3: POP     HL              ; Clear off return address
3385:	1707  F24415  	        JP      P,RESZER        ; Result zero
3386:	170A  C3C004  	        JP      OVERR           ; Overflow error
3387:			
3388:	170D  CD7017  	MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
3389:	1710  78      	        LD      A,B             ; Get exponent
3390:	1711  B7      	        OR      A               ; Is it zero?
3391:	1712  C8      	        RET     Z               ; Yes - Result is zero
3392:	1713  C602    	        ADD     A,2             ; Multiply by 4
3393:	1715  DAC004  	        JP      C,OVERR         ; Overflow - ?OV Error
3394:	1718  47      	        LD      B,A             ; Re-save exponent
3395:	1719  CDDE14  	        CALL    FPADD           ; Add BCDE to FPREG (Times 5)
3396:	171C  21E720  	        LD      HL,FPEXP        ; Point to exponent
3397:	171F  34      	        INC     (HL)            ; Double number (Times 10)
3398:	1720  C0      	        RET     NZ              ; Ok - Return
3399:	1721  C3C004  	        JP      OVERR           ; Overflow error
3400:			
3401:	1724  3AE720  	TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
3402:	1727  B7      	        OR      A
3403:	1728  C8      	        RET     Z               ; RETurn if number is zero
3404:	1729  3AE620  	        LD      A,(FPREG+2)     ; Get MSB of FPREG
3405:	172C  FE      	        .DB     0FEH            ; Test sign
3406:	172D  2F      	RETREL: CPL                     ; Invert sign
3407:	172E  17      	        RLA                     ; Sign bit to carry
3408:	172F  9F      	FLGDIF: SBC     A,A             ; Carry to all bits of A
3409:	1730  C0      	        RET     NZ              ; Return -1 if negative
3410:	1731  3C      	        INC     A               ; Bump to +1
3411:	1732  C9      	        RET                     ; Positive - Return +1
3412:			
3413:	1733  CD2417  	SGN:    CALL    TSTSGN          ; Test sign of FPREG
3414:	1736  0688    	FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
3415:	1738  110000  	        LD      DE,0            ; Zero NMSB and LSB
3416:	173B  21E720  	RETINT: LD      HL,FPEXP        ; Point to exponent
3417:	173E  4F      	        LD      C,A             ; CDE = MSB,NMSB and LSB
3418:	173F  70      	        LD      (HL),B          ; Save exponent
3419:	1740  0600    	        LD      B,0             ; CDE = integer to normalise
3420:	1742  23      	        INC     HL              ; Point to sign of result
3421:	1743  3680    	        LD      (HL),80H        ; Set sign of result
3422:	1745  17      	        RLA                     ; Carry = sign of integer
3423:	1746  C32C15  	        JP      CONPOS          ; Set sign of result
3424:			
3425:	1749  CD2417  	ABS:    CALL    TSTSGN          ; Test sign of FPREG
3426:	174C  F0      	        RET     P               ; Return if positive
3427:	174D  21E620  	INVSGN: LD      HL,FPREG+2      ; Point to MSB
3428:	1750  7E      	        LD      A,(HL)          ; Get sign of mantissa
3429:	1751  EE80    	        XOR     80H             ; Invert sign of mantissa
3430:	1753  77      	        LD      (HL),A          ; Re-save sign of mantissa
3431:	1754  C9      	        RET
3432:			
3433:	1755  EB      	STAKFP: EX      DE,HL           ; Save code string address
3434:	1756  2AE420  	        LD      HL,(FPREG)      ; LSB,NLSB of FPREG
3435:	1759  E3      	        EX      (SP),HL         ; Stack them,get return
3436:	175A  E5      	        PUSH    HL              ; Re-save return
3437:	175B  2AE620  	        LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
3438:	175E  E3      	        EX      (SP),HL         ; Stack them,get return
3439:	175F  E5      	        PUSH    HL              ; Re-save return
3440:	1760  EB      	        EX      DE,HL           ; Restore code string address
3441:	1761  C9      	        RET
3442:			
3443:	1762  CD7317  	PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
3444:	1765  EB      	FPBCDE: EX      DE,HL           ; Save code string address
3445:	1766  22E420  	        LD      (FPREG),HL      ; Save LSB,NLSB of number
3446:	1769  60      	        LD      H,B             ; Exponent of number
3447:	176A  69      	        LD      L,C             ; MSB of number
3448:	176B  22E620  	        LD      (FPREG+2),HL    ; Save MSB and exponent
3449:	176E  EB      	        EX      DE,HL           ; Restore code string address
3450:	176F  C9      	        RET
3451:			
3452:	1770  21E420  	BCDEFP: LD      HL,FPREG        ; Point to FPREG
3453:	1773  5E      	LOADFP: LD      E,(HL)          ; Get LSB of number
3454:	1774  23      	        INC     HL
3455:	1775  56      	        LD      D,(HL)          ; Get NMSB of number
3456:	1776  23      	        INC     HL
3457:	1777  4E      	        LD      C,(HL)          ; Get MSB of number
3458:	1778  23      	        INC     HL
3459:	1779  46      	        LD      B,(HL)          ; Get exponent of number
3460:	177A  23      	INCHL:  INC     HL              ; Used for conditional "INC HL"
3461:	177B  C9      	        RET
3462:			
3463:	177C  11E420  	FPTHL:  LD      DE,FPREG        ; Point to FPREG
3464:	177F  0604    	DETHL4: LD      B,4             ; 4 bytes to move
3465:	1781  1A      	DETHLB: LD      A,(DE)          ; Get source
3466:	1782  77      	        LD      (HL),A          ; Save destination
3467:	1783  13      	        INC     DE              ; Next source
3468:	1784  23      	        INC     HL              ; Next destination
3469:	1785  05      	        DEC     B               ; Count bytes
3470:	1786  C28117  	        JP      NZ,DETHLB       ; Loop if more
3471:	1789  C9      	        RET
3472:			
3473:	178A  21E620  	SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
3474:	178D  7E      	        LD      A,(HL)          ; Get MSB
3475:	178E  07      	        RLCA                    ; Old sign to carry
3476:	178F  37      	        SCF                     ; Set MSBit
3477:	1790  1F      	        RRA                     ; Set MSBit of MSB
3478:	1791  77      	        LD      (HL),A          ; Save new MSB
3479:	1792  3F      	        CCF                     ; Complement sign
3480:	1793  1F      	        RRA                     ; Old sign to carry
3481:	1794  23      	        INC     HL
3482:	1795  23      	        INC     HL
3483:	1796  77      	        LD      (HL),A          ; Set sign of result
3484:	1797  79      	        LD      A,C             ; Get MSB
3485:	1798  07      	        RLCA                    ; Old sign to carry
3486:	1799  37      	        SCF                     ; Set MSBit
3487:	179A  1F      	        RRA                     ; Set MSBit of MSB
3488:	179B  4F      	        LD      C,A             ; Save MSB
3489:	179C  1F      	        RRA
3490:	179D  AE      	        XOR     (HL)            ; New sign of result
3491:	179E  C9      	        RET
3492:			
3493:	179F  78      	CMPNUM: LD      A,B             ; Get exponent of number
3494:	17A0  B7      	        OR      A
3495:	17A1  CA2417  	        JP      Z,TSTSGN        ; Zero - Test sign of FPREG
3496:	17A4  212D17  	        LD      HL,RETREL       ; Return relation routine
3497:	17A7  E5      	        PUSH    HL              ; Save for return
3498:	17A8  CD2417  	        CALL    TSTSGN          ; Test sign of FPREG
3499:	17AB  79      	        LD      A,C             ; Get MSB of number
3500:	17AC  C8      	        RET     Z               ; FPREG zero - Number's MSB
3501:	17AD  21E620  	        LD      HL,FPREG+2      ; MSB of FPREG
3502:	17B0  AE      	        XOR     (HL)            ; Combine signs
3503:	17B1  79      	        LD      A,C             ; Get MSB of number
3504:	17B2  F8      	        RET     M               ; Exit if signs different
3505:	17B3  CDB917  	        CALL    CMPFP           ; Compare FP numbers
3506:	17B6  1F      	        RRA                     ; Get carry to sign
3507:	17B7  A9      	        XOR     C               ; Combine with MSB of number
3508:	17B8  C9      	        RET
3509:			
3510:	17B9  23      	CMPFP:  INC     HL              ; Point to exponent
3511:	17BA  78      	        LD      A,B             ; Get exponent
3512:	17BB  BE      	        CP      (HL)            ; Compare exponents
3513:	17BC  C0      	        RET     NZ              ; Different
3514:	17BD  2B      	        DEC     HL              ; Point to MBS
3515:	17BE  79      	        LD      A,C             ; Get MSB
3516:	17BF  BE      	        CP      (HL)            ; Compare MSBs
3517:	17C0  C0      	        RET     NZ              ; Different
3518:	17C1  2B      	        DEC     HL              ; Point to NMSB
3519:	17C2  7A      	        LD      A,D             ; Get NMSB
3520:	17C3  BE      	        CP      (HL)            ; Compare NMSBs
3521:	17C4  C0      	        RET     NZ              ; Different
3522:	17C5  2B      	        DEC     HL              ; Point to LSB
3523:	17C6  7B      	        LD      A,E             ; Get LSB
3524:	17C7  96      	        SUB     (HL)            ; Compare LSBs
3525:	17C8  C0      	        RET     NZ              ; Different
3526:	17C9  E1      	        POP     HL              ; Drop RETurn
3527:	17CA  E1      	        POP     HL              ; Drop another RETurn
3528:	17CB  C9      	        RET
3529:			
3530:	17CC  47      	FPINT:  LD      B,A             ; <- Move
3531:	17CD  4F      	        LD      C,A             ; <- exponent
3532:	17CE  57      	        LD      D,A             ; <- to all
3533:	17CF  5F      	        LD      E,A             ; <- bits
3534:	17D0  B7      	        OR      A               ; Test exponent
3535:	17D1  C8      	        RET     Z               ; Zero - Return zero
3536:	17D2  E5      	        PUSH    HL              ; Save pointer to number
3537:	17D3  CD7017  	        CALL    BCDEFP          ; Move FPREG to BCDE
3538:	17D6  CD8A17  	        CALL    SIGNS           ; Set MSBs & sign of result
3539:	17D9  AE      	        XOR     (HL)            ; Combine with sign of FPREG
3540:	17DA  67      	        LD      H,A             ; Save combined signs
3541:	17DB  FCF017  	        CALL    M,DCBCDE        ; Negative - Decrement BCDE
3542:	17DE  3E98    	        LD      A,80H+24        ; 24 bits
3543:	17E0  90      	        SUB     B               ; Bits to shift
3544:	17E1  CDA315  	        CALL    SCALE           ; Shift BCDE
3545:	17E4  7C      	        LD      A,H             ; Get combined sign
3546:	17E5  17      	        RLA                     ; Sign to carry
3547:	17E6  DC7615  	        CALL    C,FPROND        ; Negative - Round number up
3548:	17E9  0600    	        LD      B,0             ; Zero exponent
3549:	17EB  DC8F15  	        CALL    C,COMPL         ; If negative make positive
3550:	17EE  E1      	        POP     HL              ; Restore pointer to number
3551:	17EF  C9      	        RET
3552:			
3553:	17F0  1B      	DCBCDE: DEC     DE              ; Decrement BCDE
3554:	17F1  7A      	        LD      A,D             ; Test LSBs
3555:	17F2  A3      	        AND     E
3556:	17F3  3C      	        INC     A
3557:	17F4  C0      	        RET     NZ              ; Exit if LSBs not FFFF
3558:	17F5  0B      	        DEC     BC              ; Decrement MSBs
3559:	17F6  C9      	        RET
3560:			
3561:	17F7  21E720  	INT:    LD      HL,FPEXP        ; Point to exponent
3562:	17FA  7E      	        LD      A,(HL)          ; Get exponent
3563:	17FB  FE98    	        CP      80H+24          ; Integer accuracy only?
3564:	17FD  3AE420  	        LD      A,(FPREG)       ; Get LSB
3565:	1800  D0      	        RET     NC              ; Yes - Already integer
3566:	1801  7E      	        LD      A,(HL)          ; Get exponent
3567:	1802  CDCC17  	        CALL    FPINT           ; F.P to integer
3568:	1805  3698    	        LD      (HL),80H+24     ; Save 24 bit integer
3569:	1807  7B      	        LD      A,E             ; Get LSB of number
3570:	1808  F5      	        PUSH    AF              ; Save LSB
3571:	1809  79      	        LD      A,C             ; Get MSB of number
3572:	180A  17      	        RLA                     ; Sign to carry
3573:	180B  CD2C15  	        CALL    CONPOS          ; Set sign of result
3574:	180E  F1      	        POP     AF              ; Restore LSB of number
3575:	180F  C9      	        RET
3576:			
3577:	1810  210000  	MLDEBC: LD      HL,0            ; Clear partial product
3578:	1813  78      	        LD      A,B             ; Test multiplier
3579:	1814  B1      	        OR      C
3580:	1815  C8      	        RET     Z               ; Return zero if zero
3581:	1816  3E10    	        LD      A,16            ; 16 bits
3582:	1818  29      	MLDBLP: ADD     HL,HL           ; Shift P.P left
3583:	1819  DA5010  	        JP      C,BSERR         ; ?BS Error if overflow
3584:	181C  EB      	        EX      DE,HL
3585:	181D  29      	        ADD     HL,HL           ; Shift multiplier left
3586:	181E  EB      	        EX      DE,HL
3587:	181F  D22618  	        JP      NC,NOMLAD       ; Bit was zero - No add
3588:	1822  09      	        ADD     HL,BC           ; Add multiplicand
3589:	1823  DA5010  	        JP      C,BSERR         ; ?BS Error if overflow
3590:	1826  3D      	NOMLAD: DEC     A               ; Count bits
3591:	1827  C21818  	        JP      NZ,MLDBLP       ; More
3592:	182A  C9      	        RET
3593:			
3594:	182B  FE2D    	ASCTFP: CP      '-'             ; Negative?
3595:	182D  F5      	        PUSH    AF              ; Save it and flags
3596:	182E  CA3718  	        JP      Z,CNVNUM        ; Yes - Convert number
3597:	1831  FE2B    	        CP      '+'             ; Positive?
3598:	1833  CA3718  	        JP      Z,CNVNUM        ; Yes - Convert number
3599:	1836  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
3600:	1837  CD4415  	CNVNUM: CALL    RESZER          ; Set result to zero
3601:	183A  47      	        LD      B,A             ; Digits after point counter
3602:	183B  57      	        LD      D,A             ; Sign of exponent
3603:	183C  5F      	        LD      E,A             ; Exponent of ten
3604:	183D  2F      	        CPL
3605:	183E  4F      	        LD      C,A             ; Before or after point flag
3606:	183F  CDD508  	MANLP:  CALL    GETCHR          ; Get next character
3607:	1842  DA8818  	        JP      C,ADDIG         ; Digit - Add to number
3608:	1845  FE2E    	        CP      '.'
3609:	1847  CA6318  	        JP      Z,DPOINT        ; '.' - Flag point
3610:	184A  FE45    	        CP      'E'
3611:	184C  C26718  	        JP      NZ,CONEXP       ; Not 'E' - Scale number
3612:	184F  CDD508  	        CALL    GETCHR          ; Get next character
3613:	1852  CD7B0E  	        CALL    SGNEXP          ; Get sign of exponent
3614:	1855  CDD508  	EXPLP:  CALL    GETCHR          ; Get next character
3615:	1858  DAAA18  	        JP      C,EDIGIT        ; Digit - Add to exponent
3616:	185B  14      	        INC     D               ; Is sign negative?
3617:	185C  C26718  	        JP      NZ,CONEXP       ; No - Scale number
3618:	185F  AF      	        XOR     A
3619:	1860  93      	        SUB     E               ; Negate exponent
3620:	1861  5F      	        LD      E,A             ; And re-save it
3621:	1862  0C      	        INC     C               ; Flag end of number
3622:	1863  0C      	DPOINT: INC     C               ; Flag point passed
3623:	1864  CA3F18  	        JP      Z,MANLP         ; Zero - Get another digit
3624:	1867  E5      	CONEXP: PUSH    HL              ; Save code string address
3625:	1868  7B      	        LD      A,E             ; Get exponent
3626:	1869  90      	        SUB     B               ; Subtract digits after point
3627:	186A  F48018  	SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
3628:	186D  F27618  	        JP      P,ENDCON        ; Positive - All done
3629:	1870  F5      	        PUSH    AF              ; Save number of times to /10
3630:	1871  CD6C16  	        CALL    DIV10           ; Divide by 10
3631:	1874  F1      	        POP     AF              ; Restore count
3632:	1875  3C      	        INC     A               ; Count divides
3633:			
3634:	1876  C26A18  	ENDCON: JP      NZ,SCALMI       ; More to do
3635:	1879  D1      	        POP     DE              ; Restore code string address
3636:	187A  F1      	        POP     AF              ; Restore sign of number
3637:	187B  CC4D17  	        CALL    Z,INVSGN        ; Negative - Negate number
3638:	187E  EB      	        EX      DE,HL           ; Code string address to HL
3639:	187F  C9      	        RET
3640:			
3641:	1880  C8      	SCALPL: RET     Z               ; Exit if no scaling needed
3642:	1881  F5      	MULTEN: PUSH    AF              ; Save count
3643:	1882  CD0D17  	        CALL    MLSP10          ; Multiply number by 10
3644:	1885  F1      	        POP     AF              ; Restore count
3645:	1886  3D      	        DEC     A               ; Count multiplies
3646:	1887  C9      	        RET
3647:			
3648:	1888  D5      	ADDIG:  PUSH    DE              ; Save sign of exponent
3649:	1889  57      	        LD      D,A             ; Save digit
3650:	188A  78      	        LD      A,B             ; Get digits after point
3651:	188B  89      	        ADC     A,C             ; Add one if after point
3652:	188C  47      	        LD      B,A             ; Re-save counter
3653:	188D  C5      	        PUSH    BC              ; Save point flags
3654:	188E  E5      	        PUSH    HL              ; Save code string address
3655:	188F  D5      	        PUSH    DE              ; Save digit
3656:	1890  CD0D17  	        CALL    MLSP10          ; Multiply number by 10
3657:	1893  F1      	        POP     AF              ; Restore digit
3658:	1894  D630    	        SUB     '0'             ; Make it absolute
3659:	1896  CD9F18  	        CALL    RSCALE          ; Re-scale number
3660:	1899  E1      	        POP     HL              ; Restore code string address
3661:	189A  C1      	        POP     BC              ; Restore point flags
3662:	189B  D1      	        POP     DE              ; Restore sign of exponent
3663:	189C  C33F18  	        JP      MANLP           ; Get another digit
3664:			
3665:	189F  CD5517  	RSCALE: CALL    STAKFP          ; Put number on stack
3666:	18A2  CD3617  	        CALL    FLGREL          ; Digit to add to FPREG
3667:	18A5  C1      	PADD:   POP     BC              ; Restore number
3668:	18A6  D1      	        POP     DE
3669:	18A7  C3DE14  	        JP      FPADD           ; Add BCDE to FPREG and return
3670:			
3671:	18AA  7B      	EDIGIT: LD      A,E             ; Get digit
3672:	18AB  07      	        RLCA                    ; Times 2
3673:	18AC  07      	        RLCA                    ; Times 4
3674:	18AD  83      	        ADD     A,E             ; Times 5
3675:	18AE  07      	        RLCA                    ; Times 10
3676:	18AF  86      	        ADD     A,(HL)          ; Add next digit
3677:	18B0  D630    	        SUB     '0'             ; Make it absolute
3678:	18B2  5F      	        LD      E,A             ; Save new digit
3679:	18B3  C35518  	        JP      EXPLP           ; Look for another digit
3680:			
3681:	18B6  E5      	LINEIN: PUSH    HL              ; Save code string address
3682:	18B7  214904  	        LD      HL,INMSG        ; Output " in "
3683:	18BA  CD1B12  	        CALL    PRS             ; Output string at HL
3684:	18BD  E1      	        POP     HL              ; Restore code string address
3685:	18BE  EB      	PRNTHL: EX      DE,HL           ; Code string address to DE
3686:	18BF  AF      	        XOR     A
3687:	18C0  0698    	        LD      B,80H+24        ; 24 bits
3688:	18C2  CD3B17  	        CALL    RETINT          ; Return the integer
3689:	18C5  211A12  	        LD      HL,PRNUMS       ; Print number string
3690:	18C8  E5      	        PUSH    HL              ; Save for return
3691:	18C9  21E920  	NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
3692:	18CC  E5      	        PUSH    HL              ; Save for return
3693:	18CD  CD2417  	        CALL    TSTSGN          ; Test sign of FPREG
3694:	18D0  3620    	        LD      (HL),' '        ; Space at start
3695:	18D2  F2D718  	        JP      P,SPCFST        ; Positive - Space to start
3696:	18D5  362D    	        LD      (HL),'-'        ; '-' sign at start
3697:	18D7  23      	SPCFST: INC     HL              ; First byte of number
3698:	18D8  3630    	        LD      (HL),'0'        ; '0' if zero
3699:	18DA  CA8D19  	        JP      Z,JSTZER        ; Return '0' if zero
3700:	18DD  E5      	        PUSH    HL              ; Save buffer address
3701:	18DE  FC4D17  	        CALL    M,INVSGN        ; Negate FPREG if negative
3702:	18E1  AF      	        XOR     A               ; Zero A
3703:	18E2  F5      	        PUSH    AF              ; Save it
3704:	18E3  CD9319  	        CALL    RNGTST          ; Test number is in range
3705:	18E6  014391  	SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
3706:	18E9  11F84F  	        LD      DE,4FF8H
3707:	18EC  CD9F17  	        CALL    CMPNUM          ; Compare numbers
3708:	18EF  B7      	        OR      A
3709:	18F0  E20419  	        JP      PO,INRNG        ; > 99999.9 - Sort it out
3710:	18F3  F1      	        POP     AF              ; Restore count
3711:	18F4  CD8118  	        CALL    MULTEN          ; Multiply by ten
3712:	18F7  F5      	        PUSH    AF              ; Re-save count
3713:	18F8  C3E618  	        JP      SIXDIG          ; Test it again
3714:			
3715:	18FB  CD6C16  	GTSIXD: CALL    DIV10           ; Divide by 10
3716:	18FE  F1      	        POP     AF              ; Get count
3717:	18FF  3C      	        INC     A               ; Count divides
3718:	1900  F5      	        PUSH    AF              ; Re-save count
3719:	1901  CD9319  	        CALL    RNGTST          ; Test number is in range
3720:	1904  CDCC14  	INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
3721:	1907  3C      	        INC     A
3722:	1908  CDCC17  	        CALL    FPINT           ; F.P to integer
3723:	190B  CD6517  	        CALL    FPBCDE          ; Move BCDE to FPREG
3724:	190E  010603  	        LD      BC,0306H        ; 1E+06 to 1E-03 range
3725:	1911  F1      	        POP     AF              ; Restore count
3726:	1912  81      	        ADD     A,C             ; 6 digits before point
3727:	1913  3C      	        INC     A               ; Add one
3728:	1914  FA2019  	        JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
3729:	1917  FE08    	        CP      6+1+1           ; More than 999999 ?
3730:	1919  D22019  	        JP      NC,MAKNUM       ; Yes - Do it in 'E' form
3731:	191C  3C      	        INC     A               ; Adjust for exponent
3732:	191D  47      	        LD      B,A             ; Exponent of number
3733:	191E  3E02    	        LD      A,2             ; Make it zero after
3734:			
3735:	1920  3D      	MAKNUM: DEC     A               ; Adjust for digits to do
3736:	1921  3D      	        DEC     A
3737:	1922  E1      	        POP     HL              ; Restore buffer address
3738:	1923  F5      	        PUSH    AF              ; Save count
3739:	1924  11A619  	        LD      DE,POWERS       ; Powers of ten
3740:	1927  05      	        DEC     B               ; Count digits before point
3741:	1928  C23119  	        JP      NZ,DIGTXT       ; Not zero - Do number
3742:	192B  362E    	        LD      (HL),'.'        ; Save point
3743:	192D  23      	        INC     HL              ; Move on
3744:	192E  3630    	        LD      (HL),'0'        ; Save zero
3745:	1930  23      	        INC     HL              ; Move on
3746:	1931  05      	DIGTXT: DEC     B               ; Count digits before point
3747:	1932  362E    	        LD      (HL),'.'        ; Save point in case
3748:	1934  CC7A17  	        CALL    Z,INCHL         ; Last digit - move on
3749:	1937  C5      	        PUSH    BC              ; Save digits before point
3750:	1938  E5      	        PUSH    HL              ; Save buffer address
3751:	1939  D5      	        PUSH    DE              ; Save powers of ten
3752:	193A  CD7017  	        CALL    BCDEFP          ; Move FPREG to BCDE
3753:	193D  E1      	        POP     HL              ; Powers of ten table
3754:	193E  062F    	        LD      B, '0'-1        ; ASCII '0' - 1
3755:	1940  04      	TRYAGN: INC     B               ; Count subtractions
3756:	1941  7B      	        LD      A,E             ; Get LSB
3757:	1942  96      	        SUB     (HL)            ; Subtract LSB
3758:	1943  5F      	        LD      E,A             ; Save LSB
3759:	1944  23      	        INC     HL
3760:	1945  7A      	        LD      A,D             ; Get NMSB
3761:	1946  9E      	        SBC     A,(HL)          ; Subtract NMSB
3762:	1947  57      	        LD      D,A             ; Save NMSB
3763:	1948  23      	        INC     HL
3764:	1949  79      	        LD      A,C             ; Get MSB
3765:	194A  9E      	        SBC     A,(HL)          ; Subtract MSB
3766:	194B  4F      	        LD      C,A             ; Save MSB
3767:	194C  2B      	        DEC     HL              ; Point back to start
3768:	194D  2B      	        DEC     HL
3769:	194E  D24019  	        JP      NC,TRYAGN       ; No overflow - Try again
3770:	1951  CD8315  	        CALL    PLUCDE          ; Restore number
3771:	1954  23      	        INC     HL              ; Start of next number
3772:	1955  CD6517  	        CALL    FPBCDE          ; Move BCDE to FPREG
3773:	1958  EB      	        EX      DE,HL           ; Save point in table
3774:	1959  E1      	        POP     HL              ; Restore buffer address
3775:	195A  70      	        LD      (HL),B          ; Save digit in buffer
3776:	195B  23      	        INC     HL              ; And move on
3777:	195C  C1      	        POP     BC              ; Restore digit count
3778:	195D  0D      	        DEC     C               ; Count digits
3779:	195E  C23119  	        JP      NZ,DIGTXT       ; More - Do them
3780:	1961  05      	        DEC     B               ; Any decimal part?
3781:	1962  CA7119  	        JP      Z,DOEBIT        ; No - Do 'E' bit
3782:	1965  2B      	SUPTLZ: DEC     HL              ; Move back through buffer
3783:	1966  7E      	        LD      A,(HL)          ; Get character
3784:	1967  FE30    	        CP      '0'             ; '0' character?
3785:	1969  CA6519  	        JP      Z,SUPTLZ        ; Yes - Look back for more
3786:	196C  FE2E    	        CP      '.'             ; A decimal point?
3787:	196E  C47A17  	        CALL    NZ,INCHL        ; Move back over digit
3788:			
3789:	1971  F1      	DOEBIT: POP     AF              ; Get 'E' flag
3790:	1972  CA9019  	        JP      Z,NOENED        ; No 'E' needed - End buffer
3791:	1975  3645    	        LD      (HL),'E'        ; Put 'E' in buffer
3792:	1977  23      	        INC     HL              ; And move on
3793:	1978  362B    	        LD      (HL),'+'        ; Put '+' in buffer
3794:	197A  F28119  	        JP      P,OUTEXP        ; Positive - Output exponent
3795:	197D  362D    	        LD      (HL),'-'        ; Put '-' in buffer
3796:	197F  2F      	        CPL                     ; Negate exponent
3797:	1980  3C      	        INC     A
3798:	1981  062F    	OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
3799:	1983  04      	EXPTEN: INC     B               ; Count subtractions
3800:	1984  D60A    	        SUB     10              ; Tens digit
3801:	1986  D28319  	        JP      NC,EXPTEN       ; More to do
3802:	1989  C63A    	        ADD     A,'0'+10        ; Restore and make ASCII
3803:	198B  23      	        INC     HL              ; Move on
3804:	198C  70      	        LD      (HL),B          ; Save MSB of exponent
3805:	198D  23      	JSTZER: INC     HL              ;
3806:	198E  77      	        LD      (HL),A          ; Save LSB of exponent
3807:	198F  23      	        INC     HL
3808:	1990  71      	NOENED: LD      (HL),C          ; Mark end of buffer
3809:	1991  E1      	        POP     HL              ; Restore code string address
3810:	1992  C9      	        RET
3811:			
3812:	1993  017494  	RNGTST: LD      BC,9474H        ; BCDE = 999999.
3813:	1996  11F723  	        LD      DE,23F7H
3814:	1999  CD9F17  	        CALL    CMPNUM          ; Compare numbers
3815:	199C  B7      	        OR      A
3816:	199D  E1      	        POP     HL              ; Return address to HL
3817:	199E  E2FB18  	        JP      PO,GTSIXD       ; Too big - Divide by ten
3818:	19A1  E9      	        JP      (HL)            ; Otherwise return to caller
3819:			
3820:	19A2  00000080	HALF:   .DB     00H,00H,00H,80H ; 0.5
3821:			
3822:	19A6  A08601  	POWERS: .DB     0A0H,086H,001H  ; 100000
3823:	19A9  102700  	        .DB     010H,027H,000H  ;  10000
3824:	19AC  E80300  	        .DB     0E8H,003H,000H  ;   1000
3825:	19AF  640000  	        .DB     064H,000H,000H  ;    100
3826:	19B2  0A0000  	        .DB     00AH,000H,000H  ;     10
3827:	19B5  010000  	        .DB     001H,000H,000H  ;      1
3828:			
3829:	19B8  214D17  	NEGAFT: LD      HL,INVSGN       ; Negate result
3830:	19BB  E3      	        EX      (SP),HL         ; To be done after caller
3831:	19BC  E9      	        JP      (HL)            ; Return to caller
3832:			
3833:	19BD  CD5517  	SQR:    CALL    STAKFP          ; Put value on stack
3834:	19C0  21A219  	        LD      HL,HALF         ; Set power to 1/2
3835:	19C3  CD6217  	        CALL    PHLTFP          ; Move 1/2 to FPREG
3836:			
3837:	19C6  C1      	POWER:  POP     BC              ; Get base
3838:	19C7  D1      	        POP     DE
3839:	19C8  CD2417  	        CALL    TSTSGN          ; Test sign of power
3840:	19CB  78      	        LD      A,B             ; Get exponent of base
3841:	19CC  CA0B1A  	        JP      Z,EXP           ; Make result 1 if zero
3842:	19CF  F2D619  	        JP      P,POWER1        ; Positive base - Ok
3843:	19D2  B7      	        OR      A               ; Zero to negative power?
3844:	19D3  CAB404  	        JP      Z,DZERR         ; Yes - ?/0 Error
3845:	19D6  B7      	POWER1: OR      A               ; Base zero?
3846:	19D7  CA4515  	        JP      Z,SAVEXP        ; Yes - Return zero
3847:	19DA  D5      	        PUSH    DE              ; Save base
3848:	19DB  C5      	        PUSH    BC
3849:	19DC  79      	        LD      A,C             ; Get MSB of base
3850:	19DD  F67F    	        OR      01111111B       ; Get sign status
3851:	19DF  CD7017  	        CALL    BCDEFP          ; Move power to BCDE
3852:	19E2  F2F319  	        JP      P,POWER2        ; Positive base - Ok
3853:	19E5  D5      	        PUSH    DE              ; Save power
3854:	19E6  C5      	        PUSH    BC
3855:	19E7  CDF717  	        CALL    INT             ; Get integer of power
3856:	19EA  C1      	        POP     BC              ; Restore power
3857:	19EB  D1      	        POP     DE
3858:	19EC  F5      	        PUSH    AF              ; MSB of base
3859:	19ED  CD9F17  	        CALL    CMPNUM          ; Power an integer?
3860:	19F0  E1      	        POP     HL              ; Restore MSB of base
3861:	19F1  7C      	        LD      A,H             ; but don't affect flags
3862:	19F2  1F      	        RRA                     ; Exponent odd or even?
3863:	19F3  E1      	POWER2: POP     HL              ; Restore MSB and exponent
3864:	19F4  22E620  	        LD      (FPREG+2),HL    ; Save base in FPREG
3865:	19F7  E1      	        POP     HL              ; LSBs of base
3866:	19F8  22E420  	        LD      (FPREG),HL      ; Save in FPREG
3867:	19FB  DCB819  	        CALL    C,NEGAFT        ; Odd power - Negate result
3868:	19FE  CC4D17  	        CALL    Z,INVSGN        ; Negative base - Negate it
3869:	1A01  D5      	        PUSH    DE              ; Save power
3870:	1A02  C5      	        PUSH    BC
3871:	1A03  CDD815  	        CALL    LOG             ; Get LOG of base
3872:	1A06  C1      	        POP     BC              ; Restore power
3873:	1A07  D1      	        POP     DE
3874:	1A08  CD1916  	        CALL    FPMULT          ; Multiply LOG by power
3875:			
3876:	1A0B  CD5517  	EXP:    CALL    STAKFP          ; Put value on stack
3877:	1A0E  013881  	        LD      BC,08138H       ; BCDE = 1/Ln(2)
3878:	1A11  113BAA  	        LD      DE,0AA3BH
3879:	1A14  CD1916  	        CALL    FPMULT          ; Multiply value by 1/LN(2)
3880:	1A17  3AE720  	        LD      A,(FPEXP)       ; Get exponent
3881:	1A1A  FE88    	        CP      80H+8           ; Is it in range?
3882:	1A1C  D20017  	        JP      NC,OVTST1       ; No - Test for overflow
3883:	1A1F  CDF717  	        CALL    INT             ; Get INT of FPREG
3884:	1A22  C680    	        ADD     A,80H           ; For excess 128
3885:	1A24  C602    	        ADD     A,2             ; Exponent > 126?
3886:	1A26  DA0017  	        JP      C,OVTST1        ; Yes - Test for overflow
3887:	1A29  F5      	        PUSH    AF              ; Save scaling factor
3888:	1A2A  21C715  	        LD      HL,UNITY        ; Point to 1.
3889:	1A2D  CDCF14  	        CALL    ADDPHL          ; Add 1 to FPREG
3890:	1A30  CD1016  	        CALL    MULLN2          ; Multiply by LN(2)
3891:	1A33  F1      	        POP     AF              ; Restore scaling factor
3892:	1A34  C1      	        POP     BC              ; Restore exponent
3893:	1A35  D1      	        POP     DE
3894:	1A36  F5      	        PUSH    AF              ; Save scaling factor
3895:	1A37  CDDB14  	        CALL    SUBCDE          ; Subtract exponent from FPREG
3896:	1A3A  CD4D17  	        CALL    INVSGN          ; Negate result
3897:	1A3D  214B1A  	        LD      HL,EXPTAB       ; Coefficient table
3898:	1A40  CD7B1A  	        CALL    SMSER1          ; Sum the series
3899:	1A43  110000  	        LD      DE,0            ; Zero LSBs
3900:	1A46  C1      	        POP     BC              ; Scaling factor
3901:	1A47  4A      	        LD      C,D             ; Zero MSB
3902:	1A48  C31916  	        JP      FPMULT          ; Scale result to correct value
3903:			
3904:	1A4B  08      	EXPTAB: .DB     8                       ; Table used by EXP
3905:	1A4C  402E9474	        .DB     040H,02EH,094H,074H     ; -1/7! (-1/5040)
3906:	1A50  704F2E77	        .DB     070H,04FH,02EH,077H     ;  1/6! ( 1/720)
3907:	1A54  6E02887A	        .DB     06EH,002H,088H,07AH     ; -1/5! (-1/120)
3908:	1A58  E6A02A7C	        .DB     0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
3909:	1A5C  50AAAA7E	        .DB     050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
3910:	1A60  FFFF7F7F	        .DB     0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
3911:	1A64  00008081	        .DB     000H,000H,080H,081H     ; -1/1! (-1/1)
3912:	1A68  00000081	        .DB     000H,000H,000H,081H     ;  1/0! ( 1/1)
3913:			
3914:	1A6C  CD5517  	SUMSER: CALL    STAKFP          ; Put FPREG on stack
3915:	1A6F  111716  	        LD      DE,MULT         ; Multiply by "X"
3916:	1A72  D5      	        PUSH    DE              ; To be done after
3917:	1A73  E5      	        PUSH    HL              ; Save address of table
3918:	1A74  CD7017  	        CALL    BCDEFP          ; Move FPREG to BCDE
3919:	1A77  CD1916  	        CALL    FPMULT          ; Square the value
3920:	1A7A  E1      	        POP     HL              ; Restore address of table
3921:	1A7B  CD5517  	SMSER1: CALL    STAKFP          ; Put value on stack
3922:	1A7E  7E      	        LD      A,(HL)          ; Get number of coefficients
3923:	1A7F  23      	        INC     HL              ; Point to start of table
3924:	1A80  CD6217  	        CALL    PHLTFP          ; Move coefficient to FPREG
3925:	1A83  06      	        .DB     06H             ; Skip "POP AF"
3926:	1A84  F1      	SUMLP:  POP     AF              ; Restore count
3927:	1A85  C1      	        POP     BC              ; Restore number
3928:	1A86  D1      	        POP     DE
3929:	1A87  3D      	        DEC     A               ; Cont coefficients
3930:	1A88  C8      	        RET     Z               ; All done
3931:	1A89  D5      	        PUSH    DE              ; Save number
3932:	1A8A  C5      	        PUSH    BC
3933:	1A8B  F5      	        PUSH    AF              ; Save count
3934:	1A8C  E5      	        PUSH    HL              ; Save address in table
3935:	1A8D  CD1916  	        CALL    FPMULT          ; Multiply FPREG by BCDE
3936:	1A90  E1      	        POP     HL              ; Restore address in table
3937:	1A91  CD7317  	        CALL    LOADFP          ; Number at HL to BCDE
3938:	1A94  E5      	        PUSH    HL              ; Save address in table
3939:	1A95  CDDE14  	        CALL    FPADD           ; Add coefficient to FPREG
3940:	1A98  E1      	        POP     HL              ; Restore address in table
3941:	1A99  C3841A  	        JP      SUMLP           ; More coefficients
3942:			
3943:	1A9C  CD2417  	RND:    CALL    TSTSGN          ; Test sign of FPREG
3944:	1A9F  211920  	        LD      HL,SEED+2       ; Random number seed
3945:	1AA2  FAFD1A  	        JP      M,RESEED        ; Negative - Re-seed
3946:	1AA5  213A20  	        LD      HL,LSTRND       ; Last random number
3947:	1AA8  CD6217  	        CALL    PHLTFP          ; Move last RND to FPREG
3948:	1AAB  211920  	        LD      HL,SEED+2       ; Random number seed
3949:	1AAE  C8      	        RET     Z               ; Return if RND(0)
3950:	1AAF  86      	        ADD     A,(HL)          ; Add (SEED)+2)
3951:	1AB0  E607    	        AND     00000111B       ; 0 to 7
3952:	1AB2  0600    	        LD      B,0
3953:	1AB4  77      	        LD      (HL),A          ; Re-save seed
3954:	1AB5  23      	        INC     HL              ; Move to coefficient table
3955:	1AB6  87      	        ADD     A,A             ; 4 bytes
3956:	1AB7  87      	        ADD     A,A             ; per entry
3957:	1AB8  4F      	        LD      C,A             ; BC = Offset into table
3958:	1AB9  09      	        ADD     HL,BC           ; Point to coefficient
3959:	1ABA  CD7317  	        CALL    LOADFP          ; Coefficient to BCDE
3960:	1ABD  CD1916  	        CALL    FPMULT  ;       ; Multiply FPREG by coefficient
3961:	1AC0  3A1820  	        LD      A,(SEED+1)      ; Get (SEED+1)
3962:	1AC3  3C      	        INC     A               ; Add 1
3963:	1AC4  E603    	        AND     00000011B       ; 0 to 3
3964:	1AC6  0600    	        LD      B,0
3965:	1AC8  FE01    	        CP      1               ; Is it zero?
3966:	1ACA  88      	        ADC     A,B             ; Yes - Make it 1
3967:	1ACB  321820  	        LD      (SEED+1),A      ; Re-save seed
3968:	1ACE  21011B  	        LD      HL,RNDTAB-4     ; Addition table
3969:	1AD1  87      	        ADD     A,A             ; 4 bytes
3970:	1AD2  87      	        ADD     A,A             ; per entry
3971:	1AD3  4F      	        LD      C,A             ; BC = Offset into table
3972:	1AD4  09      	        ADD     HL,BC           ; Point to value
3973:	1AD5  CDCF14  	        CALL    ADDPHL          ; Add value to FPREG
3974:	1AD8  CD7017  	RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
3975:	1ADB  7B      	        LD      A,E             ; Get LSB
3976:	1ADC  59      	        LD      E,C             ; LSB = MSB
3977:	1ADD  EE4F    	        XOR     01001111B       ; Fiddle around
3978:	1ADF  4F      	        LD      C,A             ; New MSB
3979:	1AE0  3680    	        LD      (HL),80H        ; Set exponent
3980:	1AE2  2B      	        DEC     HL              ; Point to MSB
3981:	1AE3  46      	        LD      B,(HL)          ; Get MSB
3982:	1AE4  3680    	        LD      (HL),80H        ; Make value -0.5
3983:	1AE6  211720  	        LD      HL,SEED         ; Random number seed
3984:	1AE9  34      	        INC     (HL)            ; Count seed
3985:	1AEA  7E      	        LD      A,(HL)          ; Get seed
3986:	1AEB  D6AB    	        SUB     171             ; Do it modulo 171
3987:	1AED  C2F41A  	        JP      NZ,RND2         ; Non-zero - Ok
3988:	1AF0  77      	        LD      (HL),A          ; Zero seed
3989:	1AF1  0C      	        INC     C               ; Fillde about
3990:	1AF2  15      	        DEC     D               ; with the
3991:	1AF3  1C      	        INC     E               ; number
3992:	1AF4  CD2F15  	RND2:   CALL    BNORM           ; Normalise number
3993:	1AF7  213A20  	        LD      HL,LSTRND       ; Save random number
3994:	1AFA  C37C17  	        JP      FPTHL           ; Move FPREG to last and return
3995:			
3996:	1AFD  77      	RESEED: LD      (HL),A          ; Re-seed random numbers
3997:	1AFE  2B      	        DEC     HL
3998:	1AFF  77      	        LD      (HL),A
3999:	1B00  2B      	        DEC     HL
4000:	1B01  77      	        LD      (HL),A
4001:	1B02  C3D81A  	        JP      RND1            ; Return RND seed
4002:			
4003:	1B05  68B14668	RNDTAB: .DB  068H,0B1H,046H,068H     ; Table used by RND
4004:	1B09  99E99269	        .DB  099H,0E9H,092H,069H
4005:	1B0D  10D17568	        .DB  010H,0D1H,075H,068H
4006:			
4007:	1B11  215B1B  	COS:    LD      HL,HALFPI       ; Point to PI/2
4008:	1B14  CDCF14  	        CALL    ADDPHL          ; Add it to PPREG
4009:	1B17  CD5517  	SIN:    CALL    STAKFP          ; Put angle on stack
4010:	1B1A  014983  	        LD      BC,8349H        ; BCDE = 2 PI
4011:	1B1D  11DB0F  	        LD      DE,0FDBH
4012:	1B20  CD6517  	        CALL    FPBCDE          ; Move 2 PI to FPREG
4013:	1B23  C1      	        POP     BC              ; Restore angle
4014:	1B24  D1      	        POP     DE
4015:	1B25  CD7A16  	        CALL    DVBCDE          ; Divide angle by 2 PI
4016:	1B28  CD5517  	        CALL    STAKFP          ; Put it on stack
4017:	1B2B  CDF717  	        CALL    INT             ; Get INT of result
4018:	1B2E  C1      	        POP     BC              ; Restore number
4019:	1B2F  D1      	        POP     DE
4020:	1B30  CDDB14  	        CALL    SUBCDE          ; Make it 0 <= value < 1
4021:	1B33  215F1B  	        LD      HL,QUARTR       ; Point to 0.25
4022:	1B36  CDD514  	        CALL    SUBPHL          ; Subtract value from 0.25
4023:	1B39  CD2417  	        CALL    TSTSGN          ; Test sign of value
4024:	1B3C  37      	        SCF                     ; Flag positive
4025:	1B3D  F2471B  	        JP      P,SIN1          ; Positive - Ok
4026:	1B40  CDCC14  	        CALL    ROUND           ; Add 0.5 to value
4027:	1B43  CD2417  	        CALL    TSTSGN          ; Test sign of value
4028:	1B46  B7      	        OR      A               ; Flag negative
4029:	1B47  F5      	SIN1:   PUSH    AF              ; Save sign
4030:	1B48  F44D17  	        CALL    P,INVSGN        ; Negate value if positive
4031:	1B4B  215F1B  	        LD      HL,QUARTR       ; Point to 0.25
4032:	1B4E  CDCF14  	        CALL    ADDPHL          ; Add 0.25 to value
4033:	1B51  F1      	        POP     AF              ; Restore sign
4034:	1B52  D44D17  	        CALL    NC,INVSGN       ; Negative - Make positive
4035:	1B55  21631B  	        LD      HL,SINTAB       ; Coefficient table
4036:	1B58  C36C1A  	        JP      SUMSER          ; Evaluate sum of series
4037:			
4038:	1B5B  DB0F4981	HALFPI: .DB  0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
4039:			
4040:	1B5F  0000007F	QUARTR: .DB  000H,000H,000H,07FH     ; 0.25
4041:			
4042:	1B63  05      	SINTAB: .DB  5                       ; Table used by SIN
4043:	1B64  BAD71E86	        .DB  0BAH,0D7H,01EH,086H     ; 39.711
4044:	1B68  64269987	        .DB  064H,026H,099H,087H     ;-76.575
4045:	1B6C  58342387	        .DB  058H,034H,023H,087H     ; 81.602
4046:	1B70  E05DA586	        .DB  0E0H,05DH,0A5H,086H     ;-41.342
4047:	1B74  DA0F4983	        .DB  0DAH,00FH,049H,083H     ;  6.2832
4048:			
4049:	1B78  CD5517  	TAN:    CALL    STAKFP          ; Put angle on stack
4050:	1B7B  CD171B  	        CALL    SIN             ; Get SIN of angle
4051:	1B7E  C1      	        POP     BC              ; Restore angle
4052:	1B7F  E1      	        POP     HL
4053:	1B80  CD5517  	        CALL    STAKFP          ; Save SIN of angle
4054:	1B83  EB      	        EX      DE,HL           ; BCDE = Angle
4055:	1B84  CD6517  	        CALL    FPBCDE          ; Angle to FPREG
4056:	1B87  CD111B  	        CALL    COS             ; Get COS of angle
4057:	1B8A  C37816  	        JP      DIV             ; TAN = SIN / COS
4058:			
4059:	1B8D  CD2417  	ATN:    CALL    TSTSGN          ; Test sign of value
4060:	1B90  FCB819  	        CALL    M,NEGAFT        ; Negate result after if -ve
4061:	1B93  FC4D17  	        CALL    M,INVSGN        ; Negate value if -ve
4062:	1B96  3AE720  	        LD      A,(FPEXP)       ; Get exponent
4063:	1B99  FE81    	        CP      81H             ; Number less than 1?
4064:	1B9B  DAAA1B  	        JP      C,ATN1          ; Yes - Get arc tangnt
4065:	1B9E  010081  	        LD      BC,8100H        ; BCDE = 1
4066:	1BA1  51      	        LD      D,C
4067:	1BA2  59      	        LD      E,C
4068:	1BA3  CD7A16  	        CALL    DVBCDE          ; Get reciprocal of number
4069:	1BA6  21D514  	        LD      HL,SUBPHL       ; Sub angle from PI/2
4070:	1BA9  E5      	        PUSH    HL              ; Save for angle > 1
4071:	1BAA  21B41B  	ATN1:   LD      HL,ATNTAB       ; Coefficient table
4072:	1BAD  CD6C1A  	        CALL    SUMSER          ; Evaluate sum of series
4073:	1BB0  215B1B  	        LD      HL,HALFPI       ; PI/2 - angle in case > 1
4074:	1BB3  C9      	        RET                     ; Number > 1 - Sub from PI/2
4075:			
4076:	1BB4  09      	ATNTAB: .DB  9                       ; Table used by ATN
4077:	1BB5  4AD73B78	        .DB  04AH,0D7H,03BH,078H     ; 1/17
4078:	1BB9  026E847B	        .DB  002H,06EH,084H,07BH     ;-1/15
4079:	1BBD  FEC12F7C	        .DB  0FEH,0C1H,02FH,07CH     ; 1/13
4080:	1BC1  74319A7D	        .DB  074H,031H,09AH,07DH     ;-1/11
4081:	1BC5  843D5A7D	        .DB  084H,03DH,05AH,07DH     ; 1/9
4082:	1BC9  C87F917E	        .DB  0C8H,07FH,091H,07EH     ;-1/7
4083:	1BCD  E4BB4C7E	        .DB  0E4H,0BBH,04CH,07EH     ; 1/5
4084:	1BD1  6CAAAA7F	        .DB  06CH,0AAH,0AAH,07FH     ;-1/3
4085:	1BD5  00000081	        .DB  000H,000H,000H,081H     ; 1/1
4086:			
4087:			
4088:	1BD9  C9      	ARET:   RET                     ; A RETurn instruction
4089:			
4090:	1BDA  D7      	GETINP: RST     10H             ;input a character
4091:	1BDB  C9      	        RET
4092:			
4093:	1BDC          	CLS: 
4094:	1BDC  3E0C    	        LD      A,CS            ; ASCII Clear screen
4095:	1BDE  C30F1D  	        JP      MONOUT          ; Output character
4096:			
4097:	1BE1  CDA314  	WIDTH:  CALL    GETINT          ; Get integer 0-255
4098:	1BE4  7B      	        LD      A,E             ; Width to A
4099:	1BE5  324220  	        LD      (LWIDTH),A      ; Set width
4100:	1BE8  C9      	        RET
4101:			
4102:	1BE9  CD420D  	LINES:  CALL    GETNUM          ; Get a number
4103:	1BEC  CD8709  	        CALL    DEINT           ; Get integer -32768 to 32767
4104:	1BEF  ED534620	        LD      (LINESC),DE     ; Set lines counter
4105:	1BF3  ED534820	        LD      (LINESN),DE     ; Set lines number
4106:	1BF7  C9      	        RET
4107:			
4108:	1BF8  CD8709  	DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
4109:	1BFB  D5      	        PUSH    DE              ; Save number
4110:	1BFC  E1      	        POP     HL              ; Number to HL
4111:	1BFD  46      	        LD      B,(HL)          ; Get LSB of contents
4112:	1BFE  23      	        INC     HL
4113:	1BFF  7E      	        LD      A,(HL)          ; Get MSB of contents
4114:	1C00  C3FD10  	        JP      ABPASS          ; Return integer AB
4115:			
4116:	1C03  CD420D  	DOKE:   CALL    GETNUM          ; Get a number
4117:	1C06  CD8709  	        CALL    DEINT           ; Get integer -32768 to 32767
4118:	1C09  D5      	        PUSH    DE              ; Save address
4119:	1C0A  CD4B07  	        CALL    CHKSYN          ; Make sure ',' follows
4120:	1C0D  2C      	        .DB     ','
4121:	1C0E  CD420D  	        CALL    GETNUM          ; Get a number
4122:	1C11  CD8709  	        CALL    DEINT           ; Get integer -32768 to 32767
4123:	1C14  E3      	        EX      (SP),HL         ; Save value,get address
4124:	1C15  73      	        LD      (HL),E          ; Save LSB of value
4125:	1C16  23      	        INC     HL
4126:	1C17  72      	        LD      (HL),D          ; Save MSB of value
4127:	1C18  E1      	        POP     HL              ; Restore code string address
4128:	1C19  C9      	        RET
4129:			
4130:			
4131:			; HEX$(nn) Convert 16 bit number to Hexadecimal string
4132:			
4133:	1C1A  CD450D  	HEX:    CALL    TSTNUM          ; Verify it's a number
4134:	1C1D  CD8709  	        CALL    DEINT           ; Get integer -32768 to 32767
4135:	1C20  C5      	        PUSH    BC              ; Save contents of BC
4136:	1C21  21E920  	        LD      HL,PBUFF
4137:	1C24  7A      	        LD      A,D             ; Get high order into A
4138:	1C25  FE00    	        CP      0H
4139:	1C27  280C    	        JR      Z,HEX2          ; Skip output if both high digits are zero
4140:	1C29  CD521C  	        CALL    BYT2ASC         ; Convert D to ASCII
4141:	1C2C  78      	        LD      A,B
4142:	1C2D  FE30    	        CP      '0'
4143:	1C2F  2802    	        JR      Z,HEX1          ; Don't store high digit if zero
4144:	1C31  70      	        LD      (HL),B          ; Store it to PBUFF
4145:	1C32  23      	        INC     HL              ; Next location
4146:	1C33  71      	HEX1:   LD      (HL),C          ; Store C to PBUFF+1
4147:	1C34  23      	        INC     HL              ; Next location
4148:	1C35  7B      	HEX2:   LD      A,E             ; Get lower byte
4149:	1C36  CD521C  	        CALL    BYT2ASC         ; Convert E to ASCII
4150:	1C39  7A      	        LD      A,D
4151:	1C3A  FE00    	        CP      0H
4152:	1C3C  2005    	        JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
4153:	1C3E  78      	        LD      A,B
4154:	1C3F  FE30    	        CP      '0'             ; If high digit of lower byte is zero then don't print
4155:	1C41  2802    	        JR      Z,HEX4
4156:	1C43  70      	HEX3:   LD      (HL),B          ; to PBUFF+2
4157:	1C44  23      	        INC     HL              ; Next location
4158:	1C45  71      	HEX4:   LD      (HL),C          ; to PBUFF+3
4159:	1C46  23      	        INC     HL              ; PBUFF+4 to zero
4160:	1C47  AF      	        XOR     A               ; Terminating character
4161:	1C48  77      	        LD      (HL),A          ; Store zero to terminate
4162:	1C49  23      	        INC     HL              ; Make sure PBUFF is terminated
4163:	1C4A  77      	        LD      (HL),A          ; Store the double zero there
4164:	1C4B  C1      	        POP     BC              ; Get BC back
4165:	1C4C  21E920  	        LD      HL,PBUFF        ; Reset to start of PBUFF
4166:	1C4F  C3AB11  	        JP      STR1            ; Convert the PBUFF to a string and return it
4167:			
4168:	1C52  47      	BYT2ASC LD      B,A             ; Save original value
4169:	1C53  E60F    	        AND     0FH             ; Strip off upper nybble
4170:	1C55  FE0A    	        CP      0AH             ; 0-9?
4171:	1C57  3802    	        JR      C,ADD30         ; If A-F, add 7 more
4172:	1C59  C607    	        ADD     A,07H           ; Bring value up to ASCII A-F
4173:	1C5B  C630    	ADD30   ADD     A,30H           ; And make ASCII
4174:	1C5D  4F      	        LD      C,A             ; Save converted char to C
4175:	1C5E  78      	        LD      A,B             ; Retrieve original value
4176:	1C5F  0F      	        RRCA                    ; and Rotate it right
4177:	1C60  0F      	        RRCA
4178:	1C61  0F      	        RRCA
4179:	1C62  0F      	        RRCA
4180:	1C63  E60F    	        AND     0FH             ; Mask off upper nybble
4181:	1C65  FE0A    	        CP      0AH             ; 0-9? < A hex?
4182:	1C67  3802    	        JR      C,ADD301        ; Skip Add 7
4183:	1C69  C607    	        ADD     A,07H           ; Bring it up to ASCII A-F
4184:	1C6B  C630    	ADD301  ADD     A,30H           ; And make it full ASCII
4185:	1C6D  47      	        LD      B,A             ; Store high order byte
4186:	1C6E  C9      	        RET
4187:			
4188:			; Convert "&Hnnnn" to FPREG
4189:			; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
4190:			; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
4191:	1C6F  EB      	HEXTFP  EX      DE,HL           ; Move code string pointer to DE
4192:	1C70  210000  	        LD      HL,0000H        ; Zero out the value
4193:	1C73  CD881C  	        CALL    GETHEX          ; Check the number for valid hex
4194:	1C76  DAA81C  	        JP      C,HXERR         ; First value wasn't hex, HX error
4195:	1C79  1805    	        JR      HEXLP1          ; Convert first character
4196:	1C7B  CD881C  	HEXLP   CALL    GETHEX          ; Get second and addtional characters
4197:	1C7E  381F    	        JR      C,HEXIT         ; Exit if not a hex character
4198:	1C80  29      	HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
4199:	1C81  29      	        ADD     HL,HL
4200:	1C82  29      	        ADD     HL,HL
4201:	1C83  29      	        ADD     HL,HL
4202:	1C84  B5      	        OR      L               ; Add in D0-D3 into L
4203:	1C85  6F      	        LD      L,A             ; Save new value
4204:	1C86  18F3    	        JR      HEXLP           ; And continue until all hex characters are in
4205:			
4206:	1C88  13      	GETHEX  INC     DE              ; Next location
4207:	1C89  1A      	        LD      A,(DE)          ; Load character at pointer
4208:	1C8A  FE20    	        CP      ' '
4209:	1C8C  CA881C  	        JP      Z,GETHEX        ; Skip spaces
4210:	1C8F  D630    	        SUB     30H             ; Get absolute value
4211:	1C91  D8      	        RET     C               ; < "0", error
4212:	1C92  FE0A    	        CP      0AH
4213:	1C94  3805    	        JR      C,NOSUB7        ; Is already in the range 0-9
4214:	1C96  D607    	        SUB     07H             ; Reduce to A-F
4215:	1C98  FE0A    	        CP      0AH             ; Value should be $0A-$0F at this point
4216:	1C9A  D8      	        RET     C               ; CY set if was :            ; < = > ? @
4217:	1C9B  FE10    	NOSUB7  CP      10H             ; > Greater than "F"?
4218:	1C9D  3F      	        CCF
4219:	1C9E  C9      	        RET                     ; CY set if it wasn't valid hex
4220:			
4221:	1C9F  EB      	HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
4222:	1CA0  7A      	        LD      A,D             ; Load DE into AC
4223:	1CA1  4B      	        LD      C,E             ; For prep to 
4224:	1CA2  E5      	        PUSH    HL
4225:	1CA3  CDFC10  	        CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4226:	1CA6  E1      	        POP     HL
4227:	1CA7  C9      	        RET
4228:			
4229:	1CA8  1E26    	HXERR:  LD      E,HE            ; ?HEX Error
4230:	1CAA  C3C504  	        JP      ERROR
4231:			
4232:			; BIN$(NN) Convert integer to a 1-16 char binary string
4233:	1CAD  CD450D  	BIN:    CALL    TSTNUM          ; Verify it's a number
4234:	1CB0  CD8709  	        CALL    DEINT           ; Get integer -32768 to 32767
4235:	1CB3  C5      	BIN2:   PUSH    BC              ; Save contents of BC
4236:	1CB4  21E920  	        LD      HL,PBUFF
4237:	1CB7  0611    	        LD      B,17            ; One higher than max char count
4238:	1CB9          	ZEROSUP:                        ; Suppress leading zeros
4239:	1CB9  05      	        DEC     B               ; Max 16 chars
4240:	1CBA  78      	        LD      A,B
4241:	1CBB  FE01    	        CP      01H
4242:	1CBD  2808    	        JR      Z,BITOUT        ; Always output at least one character
4243:	1CBF  CB13    	        RL      E
4244:	1CC1  CB12    	        RL      D
4245:	1CC3  30F4    	        JR      NC,ZEROSUP
4246:	1CC5  1804    	        JR      BITOUT2
4247:	1CC7          	BITOUT:
4248:	1CC7  CB13    	        RL      E
4249:	1CC9  CB12    	        RL      D               ; Top bit now in carry
4250:	1CCB          	BITOUT2:
4251:	1CCB  3E30    	        LD      A,'0'           ; Char for '0'
4252:	1CCD  CE00    	        ADC     A,0             ; If carry set then '0' --> '1'
4253:	1CCF  77      	        LD      (HL),A
4254:	1CD0  23      	        INC     HL
4255:	1CD1  05      	        DEC     B
4256:	1CD2  20F3    	        JR      NZ,BITOUT
4257:	1CD4  AF      	        XOR     A               ; Terminating character
4258:	1CD5  77      	        LD      (HL),A          ; Store zero to terminate
4259:	1CD6  23      	        INC     HL              ; Make sure PBUFF is terminated
4260:	1CD7  77      	        LD      (HL),A          ; Store the double zero there
4261:	1CD8  C1      	        POP     BC
4262:	1CD9  21E920  	        LD      HL,PBUFF
4263:	1CDC  C3AB11  	        JP      STR1
4264:			
4265:			; Convert "&Bnnnn" to FPREG
4266:			; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
4267:	1CDF  EB      	BINTFP: EX      DE,HL           ; Move code string pointer to DE
4268:	1CE0  210000  	        LD      HL,0000H        ; Zero out the value
4269:	1CE3  CDFC1C  	        CALL    CHKBIN          ; Check the number for valid bin
4270:	1CE6  DA0A1D  	        JP      C,BINERR        ; First value wasn't bin, HX error
4271:	1CE9  D630    	BINIT:  SUB     '0'
4272:	1CEB  29      	        ADD     HL,HL           ; Rotate HL left
4273:	1CEC  B5      	        OR      L
4274:	1CED  6F      	        LD      L,A
4275:	1CEE  CDFC1C  	        CALL    CHKBIN          ; Get second and addtional characters
4276:	1CF1  30F6    	        JR      NC,BINIT        ; Process if a bin character
4277:	1CF3  EB      	        EX      DE,HL           ; Value into DE, Code string into HL
4278:	1CF4  7A      	        LD      A,D             ; Load DE into AC
4279:	1CF5  4B      	        LD      C,E             ; For prep to 
4280:	1CF6  E5      	        PUSH    HL
4281:	1CF7  CDFC10  	        CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4282:	1CFA  E1      	        POP     HL
4283:	1CFB  C9      	        RET
4284:			
4285:			; Char is in A, NC if char is 0 or 1
4286:	1CFC  13      	CHKBIN: INC     DE
4287:	1CFD  1A      	        LD      A,(DE)
4288:	1CFE  FE20    	        CP      ' '
4289:	1D00  CAFC1C  	        JP      Z,CHKBIN        ; Skip spaces
4290:	1D03  FE30    	        CP      '0'             ; Set C if < '0'
4291:	1D05  D8      	        RET     C
4292:	1D06  FE32    	        CP      '2'
4293:	1D08  3F      	        CCF                     ; Set C if > '1'
4294:	1D09  C9      	        RET
4295:			
4296:	1D0A  1E28    	BINERR: LD      E,BN            ; ?BIN Error
4297:	1D0C  C3C504  	        JP      ERROR
4298:			
4299:	1D0F  C30800  	MONOUT: JP      0008H           ; output a char
4300:			
4301:			
4302:	1D12  76      	MONITR: HALT
4303:			        ;JP      0000H           ; Restart (Normally Monitor Start)
4304:			
4305:			
4306:	1D13  ED45    	ARETN:  RETN                    ; Return from NMI
4307:			
4308:			
4309:	1D15  F5      	TSTBIT: PUSH    AF              ; Save bit mask
4310:	1D16  A0      	        AND     B               ; Get common bits
4311:	1D17  C1      	        POP     BC              ; Restore bit mask
4312:	1D18  B8      	        CP      B               ; Same bit set?
4313:	1D19  3E00    	        LD      A,0             ; Return 0 in A
4314:	1D1B  C9      	        RET
4315:			
4316:	1D1C  CD5607  	OUTNCR: CALL    OUTC            ; Output character in A
4317:	1D1F  C37D0B  	        JP      PRNTCRLF        ; Output CRLF
4318:			
4319:			; *** USR ***
4320:			; USR(X) jumps here, default USRJP at 0x2048 contains a jump to a RET code
4321:			; Put the user function into ram - int16_t arg: DE, int16_t ret: DE
4322:			; Put the function address into USRJP+1 (0x2049/0x204a = 8265/8266)
4323:	1D22  CD8709  	USR:    CALL    DEINT           ; Get int16_t argument into DE
4324:	1D25  CD0320  	        CALL    USRJP           ; Execute the user program
4325:	1D28  7A      	        LD      A,D             ; int16_t result is returned in DE
4326:	1D29  43      	        LD      B,E             ; Move result to AB
4327:	1D2A  CDFD10  	        CALL    ABPASS          ; Pass the result back to BASIC
4328:	1D2D  C9      	        RET
4329:			
4330:	1D2E ..1FFF 00	        .DC     (ROMSIZE - $), 0
4331:			
4332:	2000          	.end



Statistics:

     4	passes
     0	jr promotions
   639	symbols
  7936	bytes



Symbol Table:

ABPASS          10FD      4349
ABS             1749      5961
ACCSUM           966      2406
ACPASS          10FC      4348
ADD30           1C5B      7259
ADD301          1C6B      7275
ADDEXP          16E2      5858
ADDIG           1888      6280
ADDPHL          14CF      5327
ALLFOL          13CB      5067
ANTVLU           C66      3174
ARET            1BD9      7129
ARETN           1D13      7443
ARLDSV          101D      4125
ARREND          20DA      8410
ARRLP           1296      4758
ASC             139C      5020
ASCTFP          182B      6187
ASPCS            BC8      3016
ATN             1B8D      7053
ATN1            1BAA      7082
ATNTAB          1BB4      7092
ATOH             9A1      2465
BADINP           BED      3053
BAKSTK           45A      1114
BAKTMP          137C      4988
BASTXT          205E      8286
BCDEFP          1770      6000
BFREE            1AA      426
BIN             1CAD      7341
BIN2            1CB3      7347
BINERR          1D0A      7434
BINIT           1CE9      7401
BINTFP          1CDF      7391
BITOUT          1CC7      7367
BITOUT2         1CCB      7371
BKSP           =08        8
BN             =28        40
BNORM           152F      5423
BNRMLP          1532      5426
BRK              918      2328
BRKFLG          204D      8269
BRKLIN          20CE      8398
BRKMSG           454      1108
BRKRET           1A4      420
BS             =10        16
BSERR           1050      4176
BUFFER          2061      8289
BYT2ASC         1C52      7250
BYTSFT          1667      5735
CAN            =18        24
CFEVAL           FB3      4019
CHARTY           F61      3937
CHEKFN          1194      4500
CHKBIN          1CFC      7420
CHKLTR           973      2419
CHKSTK           48E      1166
CHKSUM          204A      8266
CHKSYN           74B      1867
CHKTYP           D47      3399
CHR             13AD      5037
CLEAR            9C6      2502
CLOTST           780      1920
CLREG            5E3      1507
CLRPTR           5BE      1470
CLS             1BDC      7132
CMPFP           17B9      6073
CMPLG1           EC7      3783
CMPLOG           EC5      3781
CMPNUM          179F      6047
CMPRES           F09      3849
CMPSTR           EF1      3825
CN             =20        32
CNVNUM          1837      6199
COLD             100      256
COMMAN          2043      8259
COMPL           158F      5519
CONCAT          1311      4881
CONEXP          1867      6247
CONPOS          152C      5420
CONT             94B      2379
CONTAD          20D4      8404
CONVAR           E32      3634
COPY             11D      285
COS             1B11      6929
COUNT            7F0      2032
CPDEHL           745      1861
CPYLIT           6B5      1717
CR             =0D        13
CRARLP          1070      4208
CREARY          1055      4181
CRESTR           AC5      2757
CRNCLP           616      1558
CRTMST          11CD      4557
CRTST           11D9      4569
CRTSTE          11EF      4591
CRUNCH           60D      1549
CS             =0C        12
CSTART           10C      268
CTLOFG          2045      8261
CTRLC          =03        3
CTRLG          =07        7
CTRLO          =0F        15
CTRLQ          =11        17
CTRLR          =12        18
CTRLS          =13        19
CTRLU          =15        21
CUROPR          20C5      8389
CURPOS          20AB      8363
DATA             A6C      2668
DATFLG          20AE      8366
DATLIN          20C9      8393
DATSNR           4AB      1195
DCBCDE          17F0      6128
DD             =12        18
DDERR            4BA      1210
DEEK            1BF8      7160
DEF             1111      4369
DEFSIZ          1078      4216
DEINT            987      2439
DEL            =7F        127
DELCHR           6C5      1733
DEPINT           981      2433
DETHL4          177F      6015
DETHLB          1781      6017
DIGTXT          1931      6449
DIM              F33      3891
DIMRET           F2A      3882
DINPOS           77A      1914
DIV             1678      5752
DIV1           =200A      8202
DIV10           166C      5740
DIV2           =200E      8206
DIV3           =2012      8210
DIV4           =2015      8213
DIVLP           169F      5791
DIVSUP          2009      8201
DOAGN            5FC      1532
DOCOM            B99      2969
DOEBIT          1971      6513
DOFN            113E      4414
DOKE            1C03      7171
DONULL           B87      2951
DOSPC            BC3      3011
DOTAB            BB0      2992
DPOINT          1863      6243
DTSTR           11DD      4573
DVBCDE          167A      5754
DZ             =14        20
DZERR            4B4      1204
EDIGIT          18AA      6314
ENDBUF           6BC      1724
ENDCON          1876      6262
ENDDIM          10D7      4311
ENDINP           B78      2936
ENDNAM           F55      3925
ENDPRG           927      2343
ENFMEM           497      1175
ERRIN            4E5      1253
ERRLIN          20D2      8402
ERRMSG           442      1090
ERROR            4C5      1221
ERRORS           3B8      952
ESC            =1B        27
EVAL             D54      3412
EVAL1            D57      3415
EVAL2            D60      3424
EVAL3            D63      3427
EVLPAR           E19      3609
EVNOT            F13      3859
EXCUTE           8B5      2229
EXP             1A0B      6667
EXPLP           1855      6229
EXPTAB          1A4B      6731
EXPTEN          1983      6531
EXTIG            CC2      3266
FANDT            CEC      3308
FC             =08        8
FCERR            99C      2460
FDTLP            CD3      3283
FINDEL          10B3      4275
FLGDIF          172F      5935
FLGREL          1736      5942
FNARG           20E0      8416
FNCTAB           202      514
FNDARY          1023      4131
FNDELP          10B8      4280
FNDEND           591      1425
FNDNUM          14A0      5280
FNDTOK           7CF      1999
FNDVAR           F9A      3994
FNDWRD           640      1600
FNOFST           E43      3651
FNRGNM          20DE      8414
FNTHR            FA8      4008
FNVAL            E6A      3690
FOPRND           D8C      3468
FOR              81C      2076
FORFLG          20CB      8395
FORFND           84C      2124
FORSLP           830      2096
FPADD           14DE      5342
FPBCDE          1765      5989
FPEXP          =20E7      8423
FPINT           17CC      6092
FPMULT          1619      5657
FPREG           20E4      8420
FPROND          1576      5494
FPSINT           97B      2427
FPTHL           177C      6012
FRE             10DB      4315
FRENUM          10F7      4343
FRMEVL           E35      3637
GARBGE          125E      4702
GARBLP          1261      4705
GETCHR           8D5      2261
GETCMD           509      1289
GETHEX          1C88      7304
GETINP          1BDA      7130
GETINT          14A3      5283
GETLEN          1391      5009
GETLIN           6E2      1762
GETLN            9A2      2466
GETNUM           D42      3394
GETNXT           65B      1627
GETSTR          135B      4955
GETVAR           F38      3896
GNXARY          1295      4757
GOFUNC           E72      3698
GOSUB            A18      2584
GOTO             A29      2601
GRBARY          12B5      4789
GRBDON          1236      4662
GRBLP           126F      4719
GSTRCU          135E      4958
GSTRDE          1362      4962
GSTRHL          1361      4961
GTFLNM          13A0      5024
GTFNAM           F3D      3901
GTLNLP           9A5      2469
GTSIXD          18FB      6395
GTVLUS           C3E      3134
HALF            19A2      6562
HALFPI          1B5B      7003
HE             =26        38
HEX             1C1A      7194
HEX1            1C33      7219
HEX2            1C35      7221
HEX3            1C43      7235
HEX4            1C45      7237
HEXIT           1C9F      7327
HEXLP           1C7B      7291
HEXLP1          1C80      7296
HEXTFP          1C6F      7279
HXERR           1CA8      7336
ID             =16        22
IDTEST          1186      4486
IF               AFB      2811
IFGO             B09      2825
IFJMP            8BC      2236
INCHL           177A      6010
INCLEN           776      1910
INDFND           474      1140
INEWLN           559      1369
INIT             115      277
INITAB           3E2      994
INITBE           442      1090
INITST           110      272
INMSG            449      1097
INP             1460      5216
INPBIN           C90      3216
INPBRK           924      2340
INPORT         =203F      8255
INPSUB          203E      8254
INPUT            BFE      3070
INRNG           1904      6404
INT             17F7      6135
INTVAR           5CD      1485
INVSGN          174D      5965
ITBRET           3EA      1002
ITMSEP           C81      3201
JSTZER          198D      6541
KILFOR           D32      3378
KILIN            6DC      1756
LCRFLG          20AC      8364
LEFT            13BD      5053
LEN             138D      5005
LET              A83      2691
LETNUM           AD6      2774
LETSTR           A9E      2718
LF             =0A        10
LFRGNM          1456      5206
LINEAT          205C      8284
LINEIN          18B6      6326
LINES           1BE9      7145
LINESC          2046      8262
LINESN          2048      8264
LINFND           542      1346
LIST             791      1937
LISTLP           79D      1949
LOADFP          1773      6003
LOG             15D8      5592
LOGTAB          15CB      5579
LOKFOR           45E      1118
LOOPST          20C7      8391
LS             =1C        28
LSTBIN          20CC      8396
LSTLP2           7BD      1981
LSTLP3           7C0      1984
LSTRAM          20AF      8367
LSTRND          203A      8250
LTSTND           C9B      3227
LWIDTH          2042      8258
MAKINT          14A6      5286
MAKNUM          1920      6432
MANLP           183F      6207
MATCH            68D      1677
MEMMSG           1F7      503
MID             13F7      5111
MID1            13C3      5059
MIDNUM          145B      5211
MINCDE          151E      5406
MINUS            E21      3617
MKTMST          11CA      4554
MLDBLP          1818      6168
MLDEBC          1810      6160
MLOOP            145      325
MLSP10          170D      5901
MO             =24        36
MONITR          1D12      7442
MONOUT          1D0F      7439
MORDT            CA7      3239
MORINP           6E7      1767
MOVBUF           578      1400
MOVDIR           695      1685
MOVLP            483      1155
MOVSTR           480      1152
MOVUP            47D      1149
MRPRNT           B1B      2843
MSIZE            132      306
MUL8LP          1644      5700
MULLN2          1610      5648
MULT            1617      5655
MULT8           163B      5691
MULTEN          1881      6273
MULVAL          20F6      8438
MVSTPT           ACD      2765
NEDMOR           C3A      3130
NEGAFT          19B8      6584
NEW              5BD      1469
NEXITM           BD3      3027
NEXT             CF7      3319
NEXT1            CFA      3322
NF             =00        0
NFERR            4B7      1207
NMIFLG          204C      8268
NOCHNG           685      1669
NOENED          1990      6544
NOLIN            93A      2362
NOMADD          1655      5717
NOMLAD          1826      6182
NOPMPT           C18      3096
NORMAL          1549      5449
NOSPC            67C      1660
NOSUB7          1C9B      7323
NOSWAP          14F8      5368
NOTAMP           DF6      3574
NOTSTR           F70      3952
NOXOR           1486      5254
NSCFOR           F80      3968
NULFLG          2044      8260
NULL             95E      2398
NULLP            B8E      2958
NULLS           2041      8257
NUMASC          18C9      6345
NXTARY          1037      4151
NXTBYT           66B      1643
NXTCHR           6AC      1708
NXTDAT          20DC      8412
NXTDTA           A6B      2667
NXTITM           C32      3122
NXTOPR          20D0      8400
NXTSTL           A72      2674
NXTSTT           A75      2677
OD             =06        6
OKMSG            44E      1102
OM             =0C        12
OMERR            4A6      1190
ON               ADD      2781
ONGO             AEC      2796
ONGOLP           AED      2797
ONJMP            8BD      2237
OPNPAR           D50      3408
OPRND            DCB      3531
OS             =1A        26
OTKLN            6D9      1753
OTPORT         =2007      8199
OUTC             756      1878
OUTEXP          1981      6529
OUTIT            73F      1855
OUTNCR          1D1C      7452
OUTSUB          2006      8198
OUTWRD           7D9      2009
OV             =0A        10
OVERR            4C0      1216
OVTST1          1700      5888
OVTST2          1705      5893
OVTST3          1706      5894
PADD            18A5      6309
PAND             E8C      3724
PASSA           110C      4364
PBUFF           20E9      8425
PEEK            14B4      5300
PEND             91F      2335
PHLTFP          1762      5986
PLUCDE          1583      5507
PNORM           1551      5457
POINT           2051      8273
POKE            14BB      5307
POPAF           1250      4688
POPHL           137A      4986
POPHRT          1665      5733
POPNOK           4FB      1275
POR              E8B      3723
POR1             EAE      3758
POS             1109      4361
POSINT           97E      2430
POUT            146C      5228
POWER           19C6      6598
POWER1          19D6      6614
POWER2          19F3      6643
POWERS          19A6      6566
PRINT            B1F      2847
PRITAB           3A3      931
PRNTCRLF         B7D      2941
PRNTHL          18BE      6334
PRNTLP           B22      2850
PRNTNB           B65      2917
PRNTOK           4FC      1276
PRNTST           B69      2921
PRNUMS          121A      4634
PROCES           6EB      1771
PROGND          20D6      8406
PROGST          20F9      8441
PROMPT           600      1536
PRS             121B      4635
PRS1            121E      4638
PRSLP           1225      4645
PSET            2054      8276
PSUB            14D9      5337
PTRLP            585      1413
PUTB1            738      1848
PUTBUF           725      1829
PUTCTL           72A      1834
PUTFID           891      2193
QTSTLP          11E0      4576
QTSTR           11DA      4570
QUARTR          1B5F      7007
RAMEND         =3A00      14848
RAMSIZE        =1A00      6656
RAMSTRT        =2000      8192
READ             C2D      3117
READFG          20CD      8397
REDO             BDA      3034
REM              A6E      2670
RESDIV          16B2      5810
RESEED          1AFD      6909
RESET           2057      8279
RESTNL           8FA      2298
RESTOR           8E5      2277
RESZER          1544      5444
RETADR           FE7      4071
RETINT          173B      5947
RETLIN           A66      2662
RETNAD           691      1681
RETNUL           FEA      4074
RETNUM           E2D      3629
RETREL          172D      5933
RETURN           A47      2631
RG             =04        4
RIGHT           13ED      5101
RIGHT1          13C1      5057
RINPUT          204E      8270
RLTLP            D70      3440
RND             1A9C      6812
RND1            1AD8      6872
RND2            1AF4      6900
RNDTAB          1B05      6917
RNGTST          1993      6547
ROMSIZE        =2000      8192
RONDB           1565      5477
RONDUP          1564      5476
ROUND           14CC      5324
RSCALE          189F      6303
RSLNBK           813      2067
RSTSTR          1410      5136
RUN              A0C      2572
RUNCNT           895      2197
RUNFST           5C9      1481
RUNLIN           A28      2600
SAVEXP          1545      5445
SAVSTP           888      2184
SAVSTR          11B5      4533
SBSCPT           FF5      4085
SCALE           15A3      5539
SCALLP          15A5      5541
SCALMI          186A      6250
SCALPL          1880      6272
SCNEND          12EC      4844
SCPTLP           FFB      4091
SEARCH           659      1625
SEED            2017      8215
SETIO           1490      5264
SETLIN           7E7      2023
SETLIT           6A3      1699
SETPTR           580      1408
SETTOP           169      361
SFTPRG           54A      1354
SGN             1733      5939
SGNEXP           E7B      3707
SGNRES          20E8      8424
SHRITE          15B2      5554
SHRLP           15B5      5557
SHRT1           15B9      5561
SIGNON           1B9      441
SIGNS           178A      6026
SIN             1B17      6935
SIN1            1B47      6983
SINTAB          1B63      7011
SIXDIG          18E6      6374
SMPVAR          1280      4736
SMSER1          1A7B      6779
SN             =02        2
SNERR            4B1      1201
SPACE          =20        32
SPCFST          18D7      6359
SPCLP            BCC      3020
SQR             19BD      6589
SRCHLN           59D      1437
SRCHLP           5A0      1440
SSTSA           1348      4936
ST             =1E        30
STACK          =2066      8294
STAKFP          1755      5973
STALL            90E      2318
STKTHS           DB4      3508
STLOOK         =2200      8704
STOP             91D      2333
STORED           9E9      2537
STPOOL          12C3      4803
STR             11A5      4517
STR1            11AB      4523
STRADD          12C6      4806
STRBOT          20C3      8387
STRENT           C84      3204
STRSPC          205A      8282
STTLIN           B70      2928
SUBCDE          14DB      5339
SUBPHL          14D5      5333
SUMLP           1A84      6788
SUMSER          1A6C      6764
SUPTLZ          1965      6501
SVNAM2           F54      3924
SVSTAD          11D3      4563
TAN             1B78      7032
TESTOS          1252      4690
TESTR           1234      4660
TM             =18        24
TMERR            4C3      1219
TMPSTR          20BF      8383
TMSTPL          20B3      8371
TMSTPT          20B1      8369
TOPOOL          13B9      5049
TOSTRA          1351      4945
TRYAGN          1940      6464
TSALP           1352      4946
TSTBIT          1D15      7445
TSTBRK           900      2304
TSTMEM           157      343
TSTNUM           D45      3397
TSTOPL          11FB      4603
TSTRED           EB3      3763
TSTREM           6A6      1702
TSTSGN          1724      5924
TSTSTR           D46      3398
TTYLIN           6E2      1762
TYPE            20AD      8365
UF             =22        34
UFERR            4BD      1213
UL             =0E        14
ULERR            A42      2626
UNITY           15C7      5575
UPDATA           8FB      2299
USR             1D22      7458
USRJP           2003      8195
VAL             1427      5159
VAL1            1445      5189
VAL2            144F      5199
VAL3            1452      5202
VAREND          20D8      8408
WAIT            1472      5234
WAITLP          1487      5255
WARM             103      259
WARMST           1A1      417
WIDTH           1BE1      7137
WORDS            23A      570
WORDTB           359      857
WRKSPC          2000      8192
ZDATA          =83        131
ZDIV           =AF        175
ZEND           =80        128
ZEQUAL         =B4        180
ZERARY          1096      4246
ZERBYT         = 44D      1101
ZEROLP           FD9      4057
ZEROSUP         1CB9      7353
ZFN            =A7        167
ZFOR           =81        129
ZGOSUB         =8C        140
ZGOTO          =88        136
ZGTR           =B3        179
ZLEFT          =CF        207
ZLTH           =B5        181
ZMINUS         =AD        173
ZNEW           =A4        164
ZNOT           =AA        170
ZONELP           BA7      2983
ZOR            =B2        178
ZPLUS          =AC        172
ZPOINT         =C7        199
ZPRINT         =9E        158
ZREM           =8E        142
ZSGN           =B6        182
ZSPC           =A8        168
ZSTEP          =AB        171
ZTAB           =A5        165
ZTHEN          =A9        169
ZTIMES         =AE        174
ZTO            =A6        166
