   1:			;==================================================================================
   2:			; The updates to the original BASIC within this file are copyright Grant Searle
   3:			;
   4:			; You have permission to use this for NON COMMERCIAL USE ONLY
   5:			; If you wish to use it elsewhere, please include an acknowledgement to myself.
   6:			;
   7:			; http://searle.hostei.com/grant/index.html
   8:			;
   9:			; eMail: home.micros01@btinternet.com
  10:			;
  11:			; If the above don't work, please perform an Internet search to see if I have
  12:			; updated the web page hosting service.
  13:			;
  14:			;==================================================================================
  15:			
  16:			; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
  17:			; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
  18:			; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
  19:			; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
  20:			; the original ROM code (checksum A934H). PA
  21:			
  22:			; GENERAL EQUATES
  23:			
  24:	0003          	CTRLC   .EQU   03H             ; Control "C"
  25:	0007          	CTRLG   .EQU   07H             ; Control "G"
  26:	0008          	BKSP    .EQU   08H             ; Back space
  27:	000A          	LF      .EQU   0AH             ; Line feed
  28:	000C          	CS      .EQU   0CH             ; Clear screen
  29:	000D          	CR      .EQU   0DH             ; Carriage return
  30:	000F          	CTRLO   .EQU   0FH             ; Control "O"
  31:	0011          	CTRLQ	.EQU   11H	       ; Control "Q"
  32:	0012          	CTRLR   .EQU   12H             ; Control "R"
  33:	0013          	CTRLS   .EQU   13H             ; Control "S"
  34:	0015          	CTRLU   .EQU   15H             ; Control "U"
  35:	0018          	CAN     .EQU   18H             ; Cancel Control 'X'
  36:	001B          	ESC     .EQU   1BH             ; Escape
  37:	007F          	DEL     .EQU   7FH             ; Delete
  38:			
  39:			; BASIC WORK SPACE LOCATIONS
  40:			
  41:	2000          	RAMSTART .EQU  2000H           ; Start of RAM
  42:	2045          	WRKSPC  .EQU   2045H           ; BASIC Work space
  43:	2048          	USR     .EQU   WRKSPC + 3H     ; "USR (x)" jump
  44:	204B          	OUTSUB  .EQU   WRKSPC + 6H     ; "OUT p,n"
  45:	204C          	OTPORT  .EQU   WRKSPC + 7H     ; Port (p)
  46:	204E          	DIVSUP  .EQU   WRKSPC + 9H     ; Division support routine
  47:	204F          	DIV1    .EQU   WRKSPC + 0AH    ; <- Values
  48:	2053          	DIV2    .EQU   WRKSPC + 0EH    ; <-   to
  49:	2057          	DIV3    .EQU   WRKSPC + 12H    ; <-   be
  50:	205A          	DIV4    .EQU   WRKSPC + 15H    ; <-inserted
  51:	205C          	SEED    .EQU   WRKSPC + 17H    ; Random number seed
  52:	207F          	LSTRND  .EQU   WRKSPC + 3AH    ; Last random number
  53:	2083          	INPSUB  .EQU   WRKSPC + 3EH    ; #INP (x)" Routine
  54:	2084          	INPORT  .EQU   WRKSPC + 3FH    ; PORT (x)
  55:	2086          	NULLS   .EQU   WRKSPC + 41H    ; Number of nulls
  56:	2087          	LWIDTH  .EQU   WRKSPC + 42H    ; Terminal width
  57:	2088          	COMMAN  .EQU   WRKSPC + 43H    ; Width for commas
  58:	2089          	NULFLG  .EQU   WRKSPC + 44H    ; Null after input byte flag
  59:	208A          	CTLOFG  .EQU   WRKSPC + 45H    ; Control "O" flag
  60:	208B          	LINESC  .EQU   WRKSPC + 46H    ; Lines counter
  61:	208D          	LINESN  .EQU   WRKSPC + 48H    ; Lines number
  62:	208F          	CHKSUM  .EQU   WRKSPC + 4AH    ; Array load/save check sum
  63:	2091          	NMIFLG  .EQU   WRKSPC + 4CH    ; Flag for NMI break routine
  64:	2092          	BRKFLG  .EQU   WRKSPC + 4DH    ; Break flag
  65:	2093          	RINPUT  .EQU   WRKSPC + 4EH    ; Input reflection
  66:	2096          	POINT   .EQU   WRKSPC + 51H    ; "POINT" reflection (unused)
  67:	2099          	PSET    .EQU   WRKSPC + 54H    ; "SET"   reflection
  68:	209C          	RESET   .EQU   WRKSPC + 57H    ; "RESET" reflection
  69:	209F          	STRSPC  .EQU   WRKSPC + 5AH    ; Bottom of string space
  70:	20A1          	LINEAT  .EQU   WRKSPC + 5CH    ; Current line number
  71:	20A3          	BASTXT  .EQU   WRKSPC + 5EH    ; Pointer to start of program
  72:	20A6          	BUFFER  .EQU   WRKSPC + 61H    ; Input buffer
  73:	20AB          	STACK   .EQU   WRKSPC + 66H    ; Initial stack
  74:	20F0          	CURPOS  .EQU   WRKSPC + 0ABH   ; Character position on line
  75:	20F1          	LCRFLG  .EQU   WRKSPC + 0ACH   ; Locate/Create flag
  76:	20F2          	TYPE    .EQU   WRKSPC + 0ADH   ; Data type flag
  77:	20F3          	DATFLG  .EQU   WRKSPC + 0AEH   ; Literal statement flag
  78:	20F4          	LSTRAM  .EQU   WRKSPC + 0AFH   ; Last available RAM
  79:	20F6          	TMSTPT  .EQU   WRKSPC + 0B1H   ; Temporary string pointer
  80:	20F8          	TMSTPL  .EQU   WRKSPC + 0B3H   ; Temporary string pool
  81:	2104          	TMPSTR  .EQU   WRKSPC + 0BFH   ; Temporary string
  82:	2108          	STRBOT  .EQU   WRKSPC + 0C3H   ; Bottom of string space
  83:	210A          	CUROPR  .EQU   WRKSPC + 0C5H   ; Current operator in EVAL
  84:	210C          	LOOPST  .EQU   WRKSPC + 0C7H   ; First statement of loop
  85:	210E          	DATLIN  .EQU   WRKSPC + 0C9H   ; Line of current DATA item
  86:	2110          	FORFLG  .EQU   WRKSPC + 0CBH   ; "FOR" loop flag
  87:	2111          	LSTBIN  .EQU   WRKSPC + 0CCH   ; Last byte entered
  88:	2112          	READFG  .EQU   WRKSPC + 0CDH   ; Read/Input flag
  89:	2113          	BRKLIN  .EQU   WRKSPC + 0CEH   ; Line of break
  90:	2115          	NXTOPR  .EQU   WRKSPC + 0D0H   ; Next operator in EVAL
  91:	2117          	ERRLIN  .EQU   WRKSPC + 0D2H   ; Line of error
  92:	2119          	CONTAD  .EQU   WRKSPC + 0D4H   ; Where to CONTinue
  93:	211B          	PROGND  .EQU   WRKSPC + 0D6H   ; End of program
  94:	211D          	VAREND  .EQU   WRKSPC + 0D8H   ; End of variables
  95:	211F          	ARREND  .EQU   WRKSPC + 0DAH   ; End of arrays
  96:	2121          	NXTDAT  .EQU   WRKSPC + 0DCH   ; Next data item
  97:	2123          	FNRGNM  .EQU   WRKSPC + 0DEH   ; Name of FN argument
  98:	2125          	FNARG   .EQU   WRKSPC + 0E0H   ; FN argument value
  99:	2129          	FPREG   .EQU   WRKSPC + 0E4H   ; Floating point register
 100:	212C          	FPEXP   .EQU   FPREG + 3       ; Floating point exponent
 101:	212D          	SGNRES  .EQU   WRKSPC + 0E8H   ; Sign of result
 102:	212E          	PBUFF   .EQU   WRKSPC + 0E9H   ; Number print buffer
 103:	213B          	MULVAL  .EQU   WRKSPC + 0F6H   ; Multiplier
 104:	213E          	PROGST  .EQU   WRKSPC + 0F9H   ; Start of program text area
 105:	21A2          	STLOOK  .EQU   WRKSPC + 15DH   ; Start of memory test
 106:			
 107:			; BASIC ERROR CODE VALUES
 108:			
 109:	0000          	NF      .EQU   00H             ; NEXT without FOR
 110:	0002          	SN      .EQU   02H             ; Syntax error
 111:	0004          	RG      .EQU   04H             ; RETURN without GOSUB
 112:	0006          	OD      .EQU   06H             ; Out of DATA
 113:	0008          	FC      .EQU   08H             ; Function call error
 114:	000A          	OV      .EQU   0AH             ; Overflow
 115:	000C          	OM      .EQU   0CH             ; Out of memory
 116:	000E          	UL      .EQU   0EH             ; Undefined line number
 117:	0010          	BS      .EQU   10H             ; Bad subscript
 118:	0012          	DD      .EQU   12H             ; Re-DIMensioned array
 119:	0014          	DZ      .EQU   14H             ; Division by zero (/0)
 120:	0016          	ID      .EQU   16H             ; Illegal direct
 121:	0018          	TM      .EQU   18H             ; Type miss-match
 122:	001A          	OS      .EQU   1AH             ; Out of string space
 123:	001C          	LS      .EQU   1CH             ; String too long
 124:	001E          	ST      .EQU   1EH             ; String formula too complex
 125:	0020          	CN      .EQU   20H             ; Can't CONTinue
 126:	0022          	UF      .EQU   22H             ; UnDEFined FN function
 127:	0024          	MO      .EQU   24H             ; Missing operand
 128:	0026          	HE      .EQU   26H             ; HEX error
 129:	0028          	BN      .EQU   28H             ; BIN error
 130:			
 131:	0150          	        .ORG   00150H
 132:			
 133:	0150  C35601  	COLD:   JP      STARTB          ; Jump for cold start
 134:	0153  C3F401  	WARM:   JP      WARMST          ; Jump for warm start
 135:	0156          	STARTB:
 136:	0156  DD210000	        LD      IX,0            ; Flag cold start
 137:	015A  C36101  	        JP      CSTART          ; Jump to initialise
 138:			
 139:	015D  070A    	        .DW     DEINT           ; Get integer -32768 to 32767
 140:	015F  7D11    	        .DW     ABPASS          ; Return integer in AB
 141:			
 142:			
 143:	0161  214520  	CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
 144:	0164  F9      	        LD      SP,HL           ; Set up a temporary stack
 145:	0165  C39A1D  	        JP      INITST          ; Go to initialise
 146:			
 147:	0168  112E04  	INIT:   LD      DE,INITAB       ; Initialise workspace
 148:	016B  0663    	        LD      B,INITBE-INITAB+3; Bytes to copy
 149:	016D  214520  	        LD      HL,WRKSPC       ; Into workspace RAM
 150:	0170  1A      	COPY:   LD      A,(DE)          ; Get source
 151:	0171  77      	        LD      (HL),A          ; To destination
 152:	0172  23      	        INC     HL              ; Next destination
 153:	0173  13      	        INC     DE              ; Next source
 154:	0174  05      	        DEC     B               ; Count bytes
 155:	0175  C27001  	        JP      NZ,COPY         ; More to move
 156:	0178  F9      	        LD      SP,HL           ; Temporary stack
 157:	0179  CD2F06  	        CALL    CLREG           ; Clear registers and stack
 158:	017C  CDFD0B  	        CALL    PRNTCRLF        ; Output CRLF
 159:	017F  32EF20  	        LD      (BUFFER+72+1),A ; Mark end of buffer
 160:	0182  323E21  	        LD      (PROGST),A      ; Initialise program area
 161:			
 162:			;MSIZE: LD      HL,MEMMSG       ; Point to message
 163:			;       CALL    PRS             ; Output "Memory size"
 164:	0185  2A0020  	MSIZE:  LD      HL,(RAMSTART)   ; Read RAM end from memory
 165:	0188  C3BC01  	        JP      SETTOP          ; Skip user input and mem check
 166:			
 167:	018B  CD4C06  	        CALL    PROMPT          ; Get input with '?'
 168:	018E  CD5509  	        CALL    GETCHR          ; Get next character
 169:	0191  B7      	        OR      A               ; Set flags
 170:	0192  C2AA01  	        JP      NZ,TSTMEM       ; If number - Test if RAM there
 171:	0195  21A221  	        LD      HL,STLOOK       ; Point to start of RAM
 172:	0198  23      	MLOOP:  INC     HL              ; Next byte
 173:	0199  7C      	        LD      A,H             ; Above address FFFF ?
 174:	019A  B5      	        OR      L
 175:	019B  CABC01  	        JP      Z,SETTOP        ; Yes - 64K RAM
 176:	019E  7E      	        LD      A,(HL)          ; Get contents
 177:	019F  47      	        LD      B,A             ; Save it
 178:	01A0  2F      	        CPL                     ; Flip all bits
 179:	01A1  77      	        LD      (HL),A          ; Put it back
 180:	01A2  BE      	        CP      (HL)            ; RAM there if same
 181:	01A3  70      	        LD      (HL),B          ; Restore old contents
 182:	01A4  CA9801  	        JP      Z,MLOOP         ; If RAM - test next byte
 183:	01A7  C3BC01  	        JP      SETTOP          ; Top of RAM found
 184:			
 185:	01AA  CD210A  	TSTMEM: CALL    ATOH            ; Get high memory into DE
 186:	01AD  B7      	        OR      A               ; Set flags on last byte
 187:	01AE  C2FD04  	        JP      NZ,SNERR        ; ?SN Error if bad character
 188:	01B1  EB      	        EX      DE,HL           ; Address into HL
 189:	01B2  2B      	        DEC     HL              ; Back one byte
 190:	01B3  3ED9    	        LD      A,11011001B     ; Test byte
 191:	01B5  46      	        LD      B,(HL)          ; Get old contents
 192:	01B6  77      	        LD      (HL),A          ; Load test byte
 193:	01B7  BE      	        CP      (HL)            ; RAM there if same
 194:	01B8  70      	        LD      (HL),B          ; Restore old contents
 195:	01B9  C28501  	        JP      NZ,MSIZE        ; Ask again if no RAM
 196:			
 197:	01BC  2B      	SETTOP: DEC     HL              ; Back one byte
 198:	01BD  11A121  	        LD      DE,STLOOK-1     ; See if enough RAM
 199:	01C0  CDC507  	        CALL    CPDEHL          ; Compare DE with HL
 200:	01C3  DA8501  	        JP      C,MSIZE         ; Ask again if not enough RAM
 201:	01C6  11CEFF  	        LD      DE,0-50         ; 50 Bytes string space
 202:	01C9  22F420  	        LD      (LSTRAM),HL     ; Save last available RAM
 203:	01CC  19      	        ADD     HL,DE           ; Allocate string space
 204:	01CD  229F20  	        LD      (STRSPC),HL     ; Save string space
 205:	01D0  CD0A06  	        CALL    CLRPTR          ; Clear program area
 206:	01D3  2A9F20  	        LD      HL,(STRSPC)     ; Get end of memory
 207:	01D6  11EFFF  	        LD      DE,0-17         ; Offset for free bytes
 208:	01D9  19      	        ADD     HL,DE           ; Adjust HL
 209:	01DA  113E21  	        LD      DE,PROGST       ; Start of program text
 210:	01DD  7D      	        LD      A,L             ; Get LSB
 211:	01DE  93      	        SUB     E               ; Adjust it
 212:	01DF  6F      	        LD      L,A             ; Re-save
 213:	01E0  7C      	        LD      A,H             ; Get MSB
 214:	01E1  9A      	        SBC     A,D             ; Adjust it
 215:	01E2  67      	        LD      H,A             ; Re-save
 216:	01E3  E5      	        PUSH    HL              ; Save bytes free
 217:	01E4  210C02  	        LD      HL,SIGNON       ; Sign-on message
 218:	01E7  CD9B12  	        CALL    PRS             ; Output string
 219:	01EA  E1      	        POP     HL              ; Get bytes free back
 220:	01EB  CD3E19  	        CALL    PRNTHL          ; Output amount of free memory
 221:	01EE  21FD01  	        LD      HL,BFREE        ; " Bytes free" message
 222:	01F1  CD9B12  	        CALL    PRS             ; Output string
 223:			
 224:	01F4  31AB20  	WARMST: LD      SP,STACK        ; Temporary stack
 225:	01F7  CD2F06  	BRKRET: CALL    CLREG           ; Clear registers and stack
 226:	01FA  C34805  	        JP      PRNTOK          ; Go to get command line
 227:			
 228:	01FD  20427974	BFREE:  .DB  " Bytes free",CR,LF,0,0
	      65732066
	      7265650D
	      0A0000
 229:			
 230:	020C  5A383020	SIGNON: .DB  "Z80 BASIC Ver 4.7b",CR,LF
	      42415349
	      43205665
	      7220342E
	      37620D0A
 231:	0220  436F7079	        .DB  "Copyright ",40,"C",41
	      72696768
	      74202843
	      29
 232:	022D  20313937	        .DB  " 1978 by Microsoft",CR,LF,0,0
	      38206279
	      204D6963
	      726F736F
	      66740D0A
	      0000
 233:			
 234:	0243  4D656D6F	MEMMSG: .DB  "Memory top",0
	      72792074
	      6F7000
 235:			
 236:			; FUNCTION ADDRESS TABLE
 237:			
 238:	024E  B317    	FNCTAB: .DW     SGN
 239:	0250  7718    	        .DW     INT
 240:	0252  C917    	        .DW     ABS
 241:	0254  4820    	        .DW     USR
 242:	0256  5B11    	        .DW     FRE
 243:	0258  E014    	        .DW     INP
 244:	025A  8911    	        .DW     POS
 245:	025C  3D1A    	        .DW     SQR
 246:	025E  1C1B    	        .DW     RND
 247:	0260  5816    	        .DW     LOG
 248:	0262  8B1A    	        .DW     EXP
 249:	0264  911B    	        .DW     COS
 250:	0266  971B    	        .DW     SIN
 251:	0268  F81B    	        .DW     TAN
 252:	026A  0D1C    	        .DW     ATN
 253:	026C  3415    	        .DW     PEEK
 254:	026E  781C    	        .DW     DEEK
 255:	0270  9620    	        .DW     POINT
 256:	0272  0D14    	        .DW     LEN
 257:	0274  2512    	        .DW     STR
 258:	0276  A714    	        .DW     VAL
 259:	0278  1C14    	        .DW     ASC
 260:	027A  2D14    	        .DW     CHR
 261:	027C  9A1C    	        .DW     HEX
 262:	027E  2D1D    	        .DW     BIN
 263:	0280  3D14    	        .DW     LEFT
 264:	0282  6D14    	        .DW     RIGHT
 265:	0284  7714    	        .DW     MID
 266:			
 267:			; RESERVED WORD LIST
 268:			
 269:	0286  C54E44  	WORDS:  .DB     'E' + 80H,"ND"
 270:	0289  C64F52  	        .DB     'F' + 80H,"OR"
 271:	028C  CE455854	        .DB     'N' + 80H,"EXT"
 272:	0290  C4415441	        .DB     'D' + 80H,"ATA"
 273:	0294  C94E5055	        .DB     'I' + 80H,"NPUT"
	      54
 274:	0299  C4494D  	        .DB     'D' + 80H,"IM"
 275:	029C  D2454144	        .DB     'R' + 80H,"EAD"
 276:	02A0  CC4554  	        .DB     'L' + 80H,"ET"
 277:	02A3  C74F544F	        .DB     'G' + 80H,"OTO"
 278:	02A7  D2554E  	        .DB     'R' + 80H,"UN"
 279:	02AA  C946    	        .DB     'I' + 80H,"F"
 280:	02AC  D2455354	        .DB     'R' + 80H,"ESTORE"
	      4F5245
 281:	02B3  C74F5355	        .DB     'G' + 80H,"OSUB"
	      42
 282:	02B8  D2455455	        .DB     'R' + 80H,"ETURN"
	      524E
 283:	02BE  D2454D  	        .DB     'R' + 80H,"EM"
 284:	02C1  D3544F50	        .DB     'S' + 80H,"TOP"
 285:	02C5  CF5554  	        .DB     'O' + 80H,"UT"
 286:	02C8  CF4E    	        .DB     'O' + 80H,"N"
 287:	02CA  CE554C4C	        .DB     'N' + 80H,"ULL"
 288:	02CE  D7414954	        .DB     'W' + 80H,"AIT"
 289:	02D2  C44546  	        .DB     'D' + 80H,"EF"
 290:	02D5  D04F4B45	        .DB     'P' + 80H,"OKE"
 291:	02D9  C44F4B45	        .DB     'D' + 80H,"OKE"
 292:	02DD  D3435245	        .DB     'S' + 80H,"CREEN"
	      454E
 293:	02E3  CC494E45	        .DB     'L' + 80H,"INES"
	      53
 294:	02E8  C34C53  	        .DB     'C' + 80H,"LS"
 295:	02EB  D7494454	        .DB     'W' + 80H,"IDTH"
	      48
 296:	02F0  CD4F4E49	        .DB     'M' + 80H,"ONITOR"
	      544F52
 297:	02F7  D34554  	        .DB     'S' + 80H,"ET"
 298:	02FA  D2455345	        .DB     'R' + 80H,"ESET"
	      54
 299:	02FF  D052494E	        .DB     'P' + 80H,"RINT"
	      54
 300:	0304  C34F4E54	        .DB     'C' + 80H,"ONT"
 301:	0308  CC495354	        .DB     'L' + 80H,"IST"
 302:	030C  C34C4541	        .DB     'C' + 80H,"LEAR"
	      52
 303:	0311  C34C4F41	        .DB     'C' + 80H,"LOAD"
	      44
 304:	0316  C3534156	        .DB     'C' + 80H,"SAVE"
	      45
 305:	031B  CE4557  	        .DB     'N' + 80H,"EW"
 306:			
 307:	031E  D4414228	        .DB     'T' + 80H,"AB("
 308:	0322  D44F    	        .DB     'T' + 80H,"O"
 309:	0324  C64E    	        .DB     'F' + 80H,"N"
 310:	0326  D3504328	        .DB     'S' + 80H,"PC("
 311:	032A  D448454E	        .DB     'T' + 80H,"HEN"
 312:	032E  CE4F54  	        .DB     'N' + 80H,"OT"
 313:	0331  D3544550	        .DB     'S' + 80H,"TEP"
 314:			
 315:	0335  AB      	        .DB     '+' + 80H
 316:	0336  AD      	        .DB     '-' + 80H
 317:	0337  AA      	        .DB     '*' + 80H
 318:	0338  AF      	        .DB     '/' + 80H
 319:	0339  DE      	        .DB     '^' + 80H
 320:	033A  C14E44  	        .DB     'A' + 80H,"ND"
 321:	033D  CF52    	        .DB     'O' + 80H,"R"
 322:	033F  BE      	        .DB     '>' + 80H
 323:	0340  BD      	        .DB     '=' + 80H
 324:	0341  BC      	        .DB     '<' + 80H
 325:			
 326:	0342  D3474E  	        .DB     'S' + 80H,"GN"
 327:	0345  C94E54  	        .DB     'I' + 80H,"NT"
 328:	0348  C14253  	        .DB     'A' + 80H,"BS"
 329:	034B  D55352  	        .DB     'U' + 80H,"SR"
 330:	034E  C65245  	        .DB     'F' + 80H,"RE"
 331:	0351  C94E50  	        .DB     'I' + 80H,"NP"
 332:	0354  D04F53  	        .DB     'P' + 80H,"OS"
 333:	0357  D35152  	        .DB     'S' + 80H,"QR"
 334:	035A  D24E44  	        .DB     'R' + 80H,"ND"
 335:	035D  CC4F47  	        .DB     'L' + 80H,"OG"
 336:	0360  C55850  	        .DB     'E' + 80H,"XP"
 337:	0363  C34F53  	        .DB     'C' + 80H,"OS"
 338:	0366  D3494E  	        .DB     'S' + 80H,"IN"
 339:	0369  D4414E  	        .DB     'T' + 80H,"AN"
 340:	036C  C1544E  	        .DB     'A' + 80H,"TN"
 341:	036F  D045454B	        .DB     'P' + 80H,"EEK"
 342:	0373  C445454B	        .DB     'D' + 80H,"EEK"
 343:	0377  D04F494E	        .DB     'P' + 80H,"OINT"
	      54
 344:	037C  CC454E  	        .DB     'L' + 80H,"EN"
 345:	037F  D3545224	        .DB     'S' + 80H,"TR$"
 346:	0383  D6414C  	        .DB     'V' + 80H,"AL"
 347:	0386  C15343  	        .DB     'A' + 80H,"SC"
 348:	0389  C3485224	        .DB     'C' + 80H,"HR$"
 349:	038D  C8455824	        .DB     'H' + 80H,"EX$"
 350:	0391  C2494E24	        .DB     'B' + 80H,"IN$"
 351:	0395  CC454654	        .DB     'L' + 80H,"EFT$"
	      24
 352:	039A  D2494748	        .DB     'R' + 80H,"IGHT$"
	      5424
 353:	03A0  CD494424	        .DB     'M' + 80H,"ID$"
 354:	03A4  80      	        .DB     80H             ; End of list marker
 355:			
 356:			; KEYWORD ADDRESS TABLE
 357:			
 358:	03A5  9F09    	WORDTB: .DW     PEND
 359:	03A7  9C08    	        .DW     FOR
 360:	03A9  770D    	        .DW     NEXT
 361:	03AB  EC0A    	        .DW     DATA
 362:	03AD  7E0C    	        .DW     INPUT
 363:	03AF  B30F    	        .DW     DIM
 364:	03B1  AD0C    	        .DW     READ
 365:	03B3  030B    	        .DW     LET
 366:	03B5  A90A    	        .DW     GOTO
 367:	03B7  8C0A    	        .DW     RUN
 368:	03B9  7B0B    	        .DW     IF
 369:	03BB  6509    	        .DW     RESTOR
 370:	03BD  980A    	        .DW     GOSUB
 371:	03BF  C70A    	        .DW     RETURN
 372:	03C1  EE0A    	        .DW     REM
 373:	03C3  9D09    	        .DW     STOP
 374:	03C5  EC14    	        .DW     POUT
 375:	03C7  5D0B    	        .DW     ON
 376:	03C9  DE09    	        .DW     NULL
 377:	03CB  F214    	        .DW     WAIT
 378:	03CD  9111    	        .DW     DEF
 379:	03CF  3B15    	        .DW     POKE
 380:	03D1  831C    	        .DW     DOKE
 381:	03D3  EE0A    	        .DW     REM             ;SCREEN
 382:	03D5  691C    	        .DW     LINES
 383:	03D7  5C1C    	        .DW     CLS
 384:	03D9  611C    	        .DW     WIDTH
 385:	03DB  991D    	        .DW     MONITR
 386:	03DD  9920    	        .DW     PSET
 387:	03DF  9C20    	        .DW     RESET
 388:	03E1  9F0B    	        .DW     PRINT
 389:	03E3  CB09    	        .DW     CONT
 390:	03E5  1108    	        .DW     LIST
 391:	03E7  460A    	        .DW     CLEAR
 392:	03E9  EE0A    	        .DW     REM             ;CLOAD
 393:	03EB  EE0A    	        .DW     REM             ;CSAVE
 394:	03ED  0906    	        .DW     NEW
 395:			
 396:			; RESERVED WORD TOKEN VALUES
 397:			
 398:	0080          	ZEND    .EQU    080H            ; END
 399:	0081          	ZFOR    .EQU    081H            ; FOR
 400:	0083          	ZDATA   .EQU    083H            ; DATA
 401:	0088          	ZGOTO   .EQU    088H            ; GOTO
 402:	008C          	ZGOSUB  .EQU    08CH            ; GOSUB
 403:	008E          	ZREM    .EQU    08EH            ; REM
 404:	009E          	ZPRINT  .EQU    09EH            ; PRINT
 405:	00A4          	ZNEW    .EQU    0A4H            ; NEW
 406:			
 407:	00A5          	ZTAB    .EQU    0A5H            ; TAB
 408:	00A6          	ZTO     .EQU    0A6H            ; TO
 409:	00A7          	ZFN     .EQU    0A7H            ; FN
 410:	00A8          	ZSPC    .EQU    0A8H            ; SPC
 411:	00A9          	ZTHEN   .EQU    0A9H            ; THEN
 412:	00AA          	ZNOT    .EQU    0AAH            ; NOT
 413:	00AB          	ZSTEP   .EQU    0ABH            ; STEP
 414:			
 415:	00AC          	ZPLUS   .EQU    0ACH            ; +
 416:	00AD          	ZMINUS  .EQU    0ADH            ; -
 417:	00AE          	ZTIMES  .EQU    0AEH            ; *
 418:	00AF          	ZDIV    .EQU    0AFH            ; /
 419:	00B2          	ZOR     .EQU    0B2H            ; OR
 420:	00B3          	ZGTR    .EQU    0B3H            ; >
 421:	00B4          	ZEQUAL  .EQU    0B4H            ; M
 422:	00B5          	ZLTH    .EQU    0B5H            ; <
 423:	00B6          	ZSGN    .EQU    0B6H            ; SGN
 424:	00C7          	ZPOINT  .EQU    0C7H            ; POINT
 425:	00CF          	ZLEFT   .EQU    0CDH +2         ; LEFT$
 426:			
 427:			; ARITHMETIC PRECEDENCE TABLE
 428:			
 429:	03EF  79      	PRITAB: .DB     79H             ; Precedence value
 430:	03F0  2519    	        .DW     PADD            ; FPREG = <last> + FPREG
 431:			
 432:	03F2  79      	        .DB     79H             ; Precedence value
 433:	03F3  5915    	        .DW     PSUB            ; FPREG = <last> - FPREG
 434:			
 435:	03F5  7C      	        .DB     7CH             ; Precedence value
 436:	03F6  9716    	        .DW     MULT            ; PPREG = <last> * FPREG
 437:			
 438:	03F8  7C      	        .DB     7CH             ; Precedence value
 439:	03F9  F816    	        .DW     DIV             ; FPREG = <last> / FPREG
 440:			
 441:	03FB  7F      	        .DB     7FH             ; Precedence value
 442:	03FC  461A    	        .DW     POWER           ; FPREG = <last> ^ FPREG
 443:			
 444:	03FE  50      	        .DB     50H             ; Precedence value
 445:	03FF  0C0F    	        .DW     PAND            ; FPREG = <last> AND FPREG
 446:			
 447:	0401  46      	        .DB     46H             ; Precedence value
 448:	0402  0B0F    	        .DW     POR             ; FPREG = <last> OR FPREG
 449:			
 450:			; BASIC ERROR CODE LIST
 451:			
 452:	0404  4E46    	ERRORS: .DB     "NF"            ; NEXT without FOR
 453:	0406  534E    	        .DB     "SN"            ; Syntax error
 454:	0408  5247    	        .DB     "RG"            ; RETURN without GOSUB
 455:	040A  4F44    	        .DB     "OD"            ; Out of DATA
 456:	040C  4643    	        .DB     "FC"            ; Illegal function call
 457:	040E  4F56    	        .DB     "OV"            ; Overflow error
 458:	0410  4F4D    	        .DB     "OM"            ; Out of memory
 459:	0412  554C    	        .DB     "UL"            ; Undefined line
 460:	0414  4253    	        .DB     "BS"            ; Bad subscript
 461:	0416  4444    	        .DB     "DD"            ; Re-DIMensioned array
 462:	0418  2F30    	        .DB     "/0"            ; Division by zero
 463:	041A  4944    	        .DB     "ID"            ; Illegal direct
 464:	041C  544D    	        .DB     "TM"            ; Type mis-match
 465:	041E  4F53    	        .DB     "OS"            ; Out of string space
 466:	0420  4C53    	        .DB     "LS"            ; String too long
 467:	0422  5354    	        .DB     "ST"            ; String formula too complex
 468:	0424  434E    	        .DB     "CN"            ; Can't CONTinue
 469:	0426  5546    	        .DB     "UF"            ; Undefined FN function
 470:	0428  4D4F    	        .DB     "MO"            ; Missing operand
 471:	042A  4858    	        .DB     "HX"            ; HEX error
 472:	042C  424E    	        .DB     "BN"            ; BIN error
 473:			
 474:			; INITIALISATION TABLE -------------------------------------------------------
 475:			
 476:	042E  C3F401  	INITAB: JP      WARMST          ; Warm start jump
 477:	0431  C31C0A  	        JP      FCERR           ; "USR (X)" jump (Set to Error)
 478:	0434  D300    	        OUT     (0),A           ; "OUT p,n" skeleton
 479:	0436  C9      	        RET
 480:	0437  D600    	        SUB     0               ; Division support routine
 481:	0439  6F      	        LD      L,A
 482:	043A  7C      	        LD      A,H
 483:	043B  DE00    	        SBC     A,0
 484:	043D  67      	        LD      H,A
 485:	043E  78      	        LD      A,B
 486:	043F  DE00    	        SBC     A,0
 487:	0441  47      	        LD      B,A
 488:	0442  3E00    	        LD      A,0
 489:	0444  C9      	        RET
 490:	0445  000000  	        .DB     0,0,0                   ; Random number seed table used by RND
 491:	0448  354ACA99	        .DB     035H,04AH,0CAH,099H     ;-2.65145E+07
 492:	044C  391C7698	        .DB     039H,01CH,076H,098H     ; 1.61291E+07
 493:	0450  2295B398	        .DB     022H,095H,0B3H,098H     ;-1.17691E+07
 494:	0454  0ADD4798	        .DB     00AH,0DDH,047H,098H     ; 1.30983E+07
 495:	0458  53D19999	        .DB     053H,0D1H,099H,099H     ;-2-01612E+07
 496:	045C  0A1A9F98	        .DB     00AH,01AH,09FH,098H     ;-1.04269E+07
 497:	0460  65BCCD98	        .DB     065H,0BCH,0CDH,098H     ;-1.34831E+07
 498:	0464  D6773E98	        .DB     0D6H,077H,03EH,098H     ; 1.24825E+07
 499:	0468  52C74F80	        .DB     052H,0C7H,04FH,080H     ; Last random number
 500:	046C  DB00    	        IN      A,(0)           ; INP (x) skeleton
 501:	046E  C9      	        RET
 502:	046F  01      	        .DB     1               ; POS (x) number (1)
 503:	0470  FF      	        .DB     255             ; Terminal width (255 = no auto CRLF)
 504:	0471  1C      	        .DB     28              ; Width for commas (3 columns)
 505:	0472  00      	        .DB     0               ; No nulls after input bytes
 506:	0473  00      	        .DB     0               ; Output enabled (^O off)
 507:	0474  1400    	        .DW     20              ; Initial lines counter
 508:	0476  1400    	        .DW     20              ; Initial lines number
 509:	0478  0000    	        .DW     0               ; Array load/save check sum
 510:	047A  00      	        .DB     0               ; Break not by NMI
 511:	047B  00      	        .DB     0               ; Break flag
 512:	047C  C34207  	        JP      TTYLIN          ; Input reflection (set to TTY)
 513:	047F  C30000  	        JP      0000H           ; POINT reflection unused
 514:	0482  C30000  	        JP      0000H           ; SET reflection
 515:	0485  C30000  	        JP      0000H          	; RESET reflection
 516:	0488  A221    	        .DW     STLOOK          ; Temp string space
 517:	048A  FEFF    	        .DW     -2              ; Current line number (cold)
 518:	048C  3F21    	        .DW     PROGST+1        ; Start of program text
 519:	048E          	INITBE:
 520:			
 521:			; END OF INITIALISATION TABLE ---------------------------------------------------
 522:			
 523:	048E  20457272	ERRMSG: .DB     " Error",0
	      6F7200
 524:	0495  20696E20	INMSG:  .DB     " in ",0
	      00
 525:	0499          	ZERBYT  .EQU    $-1             ; A zero byte
 526:	049A  4F6B0D0A	OKMSG:  .DB     "Ok",CR,LF,0,0
	      0000
 527:	04A0  42726561	BRKMSG: .DB     "Break",0
	      6B00
 528:			
 529:	04A6  210400  	BAKSTK: LD      HL,4            ; Look for "FOR" block with
 530:	04A9  39      	        ADD     HL,SP           ; same index as specified
 531:	04AA  7E      	LOKFOR: LD      A,(HL)          ; Get block ID
 532:	04AB  23      	        INC     HL              ; Point to index address
 533:	04AC  FE81    	        CP      ZFOR            ; Is it a "FOR" token
 534:	04AE  C0      	        RET     NZ              ; No - exit
 535:	04AF  4E      	        LD      C,(HL)          ; BC = Address of "FOR" index
 536:	04B0  23      	        INC     HL
 537:	04B1  46      	        LD      B,(HL)
 538:	04B2  23      	        INC     HL              ; Point to sign of STEP
 539:	04B3  E5      	        PUSH    HL              ; Save pointer to sign
 540:	04B4  69      	        LD      L,C             ; HL = address of "FOR" index
 541:	04B5  60      	        LD      H,B
 542:	04B6  7A      	        LD      A,D             ; See if an index was specified
 543:	04B7  B3      	        OR      E               ; DE = 0 if no index specified
 544:	04B8  EB      	        EX      DE,HL           ; Specified index into HL
 545:	04B9  CAC004  	        JP      Z,INDFND        ; Skip if no index given
 546:	04BC  EB      	        EX      DE,HL           ; Index back into DE
 547:	04BD  CDC507  	        CALL    CPDEHL          ; Compare index with one given
 548:	04C0  010D00  	INDFND: LD      BC,16-3         ; Offset to next block
 549:	04C3  E1      	        POP     HL              ; Restore pointer to sign
 550:	04C4  C8      	        RET     Z               ; Return if block found
 551:	04C5  09      	        ADD     HL,BC           ; Point to next block
 552:	04C6  C3AA04  	        JP      LOKFOR          ; Keep on looking
 553:			
 554:	04C9  CDE304  	MOVUP:  CALL    ENFMEM          ; See if enough memory
 555:	04CC  C5      	MOVSTR: PUSH    BC              ; Save end of source
 556:	04CD  E3      	        EX      (SP),HL         ; Swap source and dest" end
 557:	04CE  C1      	        POP     BC              ; Get end of destination
 558:	04CF  CDC507  	MOVLP:  CALL    CPDEHL          ; See if list moved
 559:	04D2  7E      	        LD      A,(HL)          ; Get byte
 560:	04D3  02      	        LD      (BC),A          ; Move it
 561:	04D4  C8      	        RET     Z               ; Exit if all done
 562:	04D5  0B      	        DEC     BC              ; Next byte to move to
 563:	04D6  2B      	        DEC     HL              ; Next byte to move
 564:	04D7  C3CF04  	        JP      MOVLP           ; Loop until all bytes moved
 565:			
 566:	04DA  E5      	CHKSTK: PUSH    HL              ; Save code string address
 567:	04DB  2A1F21  	        LD      HL,(ARREND)     ; Lowest free memory
 568:	04DE  0600    	        LD      B,0             ; BC = Number of levels to test
 569:	04E0  09      	        ADD     HL,BC           ; 2 Bytes for each level
 570:	04E1  09      	        ADD     HL,BC
 571:	04E2  3E      	        .DB     3EH             ; Skip "PUSH HL"
 572:	04E3  E5      	ENFMEM: PUSH    HL              ; Save code string address
 573:	04E4  3ED0    	        LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
 574:	04E6  95      	        SUB     L
 575:	04E7  6F      	        LD      L,A
 576:	04E8  3EFF    	        LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
 577:	04EA  9C      	        SBC     A,H
 578:	04EB  DAF204  	        JP      C,OMERR         ; Not enough - ?OM Error
 579:	04EE  67      	        LD      H,A
 580:	04EF  39      	        ADD     HL,SP           ; Test if stack is overflowed
 581:	04F0  E1      	        POP     HL              ; Restore code string address
 582:	04F1  D8      	        RET     C               ; Return if enough mmory
 583:	04F2  1E0C    	OMERR:  LD      E,OM            ; ?OM Error
 584:	04F4  C31105  	        JP      ERROR
 585:			
 586:	04F7  2A0E21  	DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
 587:	04FA  22A120  	        LD      (LINEAT),HL     ; Save as current line
 588:	04FD  1E02    	SNERR:  LD      E,SN            ; ?SN Error
 589:	04FF  01      	        .DB     01H             ; Skip "LD E,DZ"
 590:	0500  1E14    	DZERR:  LD      E,DZ            ; ?/0 Error
 591:	0502  01      	        .DB     01H             ; Skip "LD E,NF"
 592:	0503  1E00    	NFERR:  LD      E,NF            ; ?NF Error
 593:	0505  01      	        .DB     01H             ; Skip "LD E,DD"
 594:	0506  1E12    	DDERR:  LD      E,DD            ; ?DD Error
 595:	0508  01      	        .DB     01H             ; Skip "LD E,UF"
 596:	0509  1E22    	UFERR:  LD      E,UF            ; ?UF Error
 597:	050B  01      	        .DB     01H             ; Skip "LD E,OV
 598:	050C  1E0A    	OVERR:  LD      E,OV            ; ?OV Error
 599:	050E  01      	        .DB     01H             ; Skip "LD E,TM"
 600:	050F  1E18    	TMERR:  LD      E,TM            ; ?TM Error
 601:			
 602:	0511  CD2F06  	ERROR:  CALL    CLREG           ; Clear registers and stack
 603:	0514  328A20  	        LD      (CTLOFG),A      ; Enable output (A is 0)
 604:	0517  CDF00B  	        CALL    STTLIN          ; Start new line
 605:	051A  210404  	        LD      HL,ERRORS       ; Point to error codes
 606:	051D  57      	        LD      D,A             ; D = 0 (A is 0)
 607:	051E  3E3F    	        LD      A,'?'
 608:	0520  CDD607  	        CALL    OUTC            ; Output '?'
 609:	0523  19      	        ADD     HL,DE           ; Offset to correct error code
 610:	0524  7E      	        LD      A,(HL)          ; First character
 611:	0525  CDD607  	        CALL    OUTC            ; Output it
 612:	0528  CD5509  	        CALL    GETCHR          ; Get next character
 613:	052B  CDD607  	        CALL    OUTC            ; Output it
 614:	052E  218E04  	        LD      HL,ERRMSG       ; "Error" message
 615:	0531  CD9B12  	ERRIN:  CALL    PRS             ; Output message
 616:	0534  2AA120  	        LD      HL,(LINEAT)     ; Get line of error
 617:	0537  11FEFF  	        LD      DE,-2           ; Cold start error if -2
 618:	053A  CDC507  	        CALL    CPDEHL          ; See if cold start error
 619:	053D  CA6101  	        JP      Z,CSTART        ; Cold start error - Restart
 620:	0540  7C      	        LD      A,H             ; Was it a direct error?
 621:	0541  A5      	        AND     L               ; Line = -1 if direct error
 622:	0542  3C      	        INC     A
 623:	0543  C43619  	        CALL    NZ,LINEIN       ; No - output line of error
 624:	0546  3E      	        .DB     3EH             ; Skip "POP BC"
 625:	0547  C1      	POPNOK: POP     BC              ; Drop address in input buffer
 626:			
 627:	0548  AF      	PRNTOK: XOR     A               ; Output "Ok" and get command
 628:	0549  328A20  	        LD      (CTLOFG),A      ; Enable output
 629:	054C  CDF00B  	        CALL    STTLIN          ; Start new line
 630:	054F  219A04  	        LD      HL,OKMSG        ; "Ok" message
 631:	0552  CD9B12  	        CALL    PRS             ; Output "Ok"
 632:	0555  21FFFF  	GETCMD: LD      HL,-1           ; Flag direct mode
 633:	0558  22A120  	        LD      (LINEAT),HL     ; Save as current line
 634:	055B  CD4207  	        CALL    GETLIN          ; Get an input line
 635:	055E  DA5505  	        JP      C,GETCMD        ; Get line again if break
 636:	0561  CD5509  	        CALL    GETCHR          ; Get first character
 637:	0564  3C      	        INC     A               ; Test if end of line
 638:	0565  3D      	        DEC     A               ; Without affecting Carry
 639:	0566  CA5505  	        JP      Z,GETCMD        ; Nothing entered - Get another
 640:	0569  F5      	        PUSH    AF              ; Save Carry status
 641:	056A  CD210A  	        CALL    ATOH            ; Get line number into DE
 642:	056D  D5      	        PUSH    DE              ; Save line number
 643:	056E  CD5906  	        CALL    CRUNCH          ; Tokenise rest of line
 644:	0571  47      	        LD      B,A             ; Length of tokenised line
 645:	0572  D1      	        POP     DE              ; Restore line number
 646:	0573  F1      	        POP     AF              ; Restore Carry
 647:	0574  D23509  	        JP      NC,EXCUTE       ; No line number - Direct mode
 648:	0577  D5      	        PUSH    DE              ; Save line number
 649:	0578  C5      	        PUSH    BC              ; Save length of tokenised line
 650:	0579  AF      	        XOR     A
 651:	057A  321121  	        LD      (LSTBIN),A      ; Clear last byte input
 652:	057D  CD5509  	        CALL    GETCHR          ; Get next character
 653:	0580  B7      	        OR      A               ; Set flags
 654:	0581  F5      	        PUSH    AF              ; And save them
 655:	0582  CDE905  	        CALL    SRCHLN          ; Search for line number in DE
 656:	0585  DA8E05  	        JP      C,LINFND        ; Jump if line found
 657:	0588  F1      	        POP     AF              ; Get status
 658:	0589  F5      	        PUSH    AF              ; And re-save
 659:	058A  CAC20A  	        JP      Z,ULERR         ; Nothing after number - Error
 660:	058D  B7      	        OR      A               ; Clear Carry
 661:	058E  C5      	LINFND: PUSH    BC              ; Save address of line in prog
 662:	058F  D2A505  	        JP      NC,INEWLN       ; Line not found - Insert new
 663:	0592  EB      	        EX      DE,HL           ; Next line address in DE
 664:	0593  2A1B21  	        LD      HL,(PROGND)     ; End of program
 665:	0596  1A      	SFTPRG: LD      A,(DE)          ; Shift rest of program down
 666:	0597  02      	        LD      (BC),A
 667:	0598  03      	        INC     BC              ; Next destination
 668:	0599  13      	        INC     DE              ; Next source
 669:	059A  CDC507  	        CALL    CPDEHL          ; All done?
 670:	059D  C29605  	        JP      NZ,SFTPRG       ; More to do
 671:	05A0  60      	        LD      H,B             ; HL - New end of program
 672:	05A1  69      	        LD      L,C
 673:	05A2  221B21  	        LD      (PROGND),HL     ; Update end of program
 674:			
 675:	05A5  D1      	INEWLN: POP     DE              ; Get address of line,
 676:	05A6  F1      	        POP     AF              ; Get status
 677:	05A7  CACC05  	        JP      Z,SETPTR        ; No text - Set up pointers
 678:	05AA  2A1B21  	        LD      HL,(PROGND)     ; Get end of program
 679:	05AD  E3      	        EX      (SP),HL         ; Get length of input line
 680:	05AE  C1      	        POP     BC              ; End of program to BC
 681:	05AF  09      	        ADD     HL,BC           ; Find new end
 682:	05B0  E5      	        PUSH    HL              ; Save new end
 683:	05B1  CDC904  	        CALL    MOVUP           ; Make space for line
 684:	05B4  E1      	        POP     HL              ; Restore new end
 685:	05B5  221B21  	        LD      (PROGND),HL     ; Update end of program pointer
 686:	05B8  EB      	        EX      DE,HL           ; Get line to move up in HL
 687:	05B9  74      	        LD      (HL),H          ; Save MSB
 688:	05BA  D1      	        POP     DE              ; Get new line number
 689:	05BB  23      	        INC     HL              ; Skip pointer
 690:	05BC  23      	        INC     HL
 691:	05BD  73      	        LD      (HL),E          ; Save LSB of line number
 692:	05BE  23      	        INC     HL
 693:	05BF  72      	        LD      (HL),D          ; Save MSB of line number
 694:	05C0  23      	        INC     HL              ; To first byte in line
 695:	05C1  11A620  	        LD      DE,BUFFER       ; Copy buffer to program
 696:	05C4  1A      	MOVBUF: LD      A,(DE)          ; Get source
 697:	05C5  77      	        LD      (HL),A          ; Save destinations
 698:	05C6  23      	        INC     HL              ; Next source
 699:	05C7  13      	        INC     DE              ; Next destination
 700:	05C8  B7      	        OR      A               ; Done?
 701:	05C9  C2C405  	        JP      NZ,MOVBUF       ; No - Repeat
 702:	05CC  CD1506  	SETPTR: CALL    RUNFST          ; Set line pointers
 703:	05CF  23      	        INC     HL              ; To LSB of pointer
 704:	05D0  EB      	        EX      DE,HL           ; Address to DE
 705:	05D1  62      	PTRLP:  LD      H,D             ; Address to HL
 706:	05D2  6B      	        LD      L,E
 707:	05D3  7E      	        LD      A,(HL)          ; Get LSB of pointer
 708:	05D4  23      	        INC     HL              ; To MSB of pointer
 709:	05D5  B6      	        OR      (HL)            ; Compare with MSB pointer
 710:	05D6  CA5505  	        JP      Z,GETCMD        ; Get command line if end
 711:	05D9  23      	        INC     HL              ; To LSB of line number
 712:	05DA  23      	        INC     HL              ; Skip line number
 713:	05DB  23      	        INC     HL              ; Point to first byte in line
 714:	05DC  AF      	        XOR     A               ; Looking for 00 byte
 715:	05DD  BE      	FNDEND: CP      (HL)            ; Found end of line?
 716:	05DE  23      	        INC     HL              ; Move to next byte
 717:	05DF  C2DD05  	        JP      NZ,FNDEND       ; No - Keep looking
 718:	05E2  EB      	        EX      DE,HL           ; Next line address to HL
 719:	05E3  73      	        LD      (HL),E          ; Save LSB of pointer
 720:	05E4  23      	        INC     HL
 721:	05E5  72      	        LD      (HL),D          ; Save MSB of pointer
 722:	05E6  C3D105  	        JP      PTRLP           ; Do next line
 723:			
 724:	05E9  2AA320  	SRCHLN: LD      HL,(BASTXT)     ; Start of program text
 725:	05EC  44      	SRCHLP: LD      B,H             ; BC = Address to look at
 726:	05ED  4D      	        LD      C,L
 727:	05EE  7E      	        LD      A,(HL)          ; Get address of next line
 728:	05EF  23      	        INC     HL
 729:	05F0  B6      	        OR      (HL)            ; End of program found?
 730:	05F1  2B      	        DEC     HL
 731:	05F2  C8      	        RET     Z               ; Yes - Line not found
 732:	05F3  23      	        INC     HL
 733:	05F4  23      	        INC     HL
 734:	05F5  7E      	        LD      A,(HL)          ; Get LSB of line number
 735:	05F6  23      	        INC     HL
 736:	05F7  66      	        LD      H,(HL)          ; Get MSB of line number
 737:	05F8  6F      	        LD      L,A
 738:	05F9  CDC507  	        CALL    CPDEHL          ; Compare with line in DE
 739:	05FC  60      	        LD      H,B             ; HL = Start of this line
 740:	05FD  69      	        LD      L,C
 741:	05FE  7E      	        LD      A,(HL)          ; Get LSB of next line address
 742:	05FF  23      	        INC     HL
 743:	0600  66      	        LD      H,(HL)          ; Get MSB of next line address
 744:	0601  6F      	        LD      L,A             ; Next line to HL
 745:	0602  3F      	        CCF
 746:	0603  C8      	        RET     Z               ; Lines found - Exit
 747:	0604  3F      	        CCF
 748:	0605  D0      	        RET     NC              ; Line not found,at line after
 749:	0606  C3EC05  	        JP      SRCHLP          ; Keep looking
 750:			
 751:	0609  C0      	NEW:    RET     NZ              ; Return if any more on line
 752:	060A  2AA320  	CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
 753:	060D  AF      	        XOR     A               ; Set program area to empty
 754:	060E  77      	        LD      (HL),A          ; Save LSB = 00
 755:	060F  23      	        INC     HL
 756:	0610  77      	        LD      (HL),A          ; Save MSB = 00
 757:	0611  23      	        INC     HL
 758:	0612  221B21  	        LD      (PROGND),HL     ; Set program end
 759:			
 760:	0615  2AA320  	RUNFST: LD      HL,(BASTXT)     ; Clear all variables
 761:	0618  2B      	        DEC     HL
 762:			
 763:	0619  221321  	INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
 764:	061C  2AF420  	        LD      HL,(LSTRAM)     ; Get end of RAM
 765:	061F  220821  	        LD      (STRBOT),HL     ; Clear string space
 766:	0622  AF      	        XOR     A
 767:	0623  CD6509  	        CALL    RESTOR          ; Reset DATA pointers
 768:	0626  2A1B21  	        LD      HL,(PROGND)     ; Get end of program
 769:	0629  221D21  	        LD      (VAREND),HL     ; Clear variables
 770:	062C  221F21  	        LD      (ARREND),HL     ; Clear arrays
 771:			
 772:	062F  C1      	CLREG:  POP     BC              ; Save return address
 773:	0630  2A9F20  	        LD      HL,(STRSPC)     ; Get end of working RAN
 774:	0633  F9      	        LD      SP,HL           ; Set stack
 775:	0634  21F820  	        LD      HL,TMSTPL       ; Temporary string pool
 776:	0637  22F620  	        LD      (TMSTPT),HL     ; Reset temporary string ptr
 777:	063A  AF      	        XOR     A               ; A = 00
 778:	063B  6F      	        LD      L,A             ; HL = 0000
 779:	063C  67      	        LD      H,A
 780:	063D  221921  	        LD      (CONTAD),HL     ; No CONTinue
 781:	0640  321021  	        LD      (FORFLG),A      ; Clear FOR flag
 782:	0643  222321  	        LD      (FNRGNM),HL     ; Clear FN argument
 783:	0646  E5      	        PUSH    HL              ; HL = 0000
 784:	0647  C5      	        PUSH    BC              ; Put back return
 785:	0648  2A1321  	DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
 786:	064B  C9      	        RET                     ; Return to execution driver
 787:			
 788:	064C  3E3F    	PROMPT: LD      A,'?'           ; '?'
 789:	064E  CDD607  	        CALL    OUTC            ; Output character
 790:	0651  3E20    	        LD      A,' '           ; Space
 791:	0653  CDD607  	        CALL    OUTC            ; Output character
 792:	0656  C39320  	        JP      RINPUT          ; Get input line
 793:			
 794:	0659  AF      	CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
 795:	065A  32F320  	        LD      (DATFLG),A      ; Reset literal flag
 796:	065D  0E05    	        LD      C,2+3           ; 2 byte number and 3 nulls
 797:	065F  11A620  	        LD      DE,BUFFER       ; Start of input buffer
 798:	0662  7E      	CRNCLP: LD      A,(HL)          ; Get byte
 799:	0663  FE20    	        CP      ' '             ; Is it a space?
 800:	0665  CAE106  	        JP      Z,MOVDIR        ; Yes - Copy direct
 801:	0668  47      	        LD      B,A             ; Save character
 802:	0669  FE22    	        CP      '"'             ; Is it a quote?
 803:	066B  CA0107  	        JP      Z,CPYLIT        ; Yes - Copy literal string
 804:	066E  B7      	        OR      A               ; Is it end of buffer?
 805:	066F  CA0807  	        JP      Z,ENDBUF        ; Yes - End buffer
 806:	0672  3AF320  	        LD      A,(DATFLG)      ; Get data type
 807:	0675  B7      	        OR      A               ; Literal?
 808:	0676  7E      	        LD      A,(HL)          ; Get byte to copy
 809:	0677  C2E106  	        JP      NZ,MOVDIR       ; Literal - Copy direct
 810:	067A  FE3F    	        CP      '?'             ; Is it '?' short for PRINT
 811:	067C  3E9E    	        LD      A,ZPRINT        ; "PRINT" token
 812:	067E  CAE106  	        JP      Z,MOVDIR        ; Yes - replace it
 813:	0681  7E      	        LD      A,(HL)          ; Get byte again
 814:	0682  FE30    	        CP      '0'             ; Is it less than '0'
 815:	0684  DA8C06  	        JP      C,FNDWRD        ; Yes - Look for reserved words
 816:	0687  FE3C    	        CP      60; ";"+1           ; Is it "0123456789:;" ?
 817:	0689  DAE106  	        JP      C,MOVDIR        ; Yes - copy it direct
 818:	068C  D5      	FNDWRD: PUSH    DE              ; Look for reserved words
 819:	068D  118502  	        LD      DE,WORDS-1      ; Point to table
 820:	0690  C5      	        PUSH    BC              ; Save count
 821:	0691  01DD06  	        LD      BC,RETNAD       ; Where to return to
 822:	0694  C5      	        PUSH    BC              ; Save return address
 823:	0695  067F    	        LD      B,ZEND-1        ; First token value -1
 824:	0697  7E      	        LD      A,(HL)          ; Get byte
 825:	0698  FE61    	        CP      'a'             ; Less than 'a' ?
 826:	069A  DAA506  	        JP      C,SEARCH        ; Yes - search for words
 827:	069D  FE7B    	        CP      'z'+1           ; Greater than 'z' ?
 828:	069F  D2A506  	        JP      NC,SEARCH       ; Yes - search for words
 829:	06A2  E65F    	        AND     01011111B       ; Force upper case
 830:	06A4  77      	        LD      (HL),A          ; Replace byte
 831:	06A5  4E      	SEARCH: LD      C,(HL)          ; Search for a word
 832:	06A6  EB      	        EX      DE,HL
 833:	06A7  23      	GETNXT: INC     HL              ; Get next reserved word
 834:	06A8  B6      	        OR      (HL)            ; Start of word?
 835:	06A9  F2A706  	        JP      P,GETNXT        ; No - move on
 836:	06AC  04      	        INC     B               ; Increment token value
 837:	06AD  7E      	        LD      A, (HL)         ; Get byte from table
 838:	06AE  E67F    	        AND     01111111B       ; Strip bit 7
 839:	06B0  C8      	        RET     Z               ; Return if end of list
 840:	06B1  B9      	        CP      C               ; Same character as in buffer?
 841:	06B2  C2A706  	        JP      NZ,GETNXT       ; No - get next word
 842:	06B5  EB      	        EX      DE,HL
 843:	06B6  E5      	        PUSH    HL              ; Save start of word
 844:			
 845:	06B7  13      	NXTBYT: INC     DE              ; Look through rest of word
 846:	06B8  1A      	        LD      A,(DE)          ; Get byte from table
 847:	06B9  B7      	        OR      A               ; End of word ?
 848:	06BA  FAD906  	        JP      M,MATCH         ; Yes - Match found
 849:	06BD  4F      	        LD      C,A             ; Save it
 850:	06BE  78      	        LD      A,B             ; Get token value
 851:	06BF  FE88    	        CP      ZGOTO           ; Is it "GOTO" token ?
 852:	06C1  C2C806  	        JP      NZ,NOSPC        ; No - Don't allow spaces
 853:	06C4  CD5509  	        CALL    GETCHR          ; Get next character
 854:	06C7  2B      	        DEC     HL              ; Cancel increment from GETCHR
 855:	06C8  23      	NOSPC:  INC     HL              ; Next byte
 856:	06C9  7E      	        LD      A,(HL)          ; Get byte
 857:	06CA  FE61    	        CP      'a'             ; Less than 'a' ?
 858:	06CC  DAD106  	        JP      C,NOCHNG        ; Yes - don't change
 859:	06CF  E65F    	        AND     01011111B       ; Make upper case
 860:	06D1  B9      	NOCHNG: CP      C               ; Same as in buffer ?
 861:	06D2  CAB706  	        JP      Z,NXTBYT        ; Yes - keep testing
 862:	06D5  E1      	        POP     HL              ; Get back start of word
 863:	06D6  C3A506  	        JP      SEARCH          ; Look at next word
 864:			
 865:	06D9  48      	MATCH:  LD      C,B             ; Word found - Save token value
 866:	06DA  F1      	        POP     AF              ; Throw away return
 867:	06DB  EB      	        EX      DE,HL
 868:	06DC  C9      	        RET                     ; Return to "RETNAD"
 869:	06DD  EB      	RETNAD: EX      DE,HL           ; Get address in string
 870:	06DE  79      	        LD      A,C             ; Get token value
 871:	06DF  C1      	        POP     BC              ; Restore buffer length
 872:	06E0  D1      	        POP     DE              ; Get destination address
 873:	06E1  23      	MOVDIR: INC     HL              ; Next source in buffer
 874:	06E2  12      	        LD      (DE),A          ; Put byte in buffer
 875:	06E3  13      	        INC     DE              ; Move up buffer
 876:	06E4  0C      	        INC     C               ; Increment length of buffer
 877:	06E5  D63A    	        SUB     ':'             ; End of statement?
 878:	06E7  CAEF06  	        JP      Z,SETLIT        ; Jump if multi-statement line
 879:	06EA  FE49    	        CP      ZDATA-3AH       ; Is it DATA statement ?
 880:	06EC  C2F206  	        JP      NZ,TSTREM       ; No - see if REM
 881:	06EF  32F320  	SETLIT: LD      (DATFLG),A      ; Set literal flag
 882:	06F2  D654    	TSTREM: SUB     ZREM-3AH        ; Is it REM?
 883:	06F4  C26206  	        JP      NZ,CRNCLP       ; No - Leave flag
 884:	06F7  47      	        LD      B,A             ; Copy rest of buffer
 885:	06F8  7E      	NXTCHR: LD      A,(HL)          ; Get byte
 886:	06F9  B7      	        OR      A               ; End of line ?
 887:	06FA  CA0807  	        JP      Z,ENDBUF        ; Yes - Terminate buffer
 888:	06FD  B8      	        CP      B               ; End of statement ?
 889:	06FE  CAE106  	        JP      Z,MOVDIR        ; Yes - Get next one
 890:	0701  23      	CPYLIT: INC     HL              ; Move up source string
 891:	0702  12      	        LD      (DE),A          ; Save in destination
 892:	0703  0C      	        INC     C               ; Increment length
 893:	0704  13      	        INC     DE              ; Move up destination
 894:	0705  C3F806  	        JP      NXTCHR          ; Repeat
 895:			
 896:	0708  21A520  	ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
 897:	070B  12      	        LD      (DE),A          ; Mark end of buffer (A = 00)
 898:	070C  13      	        INC     DE
 899:	070D  12      	        LD      (DE),A          ; A = 00
 900:	070E  13      	        INC     DE
 901:	070F  12      	        LD      (DE),A          ; A = 00
 902:	0710  C9      	        RET
 903:			
 904:	0711  3A8920  	DODEL:  LD      A,(NULFLG)      ; Get null flag status
 905:	0714  B7      	        OR      A               ; Is it zero?
 906:	0715  3E00    	        LD      A,0             ; Zero A - Leave flags
 907:	0717  328920  	        LD      (NULFLG),A      ; Zero null flag
 908:	071A  C22507  	        JP      NZ,ECHDEL       ; Set - Echo it
 909:	071D  05      	        DEC     B               ; Decrement length
 910:	071E  CA4207  	        JP      Z,GETLIN        ; Get line again if empty
 911:	0721  CDD607  	        CALL    OUTC            ; Output null character
 912:	0724  3E      	        .DB     3EH             ; Skip "DEC B"
 913:	0725  05      	ECHDEL: DEC     B               ; Count bytes in buffer
 914:	0726  2B      	        DEC     HL              ; Back space buffer
 915:	0727  CA3907  	        JP      Z,OTKLN         ; No buffer - Try again
 916:	072A  7E      	        LD      A,(HL)          ; Get deleted byte
 917:	072B  CDD607  	        CALL    OUTC            ; Echo it
 918:	072E  C34B07  	        JP      MORINP          ; Get more input
 919:			
 920:	0731  05      	DELCHR: DEC     B               ; Count bytes in buffer
 921:	0732  2B      	        DEC     HL              ; Back space buffer
 922:	0733  CDD607  	        CALL    OUTC            ; Output character in A
 923:	0736  C24B07  	        JP      NZ,MORINP       ; Not end - Get more
 924:	0739  CDD607  	OTKLN:  CALL    OUTC            ; Output character in A
 925:	073C  CDFD0B  	KILIN:  CALL    PRNTCRLF        ; Output CRLF
 926:	073F  C34207  	        JP      TTYLIN          ; Get line again
 927:			
 928:	0742          	GETLIN:
 929:	0742  21A620  	TTYLIN: LD      HL,BUFFER       ; Get a line by character
 930:	0745  0601    	        LD      B,1             ; Set buffer as empty
 931:	0747  AF      	        XOR     A
 932:	0748  328920  	        LD      (NULFLG),A      ; Clear null flag
 933:	074B  CD0008  	MORINP: CALL    CLOTST          ; Get character and test ^O
 934:	074E  4F      	        LD      C,A             ; Save character in C
 935:	074F  FE7F    	        CP      DEL             ; Delete character?
 936:	0751  CA1107  	        JP      Z,DODEL         ; Yes - Process it
 937:	0754  3A8920  	        LD      A,(NULFLG)      ; Get null flag
 938:	0757  B7      	        OR      A               ; Test null flag status
 939:	0758  CA6407  	        JP      Z,PROCES        ; Reset - Process character
 940:	075B  3E00    	        LD      A,0             ; Set a null
 941:	075D  CDD607  	        CALL    OUTC            ; Output null
 942:	0760  AF      	        XOR     A               ; Clear A
 943:	0761  328920  	        LD      (NULFLG),A      ; Reset null flag
 944:	0764  79      	PROCES: LD      A,C             ; Get character
 945:	0765  FE07    	        CP      CTRLG           ; Bell?
 946:	0767  CAA807  	        JP      Z,PUTCTL        ; Yes - Save it
 947:	076A  FE03    	        CP      CTRLC           ; Is it control "C"?
 948:	076C  CCFD0B  	        CALL    Z,PRNTCRLF      ; Yes - Output CRLF
 949:	076F  37      	        SCF                     ; Flag break
 950:	0770  C8      	        RET     Z               ; Return if control "C"
 951:	0771  FE0D    	        CP      CR              ; Is it enter?
 952:	0773  CAF80B  	        JP      Z,ENDINP        ; Yes - Terminate input
 953:	0776  FE15    	        CP      CTRLU           ; Is it control "U"?
 954:	0778  CA3C07  	        JP      Z,KILIN         ; Yes - Get another line
 955:	077B  FE18    	        CP      CAN             ; Is it "kill line"?
 956:	077D  CA3907  	        JP      Z,OTKLN         ; Yes - Kill line
 957:	0780  FE7F    	        CP      DEL             ; Is it delete?
 958:	0782  CA3107  	        JP      Z,DELCHR        ; Yes - Delete character
 959:	0785  FE08    	        CP      BKSP            ; Is it backspace?
 960:	0787  CA3107  	        JP      Z,DELCHR        ; Yes - Delete character
 961:	078A  FE12    	        CP      CTRLR           ; Is it control "R"?
 962:	078C  C2A307  	        JP      NZ,PUTBUF       ; No - Put in buffer
 963:	078F  C5      	        PUSH    BC              ; Save buffer length
 964:	0790  D5      	        PUSH    DE              ; Save DE
 965:	0791  E5      	        PUSH    HL              ; Save buffer address
 966:	0792  3600    	        LD      (HL),0          ; Mark end of buffer
 967:	0794  CDAB1D  	        CALL    OUTNCR          ; Output and do CRLF
 968:	0797  21A620  	        LD      HL,BUFFER       ; Point to buffer start
 969:	079A  CD9B12  	        CALL    PRS             ; Output buffer
 970:	079D  E1      	        POP     HL              ; Restore buffer address
 971:	079E  D1      	        POP     DE              ; Restore DE
 972:	079F  C1      	        POP     BC              ; Restore buffer length
 973:	07A0  C34B07  	        JP      MORINP          ; Get another character
 974:			
 975:	07A3  FE20    	PUTBUF: CP      ' '             ; Is it a control code?
 976:	07A5  DA4B07  	        JP      C,MORINP        ; Yes - Ignore
 977:	07A8  78      	PUTCTL: LD      A,B             ; Get number of bytes in buffer
 978:	07A9  FE49    	        CP      72+1            ; Test for line overflow
 979:	07AB  3E07    	        LD      A,CTRLG         ; Set a bell
 980:	07AD  D2BD07  	        JP      NC,OUTNBS       ; Ring bell if buffer full
 981:	07B0  79      	        LD      A,C             ; Get character
 982:	07B1  71      	        LD      (HL),C          ; Save in buffer
 983:	07B2  321121  	        LD      (LSTBIN),A      ; Save last input byte
 984:	07B5  23      	        INC     HL              ; Move up buffer
 985:	07B6  04      	        INC     B               ; Increment length
 986:	07B7  CDD607  	OUTIT:  CALL    OUTC            ; Output the character entered
 987:	07BA  C34B07  	        JP      MORINP          ; Get another character
 988:			
 989:	07BD  CDD607  	OUTNBS: CALL    OUTC            ; Output bell and back over it
 990:	07C0  3E08    	        LD      A,BKSP          ; Set back space
 991:	07C2  C3B707  	        JP      OUTIT           ; Output it and get more
 992:			
 993:	07C5  7C      	CPDEHL: LD      A,H             ; Get H
 994:	07C6  92      	        SUB     D               ; Compare with D
 995:	07C7  C0      	        RET     NZ              ; Different - Exit
 996:	07C8  7D      	        LD      A,L             ; Get L
 997:	07C9  93      	        SUB     E               ; Compare with E
 998:	07CA  C9      	        RET                     ; Return status
 999:			
1000:	07CB  7E      	CHKSYN: LD      A,(HL)          ; Check syntax of character
1001:	07CC  E3      	        EX      (SP),HL         ; Address of test byte
1002:	07CD  BE      	        CP      (HL)            ; Same as in code string?
1003:	07CE  23      	        INC     HL              ; Return address
1004:	07CF  E3      	        EX      (SP),HL         ; Put it back
1005:	07D0  CA5509  	        JP      Z,GETCHR        ; Yes - Get next character
1006:	07D3  C3FD04  	        JP      SNERR           ; Different - ?SN Error
1007:			
1008:	07D6  F5      	OUTC:   PUSH    AF              ; Save character
1009:	07D7  3A8A20  	        LD      A,(CTLOFG)      ; Get control "O" flag
1010:	07DA  B7      	        OR      A               ; Is it set?
1011:	07DB  C2D012  	        JP      NZ,POPAF        ; Yes - don't output
1012:	07DE  F1      	        POP     AF              ; Restore character
1013:	07DF  C5      	        PUSH    BC              ; Save buffer length
1014:	07E0  F5      	        PUSH    AF              ; Save character
1015:	07E1  FE20    	        CP      ' '             ; Is it a control code?
1016:	07E3  DAFA07  	        JP      C,DINPOS        ; Yes - Don't INC POS(X)
1017:	07E6  3A8720  	        LD      A,(LWIDTH)      ; Get line width
1018:	07E9  47      	        LD      B,A             ; To B
1019:	07EA  3AF020  	        LD      A,(CURPOS)      ; Get cursor position
1020:	07ED  04      	        INC     B               ; Width 255?
1021:	07EE  CAF607  	        JP      Z,INCLEN        ; Yes - No width limit
1022:	07F1  05      	        DEC     B               ; Restore width
1023:	07F2  B8      	        CP      B               ; At end of line?
1024:	07F3  CCFD0B  	        CALL    Z,PRNTCRLF      ; Yes - output CRLF
1025:	07F6  3C      	INCLEN: INC     A               ; Move on one character
1026:	07F7  32F020  	        LD      (CURPOS),A      ; Save new position
1027:	07FA  F1      	DINPOS: POP     AF              ; Restore character
1028:	07FB  C1      	        POP     BC              ; Restore buffer length
1029:	07FC  CD961D  	        CALL    MONOUT          ; Send it
1030:	07FF  C9      	        RET
1031:			
1032:	0800  CD5A1C  	CLOTST: CALL    GETINP          ; Get input character
1033:	0803  E67F    	        AND     01111111B       ; Strip bit 7
1034:	0805  FE0F    	        CP      CTRLO           ; Is it control "O"?
1035:	0807  C0      	        RET     NZ              ; No don't flip flag
1036:	0808  3A8A20  	        LD      A,(CTLOFG)      ; Get flag
1037:	080B  2F      	        CPL                     ; Flip it
1038:	080C  328A20  	        LD      (CTLOFG),A      ; Put it back
1039:	080F  AF      	        XOR     A               ; Null character
1040:	0810  C9      	        RET
1041:			
1042:	0811  CD210A  	LIST:   CALL    ATOH            ; ASCII number to DE
1043:	0814  C0      	        RET     NZ              ; Return if anything extra
1044:	0815  C1      	        POP     BC              ; Rubbish - Not needed
1045:	0816  CDE905  	        CALL    SRCHLN          ; Search for line number in DE
1046:	0819  C5      	        PUSH    BC              ; Save address of line
1047:	081A  CD6708  	        CALL    SETLIN          ; Set up lines counter
1048:	081D  E1      	LISTLP: POP     HL              ; Restore address of line
1049:	081E  4E      	        LD      C,(HL)          ; Get LSB of next line
1050:	081F  23      	        INC     HL
1051:	0820  46      	        LD      B,(HL)          ; Get MSB of next line
1052:	0821  23      	        INC     HL
1053:	0822  78      	        LD      A,B             ; BC = 0 (End of program)?
1054:	0823  B1      	        OR      C
1055:	0824  CA4805  	        JP      Z,PRNTOK        ; Yes - Go to command mode
1056:	0827  CD7008  	        CALL    COUNT           ; Count lines
1057:	082A  CD8009  	        CALL    TSTBRK          ; Test for break key
1058:	082D  C5      	        PUSH    BC              ; Save address of next line
1059:	082E  CDFD0B  	        CALL    PRNTCRLF        ; Output CRLF
1060:	0831  5E      	        LD      E,(HL)          ; Get LSB of line number
1061:	0832  23      	        INC     HL
1062:	0833  56      	        LD      D,(HL)          ; Get MSB of line number
1063:	0834  23      	        INC     HL
1064:	0835  E5      	        PUSH    HL              ; Save address of line start
1065:	0836  EB      	        EX      DE,HL           ; Line number to HL
1066:	0837  CD3E19  	        CALL    PRNTHL          ; Output line number in decimal
1067:	083A  3E20    	        LD      A,' '           ; Space after line number
1068:	083C  E1      	        POP     HL              ; Restore start of line address
1069:	083D  CDD607  	LSTLP2: CALL    OUTC            ; Output character in A
1070:	0840  7E      	LSTLP3: LD      A,(HL)          ; Get next byte in line
1071:	0841  B7      	        OR      A               ; End of line?
1072:	0842  23      	        INC     HL              ; To next byte in line
1073:	0843  CA1D08  	        JP      Z,LISTLP        ; Yes - get next line
1074:	0846  F23D08  	        JP      P,LSTLP2        ; No token - output it
1075:	0849  D67F    	        SUB     ZEND-1          ; Find and output word
1076:	084B  4F      	        LD      C,A             ; Token offset+1 to C
1077:	084C  118602  	        LD      DE,WORDS        ; Reserved word list
1078:	084F  1A      	FNDTOK: LD      A,(DE)          ; Get character in list
1079:	0850  13      	        INC     DE              ; Move on to next
1080:	0851  B7      	        OR      A               ; Is it start of word?
1081:	0852  F24F08  	        JP      P,FNDTOK        ; No - Keep looking for word
1082:	0855  0D      	        DEC     C               ; Count words
1083:	0856  C24F08  	        JP      NZ,FNDTOK       ; Not there - keep looking
1084:	0859  E67F    	OUTWRD: AND     01111111B       ; Strip bit 7
1085:	085B  CDD607  	        CALL    OUTC            ; Output first character
1086:	085E  1A      	        LD      A,(DE)          ; Get next character
1087:	085F  13      	        INC     DE              ; Move on to next
1088:	0860  B7      	        OR      A               ; Is it end of word?
1089:	0861  F25908  	        JP      P,OUTWRD        ; No - output the rest
1090:	0864  C34008  	        JP      LSTLP3          ; Next byte in line
1091:			
1092:	0867  E5      	SETLIN: PUSH    HL              ; Set up LINES counter
1093:	0868  2A8D20  	        LD      HL,(LINESN)     ; Get LINES number
1094:	086B  228B20  	        LD      (LINESC),HL     ; Save in LINES counter
1095:	086E  E1      	        POP     HL
1096:	086F  C9      	        RET
1097:			
1098:	0870  E5      	COUNT:  PUSH    HL              ; Save code string address
1099:	0871  D5      	        PUSH    DE
1100:	0872  2A8B20  	        LD      HL,(LINESC)     ; Get LINES counter
1101:	0875  11FFFF  	        LD      DE,-1
1102:	0878  ED5A    	        ADC     HL,DE           ; Decrement
1103:	087A  228B20  	        LD      (LINESC),HL     ; Put it back
1104:	087D  D1      	        POP     DE
1105:	087E  E1      	        POP     HL              ; Restore code string address
1106:	087F  F0      	        RET     P               ; Return if more lines to go
1107:	0880  E5      	        PUSH    HL              ; Save code string address
1108:	0881  2A8D20  	        LD      HL,(LINESN)     ; Get LINES number
1109:	0884  228B20  	        LD      (LINESC),HL     ; Reset LINES counter
1110:	0887  CD5A1C  	        CALL    GETINP          ; Get input character
1111:	088A  FE03    	        CP      CTRLC           ; Is it control "C"?
1112:	088C  CA9308  	        JP      Z,RSLNBK        ; Yes - Reset LINES and break
1113:	088F  E1      	        POP     HL              ; Restore code string address
1114:	0890  C37008  	        JP      COUNT           ; Keep on counting
1115:			
1116:	0893  2A8D20  	RSLNBK: LD      HL,(LINESN)     ; Get LINES number
1117:	0896  228B20  	        LD      (LINESC),HL     ; Reset LINES counter
1118:	0899  C3F701  	        JP      BRKRET          ; Go and output "Break"
1119:			
1120:	089C  3E64    	FOR:    LD      A,64H           ; Flag "FOR" assignment
1121:	089E  321021  	        LD      (FORFLG),A      ; Save "FOR" flag
1122:	08A1  CD030B  	        CALL    LET             ; Set up initial index
1123:	08A4  C1      	        POP     BC              ; Drop RETurn address
1124:	08A5  E5      	        PUSH    HL              ; Save code string address
1125:	08A6  CDEC0A  	        CALL    DATA            ; Get next statement address
1126:	08A9  220C21  	        LD      (LOOPST),HL     ; Save it for start of loop
1127:	08AC  210200  	        LD      HL,2            ; Offset for "FOR" block
1128:	08AF  39      	        ADD     HL,SP           ; Point to it
1129:	08B0  CDAA04  	FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
1130:	08B3  D1      	        POP     DE              ; Get code string address
1131:	08B4  C2CC08  	        JP      NZ,FORFND       ; No nesting found
1132:	08B7  09      	        ADD     HL,BC           ; Move into "FOR" block
1133:	08B8  D5      	        PUSH    DE              ; Save code string address
1134:	08B9  2B      	        DEC     HL
1135:	08BA  56      	        LD      D,(HL)          ; Get MSB of loop statement
1136:	08BB  2B      	        DEC     HL
1137:	08BC  5E      	        LD      E,(HL)          ; Get LSB of loop statement
1138:	08BD  23      	        INC     HL
1139:	08BE  23      	        INC     HL
1140:	08BF  E5      	        PUSH    HL              ; Save block address
1141:	08C0  2A0C21  	        LD      HL,(LOOPST)     ; Get address of loop statement
1142:	08C3  CDC507  	        CALL    CPDEHL          ; Compare the FOR loops
1143:	08C6  E1      	        POP     HL              ; Restore block address
1144:	08C7  C2B008  	        JP      NZ,FORSLP       ; Different FORs - Find another
1145:	08CA  D1      	        POP     DE              ; Restore code string address
1146:	08CB  F9      	        LD      SP,HL           ; Remove all nested loops
1147:			
1148:	08CC  EB      	FORFND: EX      DE,HL           ; Code string address to HL
1149:	08CD  0E08    	        LD      C,8
1150:	08CF  CDDA04  	        CALL    CHKSTK          ; Check for 8 levels of stack
1151:	08D2  E5      	        PUSH    HL              ; Save code string address
1152:	08D3  2A0C21  	        LD      HL,(LOOPST)     ; Get first statement of loop
1153:	08D6  E3      	        EX      (SP),HL         ; Save and restore code string
1154:	08D7  E5      	        PUSH    HL              ; Re-save code string address
1155:	08D8  2AA120  	        LD      HL,(LINEAT)     ; Get current line number
1156:	08DB  E3      	        EX      (SP),HL         ; Save and restore code string
1157:	08DC  CDC50D  	        CALL    TSTNUM          ; Make sure it's a number
1158:	08DF  CDCB07  	        CALL    CHKSYN          ; Make sure "TO" is next
1159:	08E2  A6      	        .DB     ZTO             ; "TO" token
1160:	08E3  CDC20D  	        CALL    GETNUM          ; Get "TO" expression value
1161:	08E6  E5      	        PUSH    HL              ; Save code string address
1162:	08E7  CDF017  	        CALL    BCDEFP          ; Move "TO" value to BCDE
1163:	08EA  E1      	        POP     HL              ; Restore code string address
1164:	08EB  C5      	        PUSH    BC              ; Save "TO" value in block
1165:	08EC  D5      	        PUSH    DE
1166:	08ED  010081  	        LD      BC,8100H        ; BCDE - 1 (default STEP)
1167:	08F0  51      	        LD      D,C             ; C=0
1168:	08F1  5A      	        LD      E,D             ; D=0
1169:	08F2  7E      	        LD      A,(HL)          ; Get next byte in code string
1170:	08F3  FEAB    	        CP      ZSTEP           ; See if "STEP" is stated
1171:	08F5  3E01    	        LD      A,1             ; Sign of step = 1
1172:	08F7  C20809  	        JP      NZ,SAVSTP       ; No STEP given - Default to 1
1173:	08FA  CD5509  	        CALL    GETCHR          ; Jump over "STEP" token
1174:	08FD  CDC20D  	        CALL    GETNUM          ; Get step value
1175:	0900  E5      	        PUSH    HL              ; Save code string address
1176:	0901  CDF017  	        CALL    BCDEFP          ; Move STEP to BCDE
1177:	0904  CDA417  	        CALL    TSTSGN          ; Test sign of FPREG
1178:	0907  E1      	        POP     HL              ; Restore code string address
1179:	0908  C5      	SAVSTP: PUSH    BC              ; Save the STEP value in block
1180:	0909  D5      	        PUSH    DE
1181:	090A  F5      	        PUSH    AF              ; Save sign of STEP
1182:	090B  33      	        INC     SP              ; Don't save flags
1183:	090C  E5      	        PUSH    HL              ; Save code string address
1184:	090D  2A1321  	        LD      HL,(BRKLIN)     ; Get address of index variable
1185:	0910  E3      	        EX      (SP),HL         ; Save and restore code string
1186:	0911  0681    	PUTFID: LD      B,ZFOR          ; "FOR" block marker
1187:	0913  C5      	        PUSH    BC              ; Save it
1188:	0914  33      	        INC     SP              ; Don't save C
1189:			
1190:	0915  CD8009  	RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
1191:	0918  221321  	        LD      (BRKLIN),HL     ; Save code address for break
1192:	091B  7E      	        LD      A,(HL)          ; Get next byte in code string
1193:	091C  FE3A    	        CP      ':'             ; Multi statement line?
1194:	091E  CA3509  	        JP      Z,EXCUTE        ; Yes - Execute it
1195:	0921  B7      	        OR      A               ; End of line?
1196:	0922  C2FD04  	        JP      NZ,SNERR        ; No - Syntax error
1197:	0925  23      	        INC     HL              ; Point to address of next line
1198:	0926  7E      	        LD      A,(HL)          ; Get LSB of line pointer
1199:	0927  23      	        INC     HL
1200:	0928  B6      	        OR      (HL)            ; Is it zero (End of prog)?
1201:	0929  CAA709  	        JP      Z,ENDPRG        ; Yes - Terminate execution
1202:	092C  23      	        INC     HL              ; Point to line number
1203:	092D  5E      	        LD      E,(HL)          ; Get LSB of line number
1204:	092E  23      	        INC     HL
1205:	092F  56      	        LD      D,(HL)          ; Get MSB of line number
1206:	0930  EB      	        EX      DE,HL           ; Line number to HL
1207:	0931  22A120  	        LD      (LINEAT),HL     ; Save as current line number
1208:	0934  EB      	        EX      DE,HL           ; Line number back to DE
1209:	0935  CD5509  	EXCUTE: CALL    GETCHR          ; Get key word
1210:	0938  111509  	        LD      DE,RUNCNT       ; Where to RETurn to
1211:	093B  D5      	        PUSH    DE              ; Save for RETurn
1212:	093C  C8      	IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
1213:	093D  D680    	ONJMP:  SUB     ZEND            ; Is it a token?
1214:	093F  DA030B  	        JP      C,LET           ; No - try to assign it
1215:	0942  FE25    	        CP      ZNEW+1-ZEND     ; END to NEW ?
1216:	0944  D2FD04  	        JP      NC,SNERR        ; Not a key word - ?SN Error
1217:	0947  07      	        RLCA                    ; Double it
1218:	0948  4F      	        LD      C,A             ; BC = Offset into table
1219:	0949  0600    	        LD      B,0
1220:	094B  EB      	        EX      DE,HL           ; Save code string address
1221:	094C  21A503  	        LD      HL,WORDTB       ; Keyword address table
1222:	094F  09      	        ADD     HL,BC           ; Point to routine address
1223:	0950  4E      	        LD      C,(HL)          ; Get LSB of routine address
1224:	0951  23      	        INC     HL
1225:	0952  46      	        LD      B,(HL)          ; Get MSB of routine address
1226:	0953  C5      	        PUSH    BC              ; Save routine address
1227:	0954  EB      	        EX      DE,HL           ; Restore code string address
1228:			
1229:	0955  23      	GETCHR: INC     HL              ; Point to next character
1230:	0956  7E      	        LD      A,(HL)          ; Get next code string byte
1231:	0957  FE3A    	        CP      ':'             ; Z if ':'
1232:	0959  D0      	        RET     NC              ; NC if > "9"
1233:	095A  FE20    	        CP      ' '
1234:	095C  CA5509  	        JP      Z,GETCHR        ; Skip over spaces
1235:	095F  FE30    	        CP      '0'
1236:	0961  3F      	        CCF                     ; NC if < '0'
1237:	0962  3C      	        INC     A               ; Test for zero - Leave carry
1238:	0963  3D      	        DEC     A               ; Z if Null
1239:	0964  C9      	        RET
1240:			
1241:	0965  EB      	RESTOR: EX      DE,HL           ; Save code string address
1242:	0966  2AA320  	        LD      HL,(BASTXT)     ; Point to start of program
1243:	0969  CA7A09  	        JP      Z,RESTNL        ; Just RESTORE - reset pointer
1244:	096C  EB      	        EX      DE,HL           ; Restore code string address
1245:	096D  CD210A  	        CALL    ATOH            ; Get line number to DE
1246:	0970  E5      	        PUSH    HL              ; Save code string address
1247:	0971  CDE905  	        CALL    SRCHLN          ; Search for line number in DE
1248:	0974  60      	        LD      H,B             ; HL = Address of line
1249:	0975  69      	        LD      L,C
1250:	0976  D1      	        POP     DE              ; Restore code string address
1251:	0977  D2C20A  	        JP      NC,ULERR        ; ?UL Error if not found
1252:	097A  2B      	RESTNL: DEC     HL              ; Byte before DATA statement
1253:	097B  222121  	UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
1254:	097E  EB      	        EX      DE,HL           ; Restore code string address
1255:	097F  C9      	        RET
1256:			
1257:			
1258:	0980  DF      	TSTBRK: RST     18H             ; Check input status
1259:	0981  C8      	        RET     Z               ; No key, go back
1260:	0982  D7      	        RST     10H             ; Get the key into A
1261:	0983  FE1B    	        CP      ESC             ; Escape key?
1262:	0985  2811    	        JR      Z,BRK           ; Yes, break
1263:	0987  FE03    	        CP      CTRLC           ; <Ctrl-C>
1264:	0989  280D    	        JR      Z,BRK           ; Yes, break
1265:	098B  FE13    	        CP      CTRLS           ; Stop scrolling?
1266:	098D  C0      	        RET     NZ              ; Other key, ignore
1267:			
1268:			
1269:	098E  D7      	STALL:  RST     10H             ; Wait for key
1270:	098F  FE11    	        CP      CTRLQ           ; Resume scrolling?
1271:	0991  C8      	        RET      Z              ; Release the chokehold
1272:	0992  FE03    	        CP      CTRLC           ; Second break?
1273:	0994  2807    	        JR      Z,STOP          ; Break during hold exits prog
1274:	0996  18F6    	        JR      STALL           ; Loop until <Ctrl-Q> or <brk>
1275:			
1276:	0998  3EFF    	BRK     LD      A,0FFH          ; Set BRKFLG
1277:	099A  329220  	        LD      (BRKFLG),A      ; Store it
1278:			
1279:			
1280:	099D  C0      	STOP:   RET     NZ              ; Exit if anything else
1281:	099E  F6      	        .DB     0F6H            ; Flag "STOP"
1282:	099F  C0      	PEND:   RET     NZ              ; Exit if anything else
1283:	09A0  221321  	        LD      (BRKLIN),HL     ; Save point of break
1284:	09A3  21      	        .DB     21H             ; Skip "OR 11111111B"
1285:	09A4  F6FF    	INPBRK: OR      11111111B       ; Flag "Break" wanted
1286:	09A6  C1      	        POP     BC              ; Return not needed and more
1287:	09A7  2AA120  	ENDPRG: LD      HL,(LINEAT)     ; Get current line number
1288:	09AA  F5      	        PUSH    AF              ; Save STOP / END status
1289:	09AB  7D      	        LD      A,L             ; Is it direct break?
1290:	09AC  A4      	        AND     H
1291:	09AD  3C      	        INC     A               ; Line is -1 if direct break
1292:	09AE  CABA09  	        JP      Z,NOLIN         ; Yes - No line number
1293:	09B1  221721  	        LD      (ERRLIN),HL     ; Save line of break
1294:	09B4  2A1321  	        LD      HL,(BRKLIN)     ; Get point of break
1295:	09B7  221921  	        LD      (CONTAD),HL     ; Save point to CONTinue
1296:	09BA  AF      	NOLIN:  XOR     A
1297:	09BB  328A20  	        LD      (CTLOFG),A      ; Enable output
1298:	09BE  CDF00B  	        CALL    STTLIN          ; Start a new line
1299:	09C1  F1      	        POP     AF              ; Restore STOP / END status
1300:	09C2  21A004  	        LD      HL,BRKMSG       ; "Break" message
1301:	09C5  C23105  	        JP      NZ,ERRIN        ; "in line" wanted?
1302:	09C8  C34805  	        JP      PRNTOK          ; Go to command mode
1303:			
1304:	09CB  2A1921  	CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
1305:	09CE  7C      	        LD      A,H             ; Is it zero?
1306:	09CF  B5      	        OR      L
1307:	09D0  1E20    	        LD      E,CN            ; ?CN Error
1308:	09D2  CA1105  	        JP      Z,ERROR         ; Yes - output "?CN Error"
1309:	09D5  EB      	        EX      DE,HL           ; Save code string address
1310:	09D6  2A1721  	        LD      HL,(ERRLIN)     ; Get line of last break
1311:	09D9  22A120  	        LD      (LINEAT),HL     ; Set up current line number
1312:	09DC  EB      	        EX      DE,HL           ; Restore code string address
1313:	09DD  C9      	        RET                     ; CONTinue where left off
1314:			
1315:	09DE  CD2315  	NULL:   CALL    GETINT          ; Get integer 0-255
1316:	09E1  C0      	        RET     NZ              ; Return if bad value
1317:	09E2  328620  	        LD      (NULLS),A       ; Set nulls number
1318:	09E5  C9      	        RET
1319:			
1320:			
1321:	09E6  E5      	ACCSUM: PUSH    HL              ; Save address in array
1322:	09E7  2A8F20  	        LD      HL,(CHKSUM)     ; Get check sum
1323:	09EA  0600    	        LD      B,0             ; BC - Value of byte
1324:	09EC  4F      	        LD      C,A
1325:	09ED  09      	        ADD     HL,BC           ; Add byte to check sum
1326:	09EE  228F20  	        LD      (CHKSUM),HL     ; Re-save check sum
1327:	09F1  E1      	        POP     HL              ; Restore address in array
1328:	09F2  C9      	        RET
1329:			
1330:	09F3  7E      	CHKLTR: LD      A,(HL)          ; Get byte
1331:	09F4  FE41    	        CP      'A'             ; < 'a' ?
1332:	09F6  D8      	        RET     C               ; Carry set if not letter
1333:	09F7  FE5B    	        CP      'Z'+1           ; > 'z' ?
1334:	09F9  3F      	        CCF
1335:	09FA  C9      	        RET                     ; Carry set if not letter
1336:			
1337:	09FB  CD5509  	FPSINT: CALL    GETCHR          ; Get next character
1338:	09FE  CDC20D  	POSINT: CALL    GETNUM          ; Get integer 0 to 32767
1339:	0A01  CDA417  	DEPINT: CALL    TSTSGN          ; Test sign of FPREG
1340:	0A04  FA1C0A  	        JP      M,FCERR         ; Negative - ?FC Error
1341:	0A07  3A2C21  	DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
1342:	0A0A  FE90    	        CP      80H+16          ; Exponent in range (16 bits)?
1343:	0A0C  DA4C18  	        JP      C,FPINT         ; Yes - convert it
1344:	0A0F  018090  	        LD      BC,9080H        ; BCDE = -32768
1345:	0A12  110000  	        LD      DE,0000
1346:	0A15  E5      	        PUSH    HL              ; Save code string address
1347:	0A16  CD1F18  	        CALL    CMPNUM          ; Compare FPREG with BCDE
1348:	0A19  E1      	        POP     HL              ; Restore code string address
1349:	0A1A  51      	        LD      D,C             ; MSB to D
1350:	0A1B  C8      	        RET     Z               ; Return if in range
1351:	0A1C  1E08    	FCERR:  LD      E,FC            ; ?FC Error
1352:	0A1E  C31105  	        JP      ERROR           ; Output error-
1353:			
1354:	0A21  2B      	ATOH:   DEC     HL              ; ASCII number to DE binary
1355:	0A22  110000  	GETLN:  LD      DE,0            ; Get number to DE
1356:	0A25  CD5509  	GTLNLP: CALL    GETCHR          ; Get next character
1357:	0A28  D0      	        RET     NC              ; Exit if not a digit
1358:	0A29  E5      	        PUSH    HL              ; Save code string address
1359:	0A2A  F5      	        PUSH    AF              ; Save digit
1360:	0A2B  219819  	        LD      HL,65529/10     ; Largest number 65529
1361:	0A2E  CDC507  	        CALL    CPDEHL          ; Number in range?
1362:	0A31  DAFD04  	        JP      C,SNERR         ; No - ?SN Error
1363:	0A34  62      	        LD      H,D             ; HL = Number
1364:	0A35  6B      	        LD      L,E
1365:	0A36  19      	        ADD     HL,DE           ; Times 2
1366:	0A37  29      	        ADD     HL,HL           ; Times 4
1367:	0A38  19      	        ADD     HL,DE           ; Times 5
1368:	0A39  29      	        ADD     HL,HL           ; Times 10
1369:	0A3A  F1      	        POP     AF              ; Restore digit
1370:	0A3B  D630    	        SUB     '0'             ; Make it 0 to 9
1371:	0A3D  5F      	        LD      E,A             ; DE = Value of digit
1372:	0A3E  1600    	        LD      D,0
1373:	0A40  19      	        ADD     HL,DE           ; Add to number
1374:	0A41  EB      	        EX      DE,HL           ; Number to DE
1375:	0A42  E1      	        POP     HL              ; Restore code string address
1376:	0A43  C3250A  	        JP      GTLNLP          ; Go to next character
1377:			
1378:	0A46  CA1906  	CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
1379:	0A49  CDFE09  	        CALL    POSINT          ; Get integer 0 to 32767 to DE
1380:	0A4C  2B      	        DEC     HL              ; Cancel increment
1381:	0A4D  CD5509  	        CALL    GETCHR          ; Get next character
1382:	0A50  E5      	        PUSH    HL              ; Save code string address
1383:	0A51  2AF420  	        LD      HL,(LSTRAM)     ; Get end of RAM
1384:	0A54  CA690A  	        JP      Z,STORED        ; No value given - Use stored
1385:	0A57  E1      	        POP     HL              ; Restore code string address
1386:	0A58  CDCB07  	        CALL    CHKSYN          ; Check for comma
1387:	0A5B  2C      	        .DB     ','
1388:	0A5C  D5      	        PUSH    DE              ; Save number
1389:	0A5D  CDFE09  	        CALL    POSINT          ; Get integer 0 to 32767
1390:	0A60  2B      	        DEC     HL              ; Cancel increment
1391:	0A61  CD5509  	        CALL    GETCHR          ; Get next character
1392:	0A64  C2FD04  	        JP      NZ,SNERR        ; ?SN Error if more on line
1393:	0A67  E3      	        EX      (SP),HL         ; Save code string address
1394:	0A68  EB      	        EX      DE,HL           ; Number to DE
1395:	0A69  7D      	STORED: LD      A,L             ; Get LSB of new RAM top
1396:	0A6A  93      	        SUB     E               ; Subtract LSB of string space
1397:	0A6B  5F      	        LD      E,A             ; Save LSB
1398:	0A6C  7C      	        LD      A,H             ; Get MSB of new RAM top
1399:	0A6D  9A      	        SBC     A,D             ; Subtract MSB of string space
1400:	0A6E  57      	        LD      D,A             ; Save MSB
1401:	0A6F  DAF204  	        JP      C,OMERR         ; ?OM Error if not enough mem
1402:	0A72  E5      	        PUSH    HL              ; Save RAM top
1403:	0A73  2A1B21  	        LD      HL,(PROGND)     ; Get program end
1404:	0A76  012800  	        LD      BC,40           ; 40 Bytes minimum working RAM
1405:	0A79  09      	        ADD     HL,BC           ; Get lowest address
1406:	0A7A  CDC507  	        CALL    CPDEHL          ; Enough memory?
1407:	0A7D  D2F204  	        JP      NC,OMERR        ; No - ?OM Error
1408:	0A80  EB      	        EX      DE,HL           ; RAM top to HL
1409:	0A81  229F20  	        LD      (STRSPC),HL     ; Set new string space
1410:	0A84  E1      	        POP     HL              ; End of memory to use
1411:	0A85  22F420  	        LD      (LSTRAM),HL     ; Set new top of RAM
1412:	0A88  E1      	        POP     HL              ; Restore code string address
1413:	0A89  C31906  	        JP      INTVAR          ; Initialise variables
1414:			
1415:	0A8C  CA1506  	RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
1416:	0A8F  CD1906  	        CALL    INTVAR          ; Initialise variables
1417:	0A92  011509  	        LD      BC,RUNCNT       ; Execution driver loop
1418:	0A95  C3A80A  	        JP      RUNLIN          ; RUN from line number
1419:			
1420:	0A98  0E03    	GOSUB:  LD      C,3             ; 3 Levels of stack needed
1421:	0A9A  CDDA04  	        CALL    CHKSTK          ; Check for 3 levels of stack
1422:	0A9D  C1      	        POP     BC              ; Get return address
1423:	0A9E  E5      	        PUSH    HL              ; Save code string for RETURN
1424:	0A9F  E5      	        PUSH    HL              ; And for GOSUB routine
1425:	0AA0  2AA120  	        LD      HL,(LINEAT)     ; Get current line
1426:	0AA3  E3      	        EX      (SP),HL         ; Into stack - Code string out
1427:	0AA4  3E8C    	        LD      A,ZGOSUB        ; "GOSUB" token
1428:	0AA6  F5      	        PUSH    AF              ; Save token
1429:	0AA7  33      	        INC     SP              ; Don't save flags
1430:			
1431:	0AA8  C5      	RUNLIN: PUSH    BC              ; Save return address
1432:	0AA9  CD210A  	GOTO:   CALL    ATOH            ; ASCII number to DE binary
1433:	0AAC  CDEE0A  	        CALL    REM             ; Get end of line
1434:	0AAF  E5      	        PUSH    HL              ; Save end of line
1435:	0AB0  2AA120  	        LD      HL,(LINEAT)     ; Get current line
1436:	0AB3  CDC507  	        CALL    CPDEHL          ; Line after current?
1437:	0AB6  E1      	        POP     HL              ; Restore end of line
1438:	0AB7  23      	        INC     HL              ; Start of next line
1439:	0AB8  DCEC05  	        CALL    C,SRCHLP        ; Line is after current line
1440:	0ABB  D4E905  	        CALL    NC,SRCHLN       ; Line is before current line
1441:	0ABE  60      	        LD      H,B             ; Set up code string address
1442:	0ABF  69      	        LD      L,C
1443:	0AC0  2B      	        DEC     HL              ; Incremented after
1444:	0AC1  D8      	        RET     C               ; Line found
1445:	0AC2  1E0E    	ULERR:  LD      E,UL            ; ?UL Error
1446:	0AC4  C31105  	        JP      ERROR           ; Output error message
1447:			
1448:	0AC7  C0      	RETURN: RET     NZ              ; Return if not just RETURN
1449:	0AC8  16FF    	        LD      D,-1            ; Flag "GOSUB" search
1450:	0ACA  CDA604  	        CALL    BAKSTK          ; Look "GOSUB" block
1451:	0ACD  F9      	        LD      SP,HL           ; Kill all FORs in subroutine
1452:	0ACE  FE8C    	        CP      ZGOSUB          ; Test for "GOSUB" token
1453:	0AD0  1E04    	        LD      E,RG            ; ?RG Error
1454:	0AD2  C21105  	        JP      NZ,ERROR        ; Error if no "GOSUB" found
1455:	0AD5  E1      	        POP     HL              ; Get RETURN line number
1456:	0AD6  22A120  	        LD      (LINEAT),HL     ; Save as current
1457:	0AD9  23      	        INC     HL              ; Was it from direct statement?
1458:	0ADA  7C      	        LD      A,H
1459:	0ADB  B5      	        OR      L               ; Return to line
1460:	0ADC  C2E60A  	        JP      NZ,RETLIN       ; No - Return to line
1461:	0ADF  3A1121  	        LD      A,(LSTBIN)      ; Any INPUT in subroutine?
1462:	0AE2  B7      	        OR      A               ; If so buffer is corrupted
1463:	0AE3  C24705  	        JP      NZ,POPNOK       ; Yes - Go to command mode
1464:	0AE6  211509  	RETLIN: LD      HL,RUNCNT       ; Execution driver loop
1465:	0AE9  E3      	        EX      (SP),HL         ; Into stack - Code string out
1466:	0AEA  3E      	        .DB     3EH             ; Skip "POP HL"
1467:	0AEB  E1      	NXTDTA: POP     HL              ; Restore code string address
1468:			
1469:	0AEC  013A    	DATA:   .DB     01H,3AH         ; ':' End of statement
1470:	0AEE  0E00    	REM:    LD      C,0             ; 00  End of statement
1471:	0AF0  0600    	        LD      B,0
1472:	0AF2  79      	NXTSTL: LD      A,C             ; Statement and byte
1473:	0AF3  48      	        LD      C,B
1474:	0AF4  47      	        LD      B,A             ; Statement end byte
1475:	0AF5  7E      	NXTSTT: LD      A,(HL)          ; Get byte
1476:	0AF6  B7      	        OR      A               ; End of line?
1477:	0AF7  C8      	        RET     Z               ; Yes - Exit
1478:	0AF8  B8      	        CP      B               ; End of statement?
1479:	0AF9  C8      	        RET     Z               ; Yes - Exit
1480:	0AFA  23      	        INC     HL              ; Next byte
1481:	0AFB  FE22    	        CP      '"'             ; Literal string?
1482:	0AFD  CAF20A  	        JP      Z,NXTSTL        ; Yes - Look for another '"'
1483:	0B00  C3F50A  	        JP      NXTSTT          ; Keep looking
1484:			
1485:	0B03  CDB80F  	LET:    CALL    GETVAR          ; Get variable name
1486:	0B06  CDCB07  	        CALL    CHKSYN          ; Make sure "=" follows
1487:	0B09  B4      	        .DB     ZEQUAL          ; "=" token
1488:	0B0A  D5      	        PUSH    DE              ; Save address of variable
1489:	0B0B  3AF220  	        LD      A,(TYPE)        ; Get data type
1490:	0B0E  F5      	        PUSH    AF              ; Save type
1491:	0B0F  CDD40D  	        CALL    EVAL            ; Evaluate expression
1492:	0B12  F1      	        POP     AF              ; Restore type
1493:	0B13  E3      	        EX      (SP),HL         ; Save code - Get var addr
1494:	0B14  221321  	        LD      (BRKLIN),HL     ; Save address of variable
1495:	0B17  1F      	        RRA                     ; Adjust type
1496:	0B18  CDC70D  	        CALL    CHKTYP          ; Check types are the same
1497:	0B1B  CA560B  	        JP      Z,LETNUM        ; Numeric - Move value
1498:	0B1E  E5      	LETSTR: PUSH    HL              ; Save address of string var
1499:	0B1F  2A2921  	        LD      HL,(FPREG)      ; Pointer to string entry
1500:	0B22  E5      	        PUSH    HL              ; Save it on stack
1501:	0B23  23      	        INC     HL              ; Skip over length
1502:	0B24  23      	        INC     HL
1503:	0B25  5E      	        LD      E,(HL)          ; LSB of string address
1504:	0B26  23      	        INC     HL
1505:	0B27  56      	        LD      D,(HL)          ; MSB of string address
1506:	0B28  2AA320  	        LD      HL,(BASTXT)     ; Point to start of program
1507:	0B2B  CDC507  	        CALL    CPDEHL          ; Is string before program?
1508:	0B2E  D2450B  	        JP      NC,CRESTR       ; Yes - Create string entry
1509:	0B31  2A9F20  	        LD      HL,(STRSPC)     ; Point to string space
1510:	0B34  CDC507  	        CALL    CPDEHL          ; Is string literal in program?
1511:	0B37  D1      	        POP     DE              ; Restore address of string
1512:	0B38  D24D0B  	        JP      NC,MVSTPT       ; Yes - Set up pointer
1513:	0B3B  210421  	        LD      HL,TMPSTR       ; Temporary string pool
1514:	0B3E  CDC507  	        CALL    CPDEHL          ; Is string in temporary pool?
1515:	0B41  D24D0B  	        JP      NC,MVSTPT       ; No - Set up pointer
1516:	0B44  3E      	        .DB     3EH             ; Skip "POP DE"
1517:	0B45  D1      	CRESTR: POP     DE              ; Restore address of string
1518:	0B46  CDFC13  	        CALL    BAKTMP          ; Back to last tmp-str entry
1519:	0B49  EB      	        EX      DE,HL           ; Address of string entry
1520:	0B4A  CD3512  	        CALL    SAVSTR          ; Save string in string area
1521:	0B4D  CDFC13  	MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
1522:	0B50  E1      	        POP     HL              ; Get string pointer
1523:	0B51  CDFF17  	        CALL    DETHL4          ; Move string pointer to var
1524:	0B54  E1      	        POP     HL              ; Restore code string address
1525:	0B55  C9      	        RET
1526:			
1527:	0B56  E5      	LETNUM: PUSH    HL              ; Save address of variable
1528:	0B57  CDFC17  	        CALL    FPTHL           ; Move value to variable
1529:	0B5A  D1      	        POP     DE              ; Restore address of variable
1530:	0B5B  E1      	        POP     HL              ; Restore code string address
1531:	0B5C  C9      	        RET
1532:			
1533:	0B5D  CD2315  	ON:     CALL    GETINT          ; Get integer 0-255
1534:	0B60  7E      	        LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
1535:	0B61  47      	        LD      B,A             ; Save in B
1536:	0B62  FE8C    	        CP      ZGOSUB          ; "GOSUB" token?
1537:	0B64  CA6C0B  	        JP      Z,ONGO          ; Yes - Find line number
1538:	0B67  CDCB07  	        CALL    CHKSYN          ; Make sure it's "GOTO"
1539:	0B6A  88      	        .DB     ZGOTO           ; "GOTO" token
1540:	0B6B  2B      	        DEC     HL              ; Cancel increment
1541:	0B6C  4B      	ONGO:   LD      C,E             ; Integer of branch value
1542:	0B6D  0D      	ONGOLP: DEC     C               ; Count branches
1543:	0B6E  78      	        LD      A,B             ; Get "GOTO" or "GOSUB" token
1544:	0B6F  CA3D09  	        JP      Z,ONJMP         ; Go to that line if right one
1545:	0B72  CD220A  	        CALL    GETLN           ; Get line number to DE
1546:	0B75  FE2C    	        CP      ','             ; Another line number?
1547:	0B77  C0      	        RET     NZ              ; No - Drop through
1548:	0B78  C36D0B  	        JP      ONGOLP          ; Yes - loop
1549:			
1550:	0B7B  CDD40D  	IF:     CALL    EVAL            ; Evaluate expression
1551:	0B7E  7E      	        LD      A,(HL)          ; Get token
1552:	0B7F  FE88    	        CP      ZGOTO           ; "GOTO" token?
1553:	0B81  CA890B  	        JP      Z,IFGO          ; Yes - Get line
1554:	0B84  CDCB07  	        CALL    CHKSYN          ; Make sure it's "THEN"
1555:	0B87  A9      	        .DB     ZTHEN           ; "THEN" token
1556:	0B88  2B      	        DEC     HL              ; Cancel increment
1557:	0B89  CDC50D  	IFGO:   CALL    TSTNUM          ; Make sure it's numeric
1558:	0B8C  CDA417  	        CALL    TSTSGN          ; Test state of expression
1559:	0B8F  CAEE0A  	        JP      Z,REM           ; False - Drop through
1560:	0B92  CD5509  	        CALL    GETCHR          ; Get next character
1561:	0B95  DAA90A  	        JP      C,GOTO          ; Number - GOTO that line
1562:	0B98  C33C09  	        JP      IFJMP           ; Otherwise do statement
1563:			
1564:	0B9B  2B      	MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
1565:	0B9C  CD5509  	        CALL    GETCHR          ; Get next character
1566:	0B9F  CAFD0B  	PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
1567:	0BA2  C8      	PRNTLP: RET     Z               ; End of list - Exit
1568:	0BA3  FEA5    	        CP      ZTAB            ; "TAB(" token?
1569:	0BA5  CA300C  	        JP      Z,DOTAB         ; Yes - Do TAB routine
1570:	0BA8  FEA8    	        CP      ZSPC            ; "SPC(" token?
1571:	0BAA  CA300C  	        JP      Z,DOTAB         ; Yes - Do SPC routine
1572:	0BAD  E5      	        PUSH    HL              ; Save code string address
1573:	0BAE  FE2C    	        CP      ','             ; Comma?
1574:	0BB0  CA190C  	        JP      Z,DOCOM         ; Yes - Move to next zone
1575:	0BB3  FE3B    	        CP      59 ;";"         ; Semi-colon?
1576:	0BB5  CA530C  	        JP      Z,NEXITM        ; Do semi-colon routine
1577:	0BB8  C1      	        POP     BC              ; Code string address to BC
1578:	0BB9  CDD40D  	        CALL    EVAL            ; Evaluate expression
1579:	0BBC  E5      	        PUSH    HL              ; Save code string address
1580:	0BBD  3AF220  	        LD      A,(TYPE)        ; Get variable type
1581:	0BC0  B7      	        OR      A               ; Is it a string variable?
1582:	0BC1  C2E90B  	        JP      NZ,PRNTST       ; Yes - Output string contents
1583:	0BC4  CD4919  	        CALL    NUMASC          ; Convert number to text
1584:	0BC7  CD5912  	        CALL    CRTST           ; Create temporary string
1585:	0BCA  3620    	        LD      (HL),' '        ; Followed by a space
1586:	0BCC  2A2921  	        LD      HL,(FPREG)      ; Get length of output
1587:	0BCF  34      	        INC     (HL)            ; Plus 1 for the space
1588:	0BD0  2A2921  	        LD      HL,(FPREG)      ; < Not needed >
1589:	0BD3  3A8720  	        LD      A,(LWIDTH)      ; Get width of line
1590:	0BD6  47      	        LD      B,A             ; To B
1591:	0BD7  04      	        INC     B               ; Width 255 (No limit)?
1592:	0BD8  CAE50B  	        JP      Z,PRNTNB        ; Yes - Output number string
1593:	0BDB  04      	        INC     B               ; Adjust it
1594:	0BDC  3AF020  	        LD      A,(CURPOS)      ; Get cursor position
1595:	0BDF  86      	        ADD     A,(HL)          ; Add length of string
1596:	0BE0  3D      	        DEC     A               ; Adjust it
1597:	0BE1  B8      	        CP      B               ; Will output fit on this line?
1598:	0BE2  D4FD0B  	        CALL    NC,PRNTCRLF     ; No - CRLF first
1599:	0BE5  CD9E12  	PRNTNB: CALL    PRS1            ; Output string at (HL)
1600:	0BE8  AF      	        XOR     A               ; Skip CALL by setting 'z' flag
1601:	0BE9  C49E12  	PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
1602:	0BEC  E1      	        POP     HL              ; Restore code string address
1603:	0BED  C39B0B  	        JP      MRPRNT          ; See if more to PRINT
1604:			
1605:	0BF0  3AF020  	STTLIN: LD      A,(CURPOS)      ; Make sure on new line
1606:	0BF3  B7      	        OR      A               ; Already at start?
1607:	0BF4  C8      	        RET     Z               ; Yes - Do nothing
1608:	0BF5  C3FD0B  	        JP      PRNTCRLF        ; Start a new line
1609:			
1610:	0BF8  3600    	ENDINP: LD      (HL),0          ; Mark end of buffer
1611:	0BFA  21A520  	        LD      HL,BUFFER-1     ; Point to buffer
1612:	0BFD  3E0D    	PRNTCRLF: LD    A,CR            ; Load a CR
1613:	0BFF  CDD607  	        CALL    OUTC            ; Output character
1614:	0C02  3E0A    	        LD      A,LF            ; Load a LF
1615:	0C04  CDD607  	        CALL    OUTC            ; Output character
1616:	0C07  AF      	DONULL: XOR     A               ; Set to position 0
1617:	0C08  32F020  	        LD      (CURPOS),A      ; Store it
1618:	0C0B  3A8620  	        LD      A,(NULLS)       ; Get number of nulls
1619:	0C0E  3D      	NULLP:  DEC     A               ; Count them
1620:	0C0F  C8      	        RET     Z               ; Return if done
1621:	0C10  F5      	        PUSH    AF              ; Save count
1622:	0C11  AF      	        XOR     A               ; Load a null
1623:	0C12  CDD607  	        CALL    OUTC            ; Output it
1624:	0C15  F1      	        POP     AF              ; Restore count
1625:	0C16  C30E0C  	        JP      NULLP           ; Keep counting
1626:			
1627:	0C19  3A8820  	DOCOM:  LD      A,(COMMAN)      ; Get comma width
1628:	0C1C  47      	        LD      B,A             ; Save in B
1629:	0C1D  3AF020  	        LD      A,(CURPOS)      ; Get current position
1630:	0C20  B8      	        CP      B               ; Within the limit?
1631:	0C21  D4FD0B  	        CALL    NC,PRNTCRLF     ; No - output CRLF
1632:	0C24  D2530C  	        JP      NC,NEXITM       ; Get next item
1633:	0C27  D60E    	ZONELP: SUB     14              ; Next zone of 14 characters
1634:	0C29  D2270C  	        JP      NC,ZONELP       ; Repeat if more zones
1635:	0C2C  2F      	        CPL                     ; Number of spaces to output
1636:	0C2D  C3480C  	        JP      ASPCS           ; Output them
1637:			
1638:	0C30  F5      	DOTAB:  PUSH    AF              ; Save token
1639:	0C31  CD2015  	        CALL    FNDNUM          ; Evaluate expression
1640:	0C34  CDCB07  	        CALL    CHKSYN          ; Make sure ")" follows
1641:	0C37  29      	        .DB     ")"
1642:	0C38  2B      	        DEC     HL              ; Back space on to ")"
1643:	0C39  F1      	        POP     AF              ; Restore token
1644:	0C3A  D6A8    	        SUB     ZSPC            ; Was it "SPC(" ?
1645:	0C3C  E5      	        PUSH    HL              ; Save code string address
1646:	0C3D  CA430C  	        JP      Z,DOSPC         ; Yes - Do 'E' spaces
1647:	0C40  3AF020  	        LD      A,(CURPOS)      ; Get current position
1648:	0C43  2F      	DOSPC:  CPL                     ; Number of spaces to print to
1649:	0C44  83      	        ADD     A,E             ; Total number to print
1650:	0C45  D2530C  	        JP      NC,NEXITM       ; TAB < Current POS(X)
1651:	0C48  3C      	ASPCS:  INC     A               ; Output A spaces
1652:	0C49  47      	        LD      B,A             ; Save number to print
1653:	0C4A  3E20    	        LD      A,' '           ; Space
1654:	0C4C  CDD607  	SPCLP:  CALL    OUTC            ; Output character in A
1655:	0C4F  05      	        DEC     B               ; Count them
1656:	0C50  C24C0C  	        JP      NZ,SPCLP        ; Repeat if more
1657:	0C53  E1      	NEXITM: POP     HL              ; Restore code string address
1658:	0C54  CD5509  	        CALL    GETCHR          ; Get next character
1659:	0C57  C3A20B  	        JP      PRNTLP          ; More to print
1660:			
1661:	0C5A  3F526564	REDO:   .DB     "?Redo from start",CR,LF,0
	      6F206672
	      6F6D2073
	      74617274
	      0D0A00
1662:			
1663:	0C6D  3A1221  	BADINP: LD      A,(READFG)      ; READ or INPUT?
1664:	0C70  B7      	        OR      A
1665:	0C71  C2F704  	        JP      NZ,DATSNR       ; READ - ?SN Error
1666:	0C74  C1      	        POP     BC              ; Throw away code string addr
1667:	0C75  215A0C  	        LD      HL,REDO         ; "Redo from start" message
1668:	0C78  CD9B12  	        CALL    PRS             ; Output string
1669:	0C7B  C34806  	        JP      DOAGN           ; Do last INPUT again
1670:			
1671:	0C7E  CD0612  	INPUT:  CALL    IDTEST          ; Test for illegal direct
1672:	0C81  7E      	        LD      A,(HL)          ; Get character after "INPUT"
1673:	0C82  FE22    	        CP      '"'             ; Is there a prompt string?
1674:	0C84  3E00    	        LD      A,0             ; Clear A and leave flags
1675:	0C86  328A20  	        LD      (CTLOFG),A      ; Enable output
1676:	0C89  C2980C  	        JP      NZ,NOPMPT       ; No prompt - get input
1677:	0C8C  CD5A12  	        CALL    QTSTR           ; Get string terminated by '"'
1678:	0C8F  CDCB07  	        CALL    CHKSYN          ; Check for ';' after prompt
1679:	0C92  3B      	        .DB     ';'
1680:	0C93  E5      	        PUSH    HL              ; Save code string address
1681:	0C94  CD9E12  	        CALL    PRS1            ; Output prompt string
1682:	0C97  3E      	        .DB     3EH             ; Skip "PUSH HL"
1683:	0C98  E5      	NOPMPT: PUSH    HL              ; Save code string address
1684:	0C99  CD4C06  	        CALL    PROMPT          ; Get input with "? " prompt
1685:	0C9C  C1      	        POP     BC              ; Restore code string address
1686:	0C9D  DAA409  	        JP      C,INPBRK        ; Break pressed - Exit
1687:	0CA0  23      	        INC     HL              ; Next byte
1688:	0CA1  7E      	        LD      A,(HL)          ; Get it
1689:	0CA2  B7      	        OR      A               ; End of line?
1690:	0CA3  2B      	        DEC     HL              ; Back again
1691:	0CA4  C5      	        PUSH    BC              ; Re-save code string address
1692:	0CA5  CAEB0A  	        JP      Z,NXTDTA        ; Yes - Find next DATA stmt
1693:	0CA8  362C    	        LD      (HL),','        ; Store comma as separator
1694:	0CAA  C3B20C  	        JP      NXTITM          ; Get next item
1695:			
1696:	0CAD  E5      	READ:   PUSH    HL              ; Save code string address
1697:	0CAE  2A2121  	        LD      HL,(NXTDAT)     ; Next DATA statement
1698:	0CB1  F6      	        .DB     0F6H            ; Flag "READ"
1699:	0CB2  AF      	NXTITM: XOR     A               ; Flag "INPUT"
1700:	0CB3  321221  	        LD      (READFG),A      ; Save "READ"/"INPUT" flag
1701:	0CB6  E3      	        EX      (SP),HL         ; Get code str' , Save pointer
1702:	0CB7  C3BE0C  	        JP      GTVLUS          ; Get values
1703:			
1704:	0CBA  CDCB07  	NEDMOR: CALL    CHKSYN          ; Check for comma between items
1705:	0CBD  2C      	        .DB     ','
1706:	0CBE  CDB80F  	GTVLUS: CALL    GETVAR          ; Get variable name
1707:	0CC1  E3      	        EX      (SP),HL         ; Save code str" , Get pointer
1708:	0CC2  D5      	        PUSH    DE              ; Save variable address
1709:	0CC3  7E      	        LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
1710:	0CC4  FE2C    	        CP      ','             ; Comma?
1711:	0CC6  CAE60C  	        JP      Z,ANTVLU        ; Yes - Get another value
1712:	0CC9  3A1221  	        LD      A,(READFG)      ; Is it READ?
1713:	0CCC  B7      	        OR      A
1714:	0CCD  C2530D  	        JP      NZ,FDTLP        ; Yes - Find next DATA stmt
1715:	0CD0  3E3F    	        LD      A,'?'           ; More INPUT needed
1716:	0CD2  CDD607  	        CALL    OUTC            ; Output character
1717:	0CD5  CD4C06  	        CALL    PROMPT          ; Get INPUT with prompt
1718:	0CD8  D1      	        POP     DE              ; Variable address
1719:	0CD9  C1      	        POP     BC              ; Code string address
1720:	0CDA  DAA409  	        JP      C,INPBRK        ; Break pressed
1721:	0CDD  23      	        INC     HL              ; Point to next DATA byte
1722:	0CDE  7E      	        LD      A,(HL)          ; Get byte
1723:	0CDF  B7      	        OR      A               ; Is it zero (No input) ?
1724:	0CE0  2B      	        DEC     HL              ; Back space INPUT pointer
1725:	0CE1  C5      	        PUSH    BC              ; Save code string address
1726:	0CE2  CAEB0A  	        JP      Z,NXTDTA        ; Find end of buffer
1727:	0CE5  D5      	        PUSH    DE              ; Save variable address
1728:	0CE6  3AF220  	ANTVLU: LD      A,(TYPE)        ; Check data type
1729:	0CE9  B7      	        OR      A               ; Is it numeric?
1730:	0CEA  CA100D  	        JP      Z,INPBIN        ; Yes - Convert to binary
1731:	0CED  CD5509  	        CALL    GETCHR          ; Get next character
1732:	0CF0  57      	        LD      D,A             ; Save input character
1733:	0CF1  47      	        LD      B,A             ; Again
1734:	0CF2  FE22    	        CP      '"'             ; Start of literal sting?
1735:	0CF4  CA040D  	        JP      Z,STRENT        ; Yes - Create string entry
1736:	0CF7  3A1221  	        LD      A,(READFG)      ; "READ" or "INPUT" ?
1737:	0CFA  B7      	        OR      A
1738:	0CFB  57      	        LD      D,A             ; Save 00 if "INPUT"
1739:	0CFC  CA010D  	        JP      Z,ITMSEP        ; "INPUT" - End with 00
1740:	0CFF  163A    	        LD      D,':'           ; "DATA" - End with 00 or ':'
1741:	0D01  062C    	ITMSEP: LD      B,','           ; Item separator
1742:	0D03  2B      	        DEC     HL              ; Back space for DTSTR
1743:	0D04  CD5D12  	STRENT: CALL    DTSTR           ; Get string terminated by D
1744:	0D07  EB      	        EX      DE,HL           ; String address to DE
1745:	0D08  211B0D  	        LD      HL,LTSTND       ; Where to go after LETSTR
1746:	0D0B  E3      	        EX      (SP),HL         ; Save HL , get input pointer
1747:	0D0C  D5      	        PUSH    DE              ; Save address of string
1748:	0D0D  C31E0B  	        JP      LETSTR          ; Assign string to variable
1749:			
1750:	0D10  CD5509  	INPBIN: CALL    GETCHR          ; Get next character
1751:	0D13  CDAB18  	        CALL    ASCTFP          ; Convert ASCII to FP number
1752:	0D16  E3      	        EX      (SP),HL         ; Save input ptr, Get var addr
1753:	0D17  CDFC17  	        CALL    FPTHL           ; Move FPREG to variable
1754:	0D1A  E1      	        POP     HL              ; Restore input pointer
1755:	0D1B  2B      	LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
1756:	0D1C  CD5509  	        CALL    GETCHR          ; Get next character
1757:	0D1F  CA270D  	        JP      Z,MORDT         ; End of line - More needed?
1758:	0D22  FE2C    	        CP      ','             ; Another value?
1759:	0D24  C26D0C  	        JP      NZ,BADINP       ; No - Bad input
1760:	0D27  E3      	MORDT:  EX      (SP),HL         ; Get code string address
1761:	0D28  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
1762:	0D29  CD5509  	        CALL    GETCHR          ; Get next character
1763:	0D2C  C2BA0C  	        JP      NZ,NEDMOR       ; More needed - Get it
1764:	0D2F  D1      	        POP     DE              ; Restore DATA pointer
1765:	0D30  3A1221  	        LD      A,(READFG)      ; "READ" or "INPUT" ?
1766:	0D33  B7      	        OR      A
1767:	0D34  EB      	        EX      DE,HL           ; DATA pointer to HL
1768:	0D35  C27B09  	        JP      NZ,UPDATA       ; Update DATA pointer if "READ"
1769:	0D38  D5      	        PUSH    DE              ; Save code string address
1770:	0D39  B6      	        OR      (HL)            ; More input given?
1771:	0D3A  21420D  	        LD      HL,EXTIG        ; "?Extra ignored" message
1772:	0D3D  C49B12  	        CALL    NZ,PRS          ; Output string if extra given
1773:	0D40  E1      	        POP     HL              ; Restore code string address
1774:	0D41  C9      	        RET
1775:			
1776:	0D42  3F457874	EXTIG:  .DB     "?Extra ignored",CR,LF,0
	      72612069
	      676E6F72
	      65640D0A
	      00
1777:			
1778:	0D53  CDEC0A  	FDTLP:  CALL    DATA            ; Get next statement
1779:	0D56  B7      	        OR      A               ; End of line?
1780:	0D57  C26C0D  	        JP      NZ,FANDT        ; No - See if DATA statement
1781:	0D5A  23      	        INC     HL
1782:	0D5B  7E      	        LD      A,(HL)          ; End of program?
1783:	0D5C  23      	        INC     HL
1784:	0D5D  B6      	        OR      (HL)            ; 00 00 Ends program
1785:	0D5E  1E06    	        LD      E,OD            ; ?OD Error
1786:	0D60  CA1105  	        JP      Z,ERROR         ; Yes - Out of DATA
1787:	0D63  23      	        INC     HL
1788:	0D64  5E      	        LD      E,(HL)          ; LSB of line number
1789:	0D65  23      	        INC     HL
1790:	0D66  56      	        LD      D,(HL)          ; MSB of line number
1791:	0D67  EB      	        EX      DE,HL
1792:	0D68  220E21  	        LD      (DATLIN),HL     ; Set line of current DATA item
1793:	0D6B  EB      	        EX      DE,HL
1794:	0D6C  CD5509  	FANDT:  CALL    GETCHR          ; Get next character
1795:	0D6F  FE83    	        CP      ZDATA           ; "DATA" token
1796:	0D71  C2530D  	        JP      NZ,FDTLP        ; No "DATA" - Keep looking
1797:	0D74  C3E60C  	        JP      ANTVLU          ; Found - Convert input
1798:			
1799:	0D77  110000  	NEXT:   LD      DE,0            ; In case no index given
1800:	0D7A  C4B80F  	NEXT1:  CALL    NZ,GETVAR       ; Get index address
1801:	0D7D  221321  	        LD      (BRKLIN),HL     ; Save code string address
1802:	0D80  CDA604  	        CALL    BAKSTK          ; Look for "FOR" block
1803:	0D83  C20305  	        JP      NZ,NFERR        ; No "FOR" - ?NF Error
1804:	0D86  F9      	        LD      SP,HL           ; Clear nested loops
1805:	0D87  D5      	        PUSH    DE              ; Save index address
1806:	0D88  7E      	        LD      A,(HL)          ; Get sign of STEP
1807:	0D89  23      	        INC     HL
1808:	0D8A  F5      	        PUSH    AF              ; Save sign of STEP
1809:	0D8B  D5      	        PUSH    DE              ; Save index address
1810:	0D8C  CDE217  	        CALL    PHLTFP          ; Move index value to FPREG
1811:	0D8F  E3      	        EX      (SP),HL         ; Save address of TO value
1812:	0D90  E5      	        PUSH    HL              ; Save address of index
1813:	0D91  CD4F15  	        CALL    ADDPHL          ; Add STEP to index value
1814:	0D94  E1      	        POP     HL              ; Restore address of index
1815:	0D95  CDFC17  	        CALL    FPTHL           ; Move value to index variable
1816:	0D98  E1      	        POP     HL              ; Restore address of TO value
1817:	0D99  CDF317  	        CALL    LOADFP          ; Move TO value to BCDE
1818:	0D9C  E5      	        PUSH    HL              ; Save address of line of FOR
1819:	0D9D  CD1F18  	        CALL    CMPNUM          ; Compare index with TO value
1820:	0DA0  E1      	        POP     HL              ; Restore address of line num
1821:	0DA1  C1      	        POP     BC              ; Address of sign of STEP
1822:	0DA2  90      	        SUB     B               ; Compare with expected sign
1823:	0DA3  CDF317  	        CALL    LOADFP          ; BC = Loop stmt,DE = Line num
1824:	0DA6  CAB20D  	        JP      Z,KILFOR        ; Loop finished - Terminate it
1825:	0DA9  EB      	        EX      DE,HL           ; Loop statement line number
1826:	0DAA  22A120  	        LD      (LINEAT),HL     ; Set loop line number
1827:	0DAD  69      	        LD      L,C             ; Set code string to loop
1828:	0DAE  60      	        LD      H,B
1829:	0DAF  C31109  	        JP      PUTFID          ; Put back "FOR" and continue
1830:			
1831:	0DB2  F9      	KILFOR: LD      SP,HL           ; Remove "FOR" block
1832:	0DB3  2A1321  	        LD      HL,(BRKLIN)     ; Code string after "NEXT"
1833:	0DB6  7E      	        LD      A,(HL)          ; Get next byte in code string
1834:	0DB7  FE2C    	        CP      ','             ; More NEXTs ?
1835:	0DB9  C21509  	        JP      NZ,RUNCNT       ; No - Do next statement
1836:	0DBC  CD5509  	        CALL    GETCHR          ; Position to index name
1837:	0DBF  CD7A0D  	        CALL    NEXT1           ; Re-enter NEXT routine
1838:			; < will not RETurn to here , Exit to RUNCNT or Loop >
1839:			
1840:	0DC2  CDD40D  	GETNUM: CALL    EVAL            ; Get a numeric expression
1841:	0DC5  F6      	TSTNUM: .DB     0F6H            ; Clear carry (numeric)
1842:	0DC6  37      	TSTSTR: SCF                     ; Set carry (string)
1843:	0DC7  3AF220  	CHKTYP: LD      A,(TYPE)        ; Check types match
1844:	0DCA  8F      	        ADC     A,A             ; Expected + actual
1845:	0DCB  B7      	        OR      A               ; Clear carry , set parity
1846:	0DCC  E8      	        RET     PE              ; Even parity - Types match
1847:	0DCD  C30F05  	        JP      TMERR           ; Different types - Error
1848:			
1849:	0DD0  CDCB07  	OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
1850:	0DD3  28      	        .DB  "("
1851:	0DD4  2B      	EVAL:   DEC     HL              ; Evaluate expression & save
1852:	0DD5  1600    	        LD      D,0             ; Precedence value
1853:	0DD7  D5      	EVAL1:  PUSH    DE              ; Save precedence
1854:	0DD8  0E01    	        LD      C,1
1855:	0DDA  CDDA04  	        CALL    CHKSTK          ; Check for 1 level of stack
1856:	0DDD  CD4B0E  	        CALL    OPRND           ; Get next expression value
1857:	0DE0  221521  	EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
1858:	0DE3  2A1521  	EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
1859:	0DE6  C1      	        POP     BC              ; Precedence value and operator
1860:	0DE7  78      	        LD      A,B             ; Get precedence value
1861:	0DE8  FE78    	        CP      78H             ; "AND" or "OR" ?
1862:	0DEA  D4C50D  	        CALL    NC,TSTNUM       ; No - Make sure it's a number
1863:	0DED  7E      	        LD      A,(HL)          ; Get next operator / function
1864:	0DEE  1600    	        LD      D,0             ; Clear Last relation
1865:	0DF0  D6B3    	RLTLP:  SUB     ZGTR            ; ">" Token
1866:	0DF2  DA0C0E  	        JP      C,FOPRND        ; + - * / ^ AND OR - Test it
1867:	0DF5  FE03    	        CP      ZLTH+1-ZGTR     ; < = >
1868:	0DF7  D20C0E  	        JP      NC,FOPRND       ; Function - Call it
1869:	0DFA  FE01    	        CP      ZEQUAL-ZGTR     ; "="
1870:	0DFC  17      	        RLA                     ; <- Test for legal
1871:	0DFD  AA      	        XOR     D               ; <- combinations of < = >
1872:	0DFE  BA      	        CP      D               ; <- by combining last token
1873:	0DFF  57      	        LD      D,A             ; <- with current one
1874:	0E00  DAFD04  	        JP      C,SNERR         ; Error if "<<' '==" or ">>"
1875:	0E03  220A21  	        LD      (CUROPR),HL     ; Save address of current token
1876:	0E06  CD5509  	        CALL    GETCHR          ; Get next character
1877:	0E09  C3F00D  	        JP      RLTLP           ; Treat the two as one
1878:			
1879:	0E0C  7A      	FOPRND: LD      A,D             ; < = > found ?
1880:	0E0D  B7      	        OR      A
1881:	0E0E  C2330F  	        JP      NZ,TSTRED       ; Yes - Test for reduction
1882:	0E11  7E      	        LD      A,(HL)          ; Get operator token
1883:	0E12  220A21  	        LD      (CUROPR),HL     ; Save operator address
1884:	0E15  D6AC    	        SUB     ZPLUS           ; Operator or function?
1885:	0E17  D8      	        RET     C               ; Neither - Exit
1886:	0E18  FE07    	        CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
1887:	0E1A  D0      	        RET     NC              ; No - Exit
1888:	0E1B  5F      	        LD      E,A             ; Coded operator
1889:	0E1C  3AF220  	        LD      A,(TYPE)        ; Get data type
1890:	0E1F  3D      	        DEC     A               ; FF = numeric , 00 = string
1891:	0E20  B3      	        OR      E               ; Combine with coded operator
1892:	0E21  7B      	        LD      A,E             ; Get coded operator
1893:	0E22  CA9113  	        JP      Z,CONCAT        ; String concatenation
1894:	0E25  07      	        RLCA                    ; Times 2
1895:	0E26  83      	        ADD     A,E             ; Times 3
1896:	0E27  5F      	        LD      E,A             ; To DE (D is 0)
1897:	0E28  21EF03  	        LD      HL,PRITAB       ; Precedence table
1898:	0E2B  19      	        ADD     HL,DE           ; To the operator concerned
1899:	0E2C  78      	        LD      A,B             ; Last operator precedence
1900:	0E2D  56      	        LD      D,(HL)          ; Get evaluation precedence
1901:	0E2E  BA      	        CP      D               ; Compare with eval precedence
1902:	0E2F  D0      	        RET     NC              ; Exit if higher precedence
1903:	0E30  23      	        INC     HL              ; Point to routine address
1904:	0E31  CDC50D  	        CALL    TSTNUM          ; Make sure it's a number
1905:			
1906:	0E34  C5      	STKTHS: PUSH    BC              ; Save last precedence & token
1907:	0E35  01E30D  	        LD      BC,EVAL3        ; Where to go on prec' break
1908:	0E38  C5      	        PUSH    BC              ; Save on stack for return
1909:	0E39  43      	        LD      B,E             ; Save operator
1910:	0E3A  4A      	        LD      C,D             ; Save precedence
1911:	0E3B  CDD517  	        CALL    STAKFP          ; Move value to stack
1912:	0E3E  58      	        LD      E,B             ; Restore operator
1913:	0E3F  51      	        LD      D,C             ; Restore precedence
1914:	0E40  4E      	        LD      C,(HL)          ; Get LSB of routine address
1915:	0E41  23      	        INC     HL
1916:	0E42  46      	        LD      B,(HL)          ; Get MSB of routine address
1917:	0E43  23      	        INC     HL
1918:	0E44  C5      	        PUSH    BC              ; Save routine address
1919:	0E45  2A0A21  	        LD      HL,(CUROPR)     ; Address of current operator
1920:	0E48  C3D70D  	        JP      EVAL1           ; Loop until prec' break
1921:			
1922:	0E4B  AF      	OPRND:  XOR     A               ; Get operand routine
1923:	0E4C  32F220  	        LD      (TYPE),A        ; Set numeric expected
1924:	0E4F  CD5509  	        CALL    GETCHR          ; Get next character
1925:	0E52  1E24    	        LD      E,MO            ; ?MO Error
1926:	0E54  CA1105  	        JP      Z,ERROR         ; No operand - Error
1927:	0E57  DAAB18  	        JP      C,ASCTFP        ; Number - Get value
1928:	0E5A  CDF309  	        CALL    CHKLTR          ; See if a letter
1929:	0E5D  D2B20E  	        JP      NC,CONVAR       ; Letter - Find variable
1930:	0E60  FE26    	        CP      '&'             ; &H = HEX, &B = BINARY
1931:	0E62  2012    	        JR      NZ, NOTAMP
1932:	0E64  CD5509  	        CALL    GETCHR          ; Get next character
1933:	0E67  FE48    	        CP      'H'             ; Hex number indicated? [function added]
1934:	0E69  CAEF1C  	        JP      Z,HEXTFP        ; Convert Hex to FPREG
1935:	0E6C  FE42    	        CP      'B'             ; Binary number indicated? [function added]
1936:	0E6E  CA5F1D  	        JP      Z,BINTFP        ; Convert Bin to FPREG
1937:	0E71  1E02    	        LD      E,SN            ; If neither then a ?SN Error
1938:	0E73  CA1105  	        JP      Z,ERROR         ; 
1939:	0E76  FEAC    	NOTAMP: CP      ZPLUS           ; '+' Token ?
1940:	0E78  CA4B0E  	        JP      Z,OPRND         ; Yes - Look for operand
1941:	0E7B  FE2E    	        CP      '.'             ; '.' ?
1942:	0E7D  CAAB18  	        JP      Z,ASCTFP        ; Yes - Create FP number
1943:	0E80  FEAD    	        CP      ZMINUS          ; '-' Token ?
1944:	0E82  CAA10E  	        JP      Z,MINUS         ; Yes - Do minus
1945:	0E85  FE22    	        CP      '"'             ; Literal string ?
1946:	0E87  CA5A12  	        JP      Z,QTSTR         ; Get string terminated by '"'
1947:	0E8A  FEAA    	        CP      ZNOT            ; "NOT" Token ?
1948:	0E8C  CA930F  	        JP      Z,EVNOT         ; Yes - Eval NOT expression
1949:	0E8F  FEA7    	        CP      ZFN             ; "FN" Token ?
1950:	0E91  CABE11  	        JP      Z,DOFN          ; Yes - Do FN routine
1951:	0E94  D6B6    	        SUB     ZSGN            ; Is it a function?
1952:	0E96  D2C30E  	        JP      NC,FNOFST       ; Yes - Evaluate function
1953:	0E99  CDD00D  	EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
1954:	0E9C  CDCB07  	        CALL    CHKSYN          ; Make sure ")" follows
1955:	0E9F  29      	        .DB     ")"
1956:	0EA0  C9      	        RET
1957:			
1958:	0EA1  167D    	MINUS:  LD      D,7DH           ; '-' precedence
1959:	0EA3  CDD70D  	        CALL    EVAL1           ; Evaluate until prec' break
1960:	0EA6  2A1521  	        LD      HL,(NXTOPR)     ; Get next operator address
1961:	0EA9  E5      	        PUSH    HL              ; Save next operator address
1962:	0EAA  CDCD17  	        CALL    INVSGN          ; Negate value
1963:	0EAD  CDC50D  	RETNUM: CALL    TSTNUM          ; Make sure it's a number
1964:	0EB0  E1      	        POP     HL              ; Restore next operator address
1965:	0EB1  C9      	        RET
1966:			
1967:	0EB2  CDB80F  	CONVAR: CALL    GETVAR          ; Get variable address to DE
1968:	0EB5  E5      	FRMEVL: PUSH    HL              ; Save code string address
1969:	0EB6  EB      	        EX      DE,HL           ; Variable address to HL
1970:	0EB7  222921  	        LD      (FPREG),HL      ; Save address of variable
1971:	0EBA  3AF220  	        LD      A,(TYPE)        ; Get type
1972:	0EBD  B7      	        OR      A               ; Numeric?
1973:	0EBE  CCE217  	        CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
1974:	0EC1  E1      	        POP     HL              ; Restore code string address
1975:	0EC2  C9      	        RET
1976:			
1977:	0EC3  0600    	FNOFST: LD      B,0             ; Get address of function
1978:	0EC5  07      	        RLCA                    ; Double function offset
1979:	0EC6  4F      	        LD      C,A             ; BC = Offset in function table
1980:	0EC7  C5      	        PUSH    BC              ; Save adjusted token value
1981:	0EC8  CD5509  	        CALL    GETCHR          ; Get next character
1982:	0ECB  79      	        LD      A,C             ; Get adjusted token value
1983:	0ECC  FE31    	        CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
1984:	0ECE  DAEA0E  	        JP      C,FNVAL         ; No - Do function
1985:	0ED1  CDD00D  	        CALL    OPNPAR          ; Evaluate expression  (X,...
1986:	0ED4  CDCB07  	        CALL    CHKSYN          ; Make sure ',' follows
1987:	0ED7  2C      	        .DB     ','
1988:	0ED8  CDC60D  	        CALL    TSTSTR          ; Make sure it's a string
1989:	0EDB  EB      	        EX      DE,HL           ; Save code string address
1990:	0EDC  2A2921  	        LD      HL,(FPREG)      ; Get address of string
1991:	0EDF  E3      	        EX      (SP),HL         ; Save address of string
1992:	0EE0  E5      	        PUSH    HL              ; Save adjusted token value
1993:	0EE1  EB      	        EX      DE,HL           ; Restore code string address
1994:	0EE2  CD2315  	        CALL    GETINT          ; Get integer 0-255
1995:	0EE5  EB      	        EX      DE,HL           ; Save code string address
1996:	0EE6  E3      	        EX      (SP),HL         ; Save integer,HL = adj' token
1997:	0EE7  C3F20E  	        JP      GOFUNC          ; Jump to string function
1998:			
1999:	0EEA  CD990E  	FNVAL:  CALL    EVLPAR          ; Evaluate expression
2000:	0EED  E3      	        EX      (SP),HL         ; HL = Adjusted token value
2001:	0EEE  11AD0E  	        LD      DE,RETNUM       ; Return number from function
2002:	0EF1  D5      	        PUSH    DE              ; Save on stack
2003:	0EF2  014E02  	GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
2004:	0EF5  09      	        ADD     HL,BC           ; Point to right address
2005:	0EF6  4E      	        LD      C,(HL)          ; Get LSB of address
2006:	0EF7  23      	        INC     HL              ;
2007:	0EF8  66      	        LD      H,(HL)          ; Get MSB of address
2008:	0EF9  69      	        LD      L,C             ; Address to HL
2009:	0EFA  E9      	        JP      (HL)            ; Jump to function
2010:			
2011:	0EFB  15      	SGNEXP: DEC     D               ; Dee to flag negative exponent
2012:	0EFC  FEAD    	        CP      ZMINUS          ; '-' token ?
2013:	0EFE  C8      	        RET     Z               ; Yes - Return
2014:	0EFF  FE2D    	        CP      '-'             ; '-' ASCII ?
2015:	0F01  C8      	        RET     Z               ; Yes - Return
2016:	0F02  14      	        INC     D               ; Inc to flag positive exponent
2017:	0F03  FE2B    	        CP      '+'             ; '+' ASCII ?
2018:	0F05  C8      	        RET     Z               ; Yes - Return
2019:	0F06  FEAC    	        CP      ZPLUS           ; '+' token ?
2020:	0F08  C8      	        RET     Z               ; Yes - Return
2021:	0F09  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
2022:	0F0A  C9      	        RET                     ; Return "NZ"
2023:			
2024:	0F0B  F6      	POR:    .DB     0F6H            ; Flag "OR"
2025:	0F0C  AF      	PAND:   XOR     A               ; Flag "AND"
2026:	0F0D  F5      	        PUSH    AF              ; Save "AND" / "OR" flag
2027:	0F0E  CDC50D  	        CALL    TSTNUM          ; Make sure it's a number
2028:	0F11  CD070A  	        CALL    DEINT           ; Get integer -32768 to 32767
2029:	0F14  F1      	        POP     AF              ; Restore "AND" / "OR" flag
2030:	0F15  EB      	        EX      DE,HL           ; <- Get last
2031:	0F16  C1      	        POP     BC              ; <-  value
2032:	0F17  E3      	        EX      (SP),HL         ; <-  from
2033:	0F18  EB      	        EX      DE,HL           ; <-  stack
2034:	0F19  CDE517  	        CALL    FPBCDE          ; Move last value to FPREG
2035:	0F1C  F5      	        PUSH    AF              ; Save "AND" / "OR" flag
2036:	0F1D  CD070A  	        CALL    DEINT           ; Get integer -32768 to 32767
2037:	0F20  F1      	        POP     AF              ; Restore "AND" / "OR" flag
2038:	0F21  C1      	        POP     BC              ; Get value
2039:	0F22  79      	        LD      A,C             ; Get LSB
2040:	0F23  217C11  	        LD      HL,ACPASS       ; Address of save AC as current
2041:	0F26  C22E0F  	        JP      NZ,POR1         ; Jump if OR
2042:	0F29  A3      	        AND     E               ; "AND" LSBs
2043:	0F2A  4F      	        LD      C,A             ; Save LSB
2044:	0F2B  78      	        LD      A,B             ; Get MBS
2045:	0F2C  A2      	        AND     D               ; "AND" MSBs
2046:	0F2D  E9      	        JP      (HL)            ; Save AC as current (ACPASS)
2047:			
2048:	0F2E  B3      	POR1:   OR      E               ; "OR" LSBs
2049:	0F2F  4F      	        LD      C,A             ; Save LSB
2050:	0F30  78      	        LD      A,B             ; Get MSB
2051:	0F31  B2      	        OR      D               ; "OR" MSBs
2052:	0F32  E9      	        JP      (HL)            ; Save AC as current (ACPASS)
2053:			
2054:	0F33  21450F  	TSTRED: LD      HL,CMPLOG       ; Logical compare routine
2055:	0F36  3AF220  	        LD      A,(TYPE)        ; Get data type
2056:	0F39  1F      	        RRA                     ; Carry set = string
2057:	0F3A  7A      	        LD      A,D             ; Get last precedence value
2058:	0F3B  17      	        RLA                     ; Times 2 plus carry
2059:	0F3C  5F      	        LD      E,A             ; To E
2060:	0F3D  1664    	        LD      D,64H           ; Relational precedence
2061:	0F3F  78      	        LD      A,B             ; Get current precedence
2062:	0F40  BA      	        CP      D               ; Compare with last
2063:	0F41  D0      	        RET     NC              ; Eval if last was rel' or log'
2064:	0F42  C3340E  	        JP      STKTHS          ; Stack this one and get next
2065:			
2066:	0F45  470F    	CMPLOG: .DW     CMPLG1          ; Compare two values / strings
2067:	0F47  79      	CMPLG1: LD      A,C             ; Get data type
2068:	0F48  B7      	        OR      A
2069:	0F49  1F      	        RRA
2070:	0F4A  C1      	        POP     BC              ; Get last expression to BCDE
2071:	0F4B  D1      	        POP     DE
2072:	0F4C  F5      	        PUSH    AF              ; Save status
2073:	0F4D  CDC70D  	        CALL    CHKTYP          ; Check that types match
2074:	0F50  21890F  	        LD      HL,CMPRES       ; Result to comparison
2075:	0F53  E5      	        PUSH    HL              ; Save for RETurn
2076:	0F54  CA1F18  	        JP      Z,CMPNUM        ; Compare values if numeric
2077:	0F57  AF      	        XOR     A               ; Compare two strings
2078:	0F58  32F220  	        LD      (TYPE),A        ; Set type to numeric
2079:	0F5B  D5      	        PUSH    DE              ; Save string name
2080:	0F5C  CDDE13  	        CALL    GSTRCU          ; Get current string
2081:	0F5F  7E      	        LD      A,(HL)          ; Get length of string
2082:	0F60  23      	        INC     HL
2083:	0F61  23      	        INC     HL
2084:	0F62  4E      	        LD      C,(HL)          ; Get LSB of address
2085:	0F63  23      	        INC     HL
2086:	0F64  46      	        LD      B,(HL)          ; Get MSB of address
2087:	0F65  D1      	        POP     DE              ; Restore string name
2088:	0F66  C5      	        PUSH    BC              ; Save address of string
2089:	0F67  F5      	        PUSH    AF              ; Save length of string
2090:	0F68  CDE213  	        CALL    GSTRDE          ; Get second string
2091:	0F6B  CDF317  	        CALL    LOADFP          ; Get address of second string
2092:	0F6E  F1      	        POP     AF              ; Restore length of string 1
2093:	0F6F  57      	        LD      D,A             ; Length to D
2094:	0F70  E1      	        POP     HL              ; Restore address of string 1
2095:	0F71  7B      	CMPSTR: LD      A,E             ; Bytes of string 2 to do
2096:	0F72  B2      	        OR      D               ; Bytes of string 1 to do
2097:	0F73  C8      	        RET     Z               ; Exit if all bytes compared
2098:	0F74  7A      	        LD      A,D             ; Get bytes of string 1 to do
2099:	0F75  D601    	        SUB     1
2100:	0F77  D8      	        RET     C               ; Exit if end of string 1
2101:	0F78  AF      	        XOR     A
2102:	0F79  BB      	        CP      E               ; Bytes of string 2 to do
2103:	0F7A  3C      	        INC     A
2104:	0F7B  D0      	        RET     NC              ; Exit if end of string 2
2105:	0F7C  15      	        DEC     D               ; Count bytes in string 1
2106:	0F7D  1D      	        DEC     E               ; Count bytes in string 2
2107:	0F7E  0A      	        LD      A,(BC)          ; Byte in string 2
2108:	0F7F  BE      	        CP      (HL)            ; Compare to byte in string 1
2109:	0F80  23      	        INC     HL              ; Move up string 1
2110:	0F81  03      	        INC     BC              ; Move up string 2
2111:	0F82  CA710F  	        JP      Z,CMPSTR        ; Same - Try next bytes
2112:	0F85  3F      	        CCF                     ; Flag difference (">" or "<")
2113:	0F86  C3AF17  	        JP      FLGDIF          ; "<" gives -1 , ">" gives +1
2114:			
2115:	0F89  3C      	CMPRES: INC     A               ; Increment current value
2116:	0F8A  8F      	        ADC     A,A             ; Double plus carry
2117:	0F8B  C1      	        POP     BC              ; Get other value
2118:	0F8C  A0      	        AND     B               ; Combine them
2119:	0F8D  C6FF    	        ADD     A,-1            ; Carry set if different
2120:	0F8F  9F      	        SBC     A,A             ; 00 - Equal , FF - Different
2121:	0F90  C3B617  	        JP      FLGREL          ; Set current value & continue
2122:			
2123:	0F93  165A    	EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
2124:	0F95  CDD70D  	        CALL    EVAL1           ; Eval until precedence break
2125:	0F98  CDC50D  	        CALL    TSTNUM          ; Make sure it's a number
2126:	0F9B  CD070A  	        CALL    DEINT           ; Get integer -32768 - 32767
2127:	0F9E  7B      	        LD      A,E             ; Get LSB
2128:	0F9F  2F      	        CPL                     ; Invert LSB
2129:	0FA0  4F      	        LD      C,A             ; Save "NOT" of LSB
2130:	0FA1  7A      	        LD      A,D             ; Get MSB
2131:	0FA2  2F      	        CPL                     ; Invert MSB
2132:	0FA3  CD7C11  	        CALL    ACPASS          ; Save AC as current
2133:	0FA6  C1      	        POP     BC              ; Clean up stack
2134:	0FA7  C3E30D  	        JP      EVAL3           ; Continue evaluation
2135:			
2136:	0FAA  2B      	DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
2137:	0FAB  CD5509  	        CALL    GETCHR          ; Get next character
2138:	0FAE  C8      	        RET     Z               ; End of DIM statement
2139:	0FAF  CDCB07  	        CALL    CHKSYN          ; Make sure ',' follows
2140:	0FB2  2C      	        .DB     ','
2141:	0FB3  01AA0F  	DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
2142:	0FB6  C5      	        PUSH    BC              ; Save on stack
2143:	0FB7  F6      	        .DB     0F6H            ; Flag "Create" variable
2144:	0FB8  AF      	GETVAR: XOR     A               ; Find variable address,to DE
2145:	0FB9  32F120  	        LD      (LCRFLG),A      ; Set locate / create flag
2146:	0FBC  46      	        LD      B,(HL)          ; Get First byte of name
2147:	0FBD  CDF309  	GTFNAM: CALL    CHKLTR          ; See if a letter
2148:	0FC0  DAFD04  	        JP      C,SNERR         ; ?SN Error if not a letter
2149:	0FC3  AF      	        XOR     A
2150:	0FC4  4F      	        LD      C,A             ; Clear second byte of name
2151:	0FC5  32F220  	        LD      (TYPE),A        ; Set type to numeric
2152:	0FC8  CD5509  	        CALL    GETCHR          ; Get next character
2153:	0FCB  DAD40F  	        JP      C,SVNAM2        ; Numeric - Save in name
2154:	0FCE  CDF309  	        CALL    CHKLTR          ; See if a letter
2155:	0FD1  DAE10F  	        JP      C,CHARTY        ; Not a letter - Check type
2156:	0FD4  4F      	SVNAM2: LD      C,A             ; Save second byte of name
2157:	0FD5  CD5509  	ENDNAM: CALL    GETCHR          ; Get next character
2158:	0FD8  DAD50F  	        JP      C,ENDNAM        ; Numeric - Get another
2159:	0FDB  CDF309  	        CALL    CHKLTR          ; See if a letter
2160:	0FDE  D2D50F  	        JP      NC,ENDNAM       ; Letter - Get another
2161:	0FE1  D624    	CHARTY: SUB     '$'             ; String variable?
2162:	0FE3  C2F00F  	        JP      NZ,NOTSTR       ; No - Numeric variable
2163:	0FE6  3C      	        INC     A               ; A = 1 (string type)
2164:	0FE7  32F220  	        LD      (TYPE),A        ; Set type to string
2165:	0FEA  0F      	        RRCA                    ; A = 80H , Flag for string
2166:	0FEB  81      	        ADD     A,C             ; 2nd byte of name has bit 7 on
2167:	0FEC  4F      	        LD      C,A             ; Resave second byte on name
2168:	0FED  CD5509  	        CALL    GETCHR          ; Get next character
2169:	0FF0  3A1021  	NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
2170:	0FF3  3D      	        DEC     A
2171:	0FF4  CA9D10  	        JP      Z,ARLDSV        ; Yes - Get array name
2172:	0FF7  F20010  	        JP      P,NSCFOR        ; No array with "FOR" or "FN"
2173:	0FFA  7E      	        LD      A,(HL)          ; Get byte again
2174:	0FFB  D628    	        SUB     '('             ; Subscripted variable?
2175:	0FFD  CA7510  	        JP      Z,SBSCPT        ; Yes - Sort out subscript
2176:			
2177:	1000  AF      	NSCFOR: XOR     A               ; Simple variable
2178:	1001  321021  	        LD      (FORFLG),A      ; Clear "FOR" flag
2179:	1004  E5      	        PUSH    HL              ; Save code string address
2180:	1005  50      	        LD      D,B             ; DE = Variable name to find
2181:	1006  59      	        LD      E,C
2182:	1007  2A2321  	        LD      HL,(FNRGNM)     ; FN argument name
2183:	100A  CDC507  	        CALL    CPDEHL          ; Is it the FN argument?
2184:	100D  112521  	        LD      DE,FNARG        ; Point to argument value
2185:	1010  CAE516  	        JP      Z,POPHRT        ; Yes - Return FN argument value
2186:	1013  2A1D21  	        LD      HL,(VAREND)     ; End of variables
2187:	1016  EB      	        EX      DE,HL           ; Address of end of search
2188:	1017  2A1B21  	        LD      HL,(PROGND)     ; Start of variables address
2189:	101A  CDC507  	FNDVAR: CALL    CPDEHL          ; End of variable list table?
2190:	101D  CA3310  	        JP      Z,CFEVAL        ; Yes - Called from EVAL?
2191:	1020  79      	        LD      A,C             ; Get second byte of name
2192:	1021  96      	        SUB     (HL)            ; Compare with name in list
2193:	1022  23      	        INC     HL              ; Move on to first byte
2194:	1023  C22810  	        JP      NZ,FNTHR        ; Different - Find another
2195:	1026  78      	        LD      A,B             ; Get first byte of name
2196:	1027  96      	        SUB     (HL)            ; Compare with name in list
2197:	1028  23      	FNTHR:  INC     HL              ; Move on to LSB of value
2198:	1029  CA6710  	        JP      Z,RETADR        ; Found - Return address
2199:	102C  23      	        INC     HL              ; <- Skip
2200:	102D  23      	        INC     HL              ; <- over
2201:	102E  23      	        INC     HL              ; <- F.P.
2202:	102F  23      	        INC     HL              ; <- value
2203:	1030  C31A10  	        JP      FNDVAR          ; Keep looking
2204:			
2205:	1033  E1      	CFEVAL: POP     HL              ; Restore code string address
2206:	1034  E3      	        EX      (SP),HL         ; Get return address
2207:	1035  D5      	        PUSH    DE              ; Save address of variable
2208:	1036  11B50E  	        LD      DE,FRMEVL       ; Return address in EVAL
2209:	1039  CDC507  	        CALL    CPDEHL          ; Called from EVAL ?
2210:	103C  D1      	        POP     DE              ; Restore address of variable
2211:	103D  CA6A10  	        JP      Z,RETNUL        ; Yes - Return null variable
2212:	1040  E3      	        EX      (SP),HL         ; Put back return
2213:	1041  E5      	        PUSH    HL              ; Save code string address
2214:	1042  C5      	        PUSH    BC              ; Save variable name
2215:	1043  010600  	        LD      BC,6            ; 2 byte name plus 4 byte data
2216:	1046  2A1F21  	        LD      HL,(ARREND)     ; End of arrays
2217:	1049  E5      	        PUSH    HL              ; Save end of arrays
2218:	104A  09      	        ADD     HL,BC           ; Move up 6 bytes
2219:	104B  C1      	        POP     BC              ; Source address in BC
2220:	104C  E5      	        PUSH    HL              ; Save new end address
2221:	104D  CDC904  	        CALL    MOVUP           ; Move arrays up
2222:	1050  E1      	        POP     HL              ; Restore new end address
2223:	1051  221F21  	        LD      (ARREND),HL     ; Set new end address
2224:	1054  60      	        LD      H,B             ; End of variables to HL
2225:	1055  69      	        LD      L,C
2226:	1056  221D21  	        LD      (VAREND),HL     ; Set new end address
2227:			
2228:	1059  2B      	ZEROLP: DEC     HL              ; Back through to zero variable
2229:	105A  3600    	        LD      (HL),0          ; Zero byte in variable
2230:	105C  CDC507  	        CALL    CPDEHL          ; Done them all?
2231:	105F  C25910  	        JP      NZ,ZEROLP       ; No - Keep on going
2232:	1062  D1      	        POP     DE              ; Get variable name
2233:	1063  73      	        LD      (HL),E          ; Store second character
2234:	1064  23      	        INC     HL
2235:	1065  72      	        LD      (HL),D          ; Store first character
2236:	1066  23      	        INC     HL
2237:	1067  EB      	RETADR: EX      DE,HL           ; Address of variable in DE
2238:	1068  E1      	        POP     HL              ; Restore code string address
2239:	1069  C9      	        RET
2240:			
2241:	106A  322C21  	RETNUL: LD      (FPEXP),A       ; Set result to zero
2242:	106D  219904  	        LD      HL,ZERBYT       ; Also set a null string
2243:	1070  222921  	        LD      (FPREG),HL      ; Save for EVAL
2244:	1073  E1      	        POP     HL              ; Restore code string address
2245:	1074  C9      	        RET
2246:			
2247:	1075  E5      	SBSCPT: PUSH    HL              ; Save code string address
2248:	1076  2AF120  	        LD      HL,(LCRFLG)     ; Locate/Create and Type
2249:	1079  E3      	        EX      (SP),HL         ; Save and get code string
2250:	107A  57      	        LD      D,A             ; Zero number of dimensions
2251:	107B  D5      	SCPTLP: PUSH    DE              ; Save number of dimensions
2252:	107C  C5      	        PUSH    BC              ; Save array name
2253:	107D  CDFB09  	        CALL    FPSINT          ; Get subscript (0-32767)
2254:	1080  C1      	        POP     BC              ; Restore array name
2255:	1081  F1      	        POP     AF              ; Get number of dimensions
2256:	1082  EB      	        EX      DE,HL
2257:	1083  E3      	        EX      (SP),HL         ; Save subscript value
2258:	1084  E5      	        PUSH    HL              ; Save LCRFLG and TYPE
2259:	1085  EB      	        EX      DE,HL
2260:	1086  3C      	        INC     A               ; Count dimensions
2261:	1087  57      	        LD      D,A             ; Save in D
2262:	1088  7E      	        LD      A,(HL)          ; Get next byte in code string
2263:	1089  FE2C    	        CP      ','             ; Comma (more to come)?
2264:	108B  CA7B10  	        JP      Z,SCPTLP        ; Yes - More subscripts
2265:	108E  CDCB07  	        CALL    CHKSYN          ; Make sure ")" follows
2266:	1091  29      	        .DB     ")"
2267:	1092  221521  	        LD      (NXTOPR),HL     ; Save code string address
2268:	1095  E1      	        POP     HL              ; Get LCRFLG and TYPE
2269:	1096  22F120  	        LD      (LCRFLG),HL     ; Restore Locate/create & type
2270:	1099  1E00    	        LD      E,0             ; Flag not CSAVE* or CLOAD*
2271:	109B  D5      	        PUSH    DE              ; Save number of dimensions (D)
2272:	109C  11      	        .DB     11H             ; Skip "PUSH HL" and "PUSH AF'
2273:			
2274:	109D  E5      	ARLDSV: PUSH    HL              ; Save code string address
2275:	109E  F5      	        PUSH    AF              ; A = 00 , Flags set = Z,N
2276:	109F  2A1D21  	        LD      HL,(VAREND)     ; Start of arrays
2277:	10A2  3E      	        .DB     3EH             ; Skip "ADD HL,DE"
2278:	10A3  19      	FNDARY: ADD     HL,DE           ; Move to next array start
2279:	10A4  EB      	        EX      DE,HL
2280:	10A5  2A1F21  	        LD      HL,(ARREND)     ; End of arrays
2281:	10A8  EB      	        EX      DE,HL           ; Current array pointer
2282:	10A9  CDC507  	        CALL    CPDEHL          ; End of arrays found?
2283:	10AC  CAD510  	        JP      Z,CREARY        ; Yes - Create array
2284:	10AF  7E      	        LD      A,(HL)          ; Get second byte of name
2285:	10B0  B9      	        CP      C               ; Compare with name given
2286:	10B1  23      	        INC     HL              ; Move on
2287:	10B2  C2B710  	        JP      NZ,NXTARY       ; Different - Find next array
2288:	10B5  7E      	        LD      A,(HL)          ; Get first byte of name
2289:	10B6  B8      	        CP      B               ; Compare with name given
2290:	10B7  23      	NXTARY: INC     HL              ; Move on
2291:	10B8  5E      	        LD      E,(HL)          ; Get LSB of next array address
2292:	10B9  23      	        INC     HL
2293:	10BA  56      	        LD      D,(HL)          ; Get MSB of next array address
2294:	10BB  23      	        INC     HL
2295:	10BC  C2A310  	        JP      NZ,FNDARY       ; Not found - Keep looking
2296:	10BF  3AF120  	        LD      A,(LCRFLG)      ; Found Locate or Create it?
2297:	10C2  B7      	        OR      A
2298:	10C3  C20605  	        JP      NZ,DDERR        ; Create - ?DD Error
2299:	10C6  F1      	        POP     AF              ; Locate - Get number of dim'ns
2300:	10C7  44      	        LD      B,H             ; BC Points to array dim'ns
2301:	10C8  4D      	        LD      C,L
2302:	10C9  CAE516  	        JP      Z,POPHRT        ; Jump if array load/save
2303:	10CC  96      	        SUB     (HL)            ; Same number of dimensions?
2304:	10CD  CA3311  	        JP      Z,FINDEL        ; Yes - Find element
2305:	10D0  1E10    	BSERR:  LD      E,BS            ; ?BS Error
2306:	10D2  C31105  	        JP      ERROR           ; Output error
2307:			
2308:	10D5  110400  	CREARY: LD      DE,4            ; 4 Bytes per entry
2309:	10D8  F1      	        POP     AF              ; Array to save or 0 dim'ns?
2310:	10D9  CA1C0A  	        JP      Z,FCERR         ; Yes - ?FC Error
2311:	10DC  71      	        LD      (HL),C          ; Save second byte of name
2312:	10DD  23      	        INC     HL
2313:	10DE  70      	        LD      (HL),B          ; Save first byte of name
2314:	10DF  23      	        INC     HL
2315:	10E0  4F      	        LD      C,A             ; Number of dimensions to C
2316:	10E1  CDDA04  	        CALL    CHKSTK          ; Check if enough memory
2317:	10E4  23      	        INC     HL              ; Point to number of dimensions
2318:	10E5  23      	        INC     HL
2319:	10E6  220A21  	        LD      (CUROPR),HL     ; Save address of pointer
2320:	10E9  71      	        LD      (HL),C          ; Set number of dimensions
2321:	10EA  23      	        INC     HL
2322:	10EB  3AF120  	        LD      A,(LCRFLG)      ; Locate of Create?
2323:	10EE  17      	        RLA                     ; Carry set = Create
2324:	10EF  79      	        LD      A,C             ; Get number of dimensions
2325:	10F0  010B00  	CRARLP: LD      BC,10+1         ; Default dimension size 10
2326:	10F3  D2F810  	        JP      NC,DEFSIZ       ; Locate - Set default size
2327:	10F6  C1      	        POP     BC              ; Get specified dimension size
2328:	10F7  03      	        INC     BC              ; Include zero element
2329:	10F8  71      	DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
2330:	10F9  23      	        INC     HL
2331:	10FA  70      	        LD      (HL),B          ; Save MSB of dimension size
2332:	10FB  23      	        INC     HL
2333:	10FC  F5      	        PUSH    AF              ; Save num' of dim'ns an status
2334:	10FD  E5      	        PUSH    HL              ; Save address of dim'n size
2335:	10FE  CD9018  	        CALL    MLDEBC          ; Multiply DE by BC to find
2336:	1101  EB      	        EX      DE,HL           ; amount of mem needed (to DE)
2337:	1102  E1      	        POP     HL              ; Restore address of dimension
2338:	1103  F1      	        POP     AF              ; Restore number of dimensions
2339:	1104  3D      	        DEC     A               ; Count them
2340:	1105  C2F010  	        JP      NZ,CRARLP       ; Do next dimension if more
2341:	1108  F5      	        PUSH    AF              ; Save locate/create flag
2342:	1109  42      	        LD      B,D             ; MSB of memory needed
2343:	110A  4B      	        LD      C,E             ; LSB of memory needed
2344:	110B  EB      	        EX      DE,HL
2345:	110C  19      	        ADD     HL,DE           ; Add bytes to array start
2346:	110D  DAF204  	        JP      C,OMERR         ; Too big - Error
2347:	1110  CDE304  	        CALL    ENFMEM          ; See if enough memory
2348:	1113  221F21  	        LD      (ARREND),HL     ; Save new end of array
2349:			
2350:	1116  2B      	ZERARY: DEC     HL              ; Back through array data
2351:	1117  3600    	        LD      (HL),0          ; Set array element to zero
2352:	1119  CDC507  	        CALL    CPDEHL          ; All elements zeroed?
2353:	111C  C21611  	        JP      NZ,ZERARY       ; No - Keep on going
2354:	111F  03      	        INC     BC              ; Number of bytes + 1
2355:	1120  57      	        LD      D,A             ; A=0
2356:	1121  2A0A21  	        LD      HL,(CUROPR)     ; Get address of array
2357:	1124  5E      	        LD      E,(HL)          ; Number of dimensions
2358:	1125  EB      	        EX      DE,HL           ; To HL
2359:	1126  29      	        ADD     HL,HL           ; Two bytes per dimension size
2360:	1127  09      	        ADD     HL,BC           ; Add number of bytes
2361:	1128  EB      	        EX      DE,HL           ; Bytes needed to DE
2362:	1129  2B      	        DEC     HL
2363:	112A  2B      	        DEC     HL
2364:	112B  73      	        LD      (HL),E          ; Save LSB of bytes needed
2365:	112C  23      	        INC     HL
2366:	112D  72      	        LD      (HL),D          ; Save MSB of bytes needed
2367:	112E  23      	        INC     HL
2368:	112F  F1      	        POP     AF              ; Locate / Create?
2369:	1130  DA5711  	        JP      C,ENDDIM        ; A is 0 , End if create
2370:	1133  47      	FINDEL: LD      B,A             ; Find array element
2371:	1134  4F      	        LD      C,A
2372:	1135  7E      	        LD      A,(HL)          ; Number of dimensions
2373:	1136  23      	        INC     HL
2374:	1137  16      	        .DB     16H             ; Skip "POP HL"
2375:	1138  E1      	FNDELP: POP     HL              ; Address of next dim' size
2376:	1139  5E      	        LD      E,(HL)          ; Get LSB of dim'n size
2377:	113A  23      	        INC     HL
2378:	113B  56      	        LD      D,(HL)          ; Get MSB of dim'n size
2379:	113C  23      	        INC     HL
2380:	113D  E3      	        EX      (SP),HL         ; Save address - Get index
2381:	113E  F5      	        PUSH    AF              ; Save number of dim'ns
2382:	113F  CDC507  	        CALL    CPDEHL          ; Dimension too large?
2383:	1142  D2D010  	        JP      NC,BSERR        ; Yes - ?BS Error
2384:	1145  E5      	        PUSH    HL              ; Save index
2385:	1146  CD9018  	        CALL    MLDEBC          ; Multiply previous by size
2386:	1149  D1      	        POP     DE              ; Index supplied to DE
2387:	114A  19      	        ADD     HL,DE           ; Add index to pointer
2388:	114B  F1      	        POP     AF              ; Number of dimensions
2389:	114C  3D      	        DEC     A               ; Count them
2390:	114D  44      	        LD      B,H             ; MSB of pointer
2391:	114E  4D      	        LD      C,L             ; LSB of pointer
2392:	114F  C23811  	        JP      NZ,FNDELP       ; More - Keep going
2393:	1152  29      	        ADD     HL,HL           ; 4 Bytes per element
2394:	1153  29      	        ADD     HL,HL
2395:	1154  C1      	        POP     BC              ; Start of array
2396:	1155  09      	        ADD     HL,BC           ; Point to element
2397:	1156  EB      	        EX      DE,HL           ; Address of element to DE
2398:	1157  2A1521  	ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
2399:	115A  C9      	        RET
2400:			
2401:	115B  2A1F21  	FRE:    LD      HL,(ARREND)     ; Start of free memory
2402:	115E  EB      	        EX      DE,HL           ; To DE
2403:	115F  210000  	        LD      HL,0            ; End of free memory
2404:	1162  39      	        ADD     HL,SP           ; Current stack value
2405:	1163  3AF220  	        LD      A,(TYPE)        ; Dummy argument type
2406:	1166  B7      	        OR      A
2407:	1167  CA7711  	        JP      Z,FRENUM        ; Numeric - Free variable space
2408:	116A  CDDE13  	        CALL    GSTRCU          ; Current string to pool
2409:	116D  CDDE12  	        CALL    GARBGE          ; Garbage collection
2410:	1170  2A9F20  	        LD      HL,(STRSPC)     ; Bottom of string space in use
2411:	1173  EB      	        EX      DE,HL           ; To DE
2412:	1174  2A0821  	        LD      HL,(STRBOT)     ; Bottom of string space
2413:	1177  7D      	FRENUM: LD      A,L             ; Get LSB of end
2414:	1178  93      	        SUB     E               ; Subtract LSB of beginning
2415:	1179  4F      	        LD      C,A             ; Save difference if C
2416:	117A  7C      	        LD      A,H             ; Get MSB of end
2417:	117B  9A      	        SBC     A,D             ; Subtract MSB of beginning
2418:	117C  41      	ACPASS: LD      B,C             ; Return integer AC
2419:	117D  50      	ABPASS: LD      D,B             ; Return integer AB
2420:	117E  1E00    	        LD      E,0
2421:	1180  21F220  	        LD      HL,TYPE         ; Point to type
2422:	1183  73      	        LD      (HL),E          ; Set type to numeric
2423:	1184  0690    	        LD      B,80H+16        ; 16 bit integer
2424:	1186  C3BB17  	        JP      RETINT          ; Return the integr
2425:			
2426:	1189  3AF020  	POS:    LD      A,(CURPOS)      ; Get cursor position
2427:	118C  47      	PASSA:  LD      B,A             ; Put A into AB
2428:	118D  AF      	        XOR     A               ; Zero A
2429:	118E  C37D11  	        JP      ABPASS          ; Return integer AB
2430:			
2431:	1191  CD1412  	DEF:    CALL    CHEKFN          ; Get "FN" and name
2432:	1194  CD0612  	        CALL    IDTEST          ; Test for illegal direct
2433:	1197  01EC0A  	        LD      BC,DATA         ; To get next statement
2434:	119A  C5      	        PUSH    BC              ; Save address for RETurn
2435:	119B  D5      	        PUSH    DE              ; Save address of function ptr
2436:	119C  CDCB07  	        CALL    CHKSYN          ; Make sure "(" follows
2437:	119F  28      	        .DB     "("
2438:	11A0  CDB80F  	        CALL    GETVAR          ; Get argument variable name
2439:	11A3  E5      	        PUSH    HL              ; Save code string address
2440:	11A4  EB      	        EX      DE,HL           ; Argument address to HL
2441:	11A5  2B      	        DEC     HL
2442:	11A6  56      	        LD      D,(HL)          ; Get first byte of arg name
2443:	11A7  2B      	        DEC     HL
2444:	11A8  5E      	        LD      E,(HL)          ; Get second byte of arg name
2445:	11A9  E1      	        POP     HL              ; Restore code string address
2446:	11AA  CDC50D  	        CALL    TSTNUM          ; Make sure numeric argument
2447:	11AD  CDCB07  	        CALL    CHKSYN          ; Make sure ")" follows
2448:	11B0  29      	        .DB     ")"
2449:	11B1  CDCB07  	        CALL    CHKSYN          ; Make sure "=" follows
2450:	11B4  B4      	        .DB     ZEQUAL          ; "=" token
2451:	11B5  44      	        LD      B,H             ; Code string address to BC
2452:	11B6  4D      	        LD      C,L
2453:	11B7  E3      	        EX      (SP),HL         ; Save code str , Get FN ptr
2454:	11B8  71      	        LD      (HL),C          ; Save LSB of FN code string
2455:	11B9  23      	        INC     HL
2456:	11BA  70      	        LD      (HL),B          ; Save MSB of FN code string
2457:	11BB  C35312  	        JP      SVSTAD          ; Save address and do function
2458:			
2459:	11BE  CD1412  	DOFN:   CALL    CHEKFN          ; Make sure FN follows
2460:	11C1  D5      	        PUSH    DE              ; Save function pointer address
2461:	11C2  CD990E  	        CALL    EVLPAR          ; Evaluate expression in "()"
2462:	11C5  CDC50D  	        CALL    TSTNUM          ; Make sure numeric result
2463:	11C8  E3      	        EX      (SP),HL         ; Save code str , Get FN ptr
2464:	11C9  5E      	        LD      E,(HL)          ; Get LSB of FN code string
2465:	11CA  23      	        INC     HL
2466:	11CB  56      	        LD      D,(HL)          ; Get MSB of FN code string
2467:	11CC  23      	        INC     HL
2468:	11CD  7A      	        LD      A,D             ; And function DEFined?
2469:	11CE  B3      	        OR      E
2470:	11CF  CA0905  	        JP      Z,UFERR         ; No - ?UF Error
2471:	11D2  7E      	        LD      A,(HL)          ; Get LSB of argument address
2472:	11D3  23      	        INC     HL
2473:	11D4  66      	        LD      H,(HL)          ; Get MSB of argument address
2474:	11D5  6F      	        LD      L,A             ; HL = Arg variable address
2475:	11D6  E5      	        PUSH    HL              ; Save it
2476:	11D7  2A2321  	        LD      HL,(FNRGNM)     ; Get old argument name
2477:	11DA  E3      	        EX      (SP),HL ;       ; Save old , Get new
2478:	11DB  222321  	        LD      (FNRGNM),HL     ; Set new argument name
2479:	11DE  2A2721  	        LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2480:	11E1  E5      	        PUSH    HL              ; Save it
2481:	11E2  2A2521  	        LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
2482:	11E5  E5      	        PUSH    HL              ; Save it
2483:	11E6  212521  	        LD      HL,FNARG        ; HL = Value of argument
2484:	11E9  D5      	        PUSH    DE              ; Save FN code string address
2485:	11EA  CDFC17  	        CALL    FPTHL           ; Move FPREG to argument
2486:	11ED  E1      	        POP     HL              ; Get FN code string address
2487:	11EE  CDC20D  	        CALL    GETNUM          ; Get value from function
2488:	11F1  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
2489:	11F2  CD5509  	        CALL    GETCHR          ; Get next character
2490:	11F5  C2FD04  	        JP      NZ,SNERR        ; Bad character in FN - Error
2491:	11F8  E1      	        POP     HL              ; Get MSB,EXP of old arg
2492:	11F9  222521  	        LD      (FNARG),HL      ; Restore it
2493:	11FC  E1      	        POP     HL              ; Get LSB,NLSB of old arg
2494:	11FD  222721  	        LD      (FNARG+2),HL    ; Restore it
2495:	1200  E1      	        POP     HL              ; Get name of old arg
2496:	1201  222321  	        LD      (FNRGNM),HL     ; Restore it
2497:	1204  E1      	        POP     HL              ; Restore code string address
2498:	1205  C9      	        RET
2499:			
2500:	1206  E5      	IDTEST: PUSH    HL              ; Save code string address
2501:	1207  2AA120  	        LD      HL,(LINEAT)     ; Get current line number
2502:	120A  23      	        INC     HL              ; -1 means direct statement
2503:	120B  7C      	        LD      A,H
2504:	120C  B5      	        OR      L
2505:	120D  E1      	        POP     HL              ; Restore code string address
2506:	120E  C0      	        RET     NZ              ; Return if in program
2507:	120F  1E16    	        LD      E,ID            ; ?ID Error
2508:	1211  C31105  	        JP      ERROR
2509:			
2510:	1214  CDCB07  	CHEKFN: CALL    CHKSYN          ; Make sure FN follows
2511:	1217  A7      	        .DB     ZFN             ; "FN" token
2512:	1218  3E80    	        LD      A,80H
2513:	121A  321021  	        LD      (FORFLG),A      ; Flag FN name to find
2514:	121D  B6      	        OR      (HL)            ; FN name has bit 7 set
2515:	121E  47      	        LD      B,A             ; in first byte of name
2516:	121F  CDBD0F  	        CALL    GTFNAM          ; Get FN name
2517:	1222  C3C50D  	        JP      TSTNUM          ; Make sure numeric function
2518:			
2519:	1225  CDC50D  	STR:    CALL    TSTNUM          ; Make sure it's a number
2520:	1228  CD4919  	        CALL    NUMASC          ; Turn number into text
2521:	122B  CD5912  	STR1:   CALL    CRTST           ; Create string entry for it
2522:	122E  CDDE13  	        CALL    GSTRCU          ; Current string to pool
2523:	1231  013914  	        LD      BC,TOPOOL       ; Save in string pool
2524:	1234  C5      	        PUSH    BC              ; Save address on stack
2525:			
2526:	1235  7E      	SAVSTR: LD      A,(HL)          ; Get string length
2527:	1236  23      	        INC     HL
2528:	1237  23      	        INC     HL
2529:	1238  E5      	        PUSH    HL              ; Save pointer to string
2530:	1239  CDB412  	        CALL    TESTR           ; See if enough string space
2531:	123C  E1      	        POP     HL              ; Restore pointer to string
2532:	123D  4E      	        LD      C,(HL)          ; Get LSB of address
2533:	123E  23      	        INC     HL
2534:	123F  46      	        LD      B,(HL)          ; Get MSB of address
2535:	1240  CD4D12  	        CALL    CRTMST          ; Create string entry
2536:	1243  E5      	        PUSH    HL              ; Save pointer to MSB of addr
2537:	1244  6F      	        LD      L,A             ; Length of string
2538:	1245  CDD113  	        CALL    TOSTRA          ; Move to string area
2539:	1248  D1      	        POP     DE              ; Restore pointer to MSB
2540:	1249  C9      	        RET
2541:			
2542:	124A  CDB412  	MKTMST: CALL    TESTR           ; See if enough string space
2543:	124D  210421  	CRTMST: LD      HL,TMPSTR       ; Temporary string
2544:	1250  E5      	        PUSH    HL              ; Save it
2545:	1251  77      	        LD      (HL),A          ; Save length of string
2546:	1252  23      	        INC     HL
2547:	1253  23      	SVSTAD: INC     HL
2548:	1254  73      	        LD      (HL),E          ; Save LSB of address
2549:	1255  23      	        INC     HL
2550:	1256  72      	        LD      (HL),D          ; Save MSB of address
2551:	1257  E1      	        POP     HL              ; Restore pointer
2552:	1258  C9      	        RET
2553:			
2554:	1259  2B      	CRTST:  DEC     HL              ; DEC - INCed after
2555:	125A  0622    	QTSTR:  LD      B,'"'           ; Terminating quote
2556:	125C  50      	        LD      D,B             ; Quote to D
2557:	125D  E5      	DTSTR:  PUSH    HL              ; Save start
2558:	125E  0EFF    	        LD      C,-1            ; Set counter to -1
2559:	1260  23      	QTSTLP: INC     HL              ; Move on
2560:	1261  7E      	        LD      A,(HL)          ; Get byte
2561:	1262  0C      	        INC     C               ; Count bytes
2562:	1263  B7      	        OR      A               ; End of line?
2563:	1264  CA6F12  	        JP      Z,CRTSTE        ; Yes - Create string entry
2564:	1267  BA      	        CP      D               ; Terminator D found?
2565:	1268  CA6F12  	        JP      Z,CRTSTE        ; Yes - Create string entry
2566:	126B  B8      	        CP      B               ; Terminator B found?
2567:	126C  C26012  	        JP      NZ,QTSTLP       ; No - Keep looking
2568:	126F  FE22    	CRTSTE: CP      '"'             ; End with '"'?
2569:	1271  CC5509  	        CALL    Z,GETCHR        ; Yes - Get next character
2570:	1274  E3      	        EX      (SP),HL         ; Starting quote
2571:	1275  23      	        INC     HL              ; First byte of string
2572:	1276  EB      	        EX      DE,HL           ; To DE
2573:	1277  79      	        LD      A,C             ; Get length
2574:	1278  CD4D12  	        CALL    CRTMST          ; Create string entry
2575:	127B  110421  	TSTOPL: LD      DE,TMPSTR       ; Temporary string
2576:	127E  2AF620  	        LD      HL,(TMSTPT)     ; Temporary string pool pointer
2577:	1281  222921  	        LD      (FPREG),HL      ; Save address of string ptr
2578:	1284  3E01    	        LD      A,1
2579:	1286  32F220  	        LD      (TYPE),A        ; Set type to string
2580:	1289  CDFF17  	        CALL    DETHL4          ; Move string to pool
2581:	128C  CDC507  	        CALL    CPDEHL          ; Out of string pool?
2582:	128F  22F620  	        LD      (TMSTPT),HL     ; Save new pointer
2583:	1292  E1      	        POP     HL              ; Restore code string address
2584:	1293  7E      	        LD      A,(HL)          ; Get next code byte
2585:	1294  C0      	        RET     NZ              ; Return if pool OK
2586:	1295  1E1E    	        LD      E,ST            ; ?ST Error
2587:	1297  C31105  	        JP      ERROR           ; String pool overflow
2588:			
2589:	129A  23      	PRNUMS: INC     HL              ; Skip leading space
2590:	129B  CD5912  	PRS:    CALL    CRTST           ; Create string entry for it
2591:	129E  CDDE13  	PRS1:   CALL    GSTRCU          ; Current string to pool
2592:	12A1  CDF317  	        CALL    LOADFP          ; Move string block to BCDE
2593:	12A4  1C      	        INC     E               ; Length + 1
2594:	12A5  1D      	PRSLP:  DEC     E               ; Count characters
2595:	12A6  C8      	        RET     Z               ; End of string
2596:	12A7  0A      	        LD      A,(BC)          ; Get byte to output
2597:	12A8  CDD607  	        CALL    OUTC            ; Output character in A
2598:	12AB  FE0D    	        CP      CR              ; Return?
2599:	12AD  CC070C  	        CALL    Z,DONULL        ; Yes - Do nulls
2600:	12B0  03      	        INC     BC              ; Next byte in string
2601:	12B1  C3A512  	        JP      PRSLP           ; More characters to output
2602:			
2603:	12B4  B7      	TESTR:  OR      A               ; Test if enough room
2604:	12B5  0E      	        .DB     0EH             ; No garbage collection done
2605:	12B6  F1      	GRBDON: POP     AF              ; Garbage collection done
2606:	12B7  F5      	        PUSH    AF              ; Save status
2607:	12B8  2A9F20  	        LD      HL,(STRSPC)     ; Bottom of string space in use
2608:	12BB  EB      	        EX      DE,HL           ; To DE
2609:	12BC  2A0821  	        LD      HL,(STRBOT)     ; Bottom of string area
2610:	12BF  2F      	        CPL                     ; Negate length (Top down)
2611:	12C0  4F      	        LD      C,A             ; -Length to BC
2612:	12C1  06FF    	        LD      B,-1            ; BC = -ve length of string
2613:	12C3  09      	        ADD     HL,BC           ; Add to bottom of space in use
2614:	12C4  23      	        INC     HL              ; Plus one for 2's complement
2615:	12C5  CDC507  	        CALL    CPDEHL          ; Below string RAM area?
2616:	12C8  DAD212  	        JP      C,TESTOS        ; Tidy up if not done else err
2617:	12CB  220821  	        LD      (STRBOT),HL     ; Save new bottom of area
2618:	12CE  23      	        INC     HL              ; Point to first byte of string
2619:	12CF  EB      	        EX      DE,HL           ; Address to DE
2620:	12D0  F1      	POPAF:  POP     AF              ; Throw away status push
2621:	12D1  C9      	        RET
2622:			
2623:	12D2  F1      	TESTOS: POP     AF              ; Garbage collect been done?
2624:	12D3  1E1A    	        LD      E,OS            ; ?OS Error
2625:	12D5  CA1105  	        JP      Z,ERROR         ; Yes - Not enough string apace
2626:	12D8  BF      	        CP      A               ; Flag garbage collect done
2627:	12D9  F5      	        PUSH    AF              ; Save status
2628:	12DA  01B612  	        LD      BC,GRBDON       ; Garbage collection done
2629:	12DD  C5      	        PUSH    BC              ; Save for RETurn
2630:	12DE  2AF420  	GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
2631:	12E1  220821  	GARBLP: LD      (STRBOT),HL     ; Reset string pointer
2632:	12E4  210000  	        LD      HL,0
2633:	12E7  E5      	        PUSH    HL              ; Flag no string found
2634:	12E8  2A9F20  	        LD      HL,(STRSPC)     ; Get bottom of string space
2635:	12EB  E5      	        PUSH    HL              ; Save bottom of string space
2636:	12EC  21F820  	        LD      HL,TMSTPL       ; Temporary string pool
2637:	12EF  EB      	GRBLP:  EX      DE,HL
2638:	12F0  2AF620  	        LD      HL,(TMSTPT)     ; Temporary string pool pointer
2639:	12F3  EB      	        EX      DE,HL
2640:	12F4  CDC507  	        CALL    CPDEHL          ; Temporary string pool done?
2641:	12F7  01EF12  	        LD      BC,GRBLP        ; Loop until string pool done
2642:	12FA  C24313  	        JP      NZ,STPOOL       ; No - See if in string area
2643:	12FD  2A1B21  	        LD      HL,(PROGND)     ; Start of simple variables
2644:	1300  EB      	SMPVAR: EX      DE,HL
2645:	1301  2A1D21  	        LD      HL,(VAREND)     ; End of simple variables
2646:	1304  EB      	        EX      DE,HL
2647:	1305  CDC507  	        CALL    CPDEHL          ; All simple strings done?
2648:	1308  CA1613  	        JP      Z,ARRLP         ; Yes - Do string arrays
2649:	130B  7E      	        LD      A,(HL)          ; Get type of variable
2650:	130C  23      	        INC     HL
2651:	130D  23      	        INC     HL
2652:	130E  B7      	        OR      A               ; "S" flag set if string
2653:	130F  CD4613  	        CALL    STRADD          ; See if string in string area
2654:	1312  C30013  	        JP      SMPVAR          ; Loop until simple ones done
2655:			
2656:	1315  C1      	GNXARY: POP     BC              ; Scrap address of this array
2657:	1316  EB      	ARRLP:  EX      DE,HL
2658:	1317  2A1F21  	        LD      HL,(ARREND)     ; End of string arrays
2659:	131A  EB      	        EX      DE,HL
2660:	131B  CDC507  	        CALL    CPDEHL          ; All string arrays done?
2661:	131E  CA6C13  	        JP      Z,SCNEND        ; Yes - Move string if found
2662:	1321  CDF317  	        CALL    LOADFP          ; Get array name to BCDE
2663:	1324  7B      	        LD      A,E             ; Get type of array     
2664:	1325  E5      	        PUSH    HL              ; Save address of num of dim'ns
2665:	1326  09      	        ADD     HL,BC           ; Start of next array
2666:	1327  B7      	        OR      A               ; Test type of array
2667:	1328  F21513  	        JP      P,GNXARY        ; Numeric array - Ignore it
2668:	132B  220A21  	        LD      (CUROPR),HL     ; Save address of next array
2669:	132E  E1      	        POP     HL              ; Get address of num of dim'ns
2670:	132F  4E      	        LD      C,(HL)          ; BC = Number of dimensions
2671:	1330  0600    	        LD      B,0
2672:	1332  09      	        ADD     HL,BC           ; Two bytes per dimension size
2673:	1333  09      	        ADD     HL,BC
2674:	1334  23      	        INC     HL              ; Plus one for number of dim'ns
2675:	1335  EB      	GRBARY: EX      DE,HL
2676:	1336  2A0A21  	        LD      HL,(CUROPR)     ; Get address of next array
2677:	1339  EB      	        EX      DE,HL
2678:	133A  CDC507  	        CALL    CPDEHL          ; Is this array finished?
2679:	133D  CA1613  	        JP      Z,ARRLP         ; Yes - Get next one
2680:	1340  013513  	        LD      BC,GRBARY       ; Loop until array all done
2681:	1343  C5      	STPOOL: PUSH    BC              ; Save return address
2682:	1344  F680    	        OR      80H             ; Flag string type
2683:	1346  7E      	STRADD: LD      A,(HL)          ; Get string length
2684:	1347  23      	        INC     HL
2685:	1348  23      	        INC     HL
2686:	1349  5E      	        LD      E,(HL)          ; Get LSB of string address
2687:	134A  23      	        INC     HL
2688:	134B  56      	        LD      D,(HL)          ; Get MSB of string address
2689:	134C  23      	        INC     HL
2690:	134D  F0      	        RET     P               ; Not a string - Return
2691:	134E  B7      	        OR      A               ; Set flags on string length
2692:	134F  C8      	        RET     Z               ; Null string - Return
2693:	1350  44      	        LD      B,H             ; Save variable pointer
2694:	1351  4D      	        LD      C,L
2695:	1352  2A0821  	        LD      HL,(STRBOT)     ; Bottom of new area
2696:	1355  CDC507  	        CALL    CPDEHL          ; String been done?
2697:	1358  60      	        LD      H,B             ; Restore variable pointer
2698:	1359  69      	        LD      L,C
2699:	135A  D8      	        RET     C               ; String done - Ignore
2700:	135B  E1      	        POP     HL              ; Return address
2701:	135C  E3      	        EX      (SP),HL         ; Lowest available string area
2702:	135D  CDC507  	        CALL    CPDEHL          ; String within string area?
2703:	1360  E3      	        EX      (SP),HL         ; Lowest available string area
2704:	1361  E5      	        PUSH    HL              ; Re-save return address
2705:	1362  60      	        LD      H,B             ; Restore variable pointer
2706:	1363  69      	        LD      L,C
2707:	1364  D0      	        RET     NC              ; Outside string area - Ignore
2708:	1365  C1      	        POP     BC              ; Get return , Throw 2 away
2709:	1366  F1      	        POP     AF              ; 
2710:	1367  F1      	        POP     AF              ; 
2711:	1368  E5      	        PUSH    HL              ; Save variable pointer
2712:	1369  D5      	        PUSH    DE              ; Save address of current
2713:	136A  C5      	        PUSH    BC              ; Put back return address
2714:	136B  C9      	        RET                     ; Go to it
2715:			
2716:	136C  D1      	SCNEND: POP     DE              ; Addresses of strings
2717:	136D  E1      	        POP     HL              ; 
2718:	136E  7D      	        LD      A,L             ; HL = 0 if no more to do
2719:	136F  B4      	        OR      H
2720:	1370  C8      	        RET     Z               ; No more to do - Return
2721:	1371  2B      	        DEC     HL
2722:	1372  46      	        LD      B,(HL)          ; MSB of address of string
2723:	1373  2B      	        DEC     HL
2724:	1374  4E      	        LD      C,(HL)          ; LSB of address of string
2725:	1375  E5      	        PUSH    HL              ; Save variable address
2726:	1376  2B      	        DEC     HL
2727:	1377  2B      	        DEC     HL
2728:	1378  6E      	        LD      L,(HL)          ; HL = Length of string
2729:	1379  2600    	        LD      H,0
2730:	137B  09      	        ADD     HL,BC           ; Address of end of string+1
2731:	137C  50      	        LD      D,B             ; String address to DE
2732:	137D  59      	        LD      E,C
2733:	137E  2B      	        DEC     HL              ; Last byte in string
2734:	137F  44      	        LD      B,H             ; Address to BC
2735:	1380  4D      	        LD      C,L
2736:	1381  2A0821  	        LD      HL,(STRBOT)     ; Current bottom of string area
2737:	1384  CDCC04  	        CALL    MOVSTR          ; Move string to new address
2738:	1387  E1      	        POP     HL              ; Restore variable address
2739:	1388  71      	        LD      (HL),C          ; Save new LSB of address
2740:	1389  23      	        INC     HL
2741:	138A  70      	        LD      (HL),B          ; Save new MSB of address
2742:	138B  69      	        LD      L,C             ; Next string area+1 to HL
2743:	138C  60      	        LD      H,B
2744:	138D  2B      	        DEC     HL              ; Next string area address
2745:	138E  C3E112  	        JP      GARBLP          ; Look for more strings
2746:			
2747:	1391  C5      	CONCAT: PUSH    BC              ; Save prec' opr & code string
2748:	1392  E5      	        PUSH    HL              ; 
2749:	1393  2A2921  	        LD      HL,(FPREG)      ; Get first string
2750:	1396  E3      	        EX      (SP),HL         ; Save first string
2751:	1397  CD4B0E  	        CALL    OPRND           ; Get second string
2752:	139A  E3      	        EX      (SP),HL         ; Restore first string
2753:	139B  CDC60D  	        CALL    TSTSTR          ; Make sure it's a string
2754:	139E  7E      	        LD      A,(HL)          ; Get length of second string
2755:	139F  E5      	        PUSH    HL              ; Save first string
2756:	13A0  2A2921  	        LD      HL,(FPREG)      ; Get second string
2757:	13A3  E5      	        PUSH    HL              ; Save second string
2758:	13A4  86      	        ADD     A,(HL)          ; Add length of second string
2759:	13A5  1E1C    	        LD      E,LS            ; ?LS Error
2760:	13A7  DA1105  	        JP      C,ERROR         ; String too long - Error
2761:	13AA  CD4A12  	        CALL    MKTMST          ; Make temporary string
2762:	13AD  D1      	        POP     DE              ; Get second string to DE
2763:	13AE  CDE213  	        CALL    GSTRDE          ; Move to string pool if needed
2764:	13B1  E3      	        EX      (SP),HL         ; Get first string
2765:	13B2  CDE113  	        CALL    GSTRHL          ; Move to string pool if needed
2766:	13B5  E5      	        PUSH    HL              ; Save first string
2767:	13B6  2A0621  	        LD      HL,(TMPSTR+2)   ; Temporary string address
2768:	13B9  EB      	        EX      DE,HL           ; To DE
2769:	13BA  CDC813  	        CALL    SSTSA           ; First string to string area
2770:	13BD  CDC813  	        CALL    SSTSA           ; Second string to string area
2771:	13C0  21E00D  	        LD      HL,EVAL2        ; Return to evaluation loop
2772:	13C3  E3      	        EX      (SP),HL         ; Save return,get code string
2773:	13C4  E5      	        PUSH    HL              ; Save code string address
2774:	13C5  C37B12  	        JP      TSTOPL          ; To temporary string to pool
2775:			
2776:	13C8  E1      	SSTSA:  POP     HL              ; Return address
2777:	13C9  E3      	        EX      (SP),HL         ; Get string block,save return
2778:	13CA  7E      	        LD      A,(HL)          ; Get length of string
2779:	13CB  23      	        INC     HL
2780:	13CC  23      	        INC     HL
2781:	13CD  4E      	        LD      C,(HL)          ; Get LSB of string address
2782:	13CE  23      	        INC     HL
2783:	13CF  46      	        LD      B,(HL)          ; Get MSB of string address
2784:	13D0  6F      	        LD      L,A             ; Length to L
2785:	13D1  2C      	TOSTRA: INC     L               ; INC - DECed after
2786:	13D2  2D      	TSALP:  DEC     L               ; Count bytes moved
2787:	13D3  C8      	        RET     Z               ; End of string - Return
2788:	13D4  0A      	        LD      A,(BC)          ; Get source
2789:	13D5  12      	        LD      (DE),A          ; Save destination
2790:	13D6  03      	        INC     BC              ; Next source
2791:	13D7  13      	        INC     DE              ; Next destination
2792:	13D8  C3D213  	        JP      TSALP           ; Loop until string moved
2793:			
2794:	13DB  CDC60D  	GETSTR: CALL    TSTSTR          ; Make sure it's a string
2795:	13DE  2A2921  	GSTRCU: LD      HL,(FPREG)      ; Get current string
2796:	13E1  EB      	GSTRHL: EX      DE,HL           ; Save DE
2797:	13E2  CDFC13  	GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
2798:	13E5  EB      	        EX      DE,HL           ; Restore DE
2799:	13E6  C0      	        RET     NZ              ; No - Return
2800:	13E7  D5      	        PUSH    DE              ; Save string
2801:	13E8  50      	        LD      D,B             ; String block address to DE
2802:	13E9  59      	        LD      E,C
2803:	13EA  1B      	        DEC     DE              ; Point to length
2804:	13EB  4E      	        LD      C,(HL)          ; Get string length
2805:	13EC  2A0821  	        LD      HL,(STRBOT)     ; Current bottom of string area
2806:	13EF  CDC507  	        CALL    CPDEHL          ; Last one in string area?
2807:	13F2  C2FA13  	        JP      NZ,POPHL        ; No - Return
2808:	13F5  47      	        LD      B,A             ; Clear B (A=0)
2809:	13F6  09      	        ADD     HL,BC           ; Remove string from str' area
2810:	13F7  220821  	        LD      (STRBOT),HL     ; Save new bottom of str' area
2811:	13FA  E1      	POPHL:  POP     HL              ; Restore string
2812:	13FB  C9      	        RET
2813:			
2814:	13FC  2AF620  	BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
2815:	13FF  2B      	        DEC     HL              ; Back
2816:	1400  46      	        LD      B,(HL)          ; Get MSB of address
2817:	1401  2B      	        DEC     HL              ; Back
2818:	1402  4E      	        LD      C,(HL)          ; Get LSB of address
2819:	1403  2B      	        DEC     HL              ; Back
2820:	1404  2B      	        DEC     HL              ; Back
2821:	1405  CDC507  	        CALL    CPDEHL          ; String last in string pool?
2822:	1408  C0      	        RET     NZ              ; Yes - Leave it
2823:	1409  22F620  	        LD      (TMSTPT),HL     ; Save new string pool top
2824:	140C  C9      	        RET
2825:			
2826:	140D  018C11  	LEN:    LD      BC,PASSA        ; To return integer A
2827:	1410  C5      	        PUSH    BC              ; Save address
2828:	1411  CDDB13  	GETLEN: CALL    GETSTR          ; Get string and its length
2829:	1414  AF      	        XOR     A
2830:	1415  57      	        LD      D,A             ; Clear D
2831:	1416  32F220  	        LD      (TYPE),A        ; Set type to numeric
2832:	1419  7E      	        LD      A,(HL)          ; Get length of string
2833:	141A  B7      	        OR      A               ; Set status flags
2834:	141B  C9      	        RET
2835:			
2836:	141C  018C11  	ASC:    LD      BC,PASSA        ; To return integer A
2837:	141F  C5      	        PUSH    BC              ; Save address
2838:	1420  CD1114  	GTFLNM: CALL    GETLEN          ; Get length of string
2839:	1423  CA1C0A  	        JP      Z,FCERR         ; Null string - Error
2840:	1426  23      	        INC     HL
2841:	1427  23      	        INC     HL
2842:	1428  5E      	        LD      E,(HL)          ; Get LSB of address
2843:	1429  23      	        INC     HL
2844:	142A  56      	        LD      D,(HL)          ; Get MSB of address
2845:	142B  1A      	        LD      A,(DE)          ; Get first byte of string
2846:	142C  C9      	        RET
2847:			
2848:	142D  3E01    	CHR:    LD      A,1             ; One character string
2849:	142F  CD4A12  	        CALL    MKTMST          ; Make a temporary string
2850:	1432  CD2615  	        CALL    MAKINT          ; Make it integer A
2851:	1435  2A0621  	        LD      HL,(TMPSTR+2)   ; Get address of string
2852:	1438  73      	        LD      (HL),E          ; Save character
2853:	1439  C1      	TOPOOL: POP     BC              ; Clean up stack
2854:	143A  C37B12  	        JP      TSTOPL          ; Temporary string to pool
2855:			
2856:	143D  CDD614  	LEFT:   CALL    LFRGNM          ; Get number and ending ")"
2857:	1440  AF      	        XOR     A               ; Start at first byte in string
2858:	1441  E3      	RIGHT1: EX      (SP),HL         ; Save code string,Get string
2859:	1442  4F      	        LD      C,A             ; Starting position in string
2860:	1443  E5      	MID1:   PUSH    HL              ; Save string block address
2861:	1444  7E      	        LD      A,(HL)          ; Get length of string
2862:	1445  B8      	        CP      B               ; Compare with number given
2863:	1446  DA4B14  	        JP      C,ALLFOL        ; All following bytes required
2864:	1449  78      	        LD      A,B             ; Get new length
2865:	144A  11      	        .DB     11H             ; Skip "LD C,0"
2866:	144B  0E00    	ALLFOL: LD      C,0             ; First byte of string
2867:	144D  C5      	        PUSH    BC              ; Save position in string
2868:	144E  CDB412  	        CALL    TESTR           ; See if enough string space
2869:	1451  C1      	        POP     BC              ; Get position in string
2870:	1452  E1      	        POP     HL              ; Restore string block address
2871:	1453  E5      	        PUSH    HL              ; And re-save it
2872:	1454  23      	        INC     HL
2873:	1455  23      	        INC     HL
2874:	1456  46      	        LD      B,(HL)          ; Get LSB of address
2875:	1457  23      	        INC     HL
2876:	1458  66      	        LD      H,(HL)          ; Get MSB of address
2877:	1459  68      	        LD      L,B             ; HL = address of string
2878:	145A  0600    	        LD      B,0             ; BC = starting address
2879:	145C  09      	        ADD     HL,BC           ; Point to that byte
2880:	145D  44      	        LD      B,H             ; BC = source string
2881:	145E  4D      	        LD      C,L
2882:	145F  CD4D12  	        CALL    CRTMST          ; Create a string entry
2883:	1462  6F      	        LD      L,A             ; Length of new string
2884:	1463  CDD113  	        CALL    TOSTRA          ; Move string to string area
2885:	1466  D1      	        POP     DE              ; Clear stack
2886:	1467  CDE213  	        CALL    GSTRDE          ; Move to string pool if needed
2887:	146A  C37B12  	        JP      TSTOPL          ; Temporary string to pool
2888:			
2889:	146D  CDD614  	RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
2890:	1470  D1      	        POP     DE              ; Get string length
2891:	1471  D5      	        PUSH    DE              ; And re-save
2892:	1472  1A      	        LD      A,(DE)          ; Get length
2893:	1473  90      	        SUB     B               ; Move back N bytes
2894:	1474  C34114  	        JP      RIGHT1          ; Go and get sub-string
2895:			
2896:	1477  EB      	MID:    EX      DE,HL           ; Get code string address
2897:	1478  7E      	        LD      A,(HL)          ; Get next byte ',' or ")"
2898:	1479  CDDB14  	        CALL    MIDNUM          ; Get number supplied
2899:	147C  04      	        INC     B               ; Is it character zero?
2900:	147D  05      	        DEC     B
2901:	147E  CA1C0A  	        JP      Z,FCERR         ; Yes - Error
2902:	1481  C5      	        PUSH    BC              ; Save starting position
2903:	1482  1EFF    	        LD      E,255           ; All of string
2904:	1484  FE29    	        CP      ')'             ; Any length given?
2905:	1486  CA9014  	        JP      Z,RSTSTR        ; No - Rest of string
2906:	1489  CDCB07  	        CALL    CHKSYN          ; Make sure ',' follows
2907:	148C  2C      	        .DB     ','
2908:	148D  CD2315  	        CALL    GETINT          ; Get integer 0-255
2909:	1490  CDCB07  	RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
2910:	1493  29      	        .DB     ")"
2911:	1494  F1      	        POP     AF              ; Restore starting position
2912:	1495  E3      	        EX      (SP),HL         ; Get string,8ave code string
2913:	1496  014314  	        LD      BC,MID1         ; Continuation of MID$ routine
2914:	1499  C5      	        PUSH    BC              ; Save for return
2915:	149A  3D      	        DEC     A               ; Starting position-1
2916:	149B  BE      	        CP      (HL)            ; Compare with length
2917:	149C  0600    	        LD      B,0             ; Zero bytes length
2918:	149E  D0      	        RET     NC              ; Null string if start past end
2919:	149F  4F      	        LD      C,A             ; Save starting position-1
2920:	14A0  7E      	        LD      A,(HL)          ; Get length of string
2921:	14A1  91      	        SUB     C               ; Subtract start
2922:	14A2  BB      	        CP      E               ; Enough string for it?
2923:	14A3  47      	        LD      B,A             ; Save maximum length available
2924:	14A4  D8      	        RET     C               ; Truncate string if needed
2925:	14A5  43      	        LD      B,E             ; Set specified length
2926:	14A6  C9      	        RET                     ; Go and create string
2927:			
2928:	14A7  CD1114  	VAL:    CALL    GETLEN          ; Get length of string
2929:	14AA  CAC415  	        JP      Z,RESZER        ; Result zero
2930:	14AD  5F      	        LD      E,A             ; Save length
2931:	14AE  23      	        INC     HL
2932:	14AF  23      	        INC     HL
2933:	14B0  7E      	        LD      A,(HL)          ; Get LSB of address
2934:	14B1  23      	        INC     HL
2935:	14B2  66      	        LD      H,(HL)          ; Get MSB of address
2936:	14B3  6F      	        LD      L,A             ; HL = String address
2937:	14B4  E5      	        PUSH    HL              ; Save string address
2938:	14B5  19      	        ADD     HL,DE
2939:	14B6  46      	        LD      B,(HL)          ; Get end of string+1 byte
2940:	14B7  72      	        LD      (HL),D          ; Zero it to terminate
2941:	14B8  E3      	        EX      (SP),HL         ; Save string end,get start
2942:	14B9  C5      	        PUSH    BC              ; Save end+1 byte
2943:	14BA  7E      	        LD      A,(HL)          ; Get starting byte
2944:	14BB  FE24    	        CP      '$'             ; Hex number indicated? [function added]
2945:	14BD  C2C514  	        JP      NZ,VAL1
2946:	14C0  CDEF1C  	        CALL    HEXTFP          ; Convert Hex to FPREG
2947:	14C3  180D    	        JR      VAL3
2948:	14C5  FE25    	VAL1:   CP	'%'             ; Binary number indicated? [function added]
2949:	14C7  C2CF14  	    JP	NZ,VAL2
2950:	14CA  CD5F1D  	    CALL	BINTFP		; Convert Bin to FPREG
2951:	14CD  1803    	    JR	VAL3
2952:	14CF  CDAB18  	VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
2953:	14D2  C1      	VAL3:   POP     BC              ; Restore end+1 byte
2954:	14D3  E1      	        POP     HL              ; Restore end+1 address
2955:	14D4  70      	        LD      (HL),B          ; Put back original byte
2956:	14D5  C9      	        RET
2957:			
2958:	14D6  EB      	LFRGNM: EX      DE,HL           ; Code string address to HL
2959:	14D7  CDCB07  	        CALL    CHKSYN          ; Make sure ")" follows
2960:	14DA  29      	        .DB     ")"
2961:	14DB  C1      	MIDNUM: POP     BC              ; Get return address
2962:	14DC  D1      	        POP     DE              ; Get number supplied
2963:	14DD  C5      	        PUSH    BC              ; Re-save return address
2964:	14DE  43      	        LD      B,E             ; Number to B
2965:	14DF  C9      	        RET
2966:			
2967:	14E0  CD2615  	INP:    CALL    MAKINT          ; Make it integer A
2968:	14E3  328420  	        LD      (INPORT),A      ; Set input port
2969:	14E6  CD8320  	        CALL    INPSUB          ; Get input from port
2970:	14E9  C38C11  	        JP      PASSA           ; Return integer A
2971:			
2972:	14EC  CD1015  	POUT:   CALL    SETIO           ; Set up port number
2973:	14EF  C34B20  	        JP      OUTSUB          ; Output data and return
2974:			
2975:	14F2  CD1015  	WAIT:   CALL    SETIO           ; Set up port number
2976:	14F5  F5      	        PUSH    AF              ; Save AND mask
2977:	14F6  1E00    	        LD      E,0             ; Assume zero if none given
2978:	14F8  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
2979:	14F9  CD5509  	        CALL    GETCHR          ; Get next character
2980:	14FC  CA0615  	        JP      Z,NOXOR         ; No XOR byte given
2981:	14FF  CDCB07  	        CALL    CHKSYN          ; Make sure ',' follows
2982:	1502  2C      	        .DB     ','
2983:	1503  CD2315  	        CALL    GETINT          ; Get integer 0-255 to XOR with
2984:	1506  C1      	NOXOR:  POP     BC              ; Restore AND mask
2985:	1507  CD8320  	WAITLP: CALL    INPSUB          ; Get input
2986:	150A  AB      	        XOR     E               ; Flip selected bits
2987:	150B  A0      	        AND     B               ; Result non-zero?
2988:	150C  CA0715  	        JP      Z,WAITLP        ; No = keep waiting
2989:	150F  C9      	        RET
2990:			
2991:	1510  CD2315  	SETIO:  CALL    GETINT          ; Get integer 0-255
2992:	1513  328420  	        LD      (INPORT),A      ; Set input port
2993:	1516  324C20  	        LD      (OTPORT),A      ; Set output port
2994:	1519  CDCB07  	        CALL    CHKSYN          ; Make sure ',' follows
2995:	151C  2C      	        .DB     ','
2996:	151D  C32315  	        JP      GETINT          ; Get integer 0-255 and return
2997:			
2998:	1520  CD5509  	FNDNUM: CALL    GETCHR          ; Get next character
2999:	1523  CDC20D  	GETINT: CALL    GETNUM          ; Get a number from 0 to 255
3000:	1526  CD010A  	MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
3001:	1529  7A      	        LD      A,D             ; Get MSB of number
3002:	152A  B7      	        OR      A               ; Zero?
3003:	152B  C21C0A  	        JP      NZ,FCERR        ; No - Error
3004:	152E  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
3005:	152F  CD5509  	        CALL    GETCHR          ; Get next character
3006:	1532  7B      	        LD      A,E             ; Get number to A
3007:	1533  C9      	        RET
3008:			
3009:	1534  CD070A  	PEEK:   CALL    DEINT           ; Get memory address
3010:	1537  1A      	        LD      A,(DE)          ; Get byte in memory
3011:	1538  C38C11  	        JP      PASSA           ; Return integer A
3012:			
3013:	153B  CDC20D  	POKE:   CALL    GETNUM          ; Get memory address
3014:	153E  CD070A  	        CALL    DEINT           ; Get integer -32768 to 3276
3015:	1541  D5      	        PUSH    DE              ; Save memory address
3016:	1542  CDCB07  	        CALL    CHKSYN          ; Make sure ',' follows
3017:	1545  2C      	        .DB     ','
3018:	1546  CD2315  	        CALL    GETINT          ; Get integer 0-255
3019:	1549  D1      	        POP     DE              ; Restore memory address
3020:	154A  12      	        LD      (DE),A          ; Load it into memory
3021:	154B  C9      	        RET
3022:			
3023:	154C  21221A  	ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
3024:	154F  CDF317  	ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
3025:	1552  C35E15  	        JP      FPADD           ; Add BCDE to FPREG
3026:			
3027:	1555  CDF317  	SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
3028:	1558  21      	        .DB     21H             ; Skip "POP BC" and "POP DE"
3029:	1559  C1      	PSUB:   POP     BC              ; Get FP number from stack
3030:	155A  D1      	        POP     DE
3031:	155B  CDCD17  	SUBCDE: CALL    INVSGN          ; Negate FPREG
3032:	155E  78      	FPADD:  LD      A,B             ; Get FP exponent
3033:	155F  B7      	        OR      A               ; Is number zero?
3034:	1560  C8      	        RET     Z               ; Yes - Nothing to add
3035:	1561  3A2C21  	        LD      A,(FPEXP)       ; Get FPREG exponent
3036:	1564  B7      	        OR      A               ; Is this number zero?
3037:	1565  CAE517  	        JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3038:	1568  90      	        SUB     B               ; BCDE number larger?
3039:	1569  D27815  	        JP      NC,NOSWAP       ; No - Don't swap them
3040:	156C  2F      	        CPL                     ; Two's complement
3041:	156D  3C      	        INC     A               ;  FP exponent
3042:	156E  EB      	        EX      DE,HL
3043:	156F  CDD517  	        CALL    STAKFP          ; Put FPREG on stack
3044:	1572  EB      	        EX      DE,HL
3045:	1573  CDE517  	        CALL    FPBCDE          ; Move BCDE to FPREG
3046:	1576  C1      	        POP     BC              ; Restore number from stack
3047:	1577  D1      	        POP     DE
3048:	1578  FE19    	NOSWAP: CP      24+1            ; Second number insignificant?
3049:	157A  D0      	        RET     NC              ; Yes - First number is result
3050:	157B  F5      	        PUSH    AF              ; Save number of bits to scale
3051:	157C  CD0A18  	        CALL    SIGNS           ; Set MSBs & sign of result
3052:	157F  67      	        LD      H,A             ; Save sign of result
3053:	1580  F1      	        POP     AF              ; Restore scaling factor
3054:	1581  CD2316  	        CALL    SCALE           ; Scale BCDE to same exponent
3055:	1584  B4      	        OR      H               ; Result to be positive?
3056:	1585  212921  	        LD      HL,FPREG        ; Point to FPREG
3057:	1588  F29E15  	        JP      P,MINCDE        ; No - Subtract FPREG from CDE
3058:	158B  CD0316  	        CALL    PLUCDE          ; Add FPREG to CDE
3059:	158E  D2E415  	        JP      NC,RONDUP       ; No overflow - Round it up
3060:	1591  23      	        INC     HL              ; Point to exponent
3061:	1592  34      	        INC     (HL)            ; Increment it
3062:	1593  CA0C05  	        JP      Z,OVERR         ; Number overflowed - Error
3063:	1596  2E01    	        LD      L,1             ; 1 bit to shift right
3064:	1598  CD3916  	        CALL    SHRT1           ; Shift result right
3065:	159B  C3E415  	        JP      RONDUP          ; Round it up
3066:			
3067:	159E  AF      	MINCDE: XOR     A               ; Clear A and carry
3068:	159F  90      	        SUB     B               ; Negate exponent
3069:	15A0  47      	        LD      B,A             ; Re-save exponent
3070:	15A1  7E      	        LD      A,(HL)          ; Get LSB of FPREG
3071:	15A2  9B      	        SBC     A, E            ; Subtract LSB of BCDE
3072:	15A3  5F      	        LD      E,A             ; Save LSB of BCDE
3073:	15A4  23      	        INC     HL
3074:	15A5  7E      	        LD      A,(HL)          ; Get NMSB of FPREG
3075:	15A6  9A      	        SBC     A,D             ; Subtract NMSB of BCDE
3076:	15A7  57      	        LD      D,A             ; Save NMSB of BCDE
3077:	15A8  23      	        INC     HL
3078:	15A9  7E      	        LD      A,(HL)          ; Get MSB of FPREG
3079:	15AA  99      	        SBC     A,C             ; Subtract MSB of BCDE
3080:	15AB  4F      	        LD      C,A             ; Save MSB of BCDE
3081:	15AC  DC0F16  	CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
3082:			
3083:	15AF  68      	BNORM:  LD      L,B             ; L = Exponent
3084:	15B0  63      	        LD      H,E             ; H = LSB
3085:	15B1  AF      	        XOR     A
3086:	15B2  47      	BNRMLP: LD      B,A             ; Save bit count
3087:	15B3  79      	        LD      A,C             ; Get MSB
3088:	15B4  B7      	        OR      A               ; Is it zero?
3089:	15B5  C2D115  	        JP      NZ,PNORM        ; No - Do it bit at a time
3090:	15B8  4A      	        LD      C,D             ; MSB = NMSB
3091:	15B9  54      	        LD      D,H             ; NMSB= LSB
3092:	15BA  65      	        LD      H,L             ; LSB = VLSB
3093:	15BB  6F      	        LD      L,A             ; VLSB= 0
3094:	15BC  78      	        LD      A,B             ; Get exponent
3095:	15BD  D608    	        SUB     8               ; Count 8 bits
3096:	15BF  FEE0    	        CP      -24-8           ; Was number zero?
3097:	15C1  C2B215  	        JP      NZ,BNRMLP       ; No - Keep normalising
3098:	15C4  AF      	RESZER: XOR     A               ; Result is zero
3099:	15C5  322C21  	SAVEXP: LD      (FPEXP),A       ; Save result as zero
3100:	15C8  C9      	        RET
3101:			
3102:	15C9  05      	NORMAL: DEC     B               ; Count bits
3103:	15CA  29      	        ADD     HL,HL           ; Shift HL left
3104:	15CB  7A      	        LD      A,D             ; Get NMSB
3105:	15CC  17      	        RLA                     ; Shift left with last bit
3106:	15CD  57      	        LD      D,A             ; Save NMSB
3107:	15CE  79      	        LD      A,C             ; Get MSB
3108:	15CF  8F      	        ADC     A,A             ; Shift left with last bit
3109:	15D0  4F      	        LD      C,A             ; Save MSB
3110:	15D1  F2C915  	PNORM:  JP      P,NORMAL        ; Not done - Keep going
3111:	15D4  78      	        LD      A,B             ; Number of bits shifted
3112:	15D5  5C      	        LD      E,H             ; Save HL in EB
3113:	15D6  45      	        LD      B,L
3114:	15D7  B7      	        OR      A               ; Any shifting done?
3115:	15D8  CAE415  	        JP      Z,RONDUP        ; No - Round it up
3116:	15DB  212C21  	        LD      HL,FPEXP        ; Point to exponent
3117:	15DE  86      	        ADD     A,(HL)          ; Add shifted bits
3118:	15DF  77      	        LD      (HL),A          ; Re-save exponent
3119:	15E0  D2C415  	        JP      NC,RESZER       ; Underflow - Result is zero
3120:	15E3  C8      	        RET     Z               ; Result is zero
3121:	15E4  78      	RONDUP: LD      A,B             ; Get VLSB of number
3122:	15E5  212C21  	RONDB:  LD      HL,FPEXP        ; Point to exponent
3123:	15E8  B7      	        OR      A               ; Any rounding?
3124:	15E9  FCF615  	        CALL    M,FPROND        ; Yes - Round number up
3125:	15EC  46      	        LD      B,(HL)          ; B = Exponent
3126:	15ED  23      	        INC     HL
3127:	15EE  7E      	        LD      A,(HL)          ; Get sign of result
3128:	15EF  E680    	        AND     10000000B       ; Only bit 7 needed
3129:	15F1  A9      	        XOR     C               ; Set correct sign
3130:	15F2  4F      	        LD      C,A             ; Save correct sign in number
3131:	15F3  C3E517  	        JP      FPBCDE          ; Move BCDE to FPREG
3132:			
3133:	15F6  1C      	FPROND: INC     E               ; Round LSB
3134:	15F7  C0      	        RET     NZ              ; Return if ok
3135:	15F8  14      	        INC     D               ; Round NMSB
3136:	15F9  C0      	        RET     NZ              ; Return if ok
3137:	15FA  0C      	        INC     C               ; Round MSB
3138:	15FB  C0      	        RET     NZ              ; Return if ok
3139:	15FC  0E80    	        LD      C,80H           ; Set normal value
3140:	15FE  34      	        INC     (HL)            ; Increment exponent
3141:	15FF  C0      	        RET     NZ              ; Return if ok
3142:	1600  C30C05  	        JP      OVERR           ; Overflow error
3143:			
3144:	1603  7E      	PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
3145:	1604  83      	        ADD     A,E             ; Add LSB of BCDE
3146:	1605  5F      	        LD      E,A             ; Save LSB of BCDE
3147:	1606  23      	        INC     HL
3148:	1607  7E      	        LD      A,(HL)          ; Get NMSB of FPREG
3149:	1608  8A      	        ADC     A,D             ; Add NMSB of BCDE
3150:	1609  57      	        LD      D,A             ; Save NMSB of BCDE
3151:	160A  23      	        INC     HL
3152:	160B  7E      	        LD      A,(HL)          ; Get MSB of FPREG
3153:	160C  89      	        ADC     A,C             ; Add MSB of BCDE
3154:	160D  4F      	        LD      C,A             ; Save MSB of BCDE
3155:	160E  C9      	        RET
3156:			
3157:	160F  212D21  	COMPL:  LD      HL,SGNRES       ; Sign of result
3158:	1612  7E      	        LD      A,(HL)          ; Get sign of result
3159:	1613  2F      	        CPL                     ; Negate it
3160:	1614  77      	        LD      (HL),A          ; Put it back
3161:	1615  AF      	        XOR     A
3162:	1616  6F      	        LD      L,A             ; Set L to zero
3163:	1617  90      	        SUB     B               ; Negate exponent,set carry
3164:	1618  47      	        LD      B,A             ; Re-save exponent
3165:	1619  7D      	        LD      A,L             ; Load zero
3166:	161A  9B      	        SBC     A,E             ; Negate LSB
3167:	161B  5F      	        LD      E,A             ; Re-save LSB
3168:	161C  7D      	        LD      A,L             ; Load zero
3169:	161D  9A      	        SBC     A,D             ; Negate NMSB
3170:	161E  57      	        LD      D,A             ; Re-save NMSB
3171:	161F  7D      	        LD      A,L             ; Load zero
3172:	1620  99      	        SBC     A,C             ; Negate MSB
3173:	1621  4F      	        LD      C,A             ; Re-save MSB
3174:	1622  C9      	        RET
3175:			
3176:	1623  0600    	SCALE:  LD      B,0             ; Clear underflow
3177:	1625  D608    	SCALLP: SUB     8               ; 8 bits (a whole byte)?
3178:	1627  DA3216  	        JP      C,SHRITE        ; No - Shift right A bits
3179:	162A  43      	        LD      B,E             ; <- Shift
3180:	162B  5A      	        LD      E,D             ; <- right
3181:	162C  51      	        LD      D,C             ; <- eight
3182:	162D  0E00    	        LD      C,0             ; <- bits
3183:	162F  C32516  	        JP      SCALLP          ; More bits to shift
3184:			
3185:	1632  C609    	SHRITE: ADD     A,8+1           ; Adjust count
3186:	1634  6F      	        LD      L,A             ; Save bits to shift
3187:	1635  AF      	SHRLP:  XOR     A               ; Flag for all done
3188:	1636  2D      	        DEC     L               ; All shifting done?
3189:	1637  C8      	        RET     Z               ; Yes - Return
3190:	1638  79      	        LD      A,C             ; Get MSB
3191:	1639  1F      	SHRT1:  RRA                     ; Shift it right
3192:	163A  4F      	        LD      C,A             ; Re-save
3193:	163B  7A      	        LD      A,D             ; Get NMSB
3194:	163C  1F      	        RRA                     ; Shift right with last bit
3195:	163D  57      	        LD      D,A             ; Re-save it
3196:	163E  7B      	        LD      A,E             ; Get LSB
3197:	163F  1F      	        RRA                     ; Shift right with last bit
3198:	1640  5F      	        LD      E,A             ; Re-save it
3199:	1641  78      	        LD      A,B             ; Get underflow
3200:	1642  1F      	        RRA                     ; Shift right with last bit
3201:	1643  47      	        LD      B,A             ; Re-save underflow
3202:	1644  C33516  	        JP      SHRLP           ; More bits to do
3203:			
3204:	1647  00000081	UNITY:  .DB     000H,000H,000H,081H  ; 1.00000
3205:			
3206:	164B  03      	LOGTAB: .DB     3                    ; Table used by LOG
3207:	164C  AA561980	        .DB     0AAH,056H,019H,080H  ; 0.59898
3208:	1650  F1227680	        .DB     0F1H,022H,076H,080H  ; 0.96147
3209:	1654  45AA3882	        .DB     045H,0AAH,038H,082H  ; 2.88539
3210:			
3211:	1658  CDA417  	LOG:    CALL    TSTSGN          ; Test sign of value
3212:	165B  B7      	        OR      A
3213:	165C  EA1C0A  	        JP      PE,FCERR        ; ?FC Error if <= zero
3214:	165F  212C21  	        LD      HL,FPEXP        ; Point to exponent
3215:	1662  7E      	        LD      A,(HL)          ; Get exponent
3216:	1663  013580  	        LD      BC,8035H        ; BCDE = SQR(1/2)
3217:	1666  11F304  	        LD      DE,04F3H
3218:	1669  90      	        SUB     B               ; Scale value to be < 1
3219:	166A  F5      	        PUSH    AF              ; Save scale factor
3220:	166B  70      	        LD      (HL),B          ; Save new exponent
3221:	166C  D5      	        PUSH    DE              ; Save SQR(1/2)
3222:	166D  C5      	        PUSH    BC
3223:	166E  CD5E15  	        CALL    FPADD           ; Add SQR(1/2) to value
3224:	1671  C1      	        POP     BC              ; Restore SQR(1/2)
3225:	1672  D1      	        POP     DE
3226:	1673  04      	        INC     B               ; Make it SQR(2)
3227:	1674  CDFA16  	        CALL    DVBCDE          ; Divide by SQR(2)
3228:	1677  214716  	        LD      HL,UNITY        ; Point to 1.
3229:	167A  CD5515  	        CALL    SUBPHL          ; Subtract FPREG from 1
3230:	167D  214B16  	        LD      HL,LOGTAB       ; Coefficient table
3231:	1680  CDEC1A  	        CALL    SUMSER          ; Evaluate sum of series
3232:	1683  018080  	        LD      BC,8080H        ; BCDE = -0.5
3233:	1686  110000  	        LD      DE,0000H
3234:	1689  CD5E15  	        CALL    FPADD           ; Subtract 0.5 from FPREG
3235:	168C  F1      	        POP     AF              ; Restore scale factor
3236:	168D  CD1F19  	        CALL    RSCALE          ; Re-scale number
3237:	1690  013180  	MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
3238:	1693  111872  	        LD      DE,7218H
3239:	1696  21      	        .DB     21H             ; Skip "POP BC" and "POP DE"
3240:			
3241:	1697  C1      	MULT:   POP     BC              ; Get number from stack
3242:	1698  D1      	        POP     DE
3243:	1699  CDA417  	FPMULT: CALL    TSTSGN          ; Test sign of FPREG
3244:	169C  C8      	        RET     Z               ; Return zero if zero
3245:	169D  2E00    	        LD      L,0             ; Flag add exponents
3246:	169F  CD6217  	        CALL    ADDEXP          ; Add exponents
3247:	16A2  79      	        LD      A,C             ; Get MSB of multiplier
3248:	16A3  323B21  	        LD      (MULVAL),A      ; Save MSB of multiplier
3249:	16A6  EB      	        EX      DE,HL
3250:	16A7  223C21  	        LD      (MULVAL+1),HL   ; Save rest of multiplier
3251:	16AA  010000  	        LD      BC,0            ; Partial product (BCDE) = zero
3252:	16AD  50      	        LD      D,B
3253:	16AE  58      	        LD      E,B
3254:	16AF  21AF15  	        LD      HL,BNORM        ; Address of normalise
3255:	16B2  E5      	        PUSH    HL              ; Save for return
3256:	16B3  21BB16  	        LD      HL,MULT8        ; Address of 8 bit multiply
3257:	16B6  E5      	        PUSH    HL              ; Save for NMSB,MSB
3258:	16B7  E5      	        PUSH    HL              ; 
3259:	16B8  212921  	        LD      HL,FPREG        ; Point to number
3260:	16BB  7E      	MULT8:  LD      A,(HL)          ; Get LSB of number
3261:	16BC  23      	        INC     HL              ; Point to NMSB
3262:	16BD  B7      	        OR      A               ; Test LSB
3263:	16BE  CAE716  	        JP      Z,BYTSFT        ; Zero - shift to next byte
3264:	16C1  E5      	        PUSH    HL              ; Save address of number
3265:	16C2  2E08    	        LD      L,8             ; 8 bits to multiply by
3266:	16C4  1F      	MUL8LP: RRA                     ; Shift LSB right
3267:	16C5  67      	        LD      H,A             ; Save LSB
3268:	16C6  79      	        LD      A,C             ; Get MSB
3269:	16C7  D2D516  	        JP      NC,NOMADD       ; Bit was zero - Don't add
3270:	16CA  E5      	        PUSH    HL              ; Save LSB and count
3271:	16CB  2A3C21  	        LD      HL,(MULVAL+1)   ; Get LSB and NMSB
3272:	16CE  19      	        ADD     HL,DE           ; Add NMSB and LSB
3273:	16CF  EB      	        EX      DE,HL           ; Leave sum in DE
3274:	16D0  E1      	        POP     HL              ; Restore MSB and count
3275:	16D1  3A3B21  	        LD      A,(MULVAL)      ; Get MSB of multiplier
3276:	16D4  89      	        ADC     A,C             ; Add MSB
3277:	16D5  1F      	NOMADD: RRA                     ; Shift MSB right
3278:	16D6  4F      	        LD      C,A             ; Re-save MSB
3279:	16D7  7A      	        LD      A,D             ; Get NMSB
3280:	16D8  1F      	        RRA                     ; Shift NMSB right
3281:	16D9  57      	        LD      D,A             ; Re-save NMSB
3282:	16DA  7B      	        LD      A,E             ; Get LSB
3283:	16DB  1F      	        RRA                     ; Shift LSB right
3284:	16DC  5F      	        LD      E,A             ; Re-save LSB
3285:	16DD  78      	        LD      A,B             ; Get VLSB
3286:	16DE  1F      	        RRA                     ; Shift VLSB right
3287:	16DF  47      	        LD      B,A             ; Re-save VLSB
3288:	16E0  2D      	        DEC     L               ; Count bits multiplied
3289:	16E1  7C      	        LD      A,H             ; Get LSB of multiplier
3290:	16E2  C2C416  	        JP      NZ,MUL8LP       ; More - Do it
3291:	16E5  E1      	POPHRT: POP     HL              ; Restore address of number
3292:	16E6  C9      	        RET
3293:			
3294:	16E7  43      	BYTSFT: LD      B,E             ; Shift partial product left
3295:	16E8  5A      	        LD      E,D
3296:	16E9  51      	        LD      D,C
3297:	16EA  4F      	        LD      C,A
3298:	16EB  C9      	        RET
3299:			
3300:	16EC  CDD517  	DIV10:  CALL    STAKFP          ; Save FPREG on stack
3301:	16EF  012084  	        LD      BC,8420H        ; BCDE = 10.
3302:	16F2  110000  	        LD      DE,0000H
3303:	16F5  CDE517  	        CALL    FPBCDE          ; Move 10 to FPREG
3304:			
3305:	16F8  C1      	DIV:    POP     BC              ; Get number from stack
3306:	16F9  D1      	        POP     DE
3307:	16FA  CDA417  	DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
3308:	16FD  CA0005  	        JP      Z,DZERR         ; Error if division by zero
3309:	1700  2EFF    	        LD      L,-1            ; Flag subtract exponents
3310:	1702  CD6217  	        CALL    ADDEXP          ; Subtract exponents
3311:	1705  34      	        INC     (HL)            ; Add 2 to exponent to adjust
3312:	1706  34      	        INC     (HL)
3313:	1707  2B      	        DEC     HL              ; Point to MSB
3314:	1708  7E      	        LD      A,(HL)          ; Get MSB of dividend
3315:	1709  325720  	        LD      (DIV3),A        ; Save for subtraction
3316:	170C  2B      	        DEC     HL
3317:	170D  7E      	        LD      A,(HL)          ; Get NMSB of dividend
3318:	170E  325320  	        LD      (DIV2),A        ; Save for subtraction
3319:	1711  2B      	        DEC     HL
3320:	1712  7E      	        LD      A,(HL)          ; Get MSB of dividend
3321:	1713  324F20  	        LD      (DIV1),A        ; Save for subtraction
3322:	1716  41      	        LD      B,C             ; Get MSB
3323:	1717  EB      	        EX      DE,HL           ; NMSB,LSB to HL
3324:	1718  AF      	        XOR     A
3325:	1719  4F      	        LD      C,A             ; Clear MSB of quotient
3326:	171A  57      	        LD      D,A             ; Clear NMSB of quotient
3327:	171B  5F      	        LD      E,A             ; Clear LSB of quotient
3328:	171C  325A20  	        LD      (DIV4),A        ; Clear overflow count
3329:	171F  E5      	DIVLP:  PUSH    HL              ; Save divisor
3330:	1720  C5      	        PUSH    BC
3331:	1721  7D      	        LD      A,L             ; Get LSB of number
3332:	1722  CD4E20  	        CALL    DIVSUP          ; Subt' divisor from dividend
3333:	1725  DE00    	        SBC     A,0             ; Count for overflows
3334:	1727  3F      	        CCF
3335:	1728  D23217  	        JP      NC,RESDIV       ; Restore divisor if borrow
3336:	172B  325A20  	        LD      (DIV4),A        ; Re-save overflow count
3337:	172E  F1      	        POP     AF              ; Scrap divisor
3338:	172F  F1      	        POP     AF
3339:	1730  37      	        SCF                     ; Set carry to
3340:	1731  D2      	        .DB     0D2H            ; Skip "POP BC" and "POP HL"
3341:			
3342:	1732  C1      	RESDIV: POP     BC              ; Restore divisor
3343:	1733  E1      	        POP     HL
3344:	1734  79      	        LD      A,C             ; Get MSB of quotient
3345:	1735  3C      	        INC     A
3346:	1736  3D      	        DEC     A
3347:	1737  1F      	        RRA                     ; Bit 0 to bit 7
3348:	1738  FAE515  	        JP      M,RONDB        ; Done - Normalise result
3349:	173B  17      	        RLA                     ; Restore carry
3350:	173C  7B      	        LD      A,E             ; Get LSB of quotient
3351:	173D  17      	        RLA                     ; Double it
3352:	173E  5F      	        LD      E,A             ; Put it back
3353:	173F  7A      	        LD      A,D             ; Get NMSB of quotient
3354:	1740  17      	        RLA                     ; Double it
3355:	1741  57      	        LD      D,A             ; Put it back
3356:	1742  79      	        LD      A,C             ; Get MSB of quotient
3357:	1743  17      	        RLA                     ; Double it
3358:	1744  4F      	        LD      C,A             ; Put it back
3359:	1745  29      	        ADD     HL,HL           ; Double NMSB,LSB of divisor
3360:	1746  78      	        LD      A,B             ; Get MSB of divisor
3361:	1747  17      	        RLA                     ; Double it
3362:	1748  47      	        LD      B,A             ; Put it back
3363:	1749  3A5A20  	        LD      A,(DIV4)        ; Get VLSB of quotient
3364:	174C  17      	        RLA                     ; Double it
3365:	174D  325A20  	        LD      (DIV4),A        ; Put it back
3366:	1750  79      	        LD      A,C             ; Get MSB of quotient
3367:	1751  B2      	        OR      D               ; Merge NMSB
3368:	1752  B3      	        OR      E               ; Merge LSB
3369:	1753  C21F17  	        JP      NZ,DIVLP        ; Not done - Keep dividing
3370:	1756  E5      	        PUSH    HL              ; Save divisor
3371:	1757  212C21  	        LD      HL,FPEXP        ; Point to exponent
3372:	175A  35      	        DEC     (HL)            ; Divide by 2
3373:	175B  E1      	        POP     HL              ; Restore divisor
3374:	175C  C21F17  	        JP      NZ,DIVLP        ; Ok - Keep going
3375:	175F  C30C05  	        JP      OVERR           ; Overflow error
3376:			
3377:	1762  78      	ADDEXP: LD      A,B             ; Get exponent of dividend
3378:	1763  B7      	        OR      A               ; Test it
3379:	1764  CA8617  	        JP      Z,OVTST3        ; Zero - Result zero
3380:	1767  7D      	        LD      A,L             ; Get add/subtract flag
3381:	1768  212C21  	        LD      HL,FPEXP        ; Point to exponent
3382:	176B  AE      	        XOR     (HL)            ; Add or subtract it
3383:	176C  80      	        ADD     A,B             ; Add the other exponent
3384:	176D  47      	        LD      B,A             ; Save new exponent
3385:	176E  1F      	        RRA                     ; Test exponent for overflow
3386:	176F  A8      	        XOR     B
3387:	1770  78      	        LD      A,B             ; Get exponent
3388:	1771  F28517  	        JP      P,OVTST2        ; Positive - Test for overflow
3389:	1774  C680    	        ADD     A,80H           ; Add excess 128
3390:	1776  77      	        LD      (HL),A          ; Save new exponent
3391:	1777  CAE516  	        JP      Z,POPHRT        ; Zero - Result zero
3392:	177A  CD0A18  	        CALL    SIGNS           ; Set MSBs and sign of result
3393:	177D  77      	        LD      (HL),A          ; Save new exponent
3394:	177E  2B      	        DEC     HL              ; Point to MSB
3395:	177F  C9      	        RET
3396:			
3397:	1780  CDA417  	OVTST1: CALL    TSTSGN          ; Test sign of FPREG
3398:	1783  2F      	        CPL                     ; Invert sign
3399:	1784  E1      	        POP     HL              ; Clean up stack
3400:	1785  B7      	OVTST2: OR      A               ; Test if new exponent zero
3401:	1786  E1      	OVTST3: POP     HL              ; Clear off return address
3402:	1787  F2C415  	        JP      P,RESZER        ; Result zero
3403:	178A  C30C05  	        JP      OVERR           ; Overflow error
3404:			
3405:	178D  CDF017  	MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
3406:	1790  78      	        LD      A,B             ; Get exponent
3407:	1791  B7      	        OR      A               ; Is it zero?
3408:	1792  C8      	        RET     Z               ; Yes - Result is zero
3409:	1793  C602    	        ADD     A,2             ; Multiply by 4
3410:	1795  DA0C05  	        JP      C,OVERR         ; Overflow - ?OV Error
3411:	1798  47      	        LD      B,A             ; Re-save exponent
3412:	1799  CD5E15  	        CALL    FPADD           ; Add BCDE to FPREG (Times 5)
3413:	179C  212C21  	        LD      HL,FPEXP        ; Point to exponent
3414:	179F  34      	        INC     (HL)            ; Double number (Times 10)
3415:	17A0  C0      	        RET     NZ              ; Ok - Return
3416:	17A1  C30C05  	        JP      OVERR           ; Overflow error
3417:			
3418:	17A4  3A2C21  	TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
3419:	17A7  B7      	        OR      A
3420:	17A8  C8      	        RET     Z               ; RETurn if number is zero
3421:	17A9  3A2B21  	        LD      A,(FPREG+2)     ; Get MSB of FPREG
3422:	17AC  FE      	        .DB     0FEH            ; Test sign
3423:	17AD  2F      	RETREL: CPL                     ; Invert sign
3424:	17AE  17      	        RLA                     ; Sign bit to carry
3425:	17AF  9F      	FLGDIF: SBC     A,A             ; Carry to all bits of A
3426:	17B0  C0      	        RET     NZ              ; Return -1 if negative
3427:	17B1  3C      	        INC     A               ; Bump to +1
3428:	17B2  C9      	        RET                     ; Positive - Return +1
3429:			
3430:	17B3  CDA417  	SGN:    CALL    TSTSGN          ; Test sign of FPREG
3431:	17B6  0688    	FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
3432:	17B8  110000  	        LD      DE,0            ; Zero NMSB and LSB
3433:	17BB  212C21  	RETINT: LD      HL,FPEXP        ; Point to exponent
3434:	17BE  4F      	        LD      C,A             ; CDE = MSB,NMSB and LSB
3435:	17BF  70      	        LD      (HL),B          ; Save exponent
3436:	17C0  0600    	        LD      B,0             ; CDE = integer to normalise
3437:	17C2  23      	        INC     HL              ; Point to sign of result
3438:	17C3  3680    	        LD      (HL),80H        ; Set sign of result
3439:	17C5  17      	        RLA                     ; Carry = sign of integer
3440:	17C6  C3AC15  	        JP      CONPOS          ; Set sign of result
3441:			
3442:	17C9  CDA417  	ABS:    CALL    TSTSGN          ; Test sign of FPREG
3443:	17CC  F0      	        RET     P               ; Return if positive
3444:	17CD  212B21  	INVSGN: LD      HL,FPREG+2      ; Point to MSB
3445:	17D0  7E      	        LD      A,(HL)          ; Get sign of mantissa
3446:	17D1  EE80    	        XOR     80H             ; Invert sign of mantissa
3447:	17D3  77      	        LD      (HL),A          ; Re-save sign of mantissa
3448:	17D4  C9      	        RET
3449:			
3450:	17D5  EB      	STAKFP: EX      DE,HL           ; Save code string address
3451:	17D6  2A2921  	        LD      HL,(FPREG)      ; LSB,NLSB of FPREG
3452:	17D9  E3      	        EX      (SP),HL         ; Stack them,get return
3453:	17DA  E5      	        PUSH    HL              ; Re-save return
3454:	17DB  2A2B21  	        LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
3455:	17DE  E3      	        EX      (SP),HL         ; Stack them,get return
3456:	17DF  E5      	        PUSH    HL              ; Re-save return
3457:	17E0  EB      	        EX      DE,HL           ; Restore code string address
3458:	17E1  C9      	        RET
3459:			
3460:	17E2  CDF317  	PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
3461:	17E5  EB      	FPBCDE: EX      DE,HL           ; Save code string address
3462:	17E6  222921  	        LD      (FPREG),HL      ; Save LSB,NLSB of number
3463:	17E9  60      	        LD      H,B             ; Exponent of number
3464:	17EA  69      	        LD      L,C             ; MSB of number
3465:	17EB  222B21  	        LD      (FPREG+2),HL    ; Save MSB and exponent
3466:	17EE  EB      	        EX      DE,HL           ; Restore code string address
3467:	17EF  C9      	        RET
3468:			
3469:	17F0  212921  	BCDEFP: LD      HL,FPREG        ; Point to FPREG
3470:	17F3  5E      	LOADFP: LD      E,(HL)          ; Get LSB of number
3471:	17F4  23      	        INC     HL
3472:	17F5  56      	        LD      D,(HL)          ; Get NMSB of number
3473:	17F6  23      	        INC     HL
3474:	17F7  4E      	        LD      C,(HL)          ; Get MSB of number
3475:	17F8  23      	        INC     HL
3476:	17F9  46      	        LD      B,(HL)          ; Get exponent of number
3477:	17FA  23      	INCHL:  INC     HL              ; Used for conditional "INC HL"
3478:	17FB  C9      	        RET
3479:			
3480:	17FC  112921  	FPTHL:  LD      DE,FPREG        ; Point to FPREG
3481:	17FF  0604    	DETHL4: LD      B,4             ; 4 bytes to move
3482:	1801  1A      	DETHLB: LD      A,(DE)          ; Get source
3483:	1802  77      	        LD      (HL),A          ; Save destination
3484:	1803  13      	        INC     DE              ; Next source
3485:	1804  23      	        INC     HL              ; Next destination
3486:	1805  05      	        DEC     B               ; Count bytes
3487:	1806  C20118  	        JP      NZ,DETHLB       ; Loop if more
3488:	1809  C9      	        RET
3489:			
3490:	180A  212B21  	SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
3491:	180D  7E      	        LD      A,(HL)          ; Get MSB
3492:	180E  07      	        RLCA                    ; Old sign to carry
3493:	180F  37      	        SCF                     ; Set MSBit
3494:	1810  1F      	        RRA                     ; Set MSBit of MSB
3495:	1811  77      	        LD      (HL),A          ; Save new MSB
3496:	1812  3F      	        CCF                     ; Complement sign
3497:	1813  1F      	        RRA                     ; Old sign to carry
3498:	1814  23      	        INC     HL
3499:	1815  23      	        INC     HL
3500:	1816  77      	        LD      (HL),A          ; Set sign of result
3501:	1817  79      	        LD      A,C             ; Get MSB
3502:	1818  07      	        RLCA                    ; Old sign to carry
3503:	1819  37      	        SCF                     ; Set MSBit
3504:	181A  1F      	        RRA                     ; Set MSBit of MSB
3505:	181B  4F      	        LD      C,A             ; Save MSB
3506:	181C  1F      	        RRA
3507:	181D  AE      	        XOR     (HL)            ; New sign of result
3508:	181E  C9      	        RET
3509:			
3510:	181F  78      	CMPNUM: LD      A,B             ; Get exponent of number
3511:	1820  B7      	        OR      A
3512:	1821  CAA417  	        JP      Z,TSTSGN        ; Zero - Test sign of FPREG
3513:	1824  21AD17  	        LD      HL,RETREL       ; Return relation routine
3514:	1827  E5      	        PUSH    HL              ; Save for return
3515:	1828  CDA417  	        CALL    TSTSGN          ; Test sign of FPREG
3516:	182B  79      	        LD      A,C             ; Get MSB of number
3517:	182C  C8      	        RET     Z               ; FPREG zero - Number's MSB
3518:	182D  212B21  	        LD      HL,FPREG+2      ; MSB of FPREG
3519:	1830  AE      	        XOR     (HL)            ; Combine signs
3520:	1831  79      	        LD      A,C             ; Get MSB of number
3521:	1832  F8      	        RET     M               ; Exit if signs different
3522:	1833  CD3918  	        CALL    CMPFP           ; Compare FP numbers
3523:	1836  1F      	        RRA                     ; Get carry to sign
3524:	1837  A9      	        XOR     C               ; Combine with MSB of number
3525:	1838  C9      	        RET
3526:			
3527:	1839  23      	CMPFP:  INC     HL              ; Point to exponent
3528:	183A  78      	        LD      A,B             ; Get exponent
3529:	183B  BE      	        CP      (HL)            ; Compare exponents
3530:	183C  C0      	        RET     NZ              ; Different
3531:	183D  2B      	        DEC     HL              ; Point to MBS
3532:	183E  79      	        LD      A,C             ; Get MSB
3533:	183F  BE      	        CP      (HL)            ; Compare MSBs
3534:	1840  C0      	        RET     NZ              ; Different
3535:	1841  2B      	        DEC     HL              ; Point to NMSB
3536:	1842  7A      	        LD      A,D             ; Get NMSB
3537:	1843  BE      	        CP      (HL)            ; Compare NMSBs
3538:	1844  C0      	        RET     NZ              ; Different
3539:	1845  2B      	        DEC     HL              ; Point to LSB
3540:	1846  7B      	        LD      A,E             ; Get LSB
3541:	1847  96      	        SUB     (HL)            ; Compare LSBs
3542:	1848  C0      	        RET     NZ              ; Different
3543:	1849  E1      	        POP     HL              ; Drop RETurn
3544:	184A  E1      	        POP     HL              ; Drop another RETurn
3545:	184B  C9      	        RET
3546:			
3547:	184C  47      	FPINT:  LD      B,A             ; <- Move
3548:	184D  4F      	        LD      C,A             ; <- exponent
3549:	184E  57      	        LD      D,A             ; <- to all
3550:	184F  5F      	        LD      E,A             ; <- bits
3551:	1850  B7      	        OR      A               ; Test exponent
3552:	1851  C8      	        RET     Z               ; Zero - Return zero
3553:	1852  E5      	        PUSH    HL              ; Save pointer to number
3554:	1853  CDF017  	        CALL    BCDEFP          ; Move FPREG to BCDE
3555:	1856  CD0A18  	        CALL    SIGNS           ; Set MSBs & sign of result
3556:	1859  AE      	        XOR     (HL)            ; Combine with sign of FPREG
3557:	185A  67      	        LD      H,A             ; Save combined signs
3558:	185B  FC7018  	        CALL    M,DCBCDE        ; Negative - Decrement BCDE
3559:	185E  3E98    	        LD      A,80H+24        ; 24 bits
3560:	1860  90      	        SUB     B               ; Bits to shift
3561:	1861  CD2316  	        CALL    SCALE           ; Shift BCDE
3562:	1864  7C      	        LD      A,H             ; Get combined sign
3563:	1865  17      	        RLA                     ; Sign to carry
3564:	1866  DCF615  	        CALL    C,FPROND        ; Negative - Round number up
3565:	1869  0600    	        LD      B,0             ; Zero exponent
3566:	186B  DC0F16  	        CALL    C,COMPL         ; If negative make positive
3567:	186E  E1      	        POP     HL              ; Restore pointer to number
3568:	186F  C9      	        RET
3569:			
3570:	1870  1B      	DCBCDE: DEC     DE              ; Decrement BCDE
3571:	1871  7A      	        LD      A,D             ; Test LSBs
3572:	1872  A3      	        AND     E
3573:	1873  3C      	        INC     A
3574:	1874  C0      	        RET     NZ              ; Exit if LSBs not FFFF
3575:	1875  0B      	        DEC     BC              ; Decrement MSBs
3576:	1876  C9      	        RET
3577:			
3578:	1877  212C21  	INT:    LD      HL,FPEXP        ; Point to exponent
3579:	187A  7E      	        LD      A,(HL)          ; Get exponent
3580:	187B  FE98    	        CP      80H+24          ; Integer accuracy only?
3581:	187D  3A2921  	        LD      A,(FPREG)       ; Get LSB
3582:	1880  D0      	        RET     NC              ; Yes - Already integer
3583:	1881  7E      	        LD      A,(HL)          ; Get exponent
3584:	1882  CD4C18  	        CALL    FPINT           ; F.P to integer
3585:	1885  3698    	        LD      (HL),80H+24     ; Save 24 bit integer
3586:	1887  7B      	        LD      A,E             ; Get LSB of number
3587:	1888  F5      	        PUSH    AF              ; Save LSB
3588:	1889  79      	        LD      A,C             ; Get MSB of number
3589:	188A  17      	        RLA                     ; Sign to carry
3590:	188B  CDAC15  	        CALL    CONPOS          ; Set sign of result
3591:	188E  F1      	        POP     AF              ; Restore LSB of number
3592:	188F  C9      	        RET
3593:			
3594:	1890  210000  	MLDEBC: LD      HL,0            ; Clear partial product
3595:	1893  78      	        LD      A,B             ; Test multiplier
3596:	1894  B1      	        OR      C
3597:	1895  C8      	        RET     Z               ; Return zero if zero
3598:	1896  3E10    	        LD      A,16            ; 16 bits
3599:	1898  29      	MLDBLP: ADD     HL,HL           ; Shift P.P left
3600:	1899  DAD010  	        JP      C,BSERR         ; ?BS Error if overflow
3601:	189C  EB      	        EX      DE,HL
3602:	189D  29      	        ADD     HL,HL           ; Shift multiplier left
3603:	189E  EB      	        EX      DE,HL
3604:	189F  D2A618  	        JP      NC,NOMLAD       ; Bit was zero - No add
3605:	18A2  09      	        ADD     HL,BC           ; Add multiplicand
3606:	18A3  DAD010  	        JP      C,BSERR         ; ?BS Error if overflow
3607:	18A6  3D      	NOMLAD: DEC     A               ; Count bits
3608:	18A7  C29818  	        JP      NZ,MLDBLP       ; More
3609:	18AA  C9      	        RET
3610:			
3611:	18AB  FE2D    	ASCTFP: CP      '-'             ; Negative?
3612:	18AD  F5      	        PUSH    AF              ; Save it and flags
3613:	18AE  CAB718  	        JP      Z,CNVNUM        ; Yes - Convert number
3614:	18B1  FE2B    	        CP      '+'             ; Positive?
3615:	18B3  CAB718  	        JP      Z,CNVNUM        ; Yes - Convert number
3616:	18B6  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
3617:	18B7  CDC415  	CNVNUM: CALL    RESZER          ; Set result to zero
3618:	18BA  47      	        LD      B,A             ; Digits after point counter
3619:	18BB  57      	        LD      D,A             ; Sign of exponent
3620:	18BC  5F      	        LD      E,A             ; Exponent of ten
3621:	18BD  2F      	        CPL
3622:	18BE  4F      	        LD      C,A             ; Before or after point flag
3623:	18BF  CD5509  	MANLP:  CALL    GETCHR          ; Get next character
3624:	18C2  DA0819  	        JP      C,ADDIG         ; Digit - Add to number
3625:	18C5  FE2E    	        CP      '.'
3626:	18C7  CAE318  	        JP      Z,DPOINT        ; '.' - Flag point
3627:	18CA  FE45    	        CP      'E'
3628:	18CC  C2E718  	        JP      NZ,CONEXP       ; Not 'E' - Scale number
3629:	18CF  CD5509  	        CALL    GETCHR          ; Get next character
3630:	18D2  CDFB0E  	        CALL    SGNEXP          ; Get sign of exponent
3631:	18D5  CD5509  	EXPLP:  CALL    GETCHR          ; Get next character
3632:	18D8  DA2A19  	        JP      C,EDIGIT        ; Digit - Add to exponent
3633:	18DB  14      	        INC     D               ; Is sign negative?
3634:	18DC  C2E718  	        JP      NZ,CONEXP       ; No - Scale number
3635:	18DF  AF      	        XOR     A
3636:	18E0  93      	        SUB     E               ; Negate exponent
3637:	18E1  5F      	        LD      E,A             ; And re-save it
3638:	18E2  0C      	        INC     C               ; Flag end of number
3639:	18E3  0C      	DPOINT: INC     C               ; Flag point passed
3640:	18E4  CABF18  	        JP      Z,MANLP         ; Zero - Get another digit
3641:	18E7  E5      	CONEXP: PUSH    HL              ; Save code string address
3642:	18E8  7B      	        LD      A,E             ; Get exponent
3643:	18E9  90      	        SUB     B               ; Subtract digits after point
3644:	18EA  F40019  	SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
3645:	18ED  F2F618  	        JP      P,ENDCON        ; Positive - All done
3646:	18F0  F5      	        PUSH    AF              ; Save number of times to /10
3647:	18F1  CDEC16  	        CALL    DIV10           ; Divide by 10
3648:	18F4  F1      	        POP     AF              ; Restore count
3649:	18F5  3C      	        INC     A               ; Count divides
3650:			
3651:	18F6  C2EA18  	ENDCON: JP      NZ,SCALMI       ; More to do
3652:	18F9  D1      	        POP     DE              ; Restore code string address
3653:	18FA  F1      	        POP     AF              ; Restore sign of number
3654:	18FB  CCCD17  	        CALL    Z,INVSGN        ; Negative - Negate number
3655:	18FE  EB      	        EX      DE,HL           ; Code string address to HL
3656:	18FF  C9      	        RET
3657:			
3658:	1900  C8      	SCALPL: RET     Z               ; Exit if no scaling needed
3659:	1901  F5      	MULTEN: PUSH    AF              ; Save count
3660:	1902  CD8D17  	        CALL    MLSP10          ; Multiply number by 10
3661:	1905  F1      	        POP     AF              ; Restore count
3662:	1906  3D      	        DEC     A               ; Count multiplies
3663:	1907  C9      	        RET
3664:			
3665:	1908  D5      	ADDIG:  PUSH    DE              ; Save sign of exponent
3666:	1909  57      	        LD      D,A             ; Save digit
3667:	190A  78      	        LD      A,B             ; Get digits after point
3668:	190B  89      	        ADC     A,C             ; Add one if after point
3669:	190C  47      	        LD      B,A             ; Re-save counter
3670:	190D  C5      	        PUSH    BC              ; Save point flags
3671:	190E  E5      	        PUSH    HL              ; Save code string address
3672:	190F  D5      	        PUSH    DE              ; Save digit
3673:	1910  CD8D17  	        CALL    MLSP10          ; Multiply number by 10
3674:	1913  F1      	        POP     AF              ; Restore digit
3675:	1914  D630    	        SUB     '0'             ; Make it absolute
3676:	1916  CD1F19  	        CALL    RSCALE          ; Re-scale number
3677:	1919  E1      	        POP     HL              ; Restore code string address
3678:	191A  C1      	        POP     BC              ; Restore point flags
3679:	191B  D1      	        POP     DE              ; Restore sign of exponent
3680:	191C  C3BF18  	        JP      MANLP           ; Get another digit
3681:			
3682:	191F  CDD517  	RSCALE: CALL    STAKFP          ; Put number on stack
3683:	1922  CDB617  	        CALL    FLGREL          ; Digit to add to FPREG
3684:	1925  C1      	PADD:   POP     BC              ; Restore number
3685:	1926  D1      	        POP     DE
3686:	1927  C35E15  	        JP      FPADD           ; Add BCDE to FPREG and return
3687:			
3688:	192A  7B      	EDIGIT: LD      A,E             ; Get digit
3689:	192B  07      	        RLCA                    ; Times 2
3690:	192C  07      	        RLCA                    ; Times 4
3691:	192D  83      	        ADD     A,E             ; Times 5
3692:	192E  07      	        RLCA                    ; Times 10
3693:	192F  86      	        ADD     A,(HL)          ; Add next digit
3694:	1930  D630    	        SUB     '0'             ; Make it absolute
3695:	1932  5F      	        LD      E,A             ; Save new digit
3696:	1933  C3D518  	        JP      EXPLP           ; Look for another digit
3697:			
3698:	1936  E5      	LINEIN: PUSH    HL              ; Save code string address
3699:	1937  219504  	        LD      HL,INMSG        ; Output " in "
3700:	193A  CD9B12  	        CALL    PRS             ; Output string at HL
3701:	193D  E1      	        POP     HL              ; Restore code string address
3702:	193E  EB      	PRNTHL: EX      DE,HL           ; Code string address to DE
3703:	193F  AF      	        XOR     A
3704:	1940  0698    	        LD      B,80H+24        ; 24 bits
3705:	1942  CDBB17  	        CALL    RETINT          ; Return the integer
3706:	1945  219A12  	        LD      HL,PRNUMS       ; Print number string
3707:	1948  E5      	        PUSH    HL              ; Save for return
3708:	1949  212E21  	NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
3709:	194C  E5      	        PUSH    HL              ; Save for return
3710:	194D  CDA417  	        CALL    TSTSGN          ; Test sign of FPREG
3711:	1950  3620    	        LD      (HL),' '        ; Space at start
3712:	1952  F25719  	        JP      P,SPCFST        ; Positive - Space to start
3713:	1955  362D    	        LD      (HL),'-'        ; '-' sign at start
3714:	1957  23      	SPCFST: INC     HL              ; First byte of number
3715:	1958  3630    	        LD      (HL),'0'        ; '0' if zero
3716:	195A  CA0D1A  	        JP      Z,JSTZER        ; Return '0' if zero
3717:	195D  E5      	        PUSH    HL              ; Save buffer address
3718:	195E  FCCD17  	        CALL    M,INVSGN        ; Negate FPREG if negative
3719:	1961  AF      	        XOR     A               ; Zero A
3720:	1962  F5      	        PUSH    AF              ; Save it
3721:	1963  CD131A  	        CALL    RNGTST          ; Test number is in range
3722:	1966  014391  	SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
3723:	1969  11F84F  	        LD      DE,4FF8H
3724:	196C  CD1F18  	        CALL    CMPNUM          ; Compare numbers
3725:	196F  B7      	        OR      A
3726:	1970  E28419  	        JP      PO,INRNG        ; > 99999.9 - Sort it out
3727:	1973  F1      	        POP     AF              ; Restore count
3728:	1974  CD0119  	        CALL    MULTEN          ; Multiply by ten
3729:	1977  F5      	        PUSH    AF              ; Re-save count
3730:	1978  C36619  	        JP      SIXDIG          ; Test it again
3731:			
3732:	197B  CDEC16  	GTSIXD: CALL    DIV10           ; Divide by 10
3733:	197E  F1      	        POP     AF              ; Get count
3734:	197F  3C      	        INC     A               ; Count divides
3735:	1980  F5      	        PUSH    AF              ; Re-save count
3736:	1981  CD131A  	        CALL    RNGTST          ; Test number is in range
3737:	1984  CD4C15  	INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
3738:	1987  3C      	        INC     A
3739:	1988  CD4C18  	        CALL    FPINT           ; F.P to integer
3740:	198B  CDE517  	        CALL    FPBCDE          ; Move BCDE to FPREG
3741:	198E  010603  	        LD      BC,0306H        ; 1E+06 to 1E-03 range
3742:	1991  F1      	        POP     AF              ; Restore count
3743:	1992  81      	        ADD     A,C             ; 6 digits before point
3744:	1993  3C      	        INC     A               ; Add one
3745:	1994  FAA019  	        JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
3746:	1997  FE08    	        CP      6+1+1           ; More than 999999 ?
3747:	1999  D2A019  	        JP      NC,MAKNUM       ; Yes - Do it in 'E' form
3748:	199C  3C      	        INC     A               ; Adjust for exponent
3749:	199D  47      	        LD      B,A             ; Exponent of number
3750:	199E  3E02    	        LD      A,2             ; Make it zero after
3751:			
3752:	19A0  3D      	MAKNUM: DEC     A               ; Adjust for digits to do
3753:	19A1  3D      	        DEC     A
3754:	19A2  E1      	        POP     HL              ; Restore buffer address
3755:	19A3  F5      	        PUSH    AF              ; Save count
3756:	19A4  11261A  	        LD      DE,POWERS       ; Powers of ten
3757:	19A7  05      	        DEC     B               ; Count digits before point
3758:	19A8  C2B119  	        JP      NZ,DIGTXT       ; Not zero - Do number
3759:	19AB  362E    	        LD      (HL),'.'        ; Save point
3760:	19AD  23      	        INC     HL              ; Move on
3761:	19AE  3630    	        LD      (HL),'0'        ; Save zero
3762:	19B0  23      	        INC     HL              ; Move on
3763:	19B1  05      	DIGTXT: DEC     B               ; Count digits before point
3764:	19B2  362E    	        LD      (HL),'.'        ; Save point in case
3765:	19B4  CCFA17  	        CALL    Z,INCHL         ; Last digit - move on
3766:	19B7  C5      	        PUSH    BC              ; Save digits before point
3767:	19B8  E5      	        PUSH    HL              ; Save buffer address
3768:	19B9  D5      	        PUSH    DE              ; Save powers of ten
3769:	19BA  CDF017  	        CALL    BCDEFP          ; Move FPREG to BCDE
3770:	19BD  E1      	        POP     HL              ; Powers of ten table
3771:	19BE  062F    	        LD      B, '0'-1        ; ASCII '0' - 1
3772:	19C0  04      	TRYAGN: INC     B               ; Count subtractions
3773:	19C1  7B      	        LD      A,E             ; Get LSB
3774:	19C2  96      	        SUB     (HL)            ; Subtract LSB
3775:	19C3  5F      	        LD      E,A             ; Save LSB
3776:	19C4  23      	        INC     HL
3777:	19C5  7A      	        LD      A,D             ; Get NMSB
3778:	19C6  9E      	        SBC     A,(HL)          ; Subtract NMSB
3779:	19C7  57      	        LD      D,A             ; Save NMSB
3780:	19C8  23      	        INC     HL
3781:	19C9  79      	        LD      A,C             ; Get MSB
3782:	19CA  9E      	        SBC     A,(HL)          ; Subtract MSB
3783:	19CB  4F      	        LD      C,A             ; Save MSB
3784:	19CC  2B      	        DEC     HL              ; Point back to start
3785:	19CD  2B      	        DEC     HL
3786:	19CE  D2C019  	        JP      NC,TRYAGN       ; No overflow - Try again
3787:	19D1  CD0316  	        CALL    PLUCDE          ; Restore number
3788:	19D4  23      	        INC     HL              ; Start of next number
3789:	19D5  CDE517  	        CALL    FPBCDE          ; Move BCDE to FPREG
3790:	19D8  EB      	        EX      DE,HL           ; Save point in table
3791:	19D9  E1      	        POP     HL              ; Restore buffer address
3792:	19DA  70      	        LD      (HL),B          ; Save digit in buffer
3793:	19DB  23      	        INC     HL              ; And move on
3794:	19DC  C1      	        POP     BC              ; Restore digit count
3795:	19DD  0D      	        DEC     C               ; Count digits
3796:	19DE  C2B119  	        JP      NZ,DIGTXT       ; More - Do them
3797:	19E1  05      	        DEC     B               ; Any decimal part?
3798:	19E2  CAF119  	        JP      Z,DOEBIT        ; No - Do 'E' bit
3799:	19E5  2B      	SUPTLZ: DEC     HL              ; Move back through buffer
3800:	19E6  7E      	        LD      A,(HL)          ; Get character
3801:	19E7  FE30    	        CP      '0'             ; '0' character?
3802:	19E9  CAE519  	        JP      Z,SUPTLZ        ; Yes - Look back for more
3803:	19EC  FE2E    	        CP      '.'             ; A decimal point?
3804:	19EE  C4FA17  	        CALL    NZ,INCHL        ; Move back over digit
3805:			
3806:	19F1  F1      	DOEBIT: POP     AF              ; Get 'E' flag
3807:	19F2  CA101A  	        JP      Z,NOENED        ; No 'E' needed - End buffer
3808:	19F5  3645    	        LD      (HL),'E'        ; Put 'E' in buffer
3809:	19F7  23      	        INC     HL              ; And move on
3810:	19F8  362B    	        LD      (HL),'+'        ; Put '+' in buffer
3811:	19FA  F2011A  	        JP      P,OUTEXP        ; Positive - Output exponent
3812:	19FD  362D    	        LD      (HL),'-'        ; Put '-' in buffer
3813:	19FF  2F      	        CPL                     ; Negate exponent
3814:	1A00  3C      	        INC     A
3815:	1A01  062F    	OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
3816:	1A03  04      	EXPTEN: INC     B               ; Count subtractions
3817:	1A04  D60A    	        SUB     10              ; Tens digit
3818:	1A06  D2031A  	        JP      NC,EXPTEN       ; More to do
3819:	1A09  C63A    	        ADD     A,'0'+10        ; Restore and make ASCII
3820:	1A0B  23      	        INC     HL              ; Move on
3821:	1A0C  70      	        LD      (HL),B          ; Save MSB of exponent
3822:	1A0D  23      	JSTZER: INC     HL              ;
3823:	1A0E  77      	        LD      (HL),A          ; Save LSB of exponent
3824:	1A0F  23      	        INC     HL
3825:	1A10  71      	NOENED: LD      (HL),C          ; Mark end of buffer
3826:	1A11  E1      	        POP     HL              ; Restore code string address
3827:	1A12  C9      	        RET
3828:			
3829:	1A13  017494  	RNGTST: LD      BC,9474H        ; BCDE = 999999.
3830:	1A16  11F723  	        LD      DE,23F7H
3831:	1A19  CD1F18  	        CALL    CMPNUM          ; Compare numbers
3832:	1A1C  B7      	        OR      A
3833:	1A1D  E1      	        POP     HL              ; Return address to HL
3834:	1A1E  E27B19  	        JP      PO,GTSIXD       ; Too big - Divide by ten
3835:	1A21  E9      	        JP      (HL)            ; Otherwise return to caller
3836:			
3837:	1A22  00000080	HALF:   .DB     00H,00H,00H,80H ; 0.5
3838:			
3839:	1A26  A08601  	POWERS: .DB     0A0H,086H,001H  ; 100000
3840:	1A29  102700  	        .DB     010H,027H,000H  ;  10000
3841:	1A2C  E80300  	        .DB     0E8H,003H,000H  ;   1000
3842:	1A2F  640000  	        .DB     064H,000H,000H  ;    100
3843:	1A32  0A0000  	        .DB     00AH,000H,000H  ;     10
3844:	1A35  010000  	        .DB     001H,000H,000H  ;      1
3845:			
3846:	1A38  21CD17  	NEGAFT: LD      HL,INVSGN       ; Negate result
3847:	1A3B  E3      	        EX      (SP),HL         ; To be done after caller
3848:	1A3C  E9      	        JP      (HL)            ; Return to caller
3849:			
3850:	1A3D  CDD517  	SQR:    CALL    STAKFP          ; Put value on stack
3851:	1A40  21221A  	        LD      HL,HALF         ; Set power to 1/2
3852:	1A43  CDE217  	        CALL    PHLTFP          ; Move 1/2 to FPREG
3853:			
3854:	1A46  C1      	POWER:  POP     BC              ; Get base
3855:	1A47  D1      	        POP     DE
3856:	1A48  CDA417  	        CALL    TSTSGN          ; Test sign of power
3857:	1A4B  78      	        LD      A,B             ; Get exponent of base
3858:	1A4C  CA8B1A  	        JP      Z,EXP           ; Make result 1 if zero
3859:	1A4F  F2561A  	        JP      P,POWER1        ; Positive base - Ok
3860:	1A52  B7      	        OR      A               ; Zero to negative power?
3861:	1A53  CA0005  	        JP      Z,DZERR         ; Yes - ?/0 Error
3862:	1A56  B7      	POWER1: OR      A               ; Base zero?
3863:	1A57  CAC515  	        JP      Z,SAVEXP        ; Yes - Return zero
3864:	1A5A  D5      	        PUSH    DE              ; Save base
3865:	1A5B  C5      	        PUSH    BC
3866:	1A5C  79      	        LD      A,C             ; Get MSB of base
3867:	1A5D  F67F    	        OR      01111111B       ; Get sign status
3868:	1A5F  CDF017  	        CALL    BCDEFP          ; Move power to BCDE
3869:	1A62  F2731A  	        JP      P,POWER2        ; Positive base - Ok
3870:	1A65  D5      	        PUSH    DE              ; Save power
3871:	1A66  C5      	        PUSH    BC
3872:	1A67  CD7718  	        CALL    INT             ; Get integer of power
3873:	1A6A  C1      	        POP     BC              ; Restore power
3874:	1A6B  D1      	        POP     DE
3875:	1A6C  F5      	        PUSH    AF              ; MSB of base
3876:	1A6D  CD1F18  	        CALL    CMPNUM          ; Power an integer?
3877:	1A70  E1      	        POP     HL              ; Restore MSB of base
3878:	1A71  7C      	        LD      A,H             ; but don't affect flags
3879:	1A72  1F      	        RRA                     ; Exponent odd or even?
3880:	1A73  E1      	POWER2: POP     HL              ; Restore MSB and exponent
3881:	1A74  222B21  	        LD      (FPREG+2),HL    ; Save base in FPREG
3882:	1A77  E1      	        POP     HL              ; LSBs of base
3883:	1A78  222921  	        LD      (FPREG),HL      ; Save in FPREG
3884:	1A7B  DC381A  	        CALL    C,NEGAFT        ; Odd power - Negate result
3885:	1A7E  CCCD17  	        CALL    Z,INVSGN        ; Negative base - Negate it
3886:	1A81  D5      	        PUSH    DE              ; Save power
3887:	1A82  C5      	        PUSH    BC
3888:	1A83  CD5816  	        CALL    LOG             ; Get LOG of base
3889:	1A86  C1      	        POP     BC              ; Restore power
3890:	1A87  D1      	        POP     DE
3891:	1A88  CD9916  	        CALL    FPMULT          ; Multiply LOG by power
3892:			
3893:	1A8B  CDD517  	EXP:    CALL    STAKFP          ; Put value on stack
3894:	1A8E  013881  	        LD      BC,08138H       ; BCDE = 1/Ln(2)
3895:	1A91  113BAA  	        LD      DE,0AA3BH
3896:	1A94  CD9916  	        CALL    FPMULT          ; Multiply value by 1/LN(2)
3897:	1A97  3A2C21  	        LD      A,(FPEXP)       ; Get exponent
3898:	1A9A  FE88    	        CP      80H+8           ; Is it in range?
3899:	1A9C  D28017  	        JP      NC,OVTST1       ; No - Test for overflow
3900:	1A9F  CD7718  	        CALL    INT             ; Get INT of FPREG
3901:	1AA2  C680    	        ADD     A,80H           ; For excess 128
3902:	1AA4  C602    	        ADD     A,2             ; Exponent > 126?
3903:	1AA6  DA8017  	        JP      C,OVTST1        ; Yes - Test for overflow
3904:	1AA9  F5      	        PUSH    AF              ; Save scaling factor
3905:	1AAA  214716  	        LD      HL,UNITY        ; Point to 1.
3906:	1AAD  CD4F15  	        CALL    ADDPHL          ; Add 1 to FPREG
3907:	1AB0  CD9016  	        CALL    MULLN2          ; Multiply by LN(2)
3908:	1AB3  F1      	        POP     AF              ; Restore scaling factor
3909:	1AB4  C1      	        POP     BC              ; Restore exponent
3910:	1AB5  D1      	        POP     DE
3911:	1AB6  F5      	        PUSH    AF              ; Save scaling factor
3912:	1AB7  CD5B15  	        CALL    SUBCDE          ; Subtract exponent from FPREG
3913:	1ABA  CDCD17  	        CALL    INVSGN          ; Negate result
3914:	1ABD  21CB1A  	        LD      HL,EXPTAB       ; Coefficient table
3915:	1AC0  CDFB1A  	        CALL    SMSER1          ; Sum the series
3916:	1AC3  110000  	        LD      DE,0            ; Zero LSBs
3917:	1AC6  C1      	        POP     BC              ; Scaling factor
3918:	1AC7  4A      	        LD      C,D             ; Zero MSB
3919:	1AC8  C39916  	        JP      FPMULT          ; Scale result to correct value
3920:			
3921:	1ACB  08      	EXPTAB: .DB     8                       ; Table used by EXP
3922:	1ACC  402E9474	        .DB     040H,02EH,094H,074H     ; -1/7! (-1/5040)
3923:	1AD0  704F2E77	        .DB     070H,04FH,02EH,077H     ;  1/6! ( 1/720)
3924:	1AD4  6E02887A	        .DB     06EH,002H,088H,07AH     ; -1/5! (-1/120)
3925:	1AD8  E6A02A7C	        .DB     0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
3926:	1ADC  50AAAA7E	        .DB     050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
3927:	1AE0  FFFF7F7F	        .DB     0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
3928:	1AE4  00008081	        .DB     000H,000H,080H,081H     ; -1/1! (-1/1)
3929:	1AE8  00000081	        .DB     000H,000H,000H,081H     ;  1/0! ( 1/1)
3930:			
3931:	1AEC  CDD517  	SUMSER: CALL    STAKFP          ; Put FPREG on stack
3932:	1AEF  119716  	        LD      DE,MULT         ; Multiply by "X"
3933:	1AF2  D5      	        PUSH    DE              ; To be done after
3934:	1AF3  E5      	        PUSH    HL              ; Save address of table
3935:	1AF4  CDF017  	        CALL    BCDEFP          ; Move FPREG to BCDE
3936:	1AF7  CD9916  	        CALL    FPMULT          ; Square the value
3937:	1AFA  E1      	        POP     HL              ; Restore address of table
3938:	1AFB  CDD517  	SMSER1: CALL    STAKFP          ; Put value on stack
3939:	1AFE  7E      	        LD      A,(HL)          ; Get number of coefficients
3940:	1AFF  23      	        INC     HL              ; Point to start of table
3941:	1B00  CDE217  	        CALL    PHLTFP          ; Move coefficient to FPREG
3942:	1B03  06      	        .DB     06H             ; Skip "POP AF"
3943:	1B04  F1      	SUMLP:  POP     AF              ; Restore count
3944:	1B05  C1      	        POP     BC              ; Restore number
3945:	1B06  D1      	        POP     DE
3946:	1B07  3D      	        DEC     A               ; Cont coefficients
3947:	1B08  C8      	        RET     Z               ; All done
3948:	1B09  D5      	        PUSH    DE              ; Save number
3949:	1B0A  C5      	        PUSH    BC
3950:	1B0B  F5      	        PUSH    AF              ; Save count
3951:	1B0C  E5      	        PUSH    HL              ; Save address in table
3952:	1B0D  CD9916  	        CALL    FPMULT          ; Multiply FPREG by BCDE
3953:	1B10  E1      	        POP     HL              ; Restore address in table
3954:	1B11  CDF317  	        CALL    LOADFP          ; Number at HL to BCDE
3955:	1B14  E5      	        PUSH    HL              ; Save address in table
3956:	1B15  CD5E15  	        CALL    FPADD           ; Add coefficient to FPREG
3957:	1B18  E1      	        POP     HL              ; Restore address in table
3958:	1B19  C3041B  	        JP      SUMLP           ; More coefficients
3959:			
3960:	1B1C  CDA417  	RND:    CALL    TSTSGN          ; Test sign of FPREG
3961:	1B1F  215E20  	        LD      HL,SEED+2       ; Random number seed
3962:	1B22  FA7D1B  	        JP      M,RESEED        ; Negative - Re-seed
3963:	1B25  217F20  	        LD      HL,LSTRND       ; Last random number
3964:	1B28  CDE217  	        CALL    PHLTFP          ; Move last RND to FPREG
3965:	1B2B  215E20  	        LD      HL,SEED+2       ; Random number seed
3966:	1B2E  C8      	        RET     Z               ; Return if RND(0)
3967:	1B2F  86      	        ADD     A,(HL)          ; Add (SEED)+2)
3968:	1B30  E607    	        AND     00000111B       ; 0 to 7
3969:	1B32  0600    	        LD      B,0
3970:	1B34  77      	        LD      (HL),A          ; Re-save seed
3971:	1B35  23      	        INC     HL              ; Move to coefficient table
3972:	1B36  87      	        ADD     A,A             ; 4 bytes
3973:	1B37  87      	        ADD     A,A             ; per entry
3974:	1B38  4F      	        LD      C,A             ; BC = Offset into table
3975:	1B39  09      	        ADD     HL,BC           ; Point to coefficient
3976:	1B3A  CDF317  	        CALL    LOADFP          ; Coefficient to BCDE
3977:	1B3D  CD9916  	        CALL    FPMULT  ;       ; Multiply FPREG by coefficient
3978:	1B40  3A5D20  	        LD      A,(SEED+1)      ; Get (SEED+1)
3979:	1B43  3C      	        INC     A               ; Add 1
3980:	1B44  E603    	        AND     00000011B       ; 0 to 3
3981:	1B46  0600    	        LD      B,0
3982:	1B48  FE01    	        CP      1               ; Is it zero?
3983:	1B4A  88      	        ADC     A,B             ; Yes - Make it 1
3984:	1B4B  325D20  	        LD      (SEED+1),A      ; Re-save seed
3985:	1B4E  21811B  	        LD      HL,RNDTAB-4     ; Addition table
3986:	1B51  87      	        ADD     A,A             ; 4 bytes
3987:	1B52  87      	        ADD     A,A             ; per entry
3988:	1B53  4F      	        LD      C,A             ; BC = Offset into table
3989:	1B54  09      	        ADD     HL,BC           ; Point to value
3990:	1B55  CD4F15  	        CALL    ADDPHL          ; Add value to FPREG
3991:	1B58  CDF017  	RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
3992:	1B5B  7B      	        LD      A,E             ; Get LSB
3993:	1B5C  59      	        LD      E,C             ; LSB = MSB
3994:	1B5D  EE4F    	        XOR     01001111B       ; Fiddle around
3995:	1B5F  4F      	        LD      C,A             ; New MSB
3996:	1B60  3680    	        LD      (HL),80H        ; Set exponent
3997:	1B62  2B      	        DEC     HL              ; Point to MSB
3998:	1B63  46      	        LD      B,(HL)          ; Get MSB
3999:	1B64  3680    	        LD      (HL),80H        ; Make value -0.5
4000:	1B66  215C20  	        LD      HL,SEED         ; Random number seed
4001:	1B69  34      	        INC     (HL)            ; Count seed
4002:	1B6A  7E      	        LD      A,(HL)          ; Get seed
4003:	1B6B  D6AB    	        SUB     171             ; Do it modulo 171
4004:	1B6D  C2741B  	        JP      NZ,RND2         ; Non-zero - Ok
4005:	1B70  77      	        LD      (HL),A          ; Zero seed
4006:	1B71  0C      	        INC     C               ; Fillde about
4007:	1B72  15      	        DEC     D               ; with the
4008:	1B73  1C      	        INC     E               ; number
4009:	1B74  CDAF15  	RND2:   CALL    BNORM           ; Normalise number
4010:	1B77  217F20  	        LD      HL,LSTRND       ; Save random number
4011:	1B7A  C3FC17  	        JP      FPTHL           ; Move FPREG to last and return
4012:			
4013:	1B7D  77      	RESEED: LD      (HL),A          ; Re-seed random numbers
4014:	1B7E  2B      	        DEC     HL
4015:	1B7F  77      	        LD      (HL),A
4016:	1B80  2B      	        DEC     HL
4017:	1B81  77      	        LD      (HL),A
4018:	1B82  C3581B  	        JP      RND1            ; Return RND seed
4019:			
4020:	1B85  68B14668	RNDTAB: .DB  068H,0B1H,046H,068H     ; Table used by RND
4021:	1B89  99E99269	        .DB  099H,0E9H,092H,069H
4022:	1B8D  10D17568	        .DB  010H,0D1H,075H,068H
4023:			
4024:	1B91  21DB1B  	COS:    LD      HL,HALFPI       ; Point to PI/2
4025:	1B94  CD4F15  	        CALL    ADDPHL          ; Add it to PPREG
4026:	1B97  CDD517  	SIN:    CALL    STAKFP          ; Put angle on stack
4027:	1B9A  014983  	        LD      BC,8349H        ; BCDE = 2 PI
4028:	1B9D  11DB0F  	        LD      DE,0FDBH
4029:	1BA0  CDE517  	        CALL    FPBCDE          ; Move 2 PI to FPREG
4030:	1BA3  C1      	        POP     BC              ; Restore angle
4031:	1BA4  D1      	        POP     DE
4032:	1BA5  CDFA16  	        CALL    DVBCDE          ; Divide angle by 2 PI
4033:	1BA8  CDD517  	        CALL    STAKFP          ; Put it on stack
4034:	1BAB  CD7718  	        CALL    INT             ; Get INT of result
4035:	1BAE  C1      	        POP     BC              ; Restore number
4036:	1BAF  D1      	        POP     DE
4037:	1BB0  CD5B15  	        CALL    SUBCDE          ; Make it 0 <= value < 1
4038:	1BB3  21DF1B  	        LD      HL,QUARTR       ; Point to 0.25
4039:	1BB6  CD5515  	        CALL    SUBPHL          ; Subtract value from 0.25
4040:	1BB9  CDA417  	        CALL    TSTSGN          ; Test sign of value
4041:	1BBC  37      	        SCF                     ; Flag positive
4042:	1BBD  F2C71B  	        JP      P,SIN1          ; Positive - Ok
4043:	1BC0  CD4C15  	        CALL    ROUND           ; Add 0.5 to value
4044:	1BC3  CDA417  	        CALL    TSTSGN          ; Test sign of value
4045:	1BC6  B7      	        OR      A               ; Flag negative
4046:	1BC7  F5      	SIN1:   PUSH    AF              ; Save sign
4047:	1BC8  F4CD17  	        CALL    P,INVSGN        ; Negate value if positive
4048:	1BCB  21DF1B  	        LD      HL,QUARTR       ; Point to 0.25
4049:	1BCE  CD4F15  	        CALL    ADDPHL          ; Add 0.25 to value
4050:	1BD1  F1      	        POP     AF              ; Restore sign
4051:	1BD2  D4CD17  	        CALL    NC,INVSGN       ; Negative - Make positive
4052:	1BD5  21E31B  	        LD      HL,SINTAB       ; Coefficient table
4053:	1BD8  C3EC1A  	        JP      SUMSER          ; Evaluate sum of series
4054:			
4055:	1BDB  DB0F4981	HALFPI: .DB  0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
4056:			
4057:	1BDF  0000007F	QUARTR: .DB  000H,000H,000H,07FH     ; 0.25
4058:			
4059:	1BE3  05      	SINTAB: .DB  5                       ; Table used by SIN
4060:	1BE4  BAD71E86	        .DB  0BAH,0D7H,01EH,086H     ; 39.711
4061:	1BE8  64269987	        .DB  064H,026H,099H,087H     ;-76.575
4062:	1BEC  58342387	        .DB  058H,034H,023H,087H     ; 81.602
4063:	1BF0  E05DA586	        .DB  0E0H,05DH,0A5H,086H     ;-41.342
4064:	1BF4  DA0F4983	        .DB  0DAH,00FH,049H,083H     ;  6.2832
4065:			
4066:	1BF8  CDD517  	TAN:    CALL    STAKFP          ; Put angle on stack
4067:	1BFB  CD971B  	        CALL    SIN             ; Get SIN of angle
4068:	1BFE  C1      	        POP     BC              ; Restore angle
4069:	1BFF  E1      	        POP     HL
4070:	1C00  CDD517  	        CALL    STAKFP          ; Save SIN of angle
4071:	1C03  EB      	        EX      DE,HL           ; BCDE = Angle
4072:	1C04  CDE517  	        CALL    FPBCDE          ; Angle to FPREG
4073:	1C07  CD911B  	        CALL    COS             ; Get COS of angle
4074:	1C0A  C3F816  	        JP      DIV             ; TAN = SIN / COS
4075:			
4076:	1C0D  CDA417  	ATN:    CALL    TSTSGN          ; Test sign of value
4077:	1C10  FC381A  	        CALL    M,NEGAFT        ; Negate result after if -ve
4078:	1C13  FCCD17  	        CALL    M,INVSGN        ; Negate value if -ve
4079:	1C16  3A2C21  	        LD      A,(FPEXP)       ; Get exponent
4080:	1C19  FE81    	        CP      81H             ; Number less than 1?
4081:	1C1B  DA2A1C  	        JP      C,ATN1          ; Yes - Get arc tangnt
4082:	1C1E  010081  	        LD      BC,8100H        ; BCDE = 1
4083:	1C21  51      	        LD      D,C
4084:	1C22  59      	        LD      E,C
4085:	1C23  CDFA16  	        CALL    DVBCDE          ; Get reciprocal of number
4086:	1C26  215515  	        LD      HL,SUBPHL       ; Sub angle from PI/2
4087:	1C29  E5      	        PUSH    HL              ; Save for angle > 1
4088:	1C2A  21341C  	ATN1:   LD      HL,ATNTAB       ; Coefficient table
4089:	1C2D  CDEC1A  	        CALL    SUMSER          ; Evaluate sum of series
4090:	1C30  21DB1B  	        LD      HL,HALFPI       ; PI/2 - angle in case > 1
4091:	1C33  C9      	        RET                     ; Number > 1 - Sub from PI/2
4092:			
4093:	1C34  09      	ATNTAB: .DB  9                       ; Table used by ATN
4094:	1C35  4AD73B78	        .DB  04AH,0D7H,03BH,078H     ; 1/17
4095:	1C39  026E847B	        .DB  002H,06EH,084H,07BH     ;-1/15
4096:	1C3D  FEC12F7C	        .DB  0FEH,0C1H,02FH,07CH     ; 1/13
4097:	1C41  74319A7D	        .DB  074H,031H,09AH,07DH     ;-1/11
4098:	1C45  843D5A7D	        .DB  084H,03DH,05AH,07DH     ; 1/9
4099:	1C49  C87F917E	        .DB  0C8H,07FH,091H,07EH     ;-1/7
4100:	1C4D  E4BB4C7E	        .DB  0E4H,0BBH,04CH,07EH     ; 1/5
4101:	1C51  6CAAAA7F	        .DB  06CH,0AAH,0AAH,07FH     ;-1/3
4102:	1C55  00000081	        .DB  000H,000H,000H,081H     ; 1/1
4103:			
4104:			
4105:	1C59  C9      	ARET:   RET                     ; A RETurn instruction
4106:			
4107:	1C5A  D7      	GETINP: RST     10H             ;input a character
4108:	1C5B  C9      	        RET
4109:			
4110:	1C5C          	CLS: 
4111:	1C5C  3E0C    	        LD      A,CS            ; ASCII Clear screen
4112:	1C5E  C3961D  	        JP      MONOUT          ; Output character
4113:			
4114:	1C61  CD2315  	WIDTH:  CALL    GETINT          ; Get integer 0-255
4115:	1C64  7B      	        LD      A,E             ; Width to A
4116:	1C65  328720  	        LD      (LWIDTH),A      ; Set width
4117:	1C68  C9      	        RET
4118:			
4119:	1C69  CDC20D  	LINES:  CALL    GETNUM          ; Get a number
4120:	1C6C  CD070A  	        CALL    DEINT           ; Get integer -32768 to 32767
4121:	1C6F  ED538B20	        LD      (LINESC),DE     ; Set lines counter
4122:	1C73  ED538D20	        LD      (LINESN),DE     ; Set lines number
4123:	1C77  C9      	        RET
4124:			
4125:	1C78  CD070A  	DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
4126:	1C7B  D5      	        PUSH    DE              ; Save number
4127:	1C7C  E1      	        POP     HL              ; Number to HL
4128:	1C7D  46      	        LD      B,(HL)          ; Get LSB of contents
4129:	1C7E  23      	        INC     HL
4130:	1C7F  7E      	        LD      A,(HL)          ; Get MSB of contents
4131:	1C80  C37D11  	        JP      ABPASS          ; Return integer AB
4132:			
4133:	1C83  CDC20D  	DOKE:   CALL    GETNUM          ; Get a number
4134:	1C86  CD070A  	        CALL    DEINT           ; Get integer -32768 to 32767
4135:	1C89  D5      	        PUSH    DE              ; Save address
4136:	1C8A  CDCB07  	        CALL    CHKSYN          ; Make sure ',' follows
4137:	1C8D  2C      	        .DB     ','
4138:	1C8E  CDC20D  	        CALL    GETNUM          ; Get a number
4139:	1C91  CD070A  	        CALL    DEINT           ; Get integer -32768 to 32767
4140:	1C94  E3      	        EX      (SP),HL         ; Save value,get address
4141:	1C95  73      	        LD      (HL),E          ; Save LSB of value
4142:	1C96  23      	        INC     HL
4143:	1C97  72      	        LD      (HL),D          ; Save MSB of value
4144:	1C98  E1      	        POP     HL              ; Restore code string address
4145:	1C99  C9      	        RET
4146:			
4147:			
4148:			; HEX$(nn) Convert 16 bit number to Hexadecimal string
4149:			
4150:	1C9A  CDC50D  	HEX:    CALL    TSTNUM          ; Verify it's a number
4151:	1C9D  CD070A  	        CALL    DEINT           ; Get integer -32768 to 32767
4152:	1CA0  C5      	        PUSH    BC              ; Save contents of BC
4153:	1CA1  212E21  	        LD      HL,PBUFF
4154:	1CA4  7A      	        LD      A,D             ; Get high order into A
4155:	1CA5  FE00    	        CP      0H
4156:	1CA7  280C    	        JR      Z,HEX2          ; Skip output if both high digits are zero
4157:	1CA9  CDD21C  	        CALL    BYT2ASC         ; Convert D to ASCII
4158:	1CAC  78      	        LD      A,B
4159:	1CAD  FE30    	        CP      '0'
4160:	1CAF  2802    	        JR      Z,HEX1          ; Don't store high digit if zero
4161:	1CB1  70      	        LD      (HL),B          ; Store it to PBUFF
4162:	1CB2  23      	        INC     HL              ; Next location
4163:	1CB3  71      	HEX1:   LD      (HL),C          ; Store C to PBUFF+1
4164:	1CB4  23      	        INC     HL              ; Next location
4165:	1CB5  7B      	HEX2:   LD      A,E             ; Get lower byte
4166:	1CB6  CDD21C  	        CALL    BYT2ASC         ; Convert E to ASCII
4167:	1CB9  7A      	        LD      A,D
4168:	1CBA  FE00    	        CP      0H
4169:	1CBC  2005    	        JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
4170:	1CBE  78      	        LD      A,B
4171:	1CBF  FE30    	        CP      '0'             ; If high digit of lower byte is zero then don't print
4172:	1CC1  2802    	        JR      Z,HEX4
4173:	1CC3  70      	HEX3:   LD      (HL),B          ; to PBUFF+2
4174:	1CC4  23      	        INC     HL              ; Next location
4175:	1CC5  71      	HEX4:   LD      (HL),C          ; to PBUFF+3
4176:	1CC6  23      	        INC     HL              ; PBUFF+4 to zero
4177:	1CC7  AF      	        XOR     A               ; Terminating character
4178:	1CC8  77      	        LD      (HL),A          ; Store zero to terminate
4179:	1CC9  23      	        INC     HL              ; Make sure PBUFF is terminated
4180:	1CCA  77      	        LD      (HL),A          ; Store the double zero there
4181:	1CCB  C1      	        POP     BC              ; Get BC back
4182:	1CCC  212E21  	        LD      HL,PBUFF        ; Reset to start of PBUFF
4183:	1CCF  C32B12  	        JP      STR1            ; Convert the PBUFF to a string and return it
4184:			
4185:	1CD2  47      	BYT2ASC LD      B,A             ; Save original value
4186:	1CD3  E60F    	        AND     0FH             ; Strip off upper nybble
4187:	1CD5  FE0A    	        CP      0AH             ; 0-9?
4188:	1CD7  3802    	        JR      C,ADD30         ; If A-F, add 7 more
4189:	1CD9  C607    	        ADD     A,07H           ; Bring value up to ASCII A-F
4190:	1CDB  C630    	ADD30   ADD     A,30H           ; And make ASCII
4191:	1CDD  4F      	        LD      C,A             ; Save converted char to C
4192:	1CDE  78      	        LD      A,B             ; Retrieve original value
4193:	1CDF  0F      	        RRCA                    ; and Rotate it right
4194:	1CE0  0F      	        RRCA
4195:	1CE1  0F      	        RRCA
4196:	1CE2  0F      	        RRCA
4197:	1CE3  E60F    	        AND     0FH             ; Mask off upper nybble
4198:	1CE5  FE0A    	        CP      0AH             ; 0-9? < A hex?
4199:	1CE7  3802    	        JR      C,ADD301        ; Skip Add 7
4200:	1CE9  C607    	        ADD     A,07H           ; Bring it up to ASCII A-F
4201:	1CEB  C630    	ADD301  ADD     A,30H           ; And make it full ASCII
4202:	1CED  47      	        LD      B,A             ; Store high order byte
4203:	1CEE  C9      	        RET
4204:			
4205:			; Convert "&Hnnnn" to FPREG
4206:			; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
4207:			; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
4208:	1CEF  EB      	HEXTFP  EX      DE,HL           ; Move code string pointer to DE
4209:	1CF0  210000  	        LD      HL,0000H        ; Zero out the value
4210:	1CF3  CD081D  	        CALL    GETHEX          ; Check the number for valid hex
4211:	1CF6  DA281D  	        JP      C,HXERR         ; First value wasn't hex, HX error
4212:	1CF9  1805    	        JR      HEXLP1          ; Convert first character
4213:	1CFB  CD081D  	HEXLP   CALL    GETHEX          ; Get second and addtional characters
4214:	1CFE  381F    	        JR      C,HEXIT         ; Exit if not a hex character
4215:	1D00  29      	HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
4216:	1D01  29      	        ADD     HL,HL
4217:	1D02  29      	        ADD     HL,HL
4218:	1D03  29      	        ADD     HL,HL
4219:	1D04  B5      	        OR      L               ; Add in D0-D3 into L
4220:	1D05  6F      	        LD      L,A             ; Save new value
4221:	1D06  18F3    	        JR      HEXLP           ; And continue until all hex characters are in
4222:			
4223:	1D08  13      	GETHEX  INC     DE              ; Next location
4224:	1D09  1A      	        LD      A,(DE)          ; Load character at pointer
4225:	1D0A  FE20    	        CP      ' '
4226:	1D0C  CA081D  	        JP      Z,GETHEX        ; Skip spaces
4227:	1D0F  D630    	        SUB     30H             ; Get absolute value
4228:	1D11  D8      	        RET     C               ; < "0", error
4229:	1D12  FE0A    	        CP      0AH
4230:	1D14  3805    	        JR      C,NOSUB7        ; Is already in the range 0-9
4231:	1D16  D607    	        SUB     07H             ; Reduce to A-F
4232:	1D18  FE0A    	        CP      0AH             ; Value should be $0A-$0F at this point
4233:	1D1A  D8      	        RET     C               ; CY set if was :            ; < = > ? @
4234:	1D1B  FE10    	NOSUB7  CP      10H             ; > Greater than "F"?
4235:	1D1D  3F      	        CCF
4236:	1D1E  C9      	        RET                     ; CY set if it wasn't valid hex
4237:			
4238:	1D1F  EB      	HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
4239:	1D20  7A      	        LD      A,D             ; Load DE into AC
4240:	1D21  4B      	        LD      C,E             ; For prep to 
4241:	1D22  E5      	        PUSH    HL
4242:	1D23  CD7C11  	        CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4243:	1D26  E1      	        POP     HL
4244:	1D27  C9      	        RET
4245:			
4246:	1D28  1E26    	HXERR:  LD      E,HE            ; ?HEX Error
4247:	1D2A  C31105  	        JP      ERROR
4248:			
4249:			; BIN$(NN) Convert integer to a 1-16 char binary string
4250:	1D2D  CDC50D  	BIN:    CALL    TSTNUM          ; Verify it's a number
4251:	1D30  CD070A  	        CALL    DEINT           ; Get integer -32768 to 32767
4252:	1D33  C5      	BIN2:   PUSH    BC              ; Save contents of BC
4253:	1D34  212E21  	        LD      HL,PBUFF
4254:	1D37  0611    	        LD      B,17            ; One higher than max char count
4255:	1D39          	ZEROSUP:                        ; Suppress leading zeros
4256:	1D39  05      	        DEC     B               ; Max 16 chars
4257:	1D3A  78      	        LD      A,B
4258:	1D3B  FE01    	        CP      01H
4259:	1D3D  2808    	        JR      Z,BITOUT        ; Always output at least one character
4260:	1D3F  CB13    	        RL      E
4261:	1D41  CB12    	        RL      D
4262:	1D43  30F4    	        JR      NC,ZEROSUP
4263:	1D45  1804    	        JR      BITOUT2
4264:	1D47          	BITOUT:
4265:	1D47  CB13    	        RL      E
4266:	1D49  CB12    	        RL      D               ; Top bit now in carry
4267:	1D4B          	BITOUT2:
4268:	1D4B  3E30    	        LD      A,'0'           ; Char for '0'
4269:	1D4D  CE00    	        ADC     A,0             ; If carry set then '0' --> '1'
4270:	1D4F  77      	        LD      (HL),A
4271:	1D50  23      	        INC     HL
4272:	1D51  05      	        DEC     B
4273:	1D52  20F3    	        JR      NZ,BITOUT
4274:	1D54  AF      	        XOR     A               ; Terminating character
4275:	1D55  77      	        LD      (HL),A          ; Store zero to terminate
4276:	1D56  23      	        INC     HL              ; Make sure PBUFF is terminated
4277:	1D57  77      	        LD      (HL),A          ; Store the double zero there
4278:	1D58  C1      	        POP     BC
4279:	1D59  212E21  	        LD      HL,PBUFF
4280:	1D5C  C32B12  	        JP      STR1
4281:			
4282:			; Convert "&Bnnnn" to FPREG
4283:			; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
4284:	1D5F  EB      	BINTFP: EX      DE,HL           ; Move code string pointer to DE
4285:	1D60  210000  	        LD      HL,0000H        ; Zero out the value
4286:	1D63  CD7C1D  	        CALL    CHKBIN          ; Check the number for valid bin
4287:	1D66  DA8A1D  	        JP      C,BINERR        ; First value wasn't bin, HX error
4288:	1D69  D630    	BINIT:  SUB     '0'
4289:	1D6B  29      	        ADD     HL,HL           ; Rotate HL left
4290:	1D6C  B5      	        OR      L
4291:	1D6D  6F      	        LD      L,A
4292:	1D6E  CD7C1D  	        CALL    CHKBIN          ; Get second and addtional characters
4293:	1D71  30F6    	        JR      NC,BINIT        ; Process if a bin character
4294:	1D73  EB      	        EX      DE,HL           ; Value into DE, Code string into HL
4295:	1D74  7A      	        LD      A,D             ; Load DE into AC
4296:	1D75  4B      	        LD      C,E             ; For prep to 
4297:	1D76  E5      	        PUSH    HL
4298:	1D77  CD7C11  	        CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4299:	1D7A  E1      	        POP     HL
4300:	1D7B  C9      	        RET
4301:			
4302:			; Char is in A, NC if char is 0 or 1
4303:	1D7C  13      	CHKBIN: INC     DE
4304:	1D7D  1A      	        LD      A,(DE)
4305:	1D7E  FE20    	        CP      ' '
4306:	1D80  CA7C1D  	        JP      Z,CHKBIN        ; Skip spaces
4307:	1D83  FE30    	        CP      '0'             ; Set C if < '0'
4308:	1D85  D8      	        RET     C
4309:	1D86  FE32    	        CP      '2'
4310:	1D88  3F      	        CCF                     ; Set C if > '1'
4311:	1D89  C9      	        RET
4312:			
4313:	1D8A  1E28    	BINERR: LD      E,BN            ; ?BIN Error
4314:	1D8C  C31105  	        JP      ERROR
4315:			
4316:			
4317:	1D8F  DD21FFFF	JJUMP1: LD      IX,-1           ; Flag cold start
4318:	1D93  C36101  	        JP      CSTART          ; Go and initialise
4319:			
4320:	1D96  C30800  	MONOUT: JP      0008H           ; output a char
4321:			
4322:			
4323:	1D99  76      	MONITR: HALT
4324:			        ;JP      0000H           ; Restart (Normally Monitor Start)
4325:			
4326:			
4327:	1D9A  3E00    	INITST: LD      A,0             ; Clear break flag
4328:	1D9C  329220  	        LD      (BRKFLG),A
4329:	1D9F  C36801  	        JP      INIT
4330:			
4331:	1DA2  ED45    	ARETN:  RETN                    ; Return from NMI
4332:			
4333:			
4334:	1DA4  F5      	TSTBIT: PUSH    AF              ; Save bit mask
4335:	1DA5  A0      	        AND     B               ; Get common bits
4336:	1DA6  C1      	        POP     BC              ; Restore bit mask
4337:	1DA7  B8      	        CP      B               ; Same bit set?
4338:	1DA8  3E00    	        LD      A,0             ; Return 0 in A
4339:	1DAA  C9      	        RET
4340:			
4341:	1DAB  CDD607  	OUTNCR: CALL    OUTC            ; Output character in A
4342:	1DAE  C3FD0B  	        JP      PRNTCRLF        ; Output CRLF
4343:			
4344:	1DB1          	.end



Statistics:

     4	passes
     0	jr promotions
   637	symbols
  7265	bytes



Symbol Table:

ABPASS          117D      4477
ABS             17C9      6089
ACCSUM           9E6      2534
ACPASS          117C      4476
ADD30           1CDB      7387
ADD301          1CEB      7403
ADDEXP          1762      5986
ADDIG           1908      6408
ADDPHL          154F      5455
ALLFOL          144B      5195
ANTVLU           CE6      3302
ARET            1C59      7257
ARETN           1DA2      7586
ARLDSV          109D      4253
ARREND         =211F      8479
ARRLP           1316      4886
ASC             141C      5148
ASCTFP          18AB      6315
ASPCS            C48      3144
ATN             1C0D      7181
ATN1            1C2A      7210
ATNTAB          1C34      7220
ATOH             A21      2593
BADINP           C6D      3181
BAKSTK           4A6      1190
BAKTMP          13FC      5116
BASTXT         =20A3      8355
BCDEFP          17F0      6128
BFREE            1FD      509
BIN             1D2D      7469
BIN2            1D33      7475
BINERR          1D8A      7562
BINIT           1D69      7529
BINTFP          1D5F      7519
BITOUT          1D47      7495
BITOUT2         1D4B      7499
BKSP           =08        8
BN             =28        40
BNORM           15AF      5551
BNRMLP          15B2      5554
BRK              998      2456
BRKFLG         =2092      8338
BRKLIN         =2113      8467
BRKMSG           4A0      1184
BRKRET           1F7      503
BS             =10        16
BSERR           10D0      4304
BUFFER         =20A6      8358
BYT2ASC         1CD2      7378
BYTSFT          16E7      5863
CAN            =18        24
CFEVAL          1033      4147
CHARTY           FE1      4065
CHEKFN          1214      4628
CHKBIN          1D7C      7548
CHKLTR           9F3      2547
CHKSTK           4DA      1242
CHKSUM         =208F      8335
CHKSYN           7CB      1995
CHKTYP           DC7      3527
CHR             142D      5165
CLEAR            A46      2630
CLOTST           800      2048
CLREG            62F      1583
CLRPTR           60A      1546
CLS             1C5C      7260
CMPFP           1839      6201
CMPLG1           F47      3911
CMPLOG           F45      3909
CMPNUM          181F      6175
CMPRES           F89      3977
CMPSTR           F71      3953
CN             =20        32
CNVNUM          18B7      6327
COLD             150      336
COMMAN         =2088      8328
COMPL           160F      5647
CONCAT          1391      5009
CONEXP          18E7      6375
CONPOS          15AC      5548
CONT             9CB      2507
CONTAD         =2119      8473
CONVAR           EB2      3762
COPY             170      368
COS             1B91      7057
COUNT            870      2160
CPDEHL           7C5      1989
CPYLIT           701      1793
CR             =0D        13
CRARLP          10F0      4336
CREARY          10D5      4309
CRESTR           B45      2885
CRNCLP           662      1634
CRTMST          124D      4685
CRTST           1259      4697
CRTSTE          126F      4719
CRUNCH           659      1625
CS             =0C        12
CSTART           161      353
CTLOFG         =208A      8330
CTRLC          =03        3
CTRLG          =07        7
CTRLO          =0F        15
CTRLQ          =11        17
CTRLR          =12        18
CTRLS          =13        19
CTRLU          =15        21
CUROPR         =210A      8458
CURPOS         =20F0      8432
DATA             AEC      2796
DATFLG         =20F3      8435
DATLIN         =210E      8462
DATSNR           4F7      1271
DCBCDE          1870      6256
DD             =12        18
DDERR            506      1286
DEEK            1C78      7288
DEF             1191      4497
DEFSIZ          10F8      4344
DEINT            A07      2567
DEL            =7F        127
DELCHR           731      1841
DEPINT           A01      2561
DETHL4          17FF      6143
DETHLB          1801      6145
DIGTXT          19B1      6577
DIM              FB3      4019
DIMRET           FAA      4010
DINPOS           7FA      2042
DIV             16F8      5880
DIV1           =204F      8271
DIV10           16EC      5868
DIV2           =2053      8275
DIV3           =2057      8279
DIV4           =205A      8282
DIVLP           171F      5919
DIVSUP         =204E      8270
DOAGN            648      1608
DOCOM            C19      3097
DODEL            711      1809
DOEBIT          19F1      6641
DOFN            11BE      4542
DOKE            1C83      7299
DONULL           C07      3079
DOSPC            C43      3139
DOTAB            C30      3120
DPOINT          18E3      6371
DTSTR           125D      4701
DVBCDE          16FA      5882
DZ             =14        20
DZERR            500      1280
ECHDEL           725      1829
EDIGIT          192A      6442
ENDBUF           708      1800
ENDCON          18F6      6390
ENDDIM          1157      4439
ENDINP           BF8      3064
ENDNAM           FD5      4053
ENDPRG           9A7      2471
ENFMEM           4E3      1251
ERRIN            531      1329
ERRLIN         =2117      8471
ERRMSG           48E      1166
ERROR            511      1297
ERRORS           404      1028
ESC            =1B        27
EVAL             DD4      3540
EVAL1            DD7      3543
EVAL2            DE0      3552
EVAL3            DE3      3555
EVLPAR           E99      3737
EVNOT            F93      3987
EXCUTE           935      2357
EXP             1A8B      6795
EXPLP           18D5      6357
EXPTAB          1ACB      6859
EXPTEN          1A03      6659
EXTIG            D42      3394
FANDT            D6C      3436
FC             =08        8
FCERR            A1C      2588
FDTLP            D53      3411
FINDEL          1133      4403
FLGDIF          17AF      6063
FLGREL          17B6      6070
FNARG          =2125      8485
FNCTAB           24E      590
FNDARY          10A3      4259
FNDELP          1138      4408
FNDEND           5DD      1501
FNDNUM          1520      5408
FNDTOK           84F      2127
FNDVAR          101A      4122
FNDWRD           68C      1676
FNOFST           EC3      3779
FNRGNM         =2123      8483
FNTHR           1028      4136
FNVAL            EEA      3818
FOPRND           E0C      3596
FOR              89C      2204
FORFLG         =2110      8464
FORFND           8CC      2252
FORSLP           8B0      2224
FPADD           155E      5470
FPBCDE          17E5      6117
FPEXP          =212C      8492
FPINT           184C      6220
FPMULT          1699      5785
FPREG          =2129      8489
FPROND          15F6      5622
FPSINT           9FB      2555
FPTHL           17FC      6140
FRE             115B      4443
FRENUM          1177      4471
FRMEVL           EB5      3765
GARBGE          12DE      4830
GARBLP          12E1      4833
GETCHR           955      2389
GETCMD           555      1365
GETHEX          1D08      7432
GETINP          1C5A      7258
GETINT          1523      5411
GETLEN          1411      5137
GETLIN           742      1858
GETLN            A22      2594
GETNUM           DC2      3522
GETNXT           6A7      1703
GETSTR          13DB      5083
GETVAR           FB8      4024
GNXARY          1315      4885
GOFUNC           EF2      3826
GOSUB            A98      2712
GOTO             AA9      2729
GRBARY          1335      4917
GRBDON          12B6      4790
GRBLP           12EF      4847
GSTRCU          13DE      5086
GSTRDE          13E2      5090
GSTRHL          13E1      5089
GTFLNM          1420      5152
GTFNAM           FBD      4029
GTLNLP           A25      2597
GTSIXD          197B      6523
GTVLUS           CBE      3262
HALF            1A22      6690
HALFPI          1BDB      7131
HE             =26        38
HEX             1C9A      7322
HEX1            1CB3      7347
HEX2            1CB5      7349
HEX3            1CC3      7363
HEX4            1CC5      7365
HEXIT           1D1F      7455
HEXLP           1CFB      7419
HEXLP1          1D00      7424
HEXTFP          1CEF      7407
HXERR           1D28      7464
ID             =16        22
IDTEST          1206      4614
IF               B7B      2939
IFGO             B89      2953
IFJMP            93C      2364
INCHL           17FA      6138
INCLEN           7F6      2038
INDFND           4C0      1216
INEWLN           5A5      1445
INIT             168      360
INITAB           42E      1070
INITBE           48E      1166
INITST          1D9A      7578
INMSG            495      1173
INP             14E0      5344
INPBIN           D10      3344
INPBRK           9A4      2468
INPORT         =2084      8324
INPSUB         =2083      8323
INPUT            C7E      3198
INRNG           1984      6532
INT             1877      6263
INTVAR           619      1561
INVSGN          17CD      6093
ITMSEP           D01      3329
JJUMP1          1D8F      7567
JSTZER          1A0D      6669
KILFOR           DB2      3506
KILIN            73C      1852
LCRFLG         =20F1      8433
LEFT            143D      5181
LEN             140D      5133
LET              B03      2819
LETNUM           B56      2902
LETSTR           B1E      2846
LF             =0A        10
LFRGNM          14D6      5334
LINEAT         =20A1      8353
LINEIN          1936      6454
LINES           1C69      7273
LINESC         =208B      8331
LINESN         =208D      8333
LINFND           58E      1422
LIST             811      2065
LISTLP           81D      2077
LOADFP          17F3      6131
LOG             1658      5720
LOGTAB          164B      5707
LOKFOR           4AA      1194
LOOPST         =210C      8460
LS             =1C        28
LSTBIN         =2111      8465
LSTLP2           83D      2109
LSTLP3           840      2112
LSTRAM         =20F4      8436
LSTRND         =207F      8319
LTSTND           D1B      3355
LWIDTH         =2087      8327
MAKINT          1526      5414
MAKNUM          19A0      6560
MANLP           18BF      6335
MATCH            6D9      1753
MEMMSG           243      579
MID             1477      5239
MID1            1443      5187
MIDNUM          14DB      5339
MINCDE          159E      5534
MINUS            EA1      3745
MKTMST          124A      4682
MLDBLP          1898      6296
MLDEBC          1890      6288
MLOOP            198      408
MLSP10          178D      6029
MO             =24        36
MONITR          1D99      7577
MONOUT          1D96      7574
MORDT            D27      3367
MORINP           74B      1867
MOVBUF           5C4      1476
MOVDIR           6E1      1761
MOVLP            4CF      1231
MOVSTR           4CC      1228
MOVUP            4C9      1225
MRPRNT           B9B      2971
MSIZE            185      389
MUL8LP          16C4      5828
MULLN2          1690      5776
MULT            1697      5783
MULT8           16BB      5819
MULTEN          1901      6401
MULVAL         =213B      8507
MVSTPT           B4D      2893
NEDMOR           CBA      3258
NEGAFT          1A38      6712
NEW              609      1545
NEXITM           C53      3155
NEXT             D77      3447
NEXT1            D7A      3450
NF             =00        0
NFERR            503      1283
NMIFLG         =2091      8337
NOCHNG           6D1      1745
NOENED          1A10      6672
NOLIN            9BA      2490
NOMADD          16D5      5845
NOMLAD          18A6      6310
NOPMPT           C98      3224
NORMAL          15C9      5577
NOSPC            6C8      1736
NOSUB7          1D1B      7451
NOSWAP          1578      5496
NOTAMP           E76      3702
NOTSTR           FF0      4080
NOXOR           1506      5382
NSCFOR          1000      4096
NULFLG         =2089      8329
NULL             9DE      2526
NULLP            C0E      3086
NULLS          =2086      8326
NUMASC          1949      6473
NXTARY          10B7      4279
NXTBYT           6B7      1719
NXTCHR           6F8      1784
NXTDAT         =2121      8481
NXTDTA           AEB      2795
NXTITM           CB2      3250
NXTOPR         =2115      8469
NXTSTL           AF2      2802
NXTSTT           AF5      2805
OD             =06        6
OKMSG            49A      1178
OM             =0C        12
OMERR            4F2      1266
ON               B5D      2909
ONGO             B6C      2924
ONGOLP           B6D      2925
ONJMP            93D      2365
OPNPAR           DD0      3536
OPRND            E4B      3659
OS             =1A        26
OTKLN            739      1849
OTPORT         =204C      8268
OUTC             7D6      2006
OUTEXP          1A01      6657
OUTIT            7B7      1975
OUTNBS           7BD      1981
OUTNCR          1DAB      7595
OUTSUB         =204B      8267
OUTWRD           859      2137
OV             =0A        10
OVERR            50C      1292
OVTST1          1780      6016
OVTST2          1785      6021
OVTST3          1786      6022
PADD            1925      6437
PAND             F0C      3852
PASSA           118C      4492
PBUFF          =212E      8494
PEEK            1534      5428
PEND             99F      2463
PHLTFP          17E2      6114
PLUCDE          1603      5635
PNORM           15D1      5585
POINT          =2096      8342
POKE            153B      5435
POPAF           12D0      4816
POPHL           13FA      5114
POPHRT          16E5      5861
POPNOK           547      1351
POR              F0B      3851
POR1             F2E      3886
POS             1189      4489
POSINT           9FE      2558
POUT            14EC      5356
POWER           1A46      6726
POWER1          1A56      6742
POWER2          1A73      6771
POWERS          1A26      6694
PRINT            B9F      2975
PRITAB           3EF      1007
PRNTCRLF         BFD      3069
PRNTHL          193E      6462
PRNTLP           BA2      2978
PRNTNB           BE5      3045
PRNTOK           548      1352
PRNTST           BE9      3049
PRNUMS          129A      4762
PROCES           764      1892
PROGND         =211B      8475
PROGST         =213E      8510
PROMPT           64C      1612
PRS             129B      4763
PRS1            129E      4766
PRSLP           12A5      4773
PSET           =2099      8345
PSUB            1559      5465
PTRLP            5D1      1489
PUTBUF           7A3      1955
PUTCTL           7A8      1960
PUTFID           911      2321
QTSTLP          1260      4704
QTSTR           125A      4698
QUARTR          1BDF      7135
RAMSTART       =2000      8192
READ             CAD      3245
READFG         =2112      8466
REDO             C5A      3162
REM              AEE      2798
RESDIV          1732      5938
RESEED          1B7D      7037
RESET          =209C      8348
RESTNL           97A      2426
RESTOR           965      2405
RESZER          15C4      5572
RETADR          1067      4199
RETINT          17BB      6075
RETLIN           AE6      2790
RETNAD           6DD      1757
RETNUL          106A      4202
RETNUM           EAD      3757
RETREL          17AD      6061
RETURN           AC7      2759
RG             =04        4
RIGHT           146D      5229
RIGHT1          1441      5185
RINPUT         =2093      8339
RLTLP            DF0      3568
RND             1B1C      6940
RND1            1B58      7000
RND2            1B74      7028
RNDTAB          1B85      7045
RNGTST          1A13      6675
RONDB           15E5      5605
RONDUP          15E4      5604
ROUND           154C      5452
RSCALE          191F      6431
RSLNBK           893      2195
RSTSTR          1490      5264
RUN              A8C      2700
RUNCNT           915      2325
RUNFST           615      1557
RUNLIN           AA8      2728
SAVEXP          15C5      5573
SAVSTP           908      2312
SAVSTR          1235      4661
SBSCPT          1075      4213
SCALE           1623      5667
SCALLP          1625      5669
SCALMI          18EA      6378
SCALPL          1900      6400
SCNEND          136C      4972
SCPTLP          107B      4219
SEARCH           6A5      1701
SEED           =205C      8284
SETIO           1510      5392
SETLIN           867      2151
SETLIT           6EF      1775
SETPTR           5CC      1484
SETTOP           1BC      444
SFTPRG           596      1430
SGN             17B3      6067
SGNEXP           EFB      3835
SGNRES         =212D      8493
SHRITE          1632      5682
SHRLP           1635      5685
SHRT1           1639      5689
SIGNON           20C      524
SIGNS           180A      6154
SIN             1B97      7063
SIN1            1BC7      7111
SINTAB          1BE3      7139
SIXDIG          1966      6502
SMPVAR          1300      4864
SMSER1          1AFB      6907
SN             =02        2
SNERR            4FD      1277
SPCFST          1957      6487
SPCLP            C4C      3148
SQR             1A3D      6717
SRCHLN           5E9      1513
SRCHLP           5EC      1516
SSTSA           13C8      5064
ST             =1E        30
STACK          =20AB      8363
STAKFP          17D5      6101
STALL            98E      2446
STARTB           156      342
STKTHS           E34      3636
STLOOK         =21A2      8610
STOP             99D      2461
STORED           A69      2665
STPOOL          1343      4931
STR             1225      4645
STR1            122B      4651
STRADD          1346      4934
STRBOT         =2108      8456
STRENT           D04      3332
STRSPC         =209F      8351
STTLIN           BF0      3056
SUBCDE          155B      5467
SUBPHL          1555      5461
SUMLP           1B04      6916
SUMSER          1AEC      6892
SUPTLZ          19E5      6629
SVNAM2           FD4      4052
SVSTAD          1253      4691
TAN             1BF8      7160
TESTOS          12D2      4818
TESTR           12B4      4788
TM             =18        24
TMERR            50F      1295
TMPSTR         =2104      8452
TMSTPL         =20F8      8440
TMSTPT         =20F6      8438
TOPOOL          1439      5177
TOSTRA          13D1      5073
TRYAGN          19C0      6592
TSALP           13D2      5074
TSTBIT          1DA4      7588
TSTBRK           980      2432
TSTMEM           1AA      426
TSTNUM           DC5      3525
TSTOPL          127B      4731
TSTRED           F33      3891
TSTREM           6F2      1778
TSTSGN          17A4      6052
TSTSTR           DC6      3526
TTYLIN           742      1858
TYPE           =20F2      8434
UF             =22        34
UFERR            509      1289
UL             =0E        14
ULERR            AC2      2754
UNITY           1647      5703
UPDATA           97B      2427
USR            =2048      8264
VAL             14A7      5287
VAL1            14C5      5317
VAL2            14CF      5327
VAL3            14D2      5330
VAREND         =211D      8477
WAIT            14F2      5362
WAITLP          1507      5383
WARM             153      339
WARMST           1F4      500
WIDTH           1C61      7265
WORDS            286      646
WORDTB           3A5      933
WRKSPC         =2045      8261
ZDATA          =83        131
ZDIV           =AF        175
ZEND           =80        128
ZEQUAL         =B4        180
ZERARY          1116      4374
ZERBYT         = 499      1177
ZEROLP          1059      4185
ZEROSUP         1D39      7481
ZFN            =A7        167
ZFOR           =81        129
ZGOSUB         =8C        140
ZGOTO          =88        136
ZGTR           =B3        179
ZLEFT          =CF        207
ZLTH           =B5        181
ZMINUS         =AD        173
ZNEW           =A4        164
ZNOT           =AA        170
ZONELP           C27      3111
ZOR            =B2        178
ZPLUS          =AC        172
ZPOINT         =C7        199
ZPRINT         =9E        158
ZREM           =8E        142
ZSGN           =B6        182
ZSPC           =A8        168
ZSTEP          =AB        171
ZTAB           =A5        165
ZTHEN          =A9        169
ZTIMES         =AE        174
ZTO            =A6        166
