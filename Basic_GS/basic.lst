   1:			;==================================================================================
   2:			; The updates to the original BASIC within this file are copyright Grant Searle
   3:			;
   4:			; You have permission to use this for NON COMMERCIAL USE ONLY
   5:			; If you wish to use it elsewhere, please include an acknowledgement to myself.
   6:			;
   7:			; http://searle.hostei.com/grant/index.html
   8:			;
   9:			; eMail: home.micros01@btinternet.com
  10:			;
  11:			; If the above don't work, please perform an Internet search to see if I have
  12:			; updated the web page hosting service.
  13:			;
  14:			;==================================================================================
  15:			
  16:			; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
  17:			; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
  18:			; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
  19:			; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
  20:			; the original ROM code (checksum A934H). PA
  21:			
  22:			; GENERAL EQUATES
  23:			
  24:	0003          	CTRLC   .EQU   03H             ; Control "C"
  25:	0007          	CTRLG   .EQU   07H             ; Control "G"
  26:	0008          	BKSP    .EQU   08H             ; Back space
  27:	000A          	LF      .EQU   0AH             ; Line feed
  28:	000C          	CS      .EQU   0CH             ; Clear screen
  29:	000D          	CR      .EQU   0DH             ; Carriage return
  30:	000F          	CTRLO   .EQU   0FH             ; Control "O"
  31:	0011          	CTRLQ	.EQU   11H	       ; Control "Q"
  32:	0012          	CTRLR   .EQU   12H             ; Control "R"
  33:	0013          	CTRLS   .EQU   13H             ; Control "S"
  34:	0015          	CTRLU   .EQU   15H             ; Control "U"
  35:	001B          	ESC     .EQU   1BH             ; Escape
  36:	007F          	DEL     .EQU   7FH             ; Delete
  37:			
  38:			; BASIC WORK SPACE LOCATIONS
  39:			
  40:	2000          	RAMSTART .EQU  2000H           ; Start of RAM
  41:	2045          	WRKSPC  .EQU   2045H           ; BASIC Work space
  42:	2048          	USR     .EQU   WRKSPC + 3H     ; "USR (x)" jump
  43:	204B          	OUTSUB  .EQU   WRKSPC + 6H     ; "OUT p,n"
  44:	204C          	OTPORT  .EQU   WRKSPC + 7H     ; Port (p)
  45:	204E          	DIVSUP  .EQU   WRKSPC + 9H     ; Division support routine
  46:	204F          	DIV1    .EQU   WRKSPC + 0AH    ; <- Values
  47:	2053          	DIV2    .EQU   WRKSPC + 0EH    ; <-   to
  48:	2057          	DIV3    .EQU   WRKSPC + 12H    ; <-   be
  49:	205A          	DIV4    .EQU   WRKSPC + 15H    ; <-inserted
  50:	205C          	SEED    .EQU   WRKSPC + 17H    ; Random number seed
  51:	207F          	LSTRND  .EQU   WRKSPC + 3AH    ; Last random number
  52:	2083          	INPSUB  .EQU   WRKSPC + 3EH    ; #INP (x)" Routine
  53:	2084          	INPORT  .EQU   WRKSPC + 3FH    ; PORT (x)
  54:	2086          	NULLS   .EQU   WRKSPC + 41H    ; Number of nulls
  55:	2087          	LWIDTH  .EQU   WRKSPC + 42H    ; Terminal width
  56:	2088          	COMMAN  .EQU   WRKSPC + 43H    ; Width for commas
  57:	2089          	NULFLG  .EQU   WRKSPC + 44H    ; Null after input byte flag
  58:	208A          	CTLOFG  .EQU   WRKSPC + 45H    ; Control "O" flag
  59:	208B          	LINESC  .EQU   WRKSPC + 46H    ; Lines counter
  60:	208D          	LINESN  .EQU   WRKSPC + 48H    ; Lines number
  61:	208F          	CHKSUM  .EQU   WRKSPC + 4AH    ; Array load/save check sum
  62:	2091          	NMIFLG  .EQU   WRKSPC + 4CH    ; Flag for NMI break routine
  63:	2092          	BRKFLG  .EQU   WRKSPC + 4DH    ; Break flag
  64:	2093          	RINPUT  .EQU   WRKSPC + 4EH    ; Input reflection
  65:	2096          	POINT   .EQU   WRKSPC + 51H    ; "POINT" reflection (unused)
  66:	2099          	PSET    .EQU   WRKSPC + 54H    ; "SET"   reflection
  67:	209C          	RESET   .EQU   WRKSPC + 57H    ; "RESET" reflection
  68:	209F          	STRSPC  .EQU   WRKSPC + 5AH    ; Bottom of string space
  69:	20A1          	LINEAT  .EQU   WRKSPC + 5CH    ; Current line number
  70:	20A3          	BASTXT  .EQU   WRKSPC + 5EH    ; Pointer to start of program
  71:	20A6          	BUFFER  .EQU   WRKSPC + 61H    ; Input buffer
  72:	20AB          	STACK   .EQU   WRKSPC + 66H    ; Initial stack
  73:	20F0          	CURPOS  .EQU   WRKSPC + 0ABH   ; Character position on line
  74:	20F1          	LCRFLG  .EQU   WRKSPC + 0ACH   ; Locate/Create flag
  75:	20F2          	TYPE    .EQU   WRKSPC + 0ADH   ; Data type flag
  76:	20F3          	DATFLG  .EQU   WRKSPC + 0AEH   ; Literal statement flag
  77:	20F4          	LSTRAM  .EQU   WRKSPC + 0AFH   ; Last available RAM
  78:	20F6          	TMSTPT  .EQU   WRKSPC + 0B1H   ; Temporary string pointer
  79:	20F8          	TMSTPL  .EQU   WRKSPC + 0B3H   ; Temporary string pool
  80:	2104          	TMPSTR  .EQU   WRKSPC + 0BFH   ; Temporary string
  81:	2108          	STRBOT  .EQU   WRKSPC + 0C3H   ; Bottom of string space
  82:	210A          	CUROPR  .EQU   WRKSPC + 0C5H   ; Current operator in EVAL
  83:	210C          	LOOPST  .EQU   WRKSPC + 0C7H   ; First statement of loop
  84:	210E          	DATLIN  .EQU   WRKSPC + 0C9H   ; Line of current DATA item
  85:	2110          	FORFLG  .EQU   WRKSPC + 0CBH   ; "FOR" loop flag
  86:	2111          	LSTBIN  .EQU   WRKSPC + 0CCH   ; Last byte entered
  87:	2112          	READFG  .EQU   WRKSPC + 0CDH   ; Read/Input flag
  88:	2113          	BRKLIN  .EQU   WRKSPC + 0CEH   ; Line of break
  89:	2115          	NXTOPR  .EQU   WRKSPC + 0D0H   ; Next operator in EVAL
  90:	2117          	ERRLIN  .EQU   WRKSPC + 0D2H   ; Line of error
  91:	2119          	CONTAD  .EQU   WRKSPC + 0D4H   ; Where to CONTinue
  92:	211B          	PROGND  .EQU   WRKSPC + 0D6H   ; End of program
  93:	211D          	VAREND  .EQU   WRKSPC + 0D8H   ; End of variables
  94:	211F          	ARREND  .EQU   WRKSPC + 0DAH   ; End of arrays
  95:	2121          	NXTDAT  .EQU   WRKSPC + 0DCH   ; Next data item
  96:	2123          	FNRGNM  .EQU   WRKSPC + 0DEH   ; Name of FN argument
  97:	2125          	FNARG   .EQU   WRKSPC + 0E0H   ; FN argument value
  98:	2129          	FPREG   .EQU   WRKSPC + 0E4H   ; Floating point register
  99:	212C          	FPEXP   .EQU   FPREG + 3       ; Floating point exponent
 100:	212D          	SGNRES  .EQU   WRKSPC + 0E8H   ; Sign of result
 101:	212E          	PBUFF   .EQU   WRKSPC + 0E9H   ; Number print buffer
 102:	213B          	MULVAL  .EQU   WRKSPC + 0F6H   ; Multiplier
 103:	213E          	PROGST  .EQU   WRKSPC + 0F9H   ; Start of program text area
 104:	21A2          	STLOOK  .EQU   WRKSPC + 15DH   ; Start of memory test
 105:			
 106:			; BASIC ERROR CODE VALUES
 107:			
 108:	0000          	NF      .EQU   00H             ; NEXT without FOR
 109:	0002          	SN      .EQU   02H             ; Syntax error
 110:	0004          	RG      .EQU   04H             ; RETURN without GOSUB
 111:	0006          	OD      .EQU   06H             ; Out of DATA
 112:	0008          	FC      .EQU   08H             ; Function call error
 113:	000A          	OV      .EQU   0AH             ; Overflow
 114:	000C          	OM      .EQU   0CH             ; Out of memory
 115:	000E          	UL      .EQU   0EH             ; Undefined line number
 116:	0010          	BS      .EQU   10H             ; Bad subscript
 117:	0012          	DD      .EQU   12H             ; Re-DIMensioned array
 118:	0014          	DZ      .EQU   14H             ; Division by zero (/0)
 119:	0016          	ID      .EQU   16H             ; Illegal direct
 120:	0018          	TM      .EQU   18H             ; Type miss-match
 121:	001A          	OS      .EQU   1AH             ; Out of string space
 122:	001C          	LS      .EQU   1CH             ; String too long
 123:	001E          	ST      .EQU   1EH             ; String formula too complex
 124:	0020          	CN      .EQU   20H             ; Can't CONTinue
 125:	0022          	UF      .EQU   22H             ; UnDEFined FN function
 126:	0024          	MO      .EQU   24H             ; Missing operand
 127:	0026          	HE      .EQU   26H             ; HEX error
 128:	0028          	BN      .EQU   28H             ; BIN error
 129:			
 130:	0150          	        .ORG   00150H
 131:			
 132:	0150  C35601  	COLD:   JP      STARTB          ; Jump for cold start
 133:	0153  C3F401  	WARM:   JP      WARMST          ; Jump for warm start
 134:	0156          	STARTB:
 135:	0156  DD210000	        LD      IX,0            ; Flag cold start
 136:	015A  C36101  	        JP      CSTART          ; Jump to initialise
 137:			
 138:	015D  070A    	        .DW     DEINT           ; Get integer -32768 to 32767
 139:	015F  7D11    	        .DW     ABPASS          ; Return integer in AB
 140:			
 141:			
 142:	0161  214520  	CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
 143:	0164  F9      	        LD      SP,HL           ; Set up a temporary stack
 144:	0165  C39A1D  	        JP      INITST          ; Go to initialise
 145:			
 146:	0168  112E04  	INIT:   LD      DE,INITAB       ; Initialise workspace
 147:	016B  0663    	        LD      B,INITBE-INITAB+3; Bytes to copy
 148:	016D  214520  	        LD      HL,WRKSPC       ; Into workspace RAM
 149:	0170  1A      	COPY:   LD      A,(DE)          ; Get source
 150:	0171  77      	        LD      (HL),A          ; To destination
 151:	0172  23      	        INC     HL              ; Next destination
 152:	0173  13      	        INC     DE              ; Next source
 153:	0174  05      	        DEC     B               ; Count bytes
 154:	0175  C27001  	        JP      NZ,COPY         ; More to move
 155:	0178  F9      	        LD      SP,HL           ; Temporary stack
 156:	0179  CD2F06  	        CALL    CLREG           ; Clear registers and stack
 157:	017C  CDFD0B  	        CALL    PRNTCRLF        ; Output CRLF
 158:	017F  32EF20  	        LD      (BUFFER+72+1),A ; Mark end of buffer
 159:	0182  323E21  	        LD      (PROGST),A      ; Initialise program area
 160:			
 161:			;MSIZE: LD      HL,MEMMSG       ; Point to message
 162:			;       CALL    PRS             ; Output "Memory size"
 163:	0185  2A0020  	MSIZE:  LD      HL,(RAMSTART)   ; Read RAM end from memory
 164:	0188  C3BC01  	        JP      SETTOP          ; Skip user input and mem check
 165:			
 166:	018B  CD4C06  	        CALL    PROMPT          ; Get input with '?'
 167:	018E  CD5509  	        CALL    GETCHR          ; Get next character
 168:	0191  B7      	        OR      A               ; Set flags
 169:	0192  C2AA01  	        JP      NZ,TSTMEM       ; If number - Test if RAM there
 170:	0195  21A221  	        LD      HL,STLOOK       ; Point to start of RAM
 171:	0198  23      	MLOOP:  INC     HL              ; Next byte
 172:	0199  7C      	        LD      A,H             ; Above address FFFF ?
 173:	019A  B5      	        OR      L
 174:	019B  CABC01  	        JP      Z,SETTOP        ; Yes - 64K RAM
 175:	019E  7E      	        LD      A,(HL)          ; Get contents
 176:	019F  47      	        LD      B,A             ; Save it
 177:	01A0  2F      	        CPL                     ; Flip all bits
 178:	01A1  77      	        LD      (HL),A          ; Put it back
 179:	01A2  BE      	        CP      (HL)            ; RAM there if same
 180:	01A3  70      	        LD      (HL),B          ; Restore old contents
 181:	01A4  CA9801  	        JP      Z,MLOOP         ; If RAM - test next byte
 182:	01A7  C3BC01  	        JP      SETTOP          ; Top of RAM found
 183:			
 184:	01AA  CD210A  	TSTMEM: CALL    ATOH            ; Get high memory into DE
 185:	01AD  B7      	        OR      A               ; Set flags on last byte
 186:	01AE  C2FD04  	        JP      NZ,SNERR        ; ?SN Error if bad character
 187:	01B1  EB      	        EX      DE,HL           ; Address into HL
 188:	01B2  2B      	        DEC     HL              ; Back one byte
 189:	01B3  3ED9    	        LD      A,11011001B     ; Test byte
 190:	01B5  46      	        LD      B,(HL)          ; Get old contents
 191:	01B6  77      	        LD      (HL),A          ; Load test byte
 192:	01B7  BE      	        CP      (HL)            ; RAM there if same
 193:	01B8  70      	        LD      (HL),B          ; Restore old contents
 194:	01B9  C28501  	        JP      NZ,MSIZE        ; Ask again if no RAM
 195:			
 196:	01BC  2B      	SETTOP: DEC     HL              ; Back one byte
 197:	01BD  11A121  	        LD      DE,STLOOK-1     ; See if enough RAM
 198:	01C0  CDC507  	        CALL    CPDEHL          ; Compare DE with HL
 199:	01C3  DA8501  	        JP      C,MSIZE         ; Ask again if not enough RAM
 200:	01C6  11CEFF  	        LD      DE,0-50         ; 50 Bytes string space
 201:	01C9  22F420  	        LD      (LSTRAM),HL     ; Save last available RAM
 202:	01CC  19      	        ADD     HL,DE           ; Allocate string space
 203:	01CD  229F20  	        LD      (STRSPC),HL     ; Save string space
 204:	01D0  CD0A06  	        CALL    CLRPTR          ; Clear program area
 205:	01D3  2A9F20  	        LD      HL,(STRSPC)     ; Get end of memory
 206:	01D6  11EFFF  	        LD      DE,0-17         ; Offset for free bytes
 207:	01D9  19      	        ADD     HL,DE           ; Adjust HL
 208:	01DA  113E21  	        LD      DE,PROGST       ; Start of program text
 209:	01DD  7D      	        LD      A,L             ; Get LSB
 210:	01DE  93      	        SUB     E               ; Adjust it
 211:	01DF  6F      	        LD      L,A             ; Re-save
 212:	01E0  7C      	        LD      A,H             ; Get MSB
 213:	01E1  9A      	        SBC     A,D             ; Adjust it
 214:	01E2  67      	        LD      H,A             ; Re-save
 215:	01E3  E5      	        PUSH    HL              ; Save bytes free
 216:	01E4  210C02  	        LD      HL,SIGNON       ; Sign-on message
 217:	01E7  CD9B12  	        CALL    PRS             ; Output string
 218:	01EA  E1      	        POP     HL              ; Get bytes free back
 219:	01EB  CD3E19  	        CALL    PRNTHL          ; Output amount of free memory
 220:	01EE  21FD01  	        LD      HL,BFREE        ; " Bytes free" message
 221:	01F1  CD9B12  	        CALL    PRS             ; Output string
 222:			
 223:	01F4  31AB20  	WARMST: LD      SP,STACK        ; Temporary stack
 224:	01F7  CD2F06  	BRKRET: CALL    CLREG           ; Clear registers and stack
 225:	01FA  C34805  	        JP      PRNTOK          ; Go to get command line
 226:			
 227:	01FD  20427974	BFREE:  .DB  " Bytes free",CR,LF,0,0
	      65732066
	      7265650D
	      0A0000
 228:			
 229:	020C  5A383020	SIGNON: .DB  "Z80 BASIC Ver 4.7b",CR,LF
	      42415349
	      43205665
	      7220342E
	      37620D0A
 230:	0220  436F7079	        .DB  "Copyright ",40,"C",41
	      72696768
	      74202843
	      29
 231:	022D  20313937	        .DB  " 1978 by Microsoft",CR,LF,0,0
	      38206279
	      204D6963
	      726F736F
	      66740D0A
	      0000
 232:			
 233:	0243  4D656D6F	MEMMSG: .DB  "Memory top",0
	      72792074
	      6F7000
 234:			
 235:			; FUNCTION ADDRESS TABLE
 236:			
 237:	024E  B317    	FNCTAB: .DW     SGN
 238:	0250  7718    	        .DW     INT
 239:	0252  C917    	        .DW     ABS
 240:	0254  4820    	        .DW     USR
 241:	0256  5B11    	        .DW     FRE
 242:	0258  E014    	        .DW     INP
 243:	025A  8911    	        .DW     POS
 244:	025C  3D1A    	        .DW     SQR
 245:	025E  1C1B    	        .DW     RND
 246:	0260  5816    	        .DW     LOG
 247:	0262  8B1A    	        .DW     EXP
 248:	0264  911B    	        .DW     COS
 249:	0266  971B    	        .DW     SIN
 250:	0268  F81B    	        .DW     TAN
 251:	026A  0D1C    	        .DW     ATN
 252:	026C  3415    	        .DW     PEEK
 253:	026E  781C    	        .DW     DEEK
 254:	0270  9620    	        .DW     POINT
 255:	0272  0D14    	        .DW     LEN
 256:	0274  2512    	        .DW     STR
 257:	0276  A714    	        .DW     VAL
 258:	0278  1C14    	        .DW     ASC
 259:	027A  2D14    	        .DW     CHR
 260:	027C  9A1C    	        .DW     HEX
 261:	027E  2D1D    	        .DW     BIN
 262:	0280  3D14    	        .DW     LEFT
 263:	0282  6D14    	        .DW     RIGHT
 264:	0284  7714    	        .DW     MID
 265:			
 266:			; RESERVED WORD LIST
 267:			
 268:	0286  C54E44  	WORDS:  .DB     'E' + 80H,"ND"
 269:	0289  C64F52  	        .DB     'F' + 80H,"OR"
 270:	028C  CE455854	        .DB     'N' + 80H,"EXT"
 271:	0290  C4415441	        .DB     'D' + 80H,"ATA"
 272:	0294  C94E5055	        .DB     'I' + 80H,"NPUT"
	      54
 273:	0299  C4494D  	        .DB     'D' + 80H,"IM"
 274:	029C  D2454144	        .DB     'R' + 80H,"EAD"
 275:	02A0  CC4554  	        .DB     'L' + 80H,"ET"
 276:	02A3  C74F544F	        .DB     'G' + 80H,"OTO"
 277:	02A7  D2554E  	        .DB     'R' + 80H,"UN"
 278:	02AA  C946    	        .DB     'I' + 80H,"F"
 279:	02AC  D2455354	        .DB     'R' + 80H,"ESTORE"
	      4F5245
 280:	02B3  C74F5355	        .DB     'G' + 80H,"OSUB"
	      42
 281:	02B8  D2455455	        .DB     'R' + 80H,"ETURN"
	      524E
 282:	02BE  D2454D  	        .DB     'R' + 80H,"EM"
 283:	02C1  D3544F50	        .DB     'S' + 80H,"TOP"
 284:	02C5  CF5554  	        .DB     'O' + 80H,"UT"
 285:	02C8  CF4E    	        .DB     'O' + 80H,"N"
 286:	02CA  CE554C4C	        .DB     'N' + 80H,"ULL"
 287:	02CE  D7414954	        .DB     'W' + 80H,"AIT"
 288:	02D2  C44546  	        .DB     'D' + 80H,"EF"
 289:	02D5  D04F4B45	        .DB     'P' + 80H,"OKE"
 290:	02D9  C44F4B45	        .DB     'D' + 80H,"OKE"
 291:	02DD  D3435245	        .DB     'S' + 80H,"CREEN"
	      454E
 292:	02E3  CC494E45	        .DB     'L' + 80H,"INES"
	      53
 293:	02E8  C34C53  	        .DB     'C' + 80H,"LS"
 294:	02EB  D7494454	        .DB     'W' + 80H,"IDTH"
	      48
 295:	02F0  CD4F4E49	        .DB     'M' + 80H,"ONITOR"
	      544F52
 296:	02F7  D34554  	        .DB     'S' + 80H,"ET"
 297:	02FA  D2455345	        .DB     'R' + 80H,"ESET"
	      54
 298:	02FF  D052494E	        .DB     'P' + 80H,"RINT"
	      54
 299:	0304  C34F4E54	        .DB     'C' + 80H,"ONT"
 300:	0308  CC495354	        .DB     'L' + 80H,"IST"
 301:	030C  C34C4541	        .DB     'C' + 80H,"LEAR"
	      52
 302:	0311  C34C4F41	        .DB     'C' + 80H,"LOAD"
	      44
 303:	0316  C3534156	        .DB     'C' + 80H,"SAVE"
	      45
 304:	031B  CE4557  	        .DB     'N' + 80H,"EW"
 305:			
 306:	031E  D4414228	        .DB     'T' + 80H,"AB("
 307:	0322  D44F    	        .DB     'T' + 80H,"O"
 308:	0324  C64E    	        .DB     'F' + 80H,"N"
 309:	0326  D3504328	        .DB     'S' + 80H,"PC("
 310:	032A  D448454E	        .DB     'T' + 80H,"HEN"
 311:	032E  CE4F54  	        .DB     'N' + 80H,"OT"
 312:	0331  D3544550	        .DB     'S' + 80H,"TEP"
 313:			
 314:	0335  AB      	        .DB     '+' + 80H
 315:	0336  AD      	        .DB     '-' + 80H
 316:	0337  AA      	        .DB     '*' + 80H
 317:	0338  AF      	        .DB     '/' + 80H
 318:	0339  DE      	        .DB     '^' + 80H
 319:	033A  C14E44  	        .DB     'A' + 80H,"ND"
 320:	033D  CF52    	        .DB     'O' + 80H,"R"
 321:	033F  BE      	        .DB     '>' + 80H
 322:	0340  BD      	        .DB     '=' + 80H
 323:	0341  BC      	        .DB     '<' + 80H
 324:			
 325:	0342  D3474E  	        .DB     'S' + 80H,"GN"
 326:	0345  C94E54  	        .DB     'I' + 80H,"NT"
 327:	0348  C14253  	        .DB     'A' + 80H,"BS"
 328:	034B  D55352  	        .DB     'U' + 80H,"SR"
 329:	034E  C65245  	        .DB     'F' + 80H,"RE"
 330:	0351  C94E50  	        .DB     'I' + 80H,"NP"
 331:	0354  D04F53  	        .DB     'P' + 80H,"OS"
 332:	0357  D35152  	        .DB     'S' + 80H,"QR"
 333:	035A  D24E44  	        .DB     'R' + 80H,"ND"
 334:	035D  CC4F47  	        .DB     'L' + 80H,"OG"
 335:	0360  C55850  	        .DB     'E' + 80H,"XP"
 336:	0363  C34F53  	        .DB     'C' + 80H,"OS"
 337:	0366  D3494E  	        .DB     'S' + 80H,"IN"
 338:	0369  D4414E  	        .DB     'T' + 80H,"AN"
 339:	036C  C1544E  	        .DB     'A' + 80H,"TN"
 340:	036F  D045454B	        .DB     'P' + 80H,"EEK"
 341:	0373  C445454B	        .DB     'D' + 80H,"EEK"
 342:	0377  D04F494E	        .DB     'P' + 80H,"OINT"
	      54
 343:	037C  CC454E  	        .DB     'L' + 80H,"EN"
 344:	037F  D3545224	        .DB     'S' + 80H,"TR$"
 345:	0383  D6414C  	        .DB     'V' + 80H,"AL"
 346:	0386  C15343  	        .DB     'A' + 80H,"SC"
 347:	0389  C3485224	        .DB     'C' + 80H,"HR$"
 348:	038D  C8455824	        .DB     'H' + 80H,"EX$"
 349:	0391  C2494E24	        .DB     'B' + 80H,"IN$"
 350:	0395  CC454654	        .DB     'L' + 80H,"EFT$"
	      24
 351:	039A  D2494748	        .DB     'R' + 80H,"IGHT$"
	      5424
 352:	03A0  CD494424	        .DB     'M' + 80H,"ID$"
 353:	03A4  80      	        .DB     80H             ; End of list marker
 354:			
 355:			; KEYWORD ADDRESS TABLE
 356:			
 357:	03A5  9F09    	WORDTB: .DW     PEND
 358:	03A7  9C08    	        .DW     FOR
 359:	03A9  770D    	        .DW     NEXT
 360:	03AB  EC0A    	        .DW     DATA
 361:	03AD  7E0C    	        .DW     INPUT
 362:	03AF  B30F    	        .DW     DIM
 363:	03B1  AD0C    	        .DW     READ
 364:	03B3  030B    	        .DW     LET
 365:	03B5  A90A    	        .DW     GOTO
 366:	03B7  8C0A    	        .DW     RUN
 367:	03B9  7B0B    	        .DW     IF
 368:	03BB  6509    	        .DW     RESTOR
 369:	03BD  980A    	        .DW     GOSUB
 370:	03BF  C70A    	        .DW     RETURN
 371:	03C1  EE0A    	        .DW     REM
 372:	03C3  9D09    	        .DW     STOP
 373:	03C5  EC14    	        .DW     POUT
 374:	03C7  5D0B    	        .DW     ON
 375:	03C9  DE09    	        .DW     NULL
 376:	03CB  F214    	        .DW     WAIT
 377:	03CD  9111    	        .DW     DEF
 378:	03CF  3B15    	        .DW     POKE
 379:	03D1  831C    	        .DW     DOKE
 380:	03D3  EE0A    	        .DW     REM             ;SCREEN
 381:	03D5  691C    	        .DW     LINES
 382:	03D7  5C1C    	        .DW     CLS
 383:	03D9  611C    	        .DW     WIDTH
 384:	03DB  991D    	        .DW     MONITR
 385:	03DD  9920    	        .DW     PSET
 386:	03DF  9C20    	        .DW     RESET
 387:	03E1  9F0B    	        .DW     PRINT
 388:	03E3  CB09    	        .DW     CONT
 389:	03E5  1108    	        .DW     LIST
 390:	03E7  460A    	        .DW     CLEAR
 391:	03E9  EE0A    	        .DW     REM             ;CLOAD
 392:	03EB  EE0A    	        .DW     REM             ;CSAVE
 393:	03ED  0906    	        .DW     NEW
 394:			
 395:			; RESERVED WORD TOKEN VALUES
 396:			
 397:	0080          	ZEND    .EQU    080H            ; END
 398:	0081          	ZFOR    .EQU    081H            ; FOR
 399:	0083          	ZDATA   .EQU    083H            ; DATA
 400:	0088          	ZGOTO   .EQU    088H            ; GOTO
 401:	008C          	ZGOSUB  .EQU    08CH            ; GOSUB
 402:	008E          	ZREM    .EQU    08EH            ; REM
 403:	009E          	ZPRINT  .EQU    09EH            ; PRINT
 404:	00A4          	ZNEW    .EQU    0A4H            ; NEW
 405:			
 406:	00A5          	ZTAB    .EQU    0A5H            ; TAB
 407:	00A6          	ZTO     .EQU    0A6H            ; TO
 408:	00A7          	ZFN     .EQU    0A7H            ; FN
 409:	00A8          	ZSPC    .EQU    0A8H            ; SPC
 410:	00A9          	ZTHEN   .EQU    0A9H            ; THEN
 411:	00AA          	ZNOT    .EQU    0AAH            ; NOT
 412:	00AB          	ZSTEP   .EQU    0ABH            ; STEP
 413:			
 414:	00AC          	ZPLUS   .EQU    0ACH            ; +
 415:	00AD          	ZMINUS  .EQU    0ADH            ; -
 416:	00AE          	ZTIMES  .EQU    0AEH            ; *
 417:	00AF          	ZDIV    .EQU    0AFH            ; /
 418:	00B2          	ZOR     .EQU    0B2H            ; OR
 419:	00B3          	ZGTR    .EQU    0B3H            ; >
 420:	00B4          	ZEQUAL  .EQU    0B4H            ; M
 421:	00B5          	ZLTH    .EQU    0B5H            ; <
 422:	00B6          	ZSGN    .EQU    0B6H            ; SGN
 423:	00C7          	ZPOINT  .EQU    0C7H            ; POINT
 424:	00CF          	ZLEFT   .EQU    0CDH +2         ; LEFT$
 425:			
 426:			; ARITHMETIC PRECEDENCE TABLE
 427:			
 428:	03EF  79      	PRITAB: .DB     79H             ; Precedence value
 429:	03F0  2519    	        .DW     PADD            ; FPREG = <last> + FPREG
 430:			
 431:	03F2  79      	        .DB     79H             ; Precedence value
 432:	03F3  5915    	        .DW     PSUB            ; FPREG = <last> - FPREG
 433:			
 434:	03F5  7C      	        .DB     7CH             ; Precedence value
 435:	03F6  9716    	        .DW     MULT            ; PPREG = <last> * FPREG
 436:			
 437:	03F8  7C      	        .DB     7CH             ; Precedence value
 438:	03F9  F816    	        .DW     DIV             ; FPREG = <last> / FPREG
 439:			
 440:	03FB  7F      	        .DB     7FH             ; Precedence value
 441:	03FC  461A    	        .DW     POWER           ; FPREG = <last> ^ FPREG
 442:			
 443:	03FE  50      	        .DB     50H             ; Precedence value
 444:	03FF  0C0F    	        .DW     PAND            ; FPREG = <last> AND FPREG
 445:			
 446:	0401  46      	        .DB     46H             ; Precedence value
 447:	0402  0B0F    	        .DW     POR             ; FPREG = <last> OR FPREG
 448:			
 449:			; BASIC ERROR CODE LIST
 450:			
 451:	0404  4E46    	ERRORS: .DB     "NF"            ; NEXT without FOR
 452:	0406  534E    	        .DB     "SN"            ; Syntax error
 453:	0408  5247    	        .DB     "RG"            ; RETURN without GOSUB
 454:	040A  4F44    	        .DB     "OD"            ; Out of DATA
 455:	040C  4643    	        .DB     "FC"            ; Illegal function call
 456:	040E  4F56    	        .DB     "OV"            ; Overflow error
 457:	0410  4F4D    	        .DB     "OM"            ; Out of memory
 458:	0412  554C    	        .DB     "UL"            ; Undefined line
 459:	0414  4253    	        .DB     "BS"            ; Bad subscript
 460:	0416  4444    	        .DB     "DD"            ; Re-DIMensioned array
 461:	0418  2F30    	        .DB     "/0"            ; Division by zero
 462:	041A  4944    	        .DB     "ID"            ; Illegal direct
 463:	041C  544D    	        .DB     "TM"            ; Type mis-match
 464:	041E  4F53    	        .DB     "OS"            ; Out of string space
 465:	0420  4C53    	        .DB     "LS"            ; String too long
 466:	0422  5354    	        .DB     "ST"            ; String formula too complex
 467:	0424  434E    	        .DB     "CN"            ; Can't CONTinue
 468:	0426  5546    	        .DB     "UF"            ; Undefined FN function
 469:	0428  4D4F    	        .DB     "MO"            ; Missing operand
 470:	042A  4858    	        .DB     "HX"            ; HEX error
 471:	042C  424E    	        .DB     "BN"            ; BIN error
 472:			
 473:			; INITIALISATION TABLE -------------------------------------------------------
 474:			
 475:	042E  C3F401  	INITAB: JP      WARMST          ; Warm start jump
 476:	0431  C31C0A  	        JP      FCERR           ; "USR (X)" jump (Set to Error)
 477:	0434  D300    	        OUT     (0),A           ; "OUT p,n" skeleton
 478:	0436  C9      	        RET
 479:	0437  D600    	        SUB     0               ; Division support routine
 480:	0439  6F      	        LD      L,A
 481:	043A  7C      	        LD      A,H
 482:	043B  DE00    	        SBC     A,0
 483:	043D  67      	        LD      H,A
 484:	043E  78      	        LD      A,B
 485:	043F  DE00    	        SBC     A,0
 486:	0441  47      	        LD      B,A
 487:	0442  3E00    	        LD      A,0
 488:	0444  C9      	        RET
 489:	0445  000000  	        .DB     0,0,0                   ; Random number seed table used by RND
 490:	0448  354ACA99	        .DB     035H,04AH,0CAH,099H     ;-2.65145E+07
 491:	044C  391C7698	        .DB     039H,01CH,076H,098H     ; 1.61291E+07
 492:	0450  2295B398	        .DB     022H,095H,0B3H,098H     ;-1.17691E+07
 493:	0454  0ADD4798	        .DB     00AH,0DDH,047H,098H     ; 1.30983E+07
 494:	0458  53D19999	        .DB     053H,0D1H,099H,099H     ;-2-01612E+07
 495:	045C  0A1A9F98	        .DB     00AH,01AH,09FH,098H     ;-1.04269E+07
 496:	0460  65BCCD98	        .DB     065H,0BCH,0CDH,098H     ;-1.34831E+07
 497:	0464  D6773E98	        .DB     0D6H,077H,03EH,098H     ; 1.24825E+07
 498:	0468  52C74F80	        .DB     052H,0C7H,04FH,080H     ; Last random number
 499:	046C  DB00    	        IN      A,(0)           ; INP (x) skeleton
 500:	046E  C9      	        RET
 501:	046F  01      	        .DB     1               ; POS (x) number (1)
 502:	0470  FF      	        .DB     255             ; Terminal width (255 = no auto CRLF)
 503:	0471  1C      	        .DB     28              ; Width for commas (3 columns)
 504:	0472  00      	        .DB     0               ; No nulls after input bytes
 505:	0473  00      	        .DB     0               ; Output enabled (^O off)
 506:	0474  1400    	        .DW     20              ; Initial lines counter
 507:	0476  1400    	        .DW     20              ; Initial lines number
 508:	0478  0000    	        .DW     0               ; Array load/save check sum
 509:	047A  00      	        .DB     0               ; Break not by NMI
 510:	047B  00      	        .DB     0               ; Break flag
 511:	047C  C34207  	        JP      TTYLIN          ; Input reflection (set to TTY)
 512:	047F  C30000  	        JP      0000H           ; POINT reflection unused
 513:	0482  C30000  	        JP      0000H           ; SET reflection
 514:	0485  C30000  	        JP      0000H          	; RESET reflection
 515:	0488  A221    	        .DW     STLOOK          ; Temp string space
 516:	048A  FEFF    	        .DW     -2              ; Current line number (cold)
 517:	048C  3F21    	        .DW     PROGST+1        ; Start of program text
 518:	048E          	INITBE:
 519:			
 520:			; END OF INITIALISATION TABLE ---------------------------------------------------
 521:			
 522:	048E  20457272	ERRMSG: .DB     " Error",0
	      6F7200
 523:	0495  20696E20	INMSG:  .DB     " in ",0
	      00
 524:	0499          	ZERBYT  .EQU    $-1             ; A zero byte
 525:	049A  4F6B0D0A	OKMSG:  .DB     "Ok",CR,LF,0,0
	      0000
 526:	04A0  42726561	BRKMSG: .DB     "Break",0
	      6B00
 527:			
 528:	04A6  210400  	BAKSTK: LD      HL,4            ; Look for "FOR" block with
 529:	04A9  39      	        ADD     HL,SP           ; same index as specified
 530:	04AA  7E      	LOKFOR: LD      A,(HL)          ; Get block ID
 531:	04AB  23      	        INC     HL              ; Point to index address
 532:	04AC  FE81    	        CP      ZFOR            ; Is it a "FOR" token
 533:	04AE  C0      	        RET     NZ              ; No - exit
 534:	04AF  4E      	        LD      C,(HL)          ; BC = Address of "FOR" index
 535:	04B0  23      	        INC     HL
 536:	04B1  46      	        LD      B,(HL)
 537:	04B2  23      	        INC     HL              ; Point to sign of STEP
 538:	04B3  E5      	        PUSH    HL              ; Save pointer to sign
 539:	04B4  69      	        LD      L,C             ; HL = address of "FOR" index
 540:	04B5  60      	        LD      H,B
 541:	04B6  7A      	        LD      A,D             ; See if an index was specified
 542:	04B7  B3      	        OR      E               ; DE = 0 if no index specified
 543:	04B8  EB      	        EX      DE,HL           ; Specified index into HL
 544:	04B9  CAC004  	        JP      Z,INDFND        ; Skip if no index given
 545:	04BC  EB      	        EX      DE,HL           ; Index back into DE
 546:	04BD  CDC507  	        CALL    CPDEHL          ; Compare index with one given
 547:	04C0  010D00  	INDFND: LD      BC,16-3         ; Offset to next block
 548:	04C3  E1      	        POP     HL              ; Restore pointer to sign
 549:	04C4  C8      	        RET     Z               ; Return if block found
 550:	04C5  09      	        ADD     HL,BC           ; Point to next block
 551:	04C6  C3AA04  	        JP      LOKFOR          ; Keep on looking
 552:			
 553:	04C9  CDE304  	MOVUP:  CALL    ENFMEM          ; See if enough memory
 554:	04CC  C5      	MOVSTR: PUSH    BC              ; Save end of source
 555:	04CD  E3      	        EX      (SP),HL         ; Swap source and dest" end
 556:	04CE  C1      	        POP     BC              ; Get end of destination
 557:	04CF  CDC507  	MOVLP:  CALL    CPDEHL          ; See if list moved
 558:	04D2  7E      	        LD      A,(HL)          ; Get byte
 559:	04D3  02      	        LD      (BC),A          ; Move it
 560:	04D4  C8      	        RET     Z               ; Exit if all done
 561:	04D5  0B      	        DEC     BC              ; Next byte to move to
 562:	04D6  2B      	        DEC     HL              ; Next byte to move
 563:	04D7  C3CF04  	        JP      MOVLP           ; Loop until all bytes moved
 564:			
 565:	04DA  E5      	CHKSTK: PUSH    HL              ; Save code string address
 566:	04DB  2A1F21  	        LD      HL,(ARREND)     ; Lowest free memory
 567:	04DE  0600    	        LD      B,0             ; BC = Number of levels to test
 568:	04E0  09      	        ADD     HL,BC           ; 2 Bytes for each level
 569:	04E1  09      	        ADD     HL,BC
 570:	04E2  3E      	        .DB     3EH             ; Skip "PUSH HL"
 571:	04E3  E5      	ENFMEM: PUSH    HL              ; Save code string address
 572:	04E4  3ED0    	        LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
 573:	04E6  95      	        SUB     L
 574:	04E7  6F      	        LD      L,A
 575:	04E8  3EFF    	        LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
 576:	04EA  9C      	        SBC     A,H
 577:	04EB  DAF204  	        JP      C,OMERR         ; Not enough - ?OM Error
 578:	04EE  67      	        LD      H,A
 579:	04EF  39      	        ADD     HL,SP           ; Test if stack is overflowed
 580:	04F0  E1      	        POP     HL              ; Restore code string address
 581:	04F1  D8      	        RET     C               ; Return if enough mmory
 582:	04F2  1E0C    	OMERR:  LD      E,OM            ; ?OM Error
 583:	04F4  C31105  	        JP      ERROR
 584:			
 585:	04F7  2A0E21  	DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
 586:	04FA  22A120  	        LD      (LINEAT),HL     ; Save as current line
 587:	04FD  1E02    	SNERR:  LD      E,SN            ; ?SN Error
 588:	04FF  01      	        .DB     01H             ; Skip "LD E,DZ"
 589:	0500  1E14    	DZERR:  LD      E,DZ            ; ?/0 Error
 590:	0502  01      	        .DB     01H             ; Skip "LD E,NF"
 591:	0503  1E00    	NFERR:  LD      E,NF            ; ?NF Error
 592:	0505  01      	        .DB     01H             ; Skip "LD E,DD"
 593:	0506  1E12    	DDERR:  LD      E,DD            ; ?DD Error
 594:	0508  01      	        .DB     01H             ; Skip "LD E,UF"
 595:	0509  1E22    	UFERR:  LD      E,UF            ; ?UF Error
 596:	050B  01      	        .DB     01H             ; Skip "LD E,OV
 597:	050C  1E0A    	OVERR:  LD      E,OV            ; ?OV Error
 598:	050E  01      	        .DB     01H             ; Skip "LD E,TM"
 599:	050F  1E18    	TMERR:  LD      E,TM            ; ?TM Error
 600:			
 601:	0511  CD2F06  	ERROR:  CALL    CLREG           ; Clear registers and stack
 602:	0514  328A20  	        LD      (CTLOFG),A      ; Enable output (A is 0)
 603:	0517  CDF00B  	        CALL    STTLIN          ; Start new line
 604:	051A  210404  	        LD      HL,ERRORS       ; Point to error codes
 605:	051D  57      	        LD      D,A             ; D = 0 (A is 0)
 606:	051E  3E3F    	        LD      A,'?'
 607:	0520  CDD607  	        CALL    OUTC            ; Output '?'
 608:	0523  19      	        ADD     HL,DE           ; Offset to correct error code
 609:	0524  7E      	        LD      A,(HL)          ; First character
 610:	0525  CDD607  	        CALL    OUTC            ; Output it
 611:	0528  CD5509  	        CALL    GETCHR          ; Get next character
 612:	052B  CDD607  	        CALL    OUTC            ; Output it
 613:	052E  218E04  	        LD      HL,ERRMSG       ; "Error" message
 614:	0531  CD9B12  	ERRIN:  CALL    PRS             ; Output message
 615:	0534  2AA120  	        LD      HL,(LINEAT)     ; Get line of error
 616:	0537  11FEFF  	        LD      DE,-2           ; Cold start error if -2
 617:	053A  CDC507  	        CALL    CPDEHL          ; See if cold start error
 618:	053D  CA6101  	        JP      Z,CSTART        ; Cold start error - Restart
 619:	0540  7C      	        LD      A,H             ; Was it a direct error?
 620:	0541  A5      	        AND     L               ; Line = -1 if direct error
 621:	0542  3C      	        INC     A
 622:	0543  C43619  	        CALL    NZ,LINEIN       ; No - output line of error
 623:	0546  3E      	        .DB     3EH             ; Skip "POP BC"
 624:	0547  C1      	POPNOK: POP     BC              ; Drop address in input buffer
 625:			
 626:	0548  AF      	PRNTOK: XOR     A               ; Output "Ok" and get command
 627:	0549  328A20  	        LD      (CTLOFG),A      ; Enable output
 628:	054C  CDF00B  	        CALL    STTLIN          ; Start new line
 629:	054F  219A04  	        LD      HL,OKMSG        ; "Ok" message
 630:	0552  CD9B12  	        CALL    PRS             ; Output "Ok"
 631:	0555  21FFFF  	GETCMD: LD      HL,-1           ; Flag direct mode
 632:	0558  22A120  	        LD      (LINEAT),HL     ; Save as current line
 633:	055B  CD4207  	        CALL    GETLIN          ; Get an input line
 634:	055E  DA5505  	        JP      C,GETCMD        ; Get line again if break
 635:	0561  CD5509  	        CALL    GETCHR          ; Get first character
 636:	0564  3C      	        INC     A               ; Test if end of line
 637:	0565  3D      	        DEC     A               ; Without affecting Carry
 638:	0566  CA5505  	        JP      Z,GETCMD        ; Nothing entered - Get another
 639:	0569  F5      	        PUSH    AF              ; Save Carry status
 640:	056A  CD210A  	        CALL    ATOH            ; Get line number into DE
 641:	056D  D5      	        PUSH    DE              ; Save line number
 642:	056E  CD5906  	        CALL    CRUNCH          ; Tokenise rest of line
 643:	0571  47      	        LD      B,A             ; Length of tokenised line
 644:	0572  D1      	        POP     DE              ; Restore line number
 645:	0573  F1      	        POP     AF              ; Restore Carry
 646:	0574  D23509  	        JP      NC,EXCUTE       ; No line number - Direct mode
 647:	0577  D5      	        PUSH    DE              ; Save line number
 648:	0578  C5      	        PUSH    BC              ; Save length of tokenised line
 649:	0579  AF      	        XOR     A
 650:	057A  321121  	        LD      (LSTBIN),A      ; Clear last byte input
 651:	057D  CD5509  	        CALL    GETCHR          ; Get next character
 652:	0580  B7      	        OR      A               ; Set flags
 653:	0581  F5      	        PUSH    AF              ; And save them
 654:	0582  CDE905  	        CALL    SRCHLN          ; Search for line number in DE
 655:	0585  DA8E05  	        JP      C,LINFND        ; Jump if line found
 656:	0588  F1      	        POP     AF              ; Get status
 657:	0589  F5      	        PUSH    AF              ; And re-save
 658:	058A  CAC20A  	        JP      Z,ULERR         ; Nothing after number - Error
 659:	058D  B7      	        OR      A               ; Clear Carry
 660:	058E  C5      	LINFND: PUSH    BC              ; Save address of line in prog
 661:	058F  D2A505  	        JP      NC,INEWLN       ; Line not found - Insert new
 662:	0592  EB      	        EX      DE,HL           ; Next line address in DE
 663:	0593  2A1B21  	        LD      HL,(PROGND)     ; End of program
 664:	0596  1A      	SFTPRG: LD      A,(DE)          ; Shift rest of program down
 665:	0597  02      	        LD      (BC),A
 666:	0598  03      	        INC     BC              ; Next destination
 667:	0599  13      	        INC     DE              ; Next source
 668:	059A  CDC507  	        CALL    CPDEHL          ; All done?
 669:	059D  C29605  	        JP      NZ,SFTPRG       ; More to do
 670:	05A0  60      	        LD      H,B             ; HL - New end of program
 671:	05A1  69      	        LD      L,C
 672:	05A2  221B21  	        LD      (PROGND),HL     ; Update end of program
 673:			
 674:	05A5  D1      	INEWLN: POP     DE              ; Get address of line,
 675:	05A6  F1      	        POP     AF              ; Get status
 676:	05A7  CACC05  	        JP      Z,SETPTR        ; No text - Set up pointers
 677:	05AA  2A1B21  	        LD      HL,(PROGND)     ; Get end of program
 678:	05AD  E3      	        EX      (SP),HL         ; Get length of input line
 679:	05AE  C1      	        POP     BC              ; End of program to BC
 680:	05AF  09      	        ADD     HL,BC           ; Find new end
 681:	05B0  E5      	        PUSH    HL              ; Save new end
 682:	05B1  CDC904  	        CALL    MOVUP           ; Make space for line
 683:	05B4  E1      	        POP     HL              ; Restore new end
 684:	05B5  221B21  	        LD      (PROGND),HL     ; Update end of program pointer
 685:	05B8  EB      	        EX      DE,HL           ; Get line to move up in HL
 686:	05B9  74      	        LD      (HL),H          ; Save MSB
 687:	05BA  D1      	        POP     DE              ; Get new line number
 688:	05BB  23      	        INC     HL              ; Skip pointer
 689:	05BC  23      	        INC     HL
 690:	05BD  73      	        LD      (HL),E          ; Save LSB of line number
 691:	05BE  23      	        INC     HL
 692:	05BF  72      	        LD      (HL),D          ; Save MSB of line number
 693:	05C0  23      	        INC     HL              ; To first byte in line
 694:	05C1  11A620  	        LD      DE,BUFFER       ; Copy buffer to program
 695:	05C4  1A      	MOVBUF: LD      A,(DE)          ; Get source
 696:	05C5  77      	        LD      (HL),A          ; Save destinations
 697:	05C6  23      	        INC     HL              ; Next source
 698:	05C7  13      	        INC     DE              ; Next destination
 699:	05C8  B7      	        OR      A               ; Done?
 700:	05C9  C2C405  	        JP      NZ,MOVBUF       ; No - Repeat
 701:	05CC  CD1506  	SETPTR: CALL    RUNFST          ; Set line pointers
 702:	05CF  23      	        INC     HL              ; To LSB of pointer
 703:	05D0  EB      	        EX      DE,HL           ; Address to DE
 704:	05D1  62      	PTRLP:  LD      H,D             ; Address to HL
 705:	05D2  6B      	        LD      L,E
 706:	05D3  7E      	        LD      A,(HL)          ; Get LSB of pointer
 707:	05D4  23      	        INC     HL              ; To MSB of pointer
 708:	05D5  B6      	        OR      (HL)            ; Compare with MSB pointer
 709:	05D6  CA5505  	        JP      Z,GETCMD        ; Get command line if end
 710:	05D9  23      	        INC     HL              ; To LSB of line number
 711:	05DA  23      	        INC     HL              ; Skip line number
 712:	05DB  23      	        INC     HL              ; Point to first byte in line
 713:	05DC  AF      	        XOR     A               ; Looking for 00 byte
 714:	05DD  BE      	FNDEND: CP      (HL)            ; Found end of line?
 715:	05DE  23      	        INC     HL              ; Move to next byte
 716:	05DF  C2DD05  	        JP      NZ,FNDEND       ; No - Keep looking
 717:	05E2  EB      	        EX      DE,HL           ; Next line address to HL
 718:	05E3  73      	        LD      (HL),E          ; Save LSB of pointer
 719:	05E4  23      	        INC     HL
 720:	05E5  72      	        LD      (HL),D          ; Save MSB of pointer
 721:	05E6  C3D105  	        JP      PTRLP           ; Do next line
 722:			
 723:	05E9  2AA320  	SRCHLN: LD      HL,(BASTXT)     ; Start of program text
 724:	05EC  44      	SRCHLP: LD      B,H             ; BC = Address to look at
 725:	05ED  4D      	        LD      C,L
 726:	05EE  7E      	        LD      A,(HL)          ; Get address of next line
 727:	05EF  23      	        INC     HL
 728:	05F0  B6      	        OR      (HL)            ; End of program found?
 729:	05F1  2B      	        DEC     HL
 730:	05F2  C8      	        RET     Z               ; Yes - Line not found
 731:	05F3  23      	        INC     HL
 732:	05F4  23      	        INC     HL
 733:	05F5  7E      	        LD      A,(HL)          ; Get LSB of line number
 734:	05F6  23      	        INC     HL
 735:	05F7  66      	        LD      H,(HL)          ; Get MSB of line number
 736:	05F8  6F      	        LD      L,A
 737:	05F9  CDC507  	        CALL    CPDEHL          ; Compare with line in DE
 738:	05FC  60      	        LD      H,B             ; HL = Start of this line
 739:	05FD  69      	        LD      L,C
 740:	05FE  7E      	        LD      A,(HL)          ; Get LSB of next line address
 741:	05FF  23      	        INC     HL
 742:	0600  66      	        LD      H,(HL)          ; Get MSB of next line address
 743:	0601  6F      	        LD      L,A             ; Next line to HL
 744:	0602  3F      	        CCF
 745:	0603  C8      	        RET     Z               ; Lines found - Exit
 746:	0604  3F      	        CCF
 747:	0605  D0      	        RET     NC              ; Line not found,at line after
 748:	0606  C3EC05  	        JP      SRCHLP          ; Keep looking
 749:			
 750:	0609  C0      	NEW:    RET     NZ              ; Return if any more on line
 751:	060A  2AA320  	CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
 752:	060D  AF      	        XOR     A               ; Set program area to empty
 753:	060E  77      	        LD      (HL),A          ; Save LSB = 00
 754:	060F  23      	        INC     HL
 755:	0610  77      	        LD      (HL),A          ; Save MSB = 00
 756:	0611  23      	        INC     HL
 757:	0612  221B21  	        LD      (PROGND),HL     ; Set program end
 758:			
 759:	0615  2AA320  	RUNFST: LD      HL,(BASTXT)     ; Clear all variables
 760:	0618  2B      	        DEC     HL
 761:			
 762:	0619  221321  	INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
 763:	061C  2AF420  	        LD      HL,(LSTRAM)     ; Get end of RAM
 764:	061F  220821  	        LD      (STRBOT),HL     ; Clear string space
 765:	0622  AF      	        XOR     A
 766:	0623  CD6509  	        CALL    RESTOR          ; Reset DATA pointers
 767:	0626  2A1B21  	        LD      HL,(PROGND)     ; Get end of program
 768:	0629  221D21  	        LD      (VAREND),HL     ; Clear variables
 769:	062C  221F21  	        LD      (ARREND),HL     ; Clear arrays
 770:			
 771:	062F  C1      	CLREG:  POP     BC              ; Save return address
 772:	0630  2A9F20  	        LD      HL,(STRSPC)     ; Get end of working RAN
 773:	0633  F9      	        LD      SP,HL           ; Set stack
 774:	0634  21F820  	        LD      HL,TMSTPL       ; Temporary string pool
 775:	0637  22F620  	        LD      (TMSTPT),HL     ; Reset temporary string ptr
 776:	063A  AF      	        XOR     A               ; A = 00
 777:	063B  6F      	        LD      L,A             ; HL = 0000
 778:	063C  67      	        LD      H,A
 779:	063D  221921  	        LD      (CONTAD),HL     ; No CONTinue
 780:	0640  321021  	        LD      (FORFLG),A      ; Clear FOR flag
 781:	0643  222321  	        LD      (FNRGNM),HL     ; Clear FN argument
 782:	0646  E5      	        PUSH    HL              ; HL = 0000
 783:	0647  C5      	        PUSH    BC              ; Put back return
 784:	0648  2A1321  	DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
 785:	064B  C9      	        RET                     ; Return to execution driver
 786:			
 787:	064C  3E3F    	PROMPT: LD      A,'?'           ; '?'
 788:	064E  CDD607  	        CALL    OUTC            ; Output character
 789:	0651  3E20    	        LD      A,' '           ; Space
 790:	0653  CDD607  	        CALL    OUTC            ; Output character
 791:	0656  C39320  	        JP      RINPUT          ; Get input line
 792:			
 793:	0659  AF      	CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
 794:	065A  32F320  	        LD      (DATFLG),A      ; Reset literal flag
 795:	065D  0E05    	        LD      C,2+3           ; 2 byte number and 3 nulls
 796:	065F  11A620  	        LD      DE,BUFFER       ; Start of input buffer
 797:	0662  7E      	CRNCLP: LD      A,(HL)          ; Get byte
 798:	0663  FE20    	        CP      ' '             ; Is it a space?
 799:	0665  CAE106  	        JP      Z,MOVDIR        ; Yes - Copy direct
 800:	0668  47      	        LD      B,A             ; Save character
 801:	0669  FE22    	        CP      '"'             ; Is it a quote?
 802:	066B  CA0107  	        JP      Z,CPYLIT        ; Yes - Copy literal string
 803:	066E  B7      	        OR      A               ; Is it end of buffer?
 804:	066F  CA0807  	        JP      Z,ENDBUF        ; Yes - End buffer
 805:	0672  3AF320  	        LD      A,(DATFLG)      ; Get data type
 806:	0675  B7      	        OR      A               ; Literal?
 807:	0676  7E      	        LD      A,(HL)          ; Get byte to copy
 808:	0677  C2E106  	        JP      NZ,MOVDIR       ; Literal - Copy direct
 809:	067A  FE3F    	        CP      '?'             ; Is it '?' short for PRINT
 810:	067C  3E9E    	        LD      A,ZPRINT        ; "PRINT" token
 811:	067E  CAE106  	        JP      Z,MOVDIR        ; Yes - replace it
 812:	0681  7E      	        LD      A,(HL)          ; Get byte again
 813:	0682  FE30    	        CP      '0'             ; Is it less than '0'
 814:	0684  DA8C06  	        JP      C,FNDWRD        ; Yes - Look for reserved words
 815:	0687  FE3C    	        CP      60; ";"+1           ; Is it "0123456789:;" ?
 816:	0689  DAE106  	        JP      C,MOVDIR        ; Yes - copy it direct
 817:	068C  D5      	FNDWRD: PUSH    DE              ; Look for reserved words
 818:	068D  118502  	        LD      DE,WORDS-1      ; Point to table
 819:	0690  C5      	        PUSH    BC              ; Save count
 820:	0691  01DD06  	        LD      BC,RETNAD       ; Where to return to
 821:	0694  C5      	        PUSH    BC              ; Save return address
 822:	0695  067F    	        LD      B,ZEND-1        ; First token value -1
 823:	0697  7E      	        LD      A,(HL)          ; Get byte
 824:	0698  FE61    	        CP      'a'             ; Less than 'a' ?
 825:	069A  DAA506  	        JP      C,SEARCH        ; Yes - search for words
 826:	069D  FE7B    	        CP      'z'+1           ; Greater than 'z' ?
 827:	069F  D2A506  	        JP      NC,SEARCH       ; Yes - search for words
 828:	06A2  E65F    	        AND     01011111B       ; Force upper case
 829:	06A4  77      	        LD      (HL),A          ; Replace byte
 830:	06A5  4E      	SEARCH: LD      C,(HL)          ; Search for a word
 831:	06A6  EB      	        EX      DE,HL
 832:	06A7  23      	GETNXT: INC     HL              ; Get next reserved word
 833:	06A8  B6      	        OR      (HL)            ; Start of word?
 834:	06A9  F2A706  	        JP      P,GETNXT        ; No - move on
 835:	06AC  04      	        INC     B               ; Increment token value
 836:	06AD  7E      	        LD      A, (HL)         ; Get byte from table
 837:	06AE  E67F    	        AND     01111111B       ; Strip bit 7
 838:	06B0  C8      	        RET     Z               ; Return if end of list
 839:	06B1  B9      	        CP      C               ; Same character as in buffer?
 840:	06B2  C2A706  	        JP      NZ,GETNXT       ; No - get next word
 841:	06B5  EB      	        EX      DE,HL
 842:	06B6  E5      	        PUSH    HL              ; Save start of word
 843:			
 844:	06B7  13      	NXTBYT: INC     DE              ; Look through rest of word
 845:	06B8  1A      	        LD      A,(DE)          ; Get byte from table
 846:	06B9  B7      	        OR      A               ; End of word ?
 847:	06BA  FAD906  	        JP      M,MATCH         ; Yes - Match found
 848:	06BD  4F      	        LD      C,A             ; Save it
 849:	06BE  78      	        LD      A,B             ; Get token value
 850:	06BF  FE88    	        CP      ZGOTO           ; Is it "GOTO" token ?
 851:	06C1  C2C806  	        JP      NZ,NOSPC        ; No - Don't allow spaces
 852:	06C4  CD5509  	        CALL    GETCHR          ; Get next character
 853:	06C7  2B      	        DEC     HL              ; Cancel increment from GETCHR
 854:	06C8  23      	NOSPC:  INC     HL              ; Next byte
 855:	06C9  7E      	        LD      A,(HL)          ; Get byte
 856:	06CA  FE61    	        CP      'a'             ; Less than 'a' ?
 857:	06CC  DAD106  	        JP      C,NOCHNG        ; Yes - don't change
 858:	06CF  E65F    	        AND     01011111B       ; Make upper case
 859:	06D1  B9      	NOCHNG: CP      C               ; Same as in buffer ?
 860:	06D2  CAB706  	        JP      Z,NXTBYT        ; Yes - keep testing
 861:	06D5  E1      	        POP     HL              ; Get back start of word
 862:	06D6  C3A506  	        JP      SEARCH          ; Look at next word
 863:			
 864:	06D9  48      	MATCH:  LD      C,B             ; Word found - Save token value
 865:	06DA  F1      	        POP     AF              ; Throw away return
 866:	06DB  EB      	        EX      DE,HL
 867:	06DC  C9      	        RET                     ; Return to "RETNAD"
 868:	06DD  EB      	RETNAD: EX      DE,HL           ; Get address in string
 869:	06DE  79      	        LD      A,C             ; Get token value
 870:	06DF  C1      	        POP     BC              ; Restore buffer length
 871:	06E0  D1      	        POP     DE              ; Get destination address
 872:	06E1  23      	MOVDIR: INC     HL              ; Next source in buffer
 873:	06E2  12      	        LD      (DE),A          ; Put byte in buffer
 874:	06E3  13      	        INC     DE              ; Move up buffer
 875:	06E4  0C      	        INC     C               ; Increment length of buffer
 876:	06E5  D63A    	        SUB     ':'             ; End of statement?
 877:	06E7  CAEF06  	        JP      Z,SETLIT        ; Jump if multi-statement line
 878:	06EA  FE49    	        CP      ZDATA-3AH       ; Is it DATA statement ?
 879:	06EC  C2F206  	        JP      NZ,TSTREM       ; No - see if REM
 880:	06EF  32F320  	SETLIT: LD      (DATFLG),A      ; Set literal flag
 881:	06F2  D654    	TSTREM: SUB     ZREM-3AH        ; Is it REM?
 882:	06F4  C26206  	        JP      NZ,CRNCLP       ; No - Leave flag
 883:	06F7  47      	        LD      B,A             ; Copy rest of buffer
 884:	06F8  7E      	NXTCHR: LD      A,(HL)          ; Get byte
 885:	06F9  B7      	        OR      A               ; End of line ?
 886:	06FA  CA0807  	        JP      Z,ENDBUF        ; Yes - Terminate buffer
 887:	06FD  B8      	        CP      B               ; End of statement ?
 888:	06FE  CAE106  	        JP      Z,MOVDIR        ; Yes - Get next one
 889:	0701  23      	CPYLIT: INC     HL              ; Move up source string
 890:	0702  12      	        LD      (DE),A          ; Save in destination
 891:	0703  0C      	        INC     C               ; Increment length
 892:	0704  13      	        INC     DE              ; Move up destination
 893:	0705  C3F806  	        JP      NXTCHR          ; Repeat
 894:			
 895:	0708  21A520  	ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
 896:	070B  12      	        LD      (DE),A          ; Mark end of buffer (A = 00)
 897:	070C  13      	        INC     DE
 898:	070D  12      	        LD      (DE),A          ; A = 00
 899:	070E  13      	        INC     DE
 900:	070F  12      	        LD      (DE),A          ; A = 00
 901:	0710  C9      	        RET
 902:			
 903:	0711  3A8920  	DODEL:  LD      A,(NULFLG)      ; Get null flag status
 904:	0714  B7      	        OR      A               ; Is it zero?
 905:	0715  3E00    	        LD      A,0             ; Zero A - Leave flags
 906:	0717  328920  	        LD      (NULFLG),A      ; Zero null flag
 907:	071A  C22507  	        JP      NZ,ECHDEL       ; Set - Echo it
 908:	071D  05      	        DEC     B               ; Decrement length
 909:	071E  CA4207  	        JP      Z,GETLIN        ; Get line again if empty
 910:	0721  CDD607  	        CALL    OUTC            ; Output null character
 911:	0724  3E      	        .DB     3EH             ; Skip "DEC B"
 912:	0725  05      	ECHDEL: DEC     B               ; Count bytes in buffer
 913:	0726  2B      	        DEC     HL              ; Back space buffer
 914:	0727  CA3907  	        JP      Z,OTKLN         ; No buffer - Try again
 915:	072A  7E      	        LD      A,(HL)          ; Get deleted byte
 916:	072B  CDD607  	        CALL    OUTC            ; Echo it
 917:	072E  C34B07  	        JP      MORINP          ; Get more input
 918:			
 919:	0731  05      	DELCHR: DEC     B               ; Count bytes in buffer
 920:	0732  2B      	        DEC     HL              ; Back space buffer
 921:	0733  CDD607  	        CALL    OUTC            ; Output character in A
 922:	0736  C24B07  	        JP      NZ,MORINP       ; Not end - Get more
 923:	0739  CDD607  	OTKLN:  CALL    OUTC            ; Output character in A
 924:	073C  CDFD0B  	KILIN:  CALL    PRNTCRLF        ; Output CRLF
 925:	073F  C34207  	        JP      TTYLIN          ; Get line again
 926:			
 927:	0742          	GETLIN:
 928:	0742  21A620  	TTYLIN: LD      HL,BUFFER       ; Get a line by character
 929:	0745  0601    	        LD      B,1             ; Set buffer as empty
 930:	0747  AF      	        XOR     A
 931:	0748  328920  	        LD      (NULFLG),A      ; Clear null flag
 932:	074B  CD0008  	MORINP: CALL    CLOTST          ; Get character and test ^O
 933:	074E  4F      	        LD      C,A             ; Save character in C
 934:	074F  FE7F    	        CP      DEL             ; Delete character?
 935:	0751  CA1107  	        JP      Z,DODEL         ; Yes - Process it
 936:	0754  3A8920  	        LD      A,(NULFLG)      ; Get null flag
 937:	0757  B7      	        OR      A               ; Test null flag status
 938:	0758  CA6407  	        JP      Z,PROCES        ; Reset - Process character
 939:	075B  3E00    	        LD      A,0             ; Set a null
 940:	075D  CDD607  	        CALL    OUTC            ; Output null
 941:	0760  AF      	        XOR     A               ; Clear A
 942:	0761  328920  	        LD      (NULFLG),A      ; Reset null flag
 943:	0764  79      	PROCES: LD      A,C             ; Get character
 944:	0765  FE07    	        CP      CTRLG           ; Bell?
 945:	0767  CAA807  	        JP      Z,PUTCTL        ; Yes - Save it
 946:	076A  FE03    	        CP      CTRLC           ; Is it control "C"?
 947:	076C  CCFD0B  	        CALL    Z,PRNTCRLF      ; Yes - Output CRLF
 948:	076F  37      	        SCF                     ; Flag break
 949:	0770  C8      	        RET     Z               ; Return if control "C"
 950:	0771  FE0D    	        CP      CR              ; Is it enter?
 951:	0773  CAF80B  	        JP      Z,ENDINP        ; Yes - Terminate input
 952:	0776  FE15    	        CP      CTRLU           ; Is it control "U"?
 953:	0778  CA3C07  	        JP      Z,KILIN         ; Yes - Get another line
 954:	077B  FE40    	        CP      '@'             ; Is it "kill line"?
 955:	077D  CA3907  	        JP      Z,OTKLN         ; Yes - Kill line
 956:	0780  FE5F    	        CP      '_'             ; Is it delete?
 957:	0782  CA3107  	        JP      Z,DELCHR        ; Yes - Delete character
 958:	0785  FE08    	        CP      BKSP            ; Is it backspace?
 959:	0787  CA3107  	        JP      Z,DELCHR        ; Yes - Delete character
 960:	078A  FE12    	        CP      CTRLR           ; Is it control "R"?
 961:	078C  C2A307  	        JP      NZ,PUTBUF       ; No - Put in buffer
 962:	078F  C5      	        PUSH    BC              ; Save buffer length
 963:	0790  D5      	        PUSH    DE              ; Save DE
 964:	0791  E5      	        PUSH    HL              ; Save buffer address
 965:	0792  3600    	        LD      (HL),0          ; Mark end of buffer
 966:	0794  CDAB1D  	        CALL    OUTNCR          ; Output and do CRLF
 967:	0797  21A620  	        LD      HL,BUFFER       ; Point to buffer start
 968:	079A  CD9B12  	        CALL    PRS             ; Output buffer
 969:	079D  E1      	        POP     HL              ; Restore buffer address
 970:	079E  D1      	        POP     DE              ; Restore DE
 971:	079F  C1      	        POP     BC              ; Restore buffer length
 972:	07A0  C34B07  	        JP      MORINP          ; Get another character
 973:			
 974:	07A3  FE20    	PUTBUF: CP      ' '             ; Is it a control code?
 975:	07A5  DA4B07  	        JP      C,MORINP        ; Yes - Ignore
 976:	07A8  78      	PUTCTL: LD      A,B             ; Get number of bytes in buffer
 977:	07A9  FE49    	        CP      72+1            ; Test for line overflow
 978:	07AB  3E07    	        LD      A,CTRLG         ; Set a bell
 979:	07AD  D2BD07  	        JP      NC,OUTNBS       ; Ring bell if buffer full
 980:	07B0  79      	        LD      A,C             ; Get character
 981:	07B1  71      	        LD      (HL),C          ; Save in buffer
 982:	07B2  321121  	        LD      (LSTBIN),A      ; Save last input byte
 983:	07B5  23      	        INC     HL              ; Move up buffer
 984:	07B6  04      	        INC     B               ; Increment length
 985:	07B7  CDD607  	OUTIT:  CALL    OUTC            ; Output the character entered
 986:	07BA  C34B07  	        JP      MORINP          ; Get another character
 987:			
 988:	07BD  CDD607  	OUTNBS: CALL    OUTC            ; Output bell and back over it
 989:	07C0  3E08    	        LD      A,BKSP          ; Set back space
 990:	07C2  C3B707  	        JP      OUTIT           ; Output it and get more
 991:			
 992:	07C5  7C      	CPDEHL: LD      A,H             ; Get H
 993:	07C6  92      	        SUB     D               ; Compare with D
 994:	07C7  C0      	        RET     NZ              ; Different - Exit
 995:	07C8  7D      	        LD      A,L             ; Get L
 996:	07C9  93      	        SUB     E               ; Compare with E
 997:	07CA  C9      	        RET                     ; Return status
 998:			
 999:	07CB  7E      	CHKSYN: LD      A,(HL)          ; Check syntax of character
1000:	07CC  E3      	        EX      (SP),HL         ; Address of test byte
1001:	07CD  BE      	        CP      (HL)            ; Same as in code string?
1002:	07CE  23      	        INC     HL              ; Return address
1003:	07CF  E3      	        EX      (SP),HL         ; Put it back
1004:	07D0  CA5509  	        JP      Z,GETCHR        ; Yes - Get next character
1005:	07D3  C3FD04  	        JP      SNERR           ; Different - ?SN Error
1006:			
1007:	07D6  F5      	OUTC:   PUSH    AF              ; Save character
1008:	07D7  3A8A20  	        LD      A,(CTLOFG)      ; Get control "O" flag
1009:	07DA  B7      	        OR      A               ; Is it set?
1010:	07DB  C2D012  	        JP      NZ,POPAF        ; Yes - don't output
1011:	07DE  F1      	        POP     AF              ; Restore character
1012:	07DF  C5      	        PUSH    BC              ; Save buffer length
1013:	07E0  F5      	        PUSH    AF              ; Save character
1014:	07E1  FE20    	        CP      ' '             ; Is it a control code?
1015:	07E3  DAFA07  	        JP      C,DINPOS        ; Yes - Don't INC POS(X)
1016:	07E6  3A8720  	        LD      A,(LWIDTH)      ; Get line width
1017:	07E9  47      	        LD      B,A             ; To B
1018:	07EA  3AF020  	        LD      A,(CURPOS)      ; Get cursor position
1019:	07ED  04      	        INC     B               ; Width 255?
1020:	07EE  CAF607  	        JP      Z,INCLEN        ; Yes - No width limit
1021:	07F1  05      	        DEC     B               ; Restore width
1022:	07F2  B8      	        CP      B               ; At end of line?
1023:	07F3  CCFD0B  	        CALL    Z,PRNTCRLF      ; Yes - output CRLF
1024:	07F6  3C      	INCLEN: INC     A               ; Move on one character
1025:	07F7  32F020  	        LD      (CURPOS),A      ; Save new position
1026:	07FA  F1      	DINPOS: POP     AF              ; Restore character
1027:	07FB  C1      	        POP     BC              ; Restore buffer length
1028:	07FC  CD961D  	        CALL    MONOUT          ; Send it
1029:	07FF  C9      	        RET
1030:			
1031:	0800  CD5A1C  	CLOTST: CALL    GETINP          ; Get input character
1032:	0803  E67F    	        AND     01111111B       ; Strip bit 7
1033:	0805  FE0F    	        CP      CTRLO           ; Is it control "O"?
1034:	0807  C0      	        RET     NZ              ; No don't flip flag
1035:	0808  3A8A20  	        LD      A,(CTLOFG)      ; Get flag
1036:	080B  2F      	        CPL                     ; Flip it
1037:	080C  328A20  	        LD      (CTLOFG),A      ; Put it back
1038:	080F  AF      	        XOR     A               ; Null character
1039:	0810  C9      	        RET
1040:			
1041:	0811  CD210A  	LIST:   CALL    ATOH            ; ASCII number to DE
1042:	0814  C0      	        RET     NZ              ; Return if anything extra
1043:	0815  C1      	        POP     BC              ; Rubbish - Not needed
1044:	0816  CDE905  	        CALL    SRCHLN          ; Search for line number in DE
1045:	0819  C5      	        PUSH    BC              ; Save address of line
1046:	081A  CD6708  	        CALL    SETLIN          ; Set up lines counter
1047:	081D  E1      	LISTLP: POP     HL              ; Restore address of line
1048:	081E  4E      	        LD      C,(HL)          ; Get LSB of next line
1049:	081F  23      	        INC     HL
1050:	0820  46      	        LD      B,(HL)          ; Get MSB of next line
1051:	0821  23      	        INC     HL
1052:	0822  78      	        LD      A,B             ; BC = 0 (End of program)?
1053:	0823  B1      	        OR      C
1054:	0824  CA4805  	        JP      Z,PRNTOK        ; Yes - Go to command mode
1055:	0827  CD7008  	        CALL    COUNT           ; Count lines
1056:	082A  CD8009  	        CALL    TSTBRK          ; Test for break key
1057:	082D  C5      	        PUSH    BC              ; Save address of next line
1058:	082E  CDFD0B  	        CALL    PRNTCRLF        ; Output CRLF
1059:	0831  5E      	        LD      E,(HL)          ; Get LSB of line number
1060:	0832  23      	        INC     HL
1061:	0833  56      	        LD      D,(HL)          ; Get MSB of line number
1062:	0834  23      	        INC     HL
1063:	0835  E5      	        PUSH    HL              ; Save address of line start
1064:	0836  EB      	        EX      DE,HL           ; Line number to HL
1065:	0837  CD3E19  	        CALL    PRNTHL          ; Output line number in decimal
1066:	083A  3E20    	        LD      A,' '           ; Space after line number
1067:	083C  E1      	        POP     HL              ; Restore start of line address
1068:	083D  CDD607  	LSTLP2: CALL    OUTC            ; Output character in A
1069:	0840  7E      	LSTLP3: LD      A,(HL)          ; Get next byte in line
1070:	0841  B7      	        OR      A               ; End of line?
1071:	0842  23      	        INC     HL              ; To next byte in line
1072:	0843  CA1D08  	        JP      Z,LISTLP        ; Yes - get next line
1073:	0846  F23D08  	        JP      P,LSTLP2        ; No token - output it
1074:	0849  D67F    	        SUB     ZEND-1          ; Find and output word
1075:	084B  4F      	        LD      C,A             ; Token offset+1 to C
1076:	084C  118602  	        LD      DE,WORDS        ; Reserved word list
1077:	084F  1A      	FNDTOK: LD      A,(DE)          ; Get character in list
1078:	0850  13      	        INC     DE              ; Move on to next
1079:	0851  B7      	        OR      A               ; Is it start of word?
1080:	0852  F24F08  	        JP      P,FNDTOK        ; No - Keep looking for word
1081:	0855  0D      	        DEC     C               ; Count words
1082:	0856  C24F08  	        JP      NZ,FNDTOK       ; Not there - keep looking
1083:	0859  E67F    	OUTWRD: AND     01111111B       ; Strip bit 7
1084:	085B  CDD607  	        CALL    OUTC            ; Output first character
1085:	085E  1A      	        LD      A,(DE)          ; Get next character
1086:	085F  13      	        INC     DE              ; Move on to next
1087:	0860  B7      	        OR      A               ; Is it end of word?
1088:	0861  F25908  	        JP      P,OUTWRD        ; No - output the rest
1089:	0864  C34008  	        JP      LSTLP3          ; Next byte in line
1090:			
1091:	0867  E5      	SETLIN: PUSH    HL              ; Set up LINES counter
1092:	0868  2A8D20  	        LD      HL,(LINESN)     ; Get LINES number
1093:	086B  228B20  	        LD      (LINESC),HL     ; Save in LINES counter
1094:	086E  E1      	        POP     HL
1095:	086F  C9      	        RET
1096:			
1097:	0870  E5      	COUNT:  PUSH    HL              ; Save code string address
1098:	0871  D5      	        PUSH    DE
1099:	0872  2A8B20  	        LD      HL,(LINESC)     ; Get LINES counter
1100:	0875  11FFFF  	        LD      DE,-1
1101:	0878  ED5A    	        ADC     HL,DE           ; Decrement
1102:	087A  228B20  	        LD      (LINESC),HL     ; Put it back
1103:	087D  D1      	        POP     DE
1104:	087E  E1      	        POP     HL              ; Restore code string address
1105:	087F  F0      	        RET     P               ; Return if more lines to go
1106:	0880  E5      	        PUSH    HL              ; Save code string address
1107:	0881  2A8D20  	        LD      HL,(LINESN)     ; Get LINES number
1108:	0884  228B20  	        LD      (LINESC),HL     ; Reset LINES counter
1109:	0887  CD5A1C  	        CALL    GETINP          ; Get input character
1110:	088A  FE03    	        CP      CTRLC           ; Is it control "C"?
1111:	088C  CA9308  	        JP      Z,RSLNBK        ; Yes - Reset LINES and break
1112:	088F  E1      	        POP     HL              ; Restore code string address
1113:	0890  C37008  	        JP      COUNT           ; Keep on counting
1114:			
1115:	0893  2A8D20  	RSLNBK: LD      HL,(LINESN)     ; Get LINES number
1116:	0896  228B20  	        LD      (LINESC),HL     ; Reset LINES counter
1117:	0899  C3F701  	        JP      BRKRET          ; Go and output "Break"
1118:			
1119:	089C  3E64    	FOR:    LD      A,64H           ; Flag "FOR" assignment
1120:	089E  321021  	        LD      (FORFLG),A      ; Save "FOR" flag
1121:	08A1  CD030B  	        CALL    LET             ; Set up initial index
1122:	08A4  C1      	        POP     BC              ; Drop RETurn address
1123:	08A5  E5      	        PUSH    HL              ; Save code string address
1124:	08A6  CDEC0A  	        CALL    DATA            ; Get next statement address
1125:	08A9  220C21  	        LD      (LOOPST),HL     ; Save it for start of loop
1126:	08AC  210200  	        LD      HL,2            ; Offset for "FOR" block
1127:	08AF  39      	        ADD     HL,SP           ; Point to it
1128:	08B0  CDAA04  	FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
1129:	08B3  D1      	        POP     DE              ; Get code string address
1130:	08B4  C2CC08  	        JP      NZ,FORFND       ; No nesting found
1131:	08B7  09      	        ADD     HL,BC           ; Move into "FOR" block
1132:	08B8  D5      	        PUSH    DE              ; Save code string address
1133:	08B9  2B      	        DEC     HL
1134:	08BA  56      	        LD      D,(HL)          ; Get MSB of loop statement
1135:	08BB  2B      	        DEC     HL
1136:	08BC  5E      	        LD      E,(HL)          ; Get LSB of loop statement
1137:	08BD  23      	        INC     HL
1138:	08BE  23      	        INC     HL
1139:	08BF  E5      	        PUSH    HL              ; Save block address
1140:	08C0  2A0C21  	        LD      HL,(LOOPST)     ; Get address of loop statement
1141:	08C3  CDC507  	        CALL    CPDEHL          ; Compare the FOR loops
1142:	08C6  E1      	        POP     HL              ; Restore block address
1143:	08C7  C2B008  	        JP      NZ,FORSLP       ; Different FORs - Find another
1144:	08CA  D1      	        POP     DE              ; Restore code string address
1145:	08CB  F9      	        LD      SP,HL           ; Remove all nested loops
1146:			
1147:	08CC  EB      	FORFND: EX      DE,HL           ; Code string address to HL
1148:	08CD  0E08    	        LD      C,8
1149:	08CF  CDDA04  	        CALL    CHKSTK          ; Check for 8 levels of stack
1150:	08D2  E5      	        PUSH    HL              ; Save code string address
1151:	08D3  2A0C21  	        LD      HL,(LOOPST)     ; Get first statement of loop
1152:	08D6  E3      	        EX      (SP),HL         ; Save and restore code string
1153:	08D7  E5      	        PUSH    HL              ; Re-save code string address
1154:	08D8  2AA120  	        LD      HL,(LINEAT)     ; Get current line number
1155:	08DB  E3      	        EX      (SP),HL         ; Save and restore code string
1156:	08DC  CDC50D  	        CALL    TSTNUM          ; Make sure it's a number
1157:	08DF  CDCB07  	        CALL    CHKSYN          ; Make sure "TO" is next
1158:	08E2  A6      	        .DB     ZTO             ; "TO" token
1159:	08E3  CDC20D  	        CALL    GETNUM          ; Get "TO" expression value
1160:	08E6  E5      	        PUSH    HL              ; Save code string address
1161:	08E7  CDF017  	        CALL    BCDEFP          ; Move "TO" value to BCDE
1162:	08EA  E1      	        POP     HL              ; Restore code string address
1163:	08EB  C5      	        PUSH    BC              ; Save "TO" value in block
1164:	08EC  D5      	        PUSH    DE
1165:	08ED  010081  	        LD      BC,8100H        ; BCDE - 1 (default STEP)
1166:	08F0  51      	        LD      D,C             ; C=0
1167:	08F1  5A      	        LD      E,D             ; D=0
1168:	08F2  7E      	        LD      A,(HL)          ; Get next byte in code string
1169:	08F3  FEAB    	        CP      ZSTEP           ; See if "STEP" is stated
1170:	08F5  3E01    	        LD      A,1             ; Sign of step = 1
1171:	08F7  C20809  	        JP      NZ,SAVSTP       ; No STEP given - Default to 1
1172:	08FA  CD5509  	        CALL    GETCHR          ; Jump over "STEP" token
1173:	08FD  CDC20D  	        CALL    GETNUM          ; Get step value
1174:	0900  E5      	        PUSH    HL              ; Save code string address
1175:	0901  CDF017  	        CALL    BCDEFP          ; Move STEP to BCDE
1176:	0904  CDA417  	        CALL    TSTSGN          ; Test sign of FPREG
1177:	0907  E1      	        POP     HL              ; Restore code string address
1178:	0908  C5      	SAVSTP: PUSH    BC              ; Save the STEP value in block
1179:	0909  D5      	        PUSH    DE
1180:	090A  F5      	        PUSH    AF              ; Save sign of STEP
1181:	090B  33      	        INC     SP              ; Don't save flags
1182:	090C  E5      	        PUSH    HL              ; Save code string address
1183:	090D  2A1321  	        LD      HL,(BRKLIN)     ; Get address of index variable
1184:	0910  E3      	        EX      (SP),HL         ; Save and restore code string
1185:	0911  0681    	PUTFID: LD      B,ZFOR          ; "FOR" block marker
1186:	0913  C5      	        PUSH    BC              ; Save it
1187:	0914  33      	        INC     SP              ; Don't save C
1188:			
1189:	0915  CD8009  	RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
1190:	0918  221321  	        LD      (BRKLIN),HL     ; Save code address for break
1191:	091B  7E      	        LD      A,(HL)          ; Get next byte in code string
1192:	091C  FE3A    	        CP      ':'             ; Multi statement line?
1193:	091E  CA3509  	        JP      Z,EXCUTE        ; Yes - Execute it
1194:	0921  B7      	        OR      A               ; End of line?
1195:	0922  C2FD04  	        JP      NZ,SNERR        ; No - Syntax error
1196:	0925  23      	        INC     HL              ; Point to address of next line
1197:	0926  7E      	        LD      A,(HL)          ; Get LSB of line pointer
1198:	0927  23      	        INC     HL
1199:	0928  B6      	        OR      (HL)            ; Is it zero (End of prog)?
1200:	0929  CAA709  	        JP      Z,ENDPRG        ; Yes - Terminate execution
1201:	092C  23      	        INC     HL              ; Point to line number
1202:	092D  5E      	        LD      E,(HL)          ; Get LSB of line number
1203:	092E  23      	        INC     HL
1204:	092F  56      	        LD      D,(HL)          ; Get MSB of line number
1205:	0930  EB      	        EX      DE,HL           ; Line number to HL
1206:	0931  22A120  	        LD      (LINEAT),HL     ; Save as current line number
1207:	0934  EB      	        EX      DE,HL           ; Line number back to DE
1208:	0935  CD5509  	EXCUTE: CALL    GETCHR          ; Get key word
1209:	0938  111509  	        LD      DE,RUNCNT       ; Where to RETurn to
1210:	093B  D5      	        PUSH    DE              ; Save for RETurn
1211:	093C  C8      	IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
1212:	093D  D680    	ONJMP:  SUB     ZEND            ; Is it a token?
1213:	093F  DA030B  	        JP      C,LET           ; No - try to assign it
1214:	0942  FE25    	        CP      ZNEW+1-ZEND     ; END to NEW ?
1215:	0944  D2FD04  	        JP      NC,SNERR        ; Not a key word - ?SN Error
1216:	0947  07      	        RLCA                    ; Double it
1217:	0948  4F      	        LD      C,A             ; BC = Offset into table
1218:	0949  0600    	        LD      B,0
1219:	094B  EB      	        EX      DE,HL           ; Save code string address
1220:	094C  21A503  	        LD      HL,WORDTB       ; Keyword address table
1221:	094F  09      	        ADD     HL,BC           ; Point to routine address
1222:	0950  4E      	        LD      C,(HL)          ; Get LSB of routine address
1223:	0951  23      	        INC     HL
1224:	0952  46      	        LD      B,(HL)          ; Get MSB of routine address
1225:	0953  C5      	        PUSH    BC              ; Save routine address
1226:	0954  EB      	        EX      DE,HL           ; Restore code string address
1227:			
1228:	0955  23      	GETCHR: INC     HL              ; Point to next character
1229:	0956  7E      	        LD      A,(HL)          ; Get next code string byte
1230:	0957  FE3A    	        CP      ':'             ; Z if ':'
1231:	0959  D0      	        RET     NC              ; NC if > "9"
1232:	095A  FE20    	        CP      ' '
1233:	095C  CA5509  	        JP      Z,GETCHR        ; Skip over spaces
1234:	095F  FE30    	        CP      '0'
1235:	0961  3F      	        CCF                     ; NC if < '0'
1236:	0962  3C      	        INC     A               ; Test for zero - Leave carry
1237:	0963  3D      	        DEC     A               ; Z if Null
1238:	0964  C9      	        RET
1239:			
1240:	0965  EB      	RESTOR: EX      DE,HL           ; Save code string address
1241:	0966  2AA320  	        LD      HL,(BASTXT)     ; Point to start of program
1242:	0969  CA7A09  	        JP      Z,RESTNL        ; Just RESTORE - reset pointer
1243:	096C  EB      	        EX      DE,HL           ; Restore code string address
1244:	096D  CD210A  	        CALL    ATOH            ; Get line number to DE
1245:	0970  E5      	        PUSH    HL              ; Save code string address
1246:	0971  CDE905  	        CALL    SRCHLN          ; Search for line number in DE
1247:	0974  60      	        LD      H,B             ; HL = Address of line
1248:	0975  69      	        LD      L,C
1249:	0976  D1      	        POP     DE              ; Restore code string address
1250:	0977  D2C20A  	        JP      NC,ULERR        ; ?UL Error if not found
1251:	097A  2B      	RESTNL: DEC     HL              ; Byte before DATA statement
1252:	097B  222121  	UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
1253:	097E  EB      	        EX      DE,HL           ; Restore code string address
1254:	097F  C9      	        RET
1255:			
1256:			
1257:	0980  DF      	TSTBRK: RST     18H             ; Check input status
1258:	0981  C8      	        RET     Z               ; No key, go back
1259:	0982  D7      	        RST     10H             ; Get the key into A
1260:	0983  FE1B    	        CP      ESC             ; Escape key?
1261:	0985  2811    	        JR      Z,BRK           ; Yes, break
1262:	0987  FE03    	        CP      CTRLC           ; <Ctrl-C>
1263:	0989  280D    	        JR      Z,BRK           ; Yes, break
1264:	098B  FE13    	        CP      CTRLS           ; Stop scrolling?
1265:	098D  C0      	        RET     NZ              ; Other key, ignore
1266:			
1267:			
1268:	098E  D7      	STALL:  RST     10H             ; Wait for key
1269:	098F  FE11    	        CP      CTRLQ           ; Resume scrolling?
1270:	0991  C8      	        RET      Z              ; Release the chokehold
1271:	0992  FE03    	        CP      CTRLC           ; Second break?
1272:	0994  2807    	        JR      Z,STOP          ; Break during hold exits prog
1273:	0996  18F6    	        JR      STALL           ; Loop until <Ctrl-Q> or <brk>
1274:			
1275:	0998  3EFF    	BRK     LD      A,0FFH          ; Set BRKFLG
1276:	099A  329220  	        LD      (BRKFLG),A      ; Store it
1277:			
1278:			
1279:	099D  C0      	STOP:   RET     NZ              ; Exit if anything else
1280:	099E  F6      	        .DB     0F6H            ; Flag "STOP"
1281:	099F  C0      	PEND:   RET     NZ              ; Exit if anything else
1282:	09A0  221321  	        LD      (BRKLIN),HL     ; Save point of break
1283:	09A3  21      	        .DB     21H             ; Skip "OR 11111111B"
1284:	09A4  F6FF    	INPBRK: OR      11111111B       ; Flag "Break" wanted
1285:	09A6  C1      	        POP     BC              ; Return not needed and more
1286:	09A7  2AA120  	ENDPRG: LD      HL,(LINEAT)     ; Get current line number
1287:	09AA  F5      	        PUSH    AF              ; Save STOP / END status
1288:	09AB  7D      	        LD      A,L             ; Is it direct break?
1289:	09AC  A4      	        AND     H
1290:	09AD  3C      	        INC     A               ; Line is -1 if direct break
1291:	09AE  CABA09  	        JP      Z,NOLIN         ; Yes - No line number
1292:	09B1  221721  	        LD      (ERRLIN),HL     ; Save line of break
1293:	09B4  2A1321  	        LD      HL,(BRKLIN)     ; Get point of break
1294:	09B7  221921  	        LD      (CONTAD),HL     ; Save point to CONTinue
1295:	09BA  AF      	NOLIN:  XOR     A
1296:	09BB  328A20  	        LD      (CTLOFG),A      ; Enable output
1297:	09BE  CDF00B  	        CALL    STTLIN          ; Start a new line
1298:	09C1  F1      	        POP     AF              ; Restore STOP / END status
1299:	09C2  21A004  	        LD      HL,BRKMSG       ; "Break" message
1300:	09C5  C23105  	        JP      NZ,ERRIN        ; "in line" wanted?
1301:	09C8  C34805  	        JP      PRNTOK          ; Go to command mode
1302:			
1303:	09CB  2A1921  	CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
1304:	09CE  7C      	        LD      A,H             ; Is it zero?
1305:	09CF  B5      	        OR      L
1306:	09D0  1E20    	        LD      E,CN            ; ?CN Error
1307:	09D2  CA1105  	        JP      Z,ERROR         ; Yes - output "?CN Error"
1308:	09D5  EB      	        EX      DE,HL           ; Save code string address
1309:	09D6  2A1721  	        LD      HL,(ERRLIN)     ; Get line of last break
1310:	09D9  22A120  	        LD      (LINEAT),HL     ; Set up current line number
1311:	09DC  EB      	        EX      DE,HL           ; Restore code string address
1312:	09DD  C9      	        RET                     ; CONTinue where left off
1313:			
1314:	09DE  CD2315  	NULL:   CALL    GETINT          ; Get integer 0-255
1315:	09E1  C0      	        RET     NZ              ; Return if bad value
1316:	09E2  328620  	        LD      (NULLS),A       ; Set nulls number
1317:	09E5  C9      	        RET
1318:			
1319:			
1320:	09E6  E5      	ACCSUM: PUSH    HL              ; Save address in array
1321:	09E7  2A8F20  	        LD      HL,(CHKSUM)     ; Get check sum
1322:	09EA  0600    	        LD      B,0             ; BC - Value of byte
1323:	09EC  4F      	        LD      C,A
1324:	09ED  09      	        ADD     HL,BC           ; Add byte to check sum
1325:	09EE  228F20  	        LD      (CHKSUM),HL     ; Re-save check sum
1326:	09F1  E1      	        POP     HL              ; Restore address in array
1327:	09F2  C9      	        RET
1328:			
1329:	09F3  7E      	CHKLTR: LD      A,(HL)          ; Get byte
1330:	09F4  FE41    	        CP      'A'             ; < 'a' ?
1331:	09F6  D8      	        RET     C               ; Carry set if not letter
1332:	09F7  FE5B    	        CP      'Z'+1           ; > 'z' ?
1333:	09F9  3F      	        CCF
1334:	09FA  C9      	        RET                     ; Carry set if not letter
1335:			
1336:	09FB  CD5509  	FPSINT: CALL    GETCHR          ; Get next character
1337:	09FE  CDC20D  	POSINT: CALL    GETNUM          ; Get integer 0 to 32767
1338:	0A01  CDA417  	DEPINT: CALL    TSTSGN          ; Test sign of FPREG
1339:	0A04  FA1C0A  	        JP      M,FCERR         ; Negative - ?FC Error
1340:	0A07  3A2C21  	DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
1341:	0A0A  FE90    	        CP      80H+16          ; Exponent in range (16 bits)?
1342:	0A0C  DA4C18  	        JP      C,FPINT         ; Yes - convert it
1343:	0A0F  018090  	        LD      BC,9080H        ; BCDE = -32768
1344:	0A12  110000  	        LD      DE,0000
1345:	0A15  E5      	        PUSH    HL              ; Save code string address
1346:	0A16  CD1F18  	        CALL    CMPNUM          ; Compare FPREG with BCDE
1347:	0A19  E1      	        POP     HL              ; Restore code string address
1348:	0A1A  51      	        LD      D,C             ; MSB to D
1349:	0A1B  C8      	        RET     Z               ; Return if in range
1350:	0A1C  1E08    	FCERR:  LD      E,FC            ; ?FC Error
1351:	0A1E  C31105  	        JP      ERROR           ; Output error-
1352:			
1353:	0A21  2B      	ATOH:   DEC     HL              ; ASCII number to DE binary
1354:	0A22  110000  	GETLN:  LD      DE,0            ; Get number to DE
1355:	0A25  CD5509  	GTLNLP: CALL    GETCHR          ; Get next character
1356:	0A28  D0      	        RET     NC              ; Exit if not a digit
1357:	0A29  E5      	        PUSH    HL              ; Save code string address
1358:	0A2A  F5      	        PUSH    AF              ; Save digit
1359:	0A2B  219819  	        LD      HL,65529/10     ; Largest number 65529
1360:	0A2E  CDC507  	        CALL    CPDEHL          ; Number in range?
1361:	0A31  DAFD04  	        JP      C,SNERR         ; No - ?SN Error
1362:	0A34  62      	        LD      H,D             ; HL = Number
1363:	0A35  6B      	        LD      L,E
1364:	0A36  19      	        ADD     HL,DE           ; Times 2
1365:	0A37  29      	        ADD     HL,HL           ; Times 4
1366:	0A38  19      	        ADD     HL,DE           ; Times 5
1367:	0A39  29      	        ADD     HL,HL           ; Times 10
1368:	0A3A  F1      	        POP     AF              ; Restore digit
1369:	0A3B  D630    	        SUB     '0'             ; Make it 0 to 9
1370:	0A3D  5F      	        LD      E,A             ; DE = Value of digit
1371:	0A3E  1600    	        LD      D,0
1372:	0A40  19      	        ADD     HL,DE           ; Add to number
1373:	0A41  EB      	        EX      DE,HL           ; Number to DE
1374:	0A42  E1      	        POP     HL              ; Restore code string address
1375:	0A43  C3250A  	        JP      GTLNLP          ; Go to next character
1376:			
1377:	0A46  CA1906  	CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
1378:	0A49  CDFE09  	        CALL    POSINT          ; Get integer 0 to 32767 to DE
1379:	0A4C  2B      	        DEC     HL              ; Cancel increment
1380:	0A4D  CD5509  	        CALL    GETCHR          ; Get next character
1381:	0A50  E5      	        PUSH    HL              ; Save code string address
1382:	0A51  2AF420  	        LD      HL,(LSTRAM)     ; Get end of RAM
1383:	0A54  CA690A  	        JP      Z,STORED        ; No value given - Use stored
1384:	0A57  E1      	        POP     HL              ; Restore code string address
1385:	0A58  CDCB07  	        CALL    CHKSYN          ; Check for comma
1386:	0A5B  2C      	        .DB     ','
1387:	0A5C  D5      	        PUSH    DE              ; Save number
1388:	0A5D  CDFE09  	        CALL    POSINT          ; Get integer 0 to 32767
1389:	0A60  2B      	        DEC     HL              ; Cancel increment
1390:	0A61  CD5509  	        CALL    GETCHR          ; Get next character
1391:	0A64  C2FD04  	        JP      NZ,SNERR        ; ?SN Error if more on line
1392:	0A67  E3      	        EX      (SP),HL         ; Save code string address
1393:	0A68  EB      	        EX      DE,HL           ; Number to DE
1394:	0A69  7D      	STORED: LD      A,L             ; Get LSB of new RAM top
1395:	0A6A  93      	        SUB     E               ; Subtract LSB of string space
1396:	0A6B  5F      	        LD      E,A             ; Save LSB
1397:	0A6C  7C      	        LD      A,H             ; Get MSB of new RAM top
1398:	0A6D  9A      	        SBC     A,D             ; Subtract MSB of string space
1399:	0A6E  57      	        LD      D,A             ; Save MSB
1400:	0A6F  DAF204  	        JP      C,OMERR         ; ?OM Error if not enough mem
1401:	0A72  E5      	        PUSH    HL              ; Save RAM top
1402:	0A73  2A1B21  	        LD      HL,(PROGND)     ; Get program end
1403:	0A76  012800  	        LD      BC,40           ; 40 Bytes minimum working RAM
1404:	0A79  09      	        ADD     HL,BC           ; Get lowest address
1405:	0A7A  CDC507  	        CALL    CPDEHL          ; Enough memory?
1406:	0A7D  D2F204  	        JP      NC,OMERR        ; No - ?OM Error
1407:	0A80  EB      	        EX      DE,HL           ; RAM top to HL
1408:	0A81  229F20  	        LD      (STRSPC),HL     ; Set new string space
1409:	0A84  E1      	        POP     HL              ; End of memory to use
1410:	0A85  22F420  	        LD      (LSTRAM),HL     ; Set new top of RAM
1411:	0A88  E1      	        POP     HL              ; Restore code string address
1412:	0A89  C31906  	        JP      INTVAR          ; Initialise variables
1413:			
1414:	0A8C  CA1506  	RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
1415:	0A8F  CD1906  	        CALL    INTVAR          ; Initialise variables
1416:	0A92  011509  	        LD      BC,RUNCNT       ; Execution driver loop
1417:	0A95  C3A80A  	        JP      RUNLIN          ; RUN from line number
1418:			
1419:	0A98  0E03    	GOSUB:  LD      C,3             ; 3 Levels of stack needed
1420:	0A9A  CDDA04  	        CALL    CHKSTK          ; Check for 3 levels of stack
1421:	0A9D  C1      	        POP     BC              ; Get return address
1422:	0A9E  E5      	        PUSH    HL              ; Save code string for RETURN
1423:	0A9F  E5      	        PUSH    HL              ; And for GOSUB routine
1424:	0AA0  2AA120  	        LD      HL,(LINEAT)     ; Get current line
1425:	0AA3  E3      	        EX      (SP),HL         ; Into stack - Code string out
1426:	0AA4  3E8C    	        LD      A,ZGOSUB        ; "GOSUB" token
1427:	0AA6  F5      	        PUSH    AF              ; Save token
1428:	0AA7  33      	        INC     SP              ; Don't save flags
1429:			
1430:	0AA8  C5      	RUNLIN: PUSH    BC              ; Save return address
1431:	0AA9  CD210A  	GOTO:   CALL    ATOH            ; ASCII number to DE binary
1432:	0AAC  CDEE0A  	        CALL    REM             ; Get end of line
1433:	0AAF  E5      	        PUSH    HL              ; Save end of line
1434:	0AB0  2AA120  	        LD      HL,(LINEAT)     ; Get current line
1435:	0AB3  CDC507  	        CALL    CPDEHL          ; Line after current?
1436:	0AB6  E1      	        POP     HL              ; Restore end of line
1437:	0AB7  23      	        INC     HL              ; Start of next line
1438:	0AB8  DCEC05  	        CALL    C,SRCHLP        ; Line is after current line
1439:	0ABB  D4E905  	        CALL    NC,SRCHLN       ; Line is before current line
1440:	0ABE  60      	        LD      H,B             ; Set up code string address
1441:	0ABF  69      	        LD      L,C
1442:	0AC0  2B      	        DEC     HL              ; Incremented after
1443:	0AC1  D8      	        RET     C               ; Line found
1444:	0AC2  1E0E    	ULERR:  LD      E,UL            ; ?UL Error
1445:	0AC4  C31105  	        JP      ERROR           ; Output error message
1446:			
1447:	0AC7  C0      	RETURN: RET     NZ              ; Return if not just RETURN
1448:	0AC8  16FF    	        LD      D,-1            ; Flag "GOSUB" search
1449:	0ACA  CDA604  	        CALL    BAKSTK          ; Look "GOSUB" block
1450:	0ACD  F9      	        LD      SP,HL           ; Kill all FORs in subroutine
1451:	0ACE  FE8C    	        CP      ZGOSUB          ; Test for "GOSUB" token
1452:	0AD0  1E04    	        LD      E,RG            ; ?RG Error
1453:	0AD2  C21105  	        JP      NZ,ERROR        ; Error if no "GOSUB" found
1454:	0AD5  E1      	        POP     HL              ; Get RETURN line number
1455:	0AD6  22A120  	        LD      (LINEAT),HL     ; Save as current
1456:	0AD9  23      	        INC     HL              ; Was it from direct statement?
1457:	0ADA  7C      	        LD      A,H
1458:	0ADB  B5      	        OR      L               ; Return to line
1459:	0ADC  C2E60A  	        JP      NZ,RETLIN       ; No - Return to line
1460:	0ADF  3A1121  	        LD      A,(LSTBIN)      ; Any INPUT in subroutine?
1461:	0AE2  B7      	        OR      A               ; If so buffer is corrupted
1462:	0AE3  C24705  	        JP      NZ,POPNOK       ; Yes - Go to command mode
1463:	0AE6  211509  	RETLIN: LD      HL,RUNCNT       ; Execution driver loop
1464:	0AE9  E3      	        EX      (SP),HL         ; Into stack - Code string out
1465:	0AEA  3E      	        .DB     3EH             ; Skip "POP HL"
1466:	0AEB  E1      	NXTDTA: POP     HL              ; Restore code string address
1467:			
1468:	0AEC  013A    	DATA:   .DB     01H,3AH         ; ':' End of statement
1469:	0AEE  0E00    	REM:    LD      C,0             ; 00  End of statement
1470:	0AF0  0600    	        LD      B,0
1471:	0AF2  79      	NXTSTL: LD      A,C             ; Statement and byte
1472:	0AF3  48      	        LD      C,B
1473:	0AF4  47      	        LD      B,A             ; Statement end byte
1474:	0AF5  7E      	NXTSTT: LD      A,(HL)          ; Get byte
1475:	0AF6  B7      	        OR      A               ; End of line?
1476:	0AF7  C8      	        RET     Z               ; Yes - Exit
1477:	0AF8  B8      	        CP      B               ; End of statement?
1478:	0AF9  C8      	        RET     Z               ; Yes - Exit
1479:	0AFA  23      	        INC     HL              ; Next byte
1480:	0AFB  FE22    	        CP      '"'             ; Literal string?
1481:	0AFD  CAF20A  	        JP      Z,NXTSTL        ; Yes - Look for another '"'
1482:	0B00  C3F50A  	        JP      NXTSTT          ; Keep looking
1483:			
1484:	0B03  CDB80F  	LET:    CALL    GETVAR          ; Get variable name
1485:	0B06  CDCB07  	        CALL    CHKSYN          ; Make sure "=" follows
1486:	0B09  B4      	        .DB     ZEQUAL          ; "=" token
1487:	0B0A  D5      	        PUSH    DE              ; Save address of variable
1488:	0B0B  3AF220  	        LD      A,(TYPE)        ; Get data type
1489:	0B0E  F5      	        PUSH    AF              ; Save type
1490:	0B0F  CDD40D  	        CALL    EVAL            ; Evaluate expression
1491:	0B12  F1      	        POP     AF              ; Restore type
1492:	0B13  E3      	        EX      (SP),HL         ; Save code - Get var addr
1493:	0B14  221321  	        LD      (BRKLIN),HL     ; Save address of variable
1494:	0B17  1F      	        RRA                     ; Adjust type
1495:	0B18  CDC70D  	        CALL    CHKTYP          ; Check types are the same
1496:	0B1B  CA560B  	        JP      Z,LETNUM        ; Numeric - Move value
1497:	0B1E  E5      	LETSTR: PUSH    HL              ; Save address of string var
1498:	0B1F  2A2921  	        LD      HL,(FPREG)      ; Pointer to string entry
1499:	0B22  E5      	        PUSH    HL              ; Save it on stack
1500:	0B23  23      	        INC     HL              ; Skip over length
1501:	0B24  23      	        INC     HL
1502:	0B25  5E      	        LD      E,(HL)          ; LSB of string address
1503:	0B26  23      	        INC     HL
1504:	0B27  56      	        LD      D,(HL)          ; MSB of string address
1505:	0B28  2AA320  	        LD      HL,(BASTXT)     ; Point to start of program
1506:	0B2B  CDC507  	        CALL    CPDEHL          ; Is string before program?
1507:	0B2E  D2450B  	        JP      NC,CRESTR       ; Yes - Create string entry
1508:	0B31  2A9F20  	        LD      HL,(STRSPC)     ; Point to string space
1509:	0B34  CDC507  	        CALL    CPDEHL          ; Is string literal in program?
1510:	0B37  D1      	        POP     DE              ; Restore address of string
1511:	0B38  D24D0B  	        JP      NC,MVSTPT       ; Yes - Set up pointer
1512:	0B3B  210421  	        LD      HL,TMPSTR       ; Temporary string pool
1513:	0B3E  CDC507  	        CALL    CPDEHL          ; Is string in temporary pool?
1514:	0B41  D24D0B  	        JP      NC,MVSTPT       ; No - Set up pointer
1515:	0B44  3E      	        .DB     3EH             ; Skip "POP DE"
1516:	0B45  D1      	CRESTR: POP     DE              ; Restore address of string
1517:	0B46  CDFC13  	        CALL    BAKTMP          ; Back to last tmp-str entry
1518:	0B49  EB      	        EX      DE,HL           ; Address of string entry
1519:	0B4A  CD3512  	        CALL    SAVSTR          ; Save string in string area
1520:	0B4D  CDFC13  	MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
1521:	0B50  E1      	        POP     HL              ; Get string pointer
1522:	0B51  CDFF17  	        CALL    DETHL4          ; Move string pointer to var
1523:	0B54  E1      	        POP     HL              ; Restore code string address
1524:	0B55  C9      	        RET
1525:			
1526:	0B56  E5      	LETNUM: PUSH    HL              ; Save address of variable
1527:	0B57  CDFC17  	        CALL    FPTHL           ; Move value to variable
1528:	0B5A  D1      	        POP     DE              ; Restore address of variable
1529:	0B5B  E1      	        POP     HL              ; Restore code string address
1530:	0B5C  C9      	        RET
1531:			
1532:	0B5D  CD2315  	ON:     CALL    GETINT          ; Get integer 0-255
1533:	0B60  7E      	        LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
1534:	0B61  47      	        LD      B,A             ; Save in B
1535:	0B62  FE8C    	        CP      ZGOSUB          ; "GOSUB" token?
1536:	0B64  CA6C0B  	        JP      Z,ONGO          ; Yes - Find line number
1537:	0B67  CDCB07  	        CALL    CHKSYN          ; Make sure it's "GOTO"
1538:	0B6A  88      	        .DB     ZGOTO           ; "GOTO" token
1539:	0B6B  2B      	        DEC     HL              ; Cancel increment
1540:	0B6C  4B      	ONGO:   LD      C,E             ; Integer of branch value
1541:	0B6D  0D      	ONGOLP: DEC     C               ; Count branches
1542:	0B6E  78      	        LD      A,B             ; Get "GOTO" or "GOSUB" token
1543:	0B6F  CA3D09  	        JP      Z,ONJMP         ; Go to that line if right one
1544:	0B72  CD220A  	        CALL    GETLN           ; Get line number to DE
1545:	0B75  FE2C    	        CP      ','             ; Another line number?
1546:	0B77  C0      	        RET     NZ              ; No - Drop through
1547:	0B78  C36D0B  	        JP      ONGOLP          ; Yes - loop
1548:			
1549:	0B7B  CDD40D  	IF:     CALL    EVAL            ; Evaluate expression
1550:	0B7E  7E      	        LD      A,(HL)          ; Get token
1551:	0B7F  FE88    	        CP      ZGOTO           ; "GOTO" token?
1552:	0B81  CA890B  	        JP      Z,IFGO          ; Yes - Get line
1553:	0B84  CDCB07  	        CALL    CHKSYN          ; Make sure it's "THEN"
1554:	0B87  A9      	        .DB     ZTHEN           ; "THEN" token
1555:	0B88  2B      	        DEC     HL              ; Cancel increment
1556:	0B89  CDC50D  	IFGO:   CALL    TSTNUM          ; Make sure it's numeric
1557:	0B8C  CDA417  	        CALL    TSTSGN          ; Test state of expression
1558:	0B8F  CAEE0A  	        JP      Z,REM           ; False - Drop through
1559:	0B92  CD5509  	        CALL    GETCHR          ; Get next character
1560:	0B95  DAA90A  	        JP      C,GOTO          ; Number - GOTO that line
1561:	0B98  C33C09  	        JP      IFJMP           ; Otherwise do statement
1562:			
1563:	0B9B  2B      	MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
1564:	0B9C  CD5509  	        CALL    GETCHR          ; Get next character
1565:	0B9F  CAFD0B  	PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
1566:	0BA2  C8      	PRNTLP: RET     Z               ; End of list - Exit
1567:	0BA3  FEA5    	        CP      ZTAB            ; "TAB(" token?
1568:	0BA5  CA300C  	        JP      Z,DOTAB         ; Yes - Do TAB routine
1569:	0BA8  FEA8    	        CP      ZSPC            ; "SPC(" token?
1570:	0BAA  CA300C  	        JP      Z,DOTAB         ; Yes - Do SPC routine
1571:	0BAD  E5      	        PUSH    HL              ; Save code string address
1572:	0BAE  FE2C    	        CP      ','             ; Comma?
1573:	0BB0  CA190C  	        JP      Z,DOCOM         ; Yes - Move to next zone
1574:	0BB3  FE3B    	        CP      59 ;";"         ; Semi-colon?
1575:	0BB5  CA530C  	        JP      Z,NEXITM        ; Do semi-colon routine
1576:	0BB8  C1      	        POP     BC              ; Code string address to BC
1577:	0BB9  CDD40D  	        CALL    EVAL            ; Evaluate expression
1578:	0BBC  E5      	        PUSH    HL              ; Save code string address
1579:	0BBD  3AF220  	        LD      A,(TYPE)        ; Get variable type
1580:	0BC0  B7      	        OR      A               ; Is it a string variable?
1581:	0BC1  C2E90B  	        JP      NZ,PRNTST       ; Yes - Output string contents
1582:	0BC4  CD4919  	        CALL    NUMASC          ; Convert number to text
1583:	0BC7  CD5912  	        CALL    CRTST           ; Create temporary string
1584:	0BCA  3620    	        LD      (HL),' '        ; Followed by a space
1585:	0BCC  2A2921  	        LD      HL,(FPREG)      ; Get length of output
1586:	0BCF  34      	        INC     (HL)            ; Plus 1 for the space
1587:	0BD0  2A2921  	        LD      HL,(FPREG)      ; < Not needed >
1588:	0BD3  3A8720  	        LD      A,(LWIDTH)      ; Get width of line
1589:	0BD6  47      	        LD      B,A             ; To B
1590:	0BD7  04      	        INC     B               ; Width 255 (No limit)?
1591:	0BD8  CAE50B  	        JP      Z,PRNTNB        ; Yes - Output number string
1592:	0BDB  04      	        INC     B               ; Adjust it
1593:	0BDC  3AF020  	        LD      A,(CURPOS)      ; Get cursor position
1594:	0BDF  86      	        ADD     A,(HL)          ; Add length of string
1595:	0BE0  3D      	        DEC     A               ; Adjust it
1596:	0BE1  B8      	        CP      B               ; Will output fit on this line?
1597:	0BE2  D4FD0B  	        CALL    NC,PRNTCRLF     ; No - CRLF first
1598:	0BE5  CD9E12  	PRNTNB: CALL    PRS1            ; Output string at (HL)
1599:	0BE8  AF      	        XOR     A               ; Skip CALL by setting 'z' flag
1600:	0BE9  C49E12  	PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
1601:	0BEC  E1      	        POP     HL              ; Restore code string address
1602:	0BED  C39B0B  	        JP      MRPRNT          ; See if more to PRINT
1603:			
1604:	0BF0  3AF020  	STTLIN: LD      A,(CURPOS)      ; Make sure on new line
1605:	0BF3  B7      	        OR      A               ; Already at start?
1606:	0BF4  C8      	        RET     Z               ; Yes - Do nothing
1607:	0BF5  C3FD0B  	        JP      PRNTCRLF        ; Start a new line
1608:			
1609:	0BF8  3600    	ENDINP: LD      (HL),0          ; Mark end of buffer
1610:	0BFA  21A520  	        LD      HL,BUFFER-1     ; Point to buffer
1611:	0BFD  3E0D    	PRNTCRLF: LD    A,CR            ; Load a CR
1612:	0BFF  CDD607  	        CALL    OUTC            ; Output character
1613:	0C02  3E0A    	        LD      A,LF            ; Load a LF
1614:	0C04  CDD607  	        CALL    OUTC            ; Output character
1615:	0C07  AF      	DONULL: XOR     A               ; Set to position 0
1616:	0C08  32F020  	        LD      (CURPOS),A      ; Store it
1617:	0C0B  3A8620  	        LD      A,(NULLS)       ; Get number of nulls
1618:	0C0E  3D      	NULLP:  DEC     A               ; Count them
1619:	0C0F  C8      	        RET     Z               ; Return if done
1620:	0C10  F5      	        PUSH    AF              ; Save count
1621:	0C11  AF      	        XOR     A               ; Load a null
1622:	0C12  CDD607  	        CALL    OUTC            ; Output it
1623:	0C15  F1      	        POP     AF              ; Restore count
1624:	0C16  C30E0C  	        JP      NULLP           ; Keep counting
1625:			
1626:	0C19  3A8820  	DOCOM:  LD      A,(COMMAN)      ; Get comma width
1627:	0C1C  47      	        LD      B,A             ; Save in B
1628:	0C1D  3AF020  	        LD      A,(CURPOS)      ; Get current position
1629:	0C20  B8      	        CP      B               ; Within the limit?
1630:	0C21  D4FD0B  	        CALL    NC,PRNTCRLF     ; No - output CRLF
1631:	0C24  D2530C  	        JP      NC,NEXITM       ; Get next item
1632:	0C27  D60E    	ZONELP: SUB     14              ; Next zone of 14 characters
1633:	0C29  D2270C  	        JP      NC,ZONELP       ; Repeat if more zones
1634:	0C2C  2F      	        CPL                     ; Number of spaces to output
1635:	0C2D  C3480C  	        JP      ASPCS           ; Output them
1636:			
1637:	0C30  F5      	DOTAB:  PUSH    AF              ; Save token
1638:	0C31  CD2015  	        CALL    FNDNUM          ; Evaluate expression
1639:	0C34  CDCB07  	        CALL    CHKSYN          ; Make sure ")" follows
1640:	0C37  29      	        .DB     ")"
1641:	0C38  2B      	        DEC     HL              ; Back space on to ")"
1642:	0C39  F1      	        POP     AF              ; Restore token
1643:	0C3A  D6A8    	        SUB     ZSPC            ; Was it "SPC(" ?
1644:	0C3C  E5      	        PUSH    HL              ; Save code string address
1645:	0C3D  CA430C  	        JP      Z,DOSPC         ; Yes - Do 'E' spaces
1646:	0C40  3AF020  	        LD      A,(CURPOS)      ; Get current position
1647:	0C43  2F      	DOSPC:  CPL                     ; Number of spaces to print to
1648:	0C44  83      	        ADD     A,E             ; Total number to print
1649:	0C45  D2530C  	        JP      NC,NEXITM       ; TAB < Current POS(X)
1650:	0C48  3C      	ASPCS:  INC     A               ; Output A spaces
1651:	0C49  47      	        LD      B,A             ; Save number to print
1652:	0C4A  3E20    	        LD      A,' '           ; Space
1653:	0C4C  CDD607  	SPCLP:  CALL    OUTC            ; Output character in A
1654:	0C4F  05      	        DEC     B               ; Count them
1655:	0C50  C24C0C  	        JP      NZ,SPCLP        ; Repeat if more
1656:	0C53  E1      	NEXITM: POP     HL              ; Restore code string address
1657:	0C54  CD5509  	        CALL    GETCHR          ; Get next character
1658:	0C57  C3A20B  	        JP      PRNTLP          ; More to print
1659:			
1660:	0C5A  3F526564	REDO:   .DB     "?Redo from start",CR,LF,0
	      6F206672
	      6F6D2073
	      74617274
	      0D0A00
1661:			
1662:	0C6D  3A1221  	BADINP: LD      A,(READFG)      ; READ or INPUT?
1663:	0C70  B7      	        OR      A
1664:	0C71  C2F704  	        JP      NZ,DATSNR       ; READ - ?SN Error
1665:	0C74  C1      	        POP     BC              ; Throw away code string addr
1666:	0C75  215A0C  	        LD      HL,REDO         ; "Redo from start" message
1667:	0C78  CD9B12  	        CALL    PRS             ; Output string
1668:	0C7B  C34806  	        JP      DOAGN           ; Do last INPUT again
1669:			
1670:	0C7E  CD0612  	INPUT:  CALL    IDTEST          ; Test for illegal direct
1671:	0C81  7E      	        LD      A,(HL)          ; Get character after "INPUT"
1672:	0C82  FE22    	        CP      '"'             ; Is there a prompt string?
1673:	0C84  3E00    	        LD      A,0             ; Clear A and leave flags
1674:	0C86  328A20  	        LD      (CTLOFG),A      ; Enable output
1675:	0C89  C2980C  	        JP      NZ,NOPMPT       ; No prompt - get input
1676:	0C8C  CD5A12  	        CALL    QTSTR           ; Get string terminated by '"'
1677:	0C8F  CDCB07  	        CALL    CHKSYN          ; Check for ';' after prompt
1678:	0C92  3B      	        .DB     ';'
1679:	0C93  E5      	        PUSH    HL              ; Save code string address
1680:	0C94  CD9E12  	        CALL    PRS1            ; Output prompt string
1681:	0C97  3E      	        .DB     3EH             ; Skip "PUSH HL"
1682:	0C98  E5      	NOPMPT: PUSH    HL              ; Save code string address
1683:	0C99  CD4C06  	        CALL    PROMPT          ; Get input with "? " prompt
1684:	0C9C  C1      	        POP     BC              ; Restore code string address
1685:	0C9D  DAA409  	        JP      C,INPBRK        ; Break pressed - Exit
1686:	0CA0  23      	        INC     HL              ; Next byte
1687:	0CA1  7E      	        LD      A,(HL)          ; Get it
1688:	0CA2  B7      	        OR      A               ; End of line?
1689:	0CA3  2B      	        DEC     HL              ; Back again
1690:	0CA4  C5      	        PUSH    BC              ; Re-save code string address
1691:	0CA5  CAEB0A  	        JP      Z,NXTDTA        ; Yes - Find next DATA stmt
1692:	0CA8  362C    	        LD      (HL),','        ; Store comma as separator
1693:	0CAA  C3B20C  	        JP      NXTITM          ; Get next item
1694:			
1695:	0CAD  E5      	READ:   PUSH    HL              ; Save code string address
1696:	0CAE  2A2121  	        LD      HL,(NXTDAT)     ; Next DATA statement
1697:	0CB1  F6      	        .DB     0F6H            ; Flag "READ"
1698:	0CB2  AF      	NXTITM: XOR     A               ; Flag "INPUT"
1699:	0CB3  321221  	        LD      (READFG),A      ; Save "READ"/"INPUT" flag
1700:	0CB6  E3      	        EX      (SP),HL         ; Get code str' , Save pointer
1701:	0CB7  C3BE0C  	        JP      GTVLUS          ; Get values
1702:			
1703:	0CBA  CDCB07  	NEDMOR: CALL    CHKSYN          ; Check for comma between items
1704:	0CBD  2C      	        .DB     ','
1705:	0CBE  CDB80F  	GTVLUS: CALL    GETVAR          ; Get variable name
1706:	0CC1  E3      	        EX      (SP),HL         ; Save code str" , Get pointer
1707:	0CC2  D5      	        PUSH    DE              ; Save variable address
1708:	0CC3  7E      	        LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
1709:	0CC4  FE2C    	        CP      ','             ; Comma?
1710:	0CC6  CAE60C  	        JP      Z,ANTVLU        ; Yes - Get another value
1711:	0CC9  3A1221  	        LD      A,(READFG)      ; Is it READ?
1712:	0CCC  B7      	        OR      A
1713:	0CCD  C2530D  	        JP      NZ,FDTLP        ; Yes - Find next DATA stmt
1714:	0CD0  3E3F    	        LD      A,'?'           ; More INPUT needed
1715:	0CD2  CDD607  	        CALL    OUTC            ; Output character
1716:	0CD5  CD4C06  	        CALL    PROMPT          ; Get INPUT with prompt
1717:	0CD8  D1      	        POP     DE              ; Variable address
1718:	0CD9  C1      	        POP     BC              ; Code string address
1719:	0CDA  DAA409  	        JP      C,INPBRK        ; Break pressed
1720:	0CDD  23      	        INC     HL              ; Point to next DATA byte
1721:	0CDE  7E      	        LD      A,(HL)          ; Get byte
1722:	0CDF  B7      	        OR      A               ; Is it zero (No input) ?
1723:	0CE0  2B      	        DEC     HL              ; Back space INPUT pointer
1724:	0CE1  C5      	        PUSH    BC              ; Save code string address
1725:	0CE2  CAEB0A  	        JP      Z,NXTDTA        ; Find end of buffer
1726:	0CE5  D5      	        PUSH    DE              ; Save variable address
1727:	0CE6  3AF220  	ANTVLU: LD      A,(TYPE)        ; Check data type
1728:	0CE9  B7      	        OR      A               ; Is it numeric?
1729:	0CEA  CA100D  	        JP      Z,INPBIN        ; Yes - Convert to binary
1730:	0CED  CD5509  	        CALL    GETCHR          ; Get next character
1731:	0CF0  57      	        LD      D,A             ; Save input character
1732:	0CF1  47      	        LD      B,A             ; Again
1733:	0CF2  FE22    	        CP      '"'             ; Start of literal sting?
1734:	0CF4  CA040D  	        JP      Z,STRENT        ; Yes - Create string entry
1735:	0CF7  3A1221  	        LD      A,(READFG)      ; "READ" or "INPUT" ?
1736:	0CFA  B7      	        OR      A
1737:	0CFB  57      	        LD      D,A             ; Save 00 if "INPUT"
1738:	0CFC  CA010D  	        JP      Z,ITMSEP        ; "INPUT" - End with 00
1739:	0CFF  163A    	        LD      D,':'           ; "DATA" - End with 00 or ':'
1740:	0D01  062C    	ITMSEP: LD      B,','           ; Item separator
1741:	0D03  2B      	        DEC     HL              ; Back space for DTSTR
1742:	0D04  CD5D12  	STRENT: CALL    DTSTR           ; Get string terminated by D
1743:	0D07  EB      	        EX      DE,HL           ; String address to DE
1744:	0D08  211B0D  	        LD      HL,LTSTND       ; Where to go after LETSTR
1745:	0D0B  E3      	        EX      (SP),HL         ; Save HL , get input pointer
1746:	0D0C  D5      	        PUSH    DE              ; Save address of string
1747:	0D0D  C31E0B  	        JP      LETSTR          ; Assign string to variable
1748:			
1749:	0D10  CD5509  	INPBIN: CALL    GETCHR          ; Get next character
1750:	0D13  CDAB18  	        CALL    ASCTFP          ; Convert ASCII to FP number
1751:	0D16  E3      	        EX      (SP),HL         ; Save input ptr, Get var addr
1752:	0D17  CDFC17  	        CALL    FPTHL           ; Move FPREG to variable
1753:	0D1A  E1      	        POP     HL              ; Restore input pointer
1754:	0D1B  2B      	LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
1755:	0D1C  CD5509  	        CALL    GETCHR          ; Get next character
1756:	0D1F  CA270D  	        JP      Z,MORDT         ; End of line - More needed?
1757:	0D22  FE2C    	        CP      ','             ; Another value?
1758:	0D24  C26D0C  	        JP      NZ,BADINP       ; No - Bad input
1759:	0D27  E3      	MORDT:  EX      (SP),HL         ; Get code string address
1760:	0D28  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
1761:	0D29  CD5509  	        CALL    GETCHR          ; Get next character
1762:	0D2C  C2BA0C  	        JP      NZ,NEDMOR       ; More needed - Get it
1763:	0D2F  D1      	        POP     DE              ; Restore DATA pointer
1764:	0D30  3A1221  	        LD      A,(READFG)      ; "READ" or "INPUT" ?
1765:	0D33  B7      	        OR      A
1766:	0D34  EB      	        EX      DE,HL           ; DATA pointer to HL
1767:	0D35  C27B09  	        JP      NZ,UPDATA       ; Update DATA pointer if "READ"
1768:	0D38  D5      	        PUSH    DE              ; Save code string address
1769:	0D39  B6      	        OR      (HL)            ; More input given?
1770:	0D3A  21420D  	        LD      HL,EXTIG        ; "?Extra ignored" message
1771:	0D3D  C49B12  	        CALL    NZ,PRS          ; Output string if extra given
1772:	0D40  E1      	        POP     HL              ; Restore code string address
1773:	0D41  C9      	        RET
1774:			
1775:	0D42  3F457874	EXTIG:  .DB     "?Extra ignored",CR,LF,0
	      72612069
	      676E6F72
	      65640D0A
	      00
1776:			
1777:	0D53  CDEC0A  	FDTLP:  CALL    DATA            ; Get next statement
1778:	0D56  B7      	        OR      A               ; End of line?
1779:	0D57  C26C0D  	        JP      NZ,FANDT        ; No - See if DATA statement
1780:	0D5A  23      	        INC     HL
1781:	0D5B  7E      	        LD      A,(HL)          ; End of program?
1782:	0D5C  23      	        INC     HL
1783:	0D5D  B6      	        OR      (HL)            ; 00 00 Ends program
1784:	0D5E  1E06    	        LD      E,OD            ; ?OD Error
1785:	0D60  CA1105  	        JP      Z,ERROR         ; Yes - Out of DATA
1786:	0D63  23      	        INC     HL
1787:	0D64  5E      	        LD      E,(HL)          ; LSB of line number
1788:	0D65  23      	        INC     HL
1789:	0D66  56      	        LD      D,(HL)          ; MSB of line number
1790:	0D67  EB      	        EX      DE,HL
1791:	0D68  220E21  	        LD      (DATLIN),HL     ; Set line of current DATA item
1792:	0D6B  EB      	        EX      DE,HL
1793:	0D6C  CD5509  	FANDT:  CALL    GETCHR          ; Get next character
1794:	0D6F  FE83    	        CP      ZDATA           ; "DATA" token
1795:	0D71  C2530D  	        JP      NZ,FDTLP        ; No "DATA" - Keep looking
1796:	0D74  C3E60C  	        JP      ANTVLU          ; Found - Convert input
1797:			
1798:	0D77  110000  	NEXT:   LD      DE,0            ; In case no index given
1799:	0D7A  C4B80F  	NEXT1:  CALL    NZ,GETVAR       ; Get index address
1800:	0D7D  221321  	        LD      (BRKLIN),HL     ; Save code string address
1801:	0D80  CDA604  	        CALL    BAKSTK          ; Look for "FOR" block
1802:	0D83  C20305  	        JP      NZ,NFERR        ; No "FOR" - ?NF Error
1803:	0D86  F9      	        LD      SP,HL           ; Clear nested loops
1804:	0D87  D5      	        PUSH    DE              ; Save index address
1805:	0D88  7E      	        LD      A,(HL)          ; Get sign of STEP
1806:	0D89  23      	        INC     HL
1807:	0D8A  F5      	        PUSH    AF              ; Save sign of STEP
1808:	0D8B  D5      	        PUSH    DE              ; Save index address
1809:	0D8C  CDE217  	        CALL    PHLTFP          ; Move index value to FPREG
1810:	0D8F  E3      	        EX      (SP),HL         ; Save address of TO value
1811:	0D90  E5      	        PUSH    HL              ; Save address of index
1812:	0D91  CD4F15  	        CALL    ADDPHL          ; Add STEP to index value
1813:	0D94  E1      	        POP     HL              ; Restore address of index
1814:	0D95  CDFC17  	        CALL    FPTHL           ; Move value to index variable
1815:	0D98  E1      	        POP     HL              ; Restore address of TO value
1816:	0D99  CDF317  	        CALL    LOADFP          ; Move TO value to BCDE
1817:	0D9C  E5      	        PUSH    HL              ; Save address of line of FOR
1818:	0D9D  CD1F18  	        CALL    CMPNUM          ; Compare index with TO value
1819:	0DA0  E1      	        POP     HL              ; Restore address of line num
1820:	0DA1  C1      	        POP     BC              ; Address of sign of STEP
1821:	0DA2  90      	        SUB     B               ; Compare with expected sign
1822:	0DA3  CDF317  	        CALL    LOADFP          ; BC = Loop stmt,DE = Line num
1823:	0DA6  CAB20D  	        JP      Z,KILFOR        ; Loop finished - Terminate it
1824:	0DA9  EB      	        EX      DE,HL           ; Loop statement line number
1825:	0DAA  22A120  	        LD      (LINEAT),HL     ; Set loop line number
1826:	0DAD  69      	        LD      L,C             ; Set code string to loop
1827:	0DAE  60      	        LD      H,B
1828:	0DAF  C31109  	        JP      PUTFID          ; Put back "FOR" and continue
1829:			
1830:	0DB2  F9      	KILFOR: LD      SP,HL           ; Remove "FOR" block
1831:	0DB3  2A1321  	        LD      HL,(BRKLIN)     ; Code string after "NEXT"
1832:	0DB6  7E      	        LD      A,(HL)          ; Get next byte in code string
1833:	0DB7  FE2C    	        CP      ','             ; More NEXTs ?
1834:	0DB9  C21509  	        JP      NZ,RUNCNT       ; No - Do next statement
1835:	0DBC  CD5509  	        CALL    GETCHR          ; Position to index name
1836:	0DBF  CD7A0D  	        CALL    NEXT1           ; Re-enter NEXT routine
1837:			; < will not RETurn to here , Exit to RUNCNT or Loop >
1838:			
1839:	0DC2  CDD40D  	GETNUM: CALL    EVAL            ; Get a numeric expression
1840:	0DC5  F6      	TSTNUM: .DB     0F6H            ; Clear carry (numeric)
1841:	0DC6  37      	TSTSTR: SCF                     ; Set carry (string)
1842:	0DC7  3AF220  	CHKTYP: LD      A,(TYPE)        ; Check types match
1843:	0DCA  8F      	        ADC     A,A             ; Expected + actual
1844:	0DCB  B7      	        OR      A               ; Clear carry , set parity
1845:	0DCC  E8      	        RET     PE              ; Even parity - Types match
1846:	0DCD  C30F05  	        JP      TMERR           ; Different types - Error
1847:			
1848:	0DD0  CDCB07  	OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
1849:	0DD3  28      	        .DB  "("
1850:	0DD4  2B      	EVAL:   DEC     HL              ; Evaluate expression & save
1851:	0DD5  1600    	        LD      D,0             ; Precedence value
1852:	0DD7  D5      	EVAL1:  PUSH    DE              ; Save precedence
1853:	0DD8  0E01    	        LD      C,1
1854:	0DDA  CDDA04  	        CALL    CHKSTK          ; Check for 1 level of stack
1855:	0DDD  CD4B0E  	        CALL    OPRND           ; Get next expression value
1856:	0DE0  221521  	EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
1857:	0DE3  2A1521  	EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
1858:	0DE6  C1      	        POP     BC              ; Precedence value and operator
1859:	0DE7  78      	        LD      A,B             ; Get precedence value
1860:	0DE8  FE78    	        CP      78H             ; "AND" or "OR" ?
1861:	0DEA  D4C50D  	        CALL    NC,TSTNUM       ; No - Make sure it's a number
1862:	0DED  7E      	        LD      A,(HL)          ; Get next operator / function
1863:	0DEE  1600    	        LD      D,0             ; Clear Last relation
1864:	0DF0  D6B3    	RLTLP:  SUB     ZGTR            ; ">" Token
1865:	0DF2  DA0C0E  	        JP      C,FOPRND        ; + - * / ^ AND OR - Test it
1866:	0DF5  FE03    	        CP      ZLTH+1-ZGTR     ; < = >
1867:	0DF7  D20C0E  	        JP      NC,FOPRND       ; Function - Call it
1868:	0DFA  FE01    	        CP      ZEQUAL-ZGTR     ; "="
1869:	0DFC  17      	        RLA                     ; <- Test for legal
1870:	0DFD  AA      	        XOR     D               ; <- combinations of < = >
1871:	0DFE  BA      	        CP      D               ; <- by combining last token
1872:	0DFF  57      	        LD      D,A             ; <- with current one
1873:	0E00  DAFD04  	        JP      C,SNERR         ; Error if "<<' '==" or ">>"
1874:	0E03  220A21  	        LD      (CUROPR),HL     ; Save address of current token
1875:	0E06  CD5509  	        CALL    GETCHR          ; Get next character
1876:	0E09  C3F00D  	        JP      RLTLP           ; Treat the two as one
1877:			
1878:	0E0C  7A      	FOPRND: LD      A,D             ; < = > found ?
1879:	0E0D  B7      	        OR      A
1880:	0E0E  C2330F  	        JP      NZ,TSTRED       ; Yes - Test for reduction
1881:	0E11  7E      	        LD      A,(HL)          ; Get operator token
1882:	0E12  220A21  	        LD      (CUROPR),HL     ; Save operator address
1883:	0E15  D6AC    	        SUB     ZPLUS           ; Operator or function?
1884:	0E17  D8      	        RET     C               ; Neither - Exit
1885:	0E18  FE07    	        CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
1886:	0E1A  D0      	        RET     NC              ; No - Exit
1887:	0E1B  5F      	        LD      E,A             ; Coded operator
1888:	0E1C  3AF220  	        LD      A,(TYPE)        ; Get data type
1889:	0E1F  3D      	        DEC     A               ; FF = numeric , 00 = string
1890:	0E20  B3      	        OR      E               ; Combine with coded operator
1891:	0E21  7B      	        LD      A,E             ; Get coded operator
1892:	0E22  CA9113  	        JP      Z,CONCAT        ; String concatenation
1893:	0E25  07      	        RLCA                    ; Times 2
1894:	0E26  83      	        ADD     A,E             ; Times 3
1895:	0E27  5F      	        LD      E,A             ; To DE (D is 0)
1896:	0E28  21EF03  	        LD      HL,PRITAB       ; Precedence table
1897:	0E2B  19      	        ADD     HL,DE           ; To the operator concerned
1898:	0E2C  78      	        LD      A,B             ; Last operator precedence
1899:	0E2D  56      	        LD      D,(HL)          ; Get evaluation precedence
1900:	0E2E  BA      	        CP      D               ; Compare with eval precedence
1901:	0E2F  D0      	        RET     NC              ; Exit if higher precedence
1902:	0E30  23      	        INC     HL              ; Point to routine address
1903:	0E31  CDC50D  	        CALL    TSTNUM          ; Make sure it's a number
1904:			
1905:	0E34  C5      	STKTHS: PUSH    BC              ; Save last precedence & token
1906:	0E35  01E30D  	        LD      BC,EVAL3        ; Where to go on prec' break
1907:	0E38  C5      	        PUSH    BC              ; Save on stack for return
1908:	0E39  43      	        LD      B,E             ; Save operator
1909:	0E3A  4A      	        LD      C,D             ; Save precedence
1910:	0E3B  CDD517  	        CALL    STAKFP          ; Move value to stack
1911:	0E3E  58      	        LD      E,B             ; Restore operator
1912:	0E3F  51      	        LD      D,C             ; Restore precedence
1913:	0E40  4E      	        LD      C,(HL)          ; Get LSB of routine address
1914:	0E41  23      	        INC     HL
1915:	0E42  46      	        LD      B,(HL)          ; Get MSB of routine address
1916:	0E43  23      	        INC     HL
1917:	0E44  C5      	        PUSH    BC              ; Save routine address
1918:	0E45  2A0A21  	        LD      HL,(CUROPR)     ; Address of current operator
1919:	0E48  C3D70D  	        JP      EVAL1           ; Loop until prec' break
1920:			
1921:	0E4B  AF      	OPRND:  XOR     A               ; Get operand routine
1922:	0E4C  32F220  	        LD      (TYPE),A        ; Set numeric expected
1923:	0E4F  CD5509  	        CALL    GETCHR          ; Get next character
1924:	0E52  1E24    	        LD      E,MO            ; ?MO Error
1925:	0E54  CA1105  	        JP      Z,ERROR         ; No operand - Error
1926:	0E57  DAAB18  	        JP      C,ASCTFP        ; Number - Get value
1927:	0E5A  CDF309  	        CALL    CHKLTR          ; See if a letter
1928:	0E5D  D2B20E  	        JP      NC,CONVAR       ; Letter - Find variable
1929:	0E60  FE26    	        CP      '&'             ; &H = HEX, &B = BINARY
1930:	0E62  2012    	        JR      NZ, NOTAMP
1931:	0E64  CD5509  	        CALL    GETCHR          ; Get next character
1932:	0E67  FE48    	        CP      'H'             ; Hex number indicated? [function added]
1933:	0E69  CAEF1C  	        JP      Z,HEXTFP        ; Convert Hex to FPREG
1934:	0E6C  FE42    	        CP      'B'             ; Binary number indicated? [function added]
1935:	0E6E  CA5F1D  	        JP      Z,BINTFP        ; Convert Bin to FPREG
1936:	0E71  1E02    	        LD      E,SN            ; If neither then a ?SN Error
1937:	0E73  CA1105  	        JP      Z,ERROR         ; 
1938:	0E76  FEAC    	NOTAMP: CP      ZPLUS           ; '+' Token ?
1939:	0E78  CA4B0E  	        JP      Z,OPRND         ; Yes - Look for operand
1940:	0E7B  FE2E    	        CP      '.'             ; '.' ?
1941:	0E7D  CAAB18  	        JP      Z,ASCTFP        ; Yes - Create FP number
1942:	0E80  FEAD    	        CP      ZMINUS          ; '-' Token ?
1943:	0E82  CAA10E  	        JP      Z,MINUS         ; Yes - Do minus
1944:	0E85  FE22    	        CP      '"'             ; Literal string ?
1945:	0E87  CA5A12  	        JP      Z,QTSTR         ; Get string terminated by '"'
1946:	0E8A  FEAA    	        CP      ZNOT            ; "NOT" Token ?
1947:	0E8C  CA930F  	        JP      Z,EVNOT         ; Yes - Eval NOT expression
1948:	0E8F  FEA7    	        CP      ZFN             ; "FN" Token ?
1949:	0E91  CABE11  	        JP      Z,DOFN          ; Yes - Do FN routine
1950:	0E94  D6B6    	        SUB     ZSGN            ; Is it a function?
1951:	0E96  D2C30E  	        JP      NC,FNOFST       ; Yes - Evaluate function
1952:	0E99  CDD00D  	EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
1953:	0E9C  CDCB07  	        CALL    CHKSYN          ; Make sure ")" follows
1954:	0E9F  29      	        .DB     ")"
1955:	0EA0  C9      	        RET
1956:			
1957:	0EA1  167D    	MINUS:  LD      D,7DH           ; '-' precedence
1958:	0EA3  CDD70D  	        CALL    EVAL1           ; Evaluate until prec' break
1959:	0EA6  2A1521  	        LD      HL,(NXTOPR)     ; Get next operator address
1960:	0EA9  E5      	        PUSH    HL              ; Save next operator address
1961:	0EAA  CDCD17  	        CALL    INVSGN          ; Negate value
1962:	0EAD  CDC50D  	RETNUM: CALL    TSTNUM          ; Make sure it's a number
1963:	0EB0  E1      	        POP     HL              ; Restore next operator address
1964:	0EB1  C9      	        RET
1965:			
1966:	0EB2  CDB80F  	CONVAR: CALL    GETVAR          ; Get variable address to DE
1967:	0EB5  E5      	FRMEVL: PUSH    HL              ; Save code string address
1968:	0EB6  EB      	        EX      DE,HL           ; Variable address to HL
1969:	0EB7  222921  	        LD      (FPREG),HL      ; Save address of variable
1970:	0EBA  3AF220  	        LD      A,(TYPE)        ; Get type
1971:	0EBD  B7      	        OR      A               ; Numeric?
1972:	0EBE  CCE217  	        CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
1973:	0EC1  E1      	        POP     HL              ; Restore code string address
1974:	0EC2  C9      	        RET
1975:			
1976:	0EC3  0600    	FNOFST: LD      B,0             ; Get address of function
1977:	0EC5  07      	        RLCA                    ; Double function offset
1978:	0EC6  4F      	        LD      C,A             ; BC = Offset in function table
1979:	0EC7  C5      	        PUSH    BC              ; Save adjusted token value
1980:	0EC8  CD5509  	        CALL    GETCHR          ; Get next character
1981:	0ECB  79      	        LD      A,C             ; Get adjusted token value
1982:	0ECC  FE31    	        CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
1983:	0ECE  DAEA0E  	        JP      C,FNVAL         ; No - Do function
1984:	0ED1  CDD00D  	        CALL    OPNPAR          ; Evaluate expression  (X,...
1985:	0ED4  CDCB07  	        CALL    CHKSYN          ; Make sure ',' follows
1986:	0ED7  2C      	        .DB     ','
1987:	0ED8  CDC60D  	        CALL    TSTSTR          ; Make sure it's a string
1988:	0EDB  EB      	        EX      DE,HL           ; Save code string address
1989:	0EDC  2A2921  	        LD      HL,(FPREG)      ; Get address of string
1990:	0EDF  E3      	        EX      (SP),HL         ; Save address of string
1991:	0EE0  E5      	        PUSH    HL              ; Save adjusted token value
1992:	0EE1  EB      	        EX      DE,HL           ; Restore code string address
1993:	0EE2  CD2315  	        CALL    GETINT          ; Get integer 0-255
1994:	0EE5  EB      	        EX      DE,HL           ; Save code string address
1995:	0EE6  E3      	        EX      (SP),HL         ; Save integer,HL = adj' token
1996:	0EE7  C3F20E  	        JP      GOFUNC          ; Jump to string function
1997:			
1998:	0EEA  CD990E  	FNVAL:  CALL    EVLPAR          ; Evaluate expression
1999:	0EED  E3      	        EX      (SP),HL         ; HL = Adjusted token value
2000:	0EEE  11AD0E  	        LD      DE,RETNUM       ; Return number from function
2001:	0EF1  D5      	        PUSH    DE              ; Save on stack
2002:	0EF2  014E02  	GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
2003:	0EF5  09      	        ADD     HL,BC           ; Point to right address
2004:	0EF6  4E      	        LD      C,(HL)          ; Get LSB of address
2005:	0EF7  23      	        INC     HL              ;
2006:	0EF8  66      	        LD      H,(HL)          ; Get MSB of address
2007:	0EF9  69      	        LD      L,C             ; Address to HL
2008:	0EFA  E9      	        JP      (HL)            ; Jump to function
2009:			
2010:	0EFB  15      	SGNEXP: DEC     D               ; Dee to flag negative exponent
2011:	0EFC  FEAD    	        CP      ZMINUS          ; '-' token ?
2012:	0EFE  C8      	        RET     Z               ; Yes - Return
2013:	0EFF  FE2D    	        CP      '-'             ; '-' ASCII ?
2014:	0F01  C8      	        RET     Z               ; Yes - Return
2015:	0F02  14      	        INC     D               ; Inc to flag positive exponent
2016:	0F03  FE2B    	        CP      '+'             ; '+' ASCII ?
2017:	0F05  C8      	        RET     Z               ; Yes - Return
2018:	0F06  FEAC    	        CP      ZPLUS           ; '+' token ?
2019:	0F08  C8      	        RET     Z               ; Yes - Return
2020:	0F09  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
2021:	0F0A  C9      	        RET                     ; Return "NZ"
2022:			
2023:	0F0B  F6      	POR:    .DB     0F6H            ; Flag "OR"
2024:	0F0C  AF      	PAND:   XOR     A               ; Flag "AND"
2025:	0F0D  F5      	        PUSH    AF              ; Save "AND" / "OR" flag
2026:	0F0E  CDC50D  	        CALL    TSTNUM          ; Make sure it's a number
2027:	0F11  CD070A  	        CALL    DEINT           ; Get integer -32768 to 32767
2028:	0F14  F1      	        POP     AF              ; Restore "AND" / "OR" flag
2029:	0F15  EB      	        EX      DE,HL           ; <- Get last
2030:	0F16  C1      	        POP     BC              ; <-  value
2031:	0F17  E3      	        EX      (SP),HL         ; <-  from
2032:	0F18  EB      	        EX      DE,HL           ; <-  stack
2033:	0F19  CDE517  	        CALL    FPBCDE          ; Move last value to FPREG
2034:	0F1C  F5      	        PUSH    AF              ; Save "AND" / "OR" flag
2035:	0F1D  CD070A  	        CALL    DEINT           ; Get integer -32768 to 32767
2036:	0F20  F1      	        POP     AF              ; Restore "AND" / "OR" flag
2037:	0F21  C1      	        POP     BC              ; Get value
2038:	0F22  79      	        LD      A,C             ; Get LSB
2039:	0F23  217C11  	        LD      HL,ACPASS       ; Address of save AC as current
2040:	0F26  C22E0F  	        JP      NZ,POR1         ; Jump if OR
2041:	0F29  A3      	        AND     E               ; "AND" LSBs
2042:	0F2A  4F      	        LD      C,A             ; Save LSB
2043:	0F2B  78      	        LD      A,B             ; Get MBS
2044:	0F2C  A2      	        AND     D               ; "AND" MSBs
2045:	0F2D  E9      	        JP      (HL)            ; Save AC as current (ACPASS)
2046:			
2047:	0F2E  B3      	POR1:   OR      E               ; "OR" LSBs
2048:	0F2F  4F      	        LD      C,A             ; Save LSB
2049:	0F30  78      	        LD      A,B             ; Get MSB
2050:	0F31  B2      	        OR      D               ; "OR" MSBs
2051:	0F32  E9      	        JP      (HL)            ; Save AC as current (ACPASS)
2052:			
2053:	0F33  21450F  	TSTRED: LD      HL,CMPLOG       ; Logical compare routine
2054:	0F36  3AF220  	        LD      A,(TYPE)        ; Get data type
2055:	0F39  1F      	        RRA                     ; Carry set = string
2056:	0F3A  7A      	        LD      A,D             ; Get last precedence value
2057:	0F3B  17      	        RLA                     ; Times 2 plus carry
2058:	0F3C  5F      	        LD      E,A             ; To E
2059:	0F3D  1664    	        LD      D,64H           ; Relational precedence
2060:	0F3F  78      	        LD      A,B             ; Get current precedence
2061:	0F40  BA      	        CP      D               ; Compare with last
2062:	0F41  D0      	        RET     NC              ; Eval if last was rel' or log'
2063:	0F42  C3340E  	        JP      STKTHS          ; Stack this one and get next
2064:			
2065:	0F45  470F    	CMPLOG: .DW     CMPLG1          ; Compare two values / strings
2066:	0F47  79      	CMPLG1: LD      A,C             ; Get data type
2067:	0F48  B7      	        OR      A
2068:	0F49  1F      	        RRA
2069:	0F4A  C1      	        POP     BC              ; Get last expression to BCDE
2070:	0F4B  D1      	        POP     DE
2071:	0F4C  F5      	        PUSH    AF              ; Save status
2072:	0F4D  CDC70D  	        CALL    CHKTYP          ; Check that types match
2073:	0F50  21890F  	        LD      HL,CMPRES       ; Result to comparison
2074:	0F53  E5      	        PUSH    HL              ; Save for RETurn
2075:	0F54  CA1F18  	        JP      Z,CMPNUM        ; Compare values if numeric
2076:	0F57  AF      	        XOR     A               ; Compare two strings
2077:	0F58  32F220  	        LD      (TYPE),A        ; Set type to numeric
2078:	0F5B  D5      	        PUSH    DE              ; Save string name
2079:	0F5C  CDDE13  	        CALL    GSTRCU          ; Get current string
2080:	0F5F  7E      	        LD      A,(HL)          ; Get length of string
2081:	0F60  23      	        INC     HL
2082:	0F61  23      	        INC     HL
2083:	0F62  4E      	        LD      C,(HL)          ; Get LSB of address
2084:	0F63  23      	        INC     HL
2085:	0F64  46      	        LD      B,(HL)          ; Get MSB of address
2086:	0F65  D1      	        POP     DE              ; Restore string name
2087:	0F66  C5      	        PUSH    BC              ; Save address of string
2088:	0F67  F5      	        PUSH    AF              ; Save length of string
2089:	0F68  CDE213  	        CALL    GSTRDE          ; Get second string
2090:	0F6B  CDF317  	        CALL    LOADFP          ; Get address of second string
2091:	0F6E  F1      	        POP     AF              ; Restore length of string 1
2092:	0F6F  57      	        LD      D,A             ; Length to D
2093:	0F70  E1      	        POP     HL              ; Restore address of string 1
2094:	0F71  7B      	CMPSTR: LD      A,E             ; Bytes of string 2 to do
2095:	0F72  B2      	        OR      D               ; Bytes of string 1 to do
2096:	0F73  C8      	        RET     Z               ; Exit if all bytes compared
2097:	0F74  7A      	        LD      A,D             ; Get bytes of string 1 to do
2098:	0F75  D601    	        SUB     1
2099:	0F77  D8      	        RET     C               ; Exit if end of string 1
2100:	0F78  AF      	        XOR     A
2101:	0F79  BB      	        CP      E               ; Bytes of string 2 to do
2102:	0F7A  3C      	        INC     A
2103:	0F7B  D0      	        RET     NC              ; Exit if end of string 2
2104:	0F7C  15      	        DEC     D               ; Count bytes in string 1
2105:	0F7D  1D      	        DEC     E               ; Count bytes in string 2
2106:	0F7E  0A      	        LD      A,(BC)          ; Byte in string 2
2107:	0F7F  BE      	        CP      (HL)            ; Compare to byte in string 1
2108:	0F80  23      	        INC     HL              ; Move up string 1
2109:	0F81  03      	        INC     BC              ; Move up string 2
2110:	0F82  CA710F  	        JP      Z,CMPSTR        ; Same - Try next bytes
2111:	0F85  3F      	        CCF                     ; Flag difference (">" or "<")
2112:	0F86  C3AF17  	        JP      FLGDIF          ; "<" gives -1 , ">" gives +1
2113:			
2114:	0F89  3C      	CMPRES: INC     A               ; Increment current value
2115:	0F8A  8F      	        ADC     A,A             ; Double plus carry
2116:	0F8B  C1      	        POP     BC              ; Get other value
2117:	0F8C  A0      	        AND     B               ; Combine them
2118:	0F8D  C6FF    	        ADD     A,-1            ; Carry set if different
2119:	0F8F  9F      	        SBC     A,A             ; 00 - Equal , FF - Different
2120:	0F90  C3B617  	        JP      FLGREL          ; Set current value & continue
2121:			
2122:	0F93  165A    	EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
2123:	0F95  CDD70D  	        CALL    EVAL1           ; Eval until precedence break
2124:	0F98  CDC50D  	        CALL    TSTNUM          ; Make sure it's a number
2125:	0F9B  CD070A  	        CALL    DEINT           ; Get integer -32768 - 32767
2126:	0F9E  7B      	        LD      A,E             ; Get LSB
2127:	0F9F  2F      	        CPL                     ; Invert LSB
2128:	0FA0  4F      	        LD      C,A             ; Save "NOT" of LSB
2129:	0FA1  7A      	        LD      A,D             ; Get MSB
2130:	0FA2  2F      	        CPL                     ; Invert MSB
2131:	0FA3  CD7C11  	        CALL    ACPASS          ; Save AC as current
2132:	0FA6  C1      	        POP     BC              ; Clean up stack
2133:	0FA7  C3E30D  	        JP      EVAL3           ; Continue evaluation
2134:			
2135:	0FAA  2B      	DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
2136:	0FAB  CD5509  	        CALL    GETCHR          ; Get next character
2137:	0FAE  C8      	        RET     Z               ; End of DIM statement
2138:	0FAF  CDCB07  	        CALL    CHKSYN          ; Make sure ',' follows
2139:	0FB2  2C      	        .DB     ','
2140:	0FB3  01AA0F  	DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
2141:	0FB6  C5      	        PUSH    BC              ; Save on stack
2142:	0FB7  F6      	        .DB     0F6H            ; Flag "Create" variable
2143:	0FB8  AF      	GETVAR: XOR     A               ; Find variable address,to DE
2144:	0FB9  32F120  	        LD      (LCRFLG),A      ; Set locate / create flag
2145:	0FBC  46      	        LD      B,(HL)          ; Get First byte of name
2146:	0FBD  CDF309  	GTFNAM: CALL    CHKLTR          ; See if a letter
2147:	0FC0  DAFD04  	        JP      C,SNERR         ; ?SN Error if not a letter
2148:	0FC3  AF      	        XOR     A
2149:	0FC4  4F      	        LD      C,A             ; Clear second byte of name
2150:	0FC5  32F220  	        LD      (TYPE),A        ; Set type to numeric
2151:	0FC8  CD5509  	        CALL    GETCHR          ; Get next character
2152:	0FCB  DAD40F  	        JP      C,SVNAM2        ; Numeric - Save in name
2153:	0FCE  CDF309  	        CALL    CHKLTR          ; See if a letter
2154:	0FD1  DAE10F  	        JP      C,CHARTY        ; Not a letter - Check type
2155:	0FD4  4F      	SVNAM2: LD      C,A             ; Save second byte of name
2156:	0FD5  CD5509  	ENDNAM: CALL    GETCHR          ; Get next character
2157:	0FD8  DAD50F  	        JP      C,ENDNAM        ; Numeric - Get another
2158:	0FDB  CDF309  	        CALL    CHKLTR          ; See if a letter
2159:	0FDE  D2D50F  	        JP      NC,ENDNAM       ; Letter - Get another
2160:	0FE1  D624    	CHARTY: SUB     '$'             ; String variable?
2161:	0FE3  C2F00F  	        JP      NZ,NOTSTR       ; No - Numeric variable
2162:	0FE6  3C      	        INC     A               ; A = 1 (string type)
2163:	0FE7  32F220  	        LD      (TYPE),A        ; Set type to string
2164:	0FEA  0F      	        RRCA                    ; A = 80H , Flag for string
2165:	0FEB  81      	        ADD     A,C             ; 2nd byte of name has bit 7 on
2166:	0FEC  4F      	        LD      C,A             ; Resave second byte on name
2167:	0FED  CD5509  	        CALL    GETCHR          ; Get next character
2168:	0FF0  3A1021  	NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
2169:	0FF3  3D      	        DEC     A
2170:	0FF4  CA9D10  	        JP      Z,ARLDSV        ; Yes - Get array name
2171:	0FF7  F20010  	        JP      P,NSCFOR        ; No array with "FOR" or "FN"
2172:	0FFA  7E      	        LD      A,(HL)          ; Get byte again
2173:	0FFB  D628    	        SUB     '('             ; Subscripted variable?
2174:	0FFD  CA7510  	        JP      Z,SBSCPT        ; Yes - Sort out subscript
2175:			
2176:	1000  AF      	NSCFOR: XOR     A               ; Simple variable
2177:	1001  321021  	        LD      (FORFLG),A      ; Clear "FOR" flag
2178:	1004  E5      	        PUSH    HL              ; Save code string address
2179:	1005  50      	        LD      D,B             ; DE = Variable name to find
2180:	1006  59      	        LD      E,C
2181:	1007  2A2321  	        LD      HL,(FNRGNM)     ; FN argument name
2182:	100A  CDC507  	        CALL    CPDEHL          ; Is it the FN argument?
2183:	100D  112521  	        LD      DE,FNARG        ; Point to argument value
2184:	1010  CAE516  	        JP      Z,POPHRT        ; Yes - Return FN argument value
2185:	1013  2A1D21  	        LD      HL,(VAREND)     ; End of variables
2186:	1016  EB      	        EX      DE,HL           ; Address of end of search
2187:	1017  2A1B21  	        LD      HL,(PROGND)     ; Start of variables address
2188:	101A  CDC507  	FNDVAR: CALL    CPDEHL          ; End of variable list table?
2189:	101D  CA3310  	        JP      Z,CFEVAL        ; Yes - Called from EVAL?
2190:	1020  79      	        LD      A,C             ; Get second byte of name
2191:	1021  96      	        SUB     (HL)            ; Compare with name in list
2192:	1022  23      	        INC     HL              ; Move on to first byte
2193:	1023  C22810  	        JP      NZ,FNTHR        ; Different - Find another
2194:	1026  78      	        LD      A,B             ; Get first byte of name
2195:	1027  96      	        SUB     (HL)            ; Compare with name in list
2196:	1028  23      	FNTHR:  INC     HL              ; Move on to LSB of value
2197:	1029  CA6710  	        JP      Z,RETADR        ; Found - Return address
2198:	102C  23      	        INC     HL              ; <- Skip
2199:	102D  23      	        INC     HL              ; <- over
2200:	102E  23      	        INC     HL              ; <- F.P.
2201:	102F  23      	        INC     HL              ; <- value
2202:	1030  C31A10  	        JP      FNDVAR          ; Keep looking
2203:			
2204:	1033  E1      	CFEVAL: POP     HL              ; Restore code string address
2205:	1034  E3      	        EX      (SP),HL         ; Get return address
2206:	1035  D5      	        PUSH    DE              ; Save address of variable
2207:	1036  11B50E  	        LD      DE,FRMEVL       ; Return address in EVAL
2208:	1039  CDC507  	        CALL    CPDEHL          ; Called from EVAL ?
2209:	103C  D1      	        POP     DE              ; Restore address of variable
2210:	103D  CA6A10  	        JP      Z,RETNUL        ; Yes - Return null variable
2211:	1040  E3      	        EX      (SP),HL         ; Put back return
2212:	1041  E5      	        PUSH    HL              ; Save code string address
2213:	1042  C5      	        PUSH    BC              ; Save variable name
2214:	1043  010600  	        LD      BC,6            ; 2 byte name plus 4 byte data
2215:	1046  2A1F21  	        LD      HL,(ARREND)     ; End of arrays
2216:	1049  E5      	        PUSH    HL              ; Save end of arrays
2217:	104A  09      	        ADD     HL,BC           ; Move up 6 bytes
2218:	104B  C1      	        POP     BC              ; Source address in BC
2219:	104C  E5      	        PUSH    HL              ; Save new end address
2220:	104D  CDC904  	        CALL    MOVUP           ; Move arrays up
2221:	1050  E1      	        POP     HL              ; Restore new end address
2222:	1051  221F21  	        LD      (ARREND),HL     ; Set new end address
2223:	1054  60      	        LD      H,B             ; End of variables to HL
2224:	1055  69      	        LD      L,C
2225:	1056  221D21  	        LD      (VAREND),HL     ; Set new end address
2226:			
2227:	1059  2B      	ZEROLP: DEC     HL              ; Back through to zero variable
2228:	105A  3600    	        LD      (HL),0          ; Zero byte in variable
2229:	105C  CDC507  	        CALL    CPDEHL          ; Done them all?
2230:	105F  C25910  	        JP      NZ,ZEROLP       ; No - Keep on going
2231:	1062  D1      	        POP     DE              ; Get variable name
2232:	1063  73      	        LD      (HL),E          ; Store second character
2233:	1064  23      	        INC     HL
2234:	1065  72      	        LD      (HL),D          ; Store first character
2235:	1066  23      	        INC     HL
2236:	1067  EB      	RETADR: EX      DE,HL           ; Address of variable in DE
2237:	1068  E1      	        POP     HL              ; Restore code string address
2238:	1069  C9      	        RET
2239:			
2240:	106A  322C21  	RETNUL: LD      (FPEXP),A       ; Set result to zero
2241:	106D  219904  	        LD      HL,ZERBYT       ; Also set a null string
2242:	1070  222921  	        LD      (FPREG),HL      ; Save for EVAL
2243:	1073  E1      	        POP     HL              ; Restore code string address
2244:	1074  C9      	        RET
2245:			
2246:	1075  E5      	SBSCPT: PUSH    HL              ; Save code string address
2247:	1076  2AF120  	        LD      HL,(LCRFLG)     ; Locate/Create and Type
2248:	1079  E3      	        EX      (SP),HL         ; Save and get code string
2249:	107A  57      	        LD      D,A             ; Zero number of dimensions
2250:	107B  D5      	SCPTLP: PUSH    DE              ; Save number of dimensions
2251:	107C  C5      	        PUSH    BC              ; Save array name
2252:	107D  CDFB09  	        CALL    FPSINT          ; Get subscript (0-32767)
2253:	1080  C1      	        POP     BC              ; Restore array name
2254:	1081  F1      	        POP     AF              ; Get number of dimensions
2255:	1082  EB      	        EX      DE,HL
2256:	1083  E3      	        EX      (SP),HL         ; Save subscript value
2257:	1084  E5      	        PUSH    HL              ; Save LCRFLG and TYPE
2258:	1085  EB      	        EX      DE,HL
2259:	1086  3C      	        INC     A               ; Count dimensions
2260:	1087  57      	        LD      D,A             ; Save in D
2261:	1088  7E      	        LD      A,(HL)          ; Get next byte in code string
2262:	1089  FE2C    	        CP      ','             ; Comma (more to come)?
2263:	108B  CA7B10  	        JP      Z,SCPTLP        ; Yes - More subscripts
2264:	108E  CDCB07  	        CALL    CHKSYN          ; Make sure ")" follows
2265:	1091  29      	        .DB     ")"
2266:	1092  221521  	        LD      (NXTOPR),HL     ; Save code string address
2267:	1095  E1      	        POP     HL              ; Get LCRFLG and TYPE
2268:	1096  22F120  	        LD      (LCRFLG),HL     ; Restore Locate/create & type
2269:	1099  1E00    	        LD      E,0             ; Flag not CSAVE* or CLOAD*
2270:	109B  D5      	        PUSH    DE              ; Save number of dimensions (D)
2271:	109C  11      	        .DB     11H             ; Skip "PUSH HL" and "PUSH AF'
2272:			
2273:	109D  E5      	ARLDSV: PUSH    HL              ; Save code string address
2274:	109E  F5      	        PUSH    AF              ; A = 00 , Flags set = Z,N
2275:	109F  2A1D21  	        LD      HL,(VAREND)     ; Start of arrays
2276:	10A2  3E      	        .DB     3EH             ; Skip "ADD HL,DE"
2277:	10A3  19      	FNDARY: ADD     HL,DE           ; Move to next array start
2278:	10A4  EB      	        EX      DE,HL
2279:	10A5  2A1F21  	        LD      HL,(ARREND)     ; End of arrays
2280:	10A8  EB      	        EX      DE,HL           ; Current array pointer
2281:	10A9  CDC507  	        CALL    CPDEHL          ; End of arrays found?
2282:	10AC  CAD510  	        JP      Z,CREARY        ; Yes - Create array
2283:	10AF  7E      	        LD      A,(HL)          ; Get second byte of name
2284:	10B0  B9      	        CP      C               ; Compare with name given
2285:	10B1  23      	        INC     HL              ; Move on
2286:	10B2  C2B710  	        JP      NZ,NXTARY       ; Different - Find next array
2287:	10B5  7E      	        LD      A,(HL)          ; Get first byte of name
2288:	10B6  B8      	        CP      B               ; Compare with name given
2289:	10B7  23      	NXTARY: INC     HL              ; Move on
2290:	10B8  5E      	        LD      E,(HL)          ; Get LSB of next array address
2291:	10B9  23      	        INC     HL
2292:	10BA  56      	        LD      D,(HL)          ; Get MSB of next array address
2293:	10BB  23      	        INC     HL
2294:	10BC  C2A310  	        JP      NZ,FNDARY       ; Not found - Keep looking
2295:	10BF  3AF120  	        LD      A,(LCRFLG)      ; Found Locate or Create it?
2296:	10C2  B7      	        OR      A
2297:	10C3  C20605  	        JP      NZ,DDERR        ; Create - ?DD Error
2298:	10C6  F1      	        POP     AF              ; Locate - Get number of dim'ns
2299:	10C7  44      	        LD      B,H             ; BC Points to array dim'ns
2300:	10C8  4D      	        LD      C,L
2301:	10C9  CAE516  	        JP      Z,POPHRT        ; Jump if array load/save
2302:	10CC  96      	        SUB     (HL)            ; Same number of dimensions?
2303:	10CD  CA3311  	        JP      Z,FINDEL        ; Yes - Find element
2304:	10D0  1E10    	BSERR:  LD      E,BS            ; ?BS Error
2305:	10D2  C31105  	        JP      ERROR           ; Output error
2306:			
2307:	10D5  110400  	CREARY: LD      DE,4            ; 4 Bytes per entry
2308:	10D8  F1      	        POP     AF              ; Array to save or 0 dim'ns?
2309:	10D9  CA1C0A  	        JP      Z,FCERR         ; Yes - ?FC Error
2310:	10DC  71      	        LD      (HL),C          ; Save second byte of name
2311:	10DD  23      	        INC     HL
2312:	10DE  70      	        LD      (HL),B          ; Save first byte of name
2313:	10DF  23      	        INC     HL
2314:	10E0  4F      	        LD      C,A             ; Number of dimensions to C
2315:	10E1  CDDA04  	        CALL    CHKSTK          ; Check if enough memory
2316:	10E4  23      	        INC     HL              ; Point to number of dimensions
2317:	10E5  23      	        INC     HL
2318:	10E6  220A21  	        LD      (CUROPR),HL     ; Save address of pointer
2319:	10E9  71      	        LD      (HL),C          ; Set number of dimensions
2320:	10EA  23      	        INC     HL
2321:	10EB  3AF120  	        LD      A,(LCRFLG)      ; Locate of Create?
2322:	10EE  17      	        RLA                     ; Carry set = Create
2323:	10EF  79      	        LD      A,C             ; Get number of dimensions
2324:	10F0  010B00  	CRARLP: LD      BC,10+1         ; Default dimension size 10
2325:	10F3  D2F810  	        JP      NC,DEFSIZ       ; Locate - Set default size
2326:	10F6  C1      	        POP     BC              ; Get specified dimension size
2327:	10F7  03      	        INC     BC              ; Include zero element
2328:	10F8  71      	DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
2329:	10F9  23      	        INC     HL
2330:	10FA  70      	        LD      (HL),B          ; Save MSB of dimension size
2331:	10FB  23      	        INC     HL
2332:	10FC  F5      	        PUSH    AF              ; Save num' of dim'ns an status
2333:	10FD  E5      	        PUSH    HL              ; Save address of dim'n size
2334:	10FE  CD9018  	        CALL    MLDEBC          ; Multiply DE by BC to find
2335:	1101  EB      	        EX      DE,HL           ; amount of mem needed (to DE)
2336:	1102  E1      	        POP     HL              ; Restore address of dimension
2337:	1103  F1      	        POP     AF              ; Restore number of dimensions
2338:	1104  3D      	        DEC     A               ; Count them
2339:	1105  C2F010  	        JP      NZ,CRARLP       ; Do next dimension if more
2340:	1108  F5      	        PUSH    AF              ; Save locate/create flag
2341:	1109  42      	        LD      B,D             ; MSB of memory needed
2342:	110A  4B      	        LD      C,E             ; LSB of memory needed
2343:	110B  EB      	        EX      DE,HL
2344:	110C  19      	        ADD     HL,DE           ; Add bytes to array start
2345:	110D  DAF204  	        JP      C,OMERR         ; Too big - Error
2346:	1110  CDE304  	        CALL    ENFMEM          ; See if enough memory
2347:	1113  221F21  	        LD      (ARREND),HL     ; Save new end of array
2348:			
2349:	1116  2B      	ZERARY: DEC     HL              ; Back through array data
2350:	1117  3600    	        LD      (HL),0          ; Set array element to zero
2351:	1119  CDC507  	        CALL    CPDEHL          ; All elements zeroed?
2352:	111C  C21611  	        JP      NZ,ZERARY       ; No - Keep on going
2353:	111F  03      	        INC     BC              ; Number of bytes + 1
2354:	1120  57      	        LD      D,A             ; A=0
2355:	1121  2A0A21  	        LD      HL,(CUROPR)     ; Get address of array
2356:	1124  5E      	        LD      E,(HL)          ; Number of dimensions
2357:	1125  EB      	        EX      DE,HL           ; To HL
2358:	1126  29      	        ADD     HL,HL           ; Two bytes per dimension size
2359:	1127  09      	        ADD     HL,BC           ; Add number of bytes
2360:	1128  EB      	        EX      DE,HL           ; Bytes needed to DE
2361:	1129  2B      	        DEC     HL
2362:	112A  2B      	        DEC     HL
2363:	112B  73      	        LD      (HL),E          ; Save LSB of bytes needed
2364:	112C  23      	        INC     HL
2365:	112D  72      	        LD      (HL),D          ; Save MSB of bytes needed
2366:	112E  23      	        INC     HL
2367:	112F  F1      	        POP     AF              ; Locate / Create?
2368:	1130  DA5711  	        JP      C,ENDDIM        ; A is 0 , End if create
2369:	1133  47      	FINDEL: LD      B,A             ; Find array element
2370:	1134  4F      	        LD      C,A
2371:	1135  7E      	        LD      A,(HL)          ; Number of dimensions
2372:	1136  23      	        INC     HL
2373:	1137  16      	        .DB     16H             ; Skip "POP HL"
2374:	1138  E1      	FNDELP: POP     HL              ; Address of next dim' size
2375:	1139  5E      	        LD      E,(HL)          ; Get LSB of dim'n size
2376:	113A  23      	        INC     HL
2377:	113B  56      	        LD      D,(HL)          ; Get MSB of dim'n size
2378:	113C  23      	        INC     HL
2379:	113D  E3      	        EX      (SP),HL         ; Save address - Get index
2380:	113E  F5      	        PUSH    AF              ; Save number of dim'ns
2381:	113F  CDC507  	        CALL    CPDEHL          ; Dimension too large?
2382:	1142  D2D010  	        JP      NC,BSERR        ; Yes - ?BS Error
2383:	1145  E5      	        PUSH    HL              ; Save index
2384:	1146  CD9018  	        CALL    MLDEBC          ; Multiply previous by size
2385:	1149  D1      	        POP     DE              ; Index supplied to DE
2386:	114A  19      	        ADD     HL,DE           ; Add index to pointer
2387:	114B  F1      	        POP     AF              ; Number of dimensions
2388:	114C  3D      	        DEC     A               ; Count them
2389:	114D  44      	        LD      B,H             ; MSB of pointer
2390:	114E  4D      	        LD      C,L             ; LSB of pointer
2391:	114F  C23811  	        JP      NZ,FNDELP       ; More - Keep going
2392:	1152  29      	        ADD     HL,HL           ; 4 Bytes per element
2393:	1153  29      	        ADD     HL,HL
2394:	1154  C1      	        POP     BC              ; Start of array
2395:	1155  09      	        ADD     HL,BC           ; Point to element
2396:	1156  EB      	        EX      DE,HL           ; Address of element to DE
2397:	1157  2A1521  	ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
2398:	115A  C9      	        RET
2399:			
2400:	115B  2A1F21  	FRE:    LD      HL,(ARREND)     ; Start of free memory
2401:	115E  EB      	        EX      DE,HL           ; To DE
2402:	115F  210000  	        LD      HL,0            ; End of free memory
2403:	1162  39      	        ADD     HL,SP           ; Current stack value
2404:	1163  3AF220  	        LD      A,(TYPE)        ; Dummy argument type
2405:	1166  B7      	        OR      A
2406:	1167  CA7711  	        JP      Z,FRENUM        ; Numeric - Free variable space
2407:	116A  CDDE13  	        CALL    GSTRCU          ; Current string to pool
2408:	116D  CDDE12  	        CALL    GARBGE          ; Garbage collection
2409:	1170  2A9F20  	        LD      HL,(STRSPC)     ; Bottom of string space in use
2410:	1173  EB      	        EX      DE,HL           ; To DE
2411:	1174  2A0821  	        LD      HL,(STRBOT)     ; Bottom of string space
2412:	1177  7D      	FRENUM: LD      A,L             ; Get LSB of end
2413:	1178  93      	        SUB     E               ; Subtract LSB of beginning
2414:	1179  4F      	        LD      C,A             ; Save difference if C
2415:	117A  7C      	        LD      A,H             ; Get MSB of end
2416:	117B  9A      	        SBC     A,D             ; Subtract MSB of beginning
2417:	117C  41      	ACPASS: LD      B,C             ; Return integer AC
2418:	117D  50      	ABPASS: LD      D,B             ; Return integer AB
2419:	117E  1E00    	        LD      E,0
2420:	1180  21F220  	        LD      HL,TYPE         ; Point to type
2421:	1183  73      	        LD      (HL),E          ; Set type to numeric
2422:	1184  0690    	        LD      B,80H+16        ; 16 bit integer
2423:	1186  C3BB17  	        JP      RETINT          ; Return the integr
2424:			
2425:	1189  3AF020  	POS:    LD      A,(CURPOS)      ; Get cursor position
2426:	118C  47      	PASSA:  LD      B,A             ; Put A into AB
2427:	118D  AF      	        XOR     A               ; Zero A
2428:	118E  C37D11  	        JP      ABPASS          ; Return integer AB
2429:			
2430:	1191  CD1412  	DEF:    CALL    CHEKFN          ; Get "FN" and name
2431:	1194  CD0612  	        CALL    IDTEST          ; Test for illegal direct
2432:	1197  01EC0A  	        LD      BC,DATA         ; To get next statement
2433:	119A  C5      	        PUSH    BC              ; Save address for RETurn
2434:	119B  D5      	        PUSH    DE              ; Save address of function ptr
2435:	119C  CDCB07  	        CALL    CHKSYN          ; Make sure "(" follows
2436:	119F  28      	        .DB     "("
2437:	11A0  CDB80F  	        CALL    GETVAR          ; Get argument variable name
2438:	11A3  E5      	        PUSH    HL              ; Save code string address
2439:	11A4  EB      	        EX      DE,HL           ; Argument address to HL
2440:	11A5  2B      	        DEC     HL
2441:	11A6  56      	        LD      D,(HL)          ; Get first byte of arg name
2442:	11A7  2B      	        DEC     HL
2443:	11A8  5E      	        LD      E,(HL)          ; Get second byte of arg name
2444:	11A9  E1      	        POP     HL              ; Restore code string address
2445:	11AA  CDC50D  	        CALL    TSTNUM          ; Make sure numeric argument
2446:	11AD  CDCB07  	        CALL    CHKSYN          ; Make sure ")" follows
2447:	11B0  29      	        .DB     ")"
2448:	11B1  CDCB07  	        CALL    CHKSYN          ; Make sure "=" follows
2449:	11B4  B4      	        .DB     ZEQUAL          ; "=" token
2450:	11B5  44      	        LD      B,H             ; Code string address to BC
2451:	11B6  4D      	        LD      C,L
2452:	11B7  E3      	        EX      (SP),HL         ; Save code str , Get FN ptr
2453:	11B8  71      	        LD      (HL),C          ; Save LSB of FN code string
2454:	11B9  23      	        INC     HL
2455:	11BA  70      	        LD      (HL),B          ; Save MSB of FN code string
2456:	11BB  C35312  	        JP      SVSTAD          ; Save address and do function
2457:			
2458:	11BE  CD1412  	DOFN:   CALL    CHEKFN          ; Make sure FN follows
2459:	11C1  D5      	        PUSH    DE              ; Save function pointer address
2460:	11C2  CD990E  	        CALL    EVLPAR          ; Evaluate expression in "()"
2461:	11C5  CDC50D  	        CALL    TSTNUM          ; Make sure numeric result
2462:	11C8  E3      	        EX      (SP),HL         ; Save code str , Get FN ptr
2463:	11C9  5E      	        LD      E,(HL)          ; Get LSB of FN code string
2464:	11CA  23      	        INC     HL
2465:	11CB  56      	        LD      D,(HL)          ; Get MSB of FN code string
2466:	11CC  23      	        INC     HL
2467:	11CD  7A      	        LD      A,D             ; And function DEFined?
2468:	11CE  B3      	        OR      E
2469:	11CF  CA0905  	        JP      Z,UFERR         ; No - ?UF Error
2470:	11D2  7E      	        LD      A,(HL)          ; Get LSB of argument address
2471:	11D3  23      	        INC     HL
2472:	11D4  66      	        LD      H,(HL)          ; Get MSB of argument address
2473:	11D5  6F      	        LD      L,A             ; HL = Arg variable address
2474:	11D6  E5      	        PUSH    HL              ; Save it
2475:	11D7  2A2321  	        LD      HL,(FNRGNM)     ; Get old argument name
2476:	11DA  E3      	        EX      (SP),HL ;       ; Save old , Get new
2477:	11DB  222321  	        LD      (FNRGNM),HL     ; Set new argument name
2478:	11DE  2A2721  	        LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2479:	11E1  E5      	        PUSH    HL              ; Save it
2480:	11E2  2A2521  	        LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
2481:	11E5  E5      	        PUSH    HL              ; Save it
2482:	11E6  212521  	        LD      HL,FNARG        ; HL = Value of argument
2483:	11E9  D5      	        PUSH    DE              ; Save FN code string address
2484:	11EA  CDFC17  	        CALL    FPTHL           ; Move FPREG to argument
2485:	11ED  E1      	        POP     HL              ; Get FN code string address
2486:	11EE  CDC20D  	        CALL    GETNUM          ; Get value from function
2487:	11F1  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
2488:	11F2  CD5509  	        CALL    GETCHR          ; Get next character
2489:	11F5  C2FD04  	        JP      NZ,SNERR        ; Bad character in FN - Error
2490:	11F8  E1      	        POP     HL              ; Get MSB,EXP of old arg
2491:	11F9  222521  	        LD      (FNARG),HL      ; Restore it
2492:	11FC  E1      	        POP     HL              ; Get LSB,NLSB of old arg
2493:	11FD  222721  	        LD      (FNARG+2),HL    ; Restore it
2494:	1200  E1      	        POP     HL              ; Get name of old arg
2495:	1201  222321  	        LD      (FNRGNM),HL     ; Restore it
2496:	1204  E1      	        POP     HL              ; Restore code string address
2497:	1205  C9      	        RET
2498:			
2499:	1206  E5      	IDTEST: PUSH    HL              ; Save code string address
2500:	1207  2AA120  	        LD      HL,(LINEAT)     ; Get current line number
2501:	120A  23      	        INC     HL              ; -1 means direct statement
2502:	120B  7C      	        LD      A,H
2503:	120C  B5      	        OR      L
2504:	120D  E1      	        POP     HL              ; Restore code string address
2505:	120E  C0      	        RET     NZ              ; Return if in program
2506:	120F  1E16    	        LD      E,ID            ; ?ID Error
2507:	1211  C31105  	        JP      ERROR
2508:			
2509:	1214  CDCB07  	CHEKFN: CALL    CHKSYN          ; Make sure FN follows
2510:	1217  A7      	        .DB     ZFN             ; "FN" token
2511:	1218  3E80    	        LD      A,80H
2512:	121A  321021  	        LD      (FORFLG),A      ; Flag FN name to find
2513:	121D  B6      	        OR      (HL)            ; FN name has bit 7 set
2514:	121E  47      	        LD      B,A             ; in first byte of name
2515:	121F  CDBD0F  	        CALL    GTFNAM          ; Get FN name
2516:	1222  C3C50D  	        JP      TSTNUM          ; Make sure numeric function
2517:			
2518:	1225  CDC50D  	STR:    CALL    TSTNUM          ; Make sure it's a number
2519:	1228  CD4919  	        CALL    NUMASC          ; Turn number into text
2520:	122B  CD5912  	STR1:   CALL    CRTST           ; Create string entry for it
2521:	122E  CDDE13  	        CALL    GSTRCU          ; Current string to pool
2522:	1231  013914  	        LD      BC,TOPOOL       ; Save in string pool
2523:	1234  C5      	        PUSH    BC              ; Save address on stack
2524:			
2525:	1235  7E      	SAVSTR: LD      A,(HL)          ; Get string length
2526:	1236  23      	        INC     HL
2527:	1237  23      	        INC     HL
2528:	1238  E5      	        PUSH    HL              ; Save pointer to string
2529:	1239  CDB412  	        CALL    TESTR           ; See if enough string space
2530:	123C  E1      	        POP     HL              ; Restore pointer to string
2531:	123D  4E      	        LD      C,(HL)          ; Get LSB of address
2532:	123E  23      	        INC     HL
2533:	123F  46      	        LD      B,(HL)          ; Get MSB of address
2534:	1240  CD4D12  	        CALL    CRTMST          ; Create string entry
2535:	1243  E5      	        PUSH    HL              ; Save pointer to MSB of addr
2536:	1244  6F      	        LD      L,A             ; Length of string
2537:	1245  CDD113  	        CALL    TOSTRA          ; Move to string area
2538:	1248  D1      	        POP     DE              ; Restore pointer to MSB
2539:	1249  C9      	        RET
2540:			
2541:	124A  CDB412  	MKTMST: CALL    TESTR           ; See if enough string space
2542:	124D  210421  	CRTMST: LD      HL,TMPSTR       ; Temporary string
2543:	1250  E5      	        PUSH    HL              ; Save it
2544:	1251  77      	        LD      (HL),A          ; Save length of string
2545:	1252  23      	        INC     HL
2546:	1253  23      	SVSTAD: INC     HL
2547:	1254  73      	        LD      (HL),E          ; Save LSB of address
2548:	1255  23      	        INC     HL
2549:	1256  72      	        LD      (HL),D          ; Save MSB of address
2550:	1257  E1      	        POP     HL              ; Restore pointer
2551:	1258  C9      	        RET
2552:			
2553:	1259  2B      	CRTST:  DEC     HL              ; DEC - INCed after
2554:	125A  0622    	QTSTR:  LD      B,'"'           ; Terminating quote
2555:	125C  50      	        LD      D,B             ; Quote to D
2556:	125D  E5      	DTSTR:  PUSH    HL              ; Save start
2557:	125E  0EFF    	        LD      C,-1            ; Set counter to -1
2558:	1260  23      	QTSTLP: INC     HL              ; Move on
2559:	1261  7E      	        LD      A,(HL)          ; Get byte
2560:	1262  0C      	        INC     C               ; Count bytes
2561:	1263  B7      	        OR      A               ; End of line?
2562:	1264  CA6F12  	        JP      Z,CRTSTE        ; Yes - Create string entry
2563:	1267  BA      	        CP      D               ; Terminator D found?
2564:	1268  CA6F12  	        JP      Z,CRTSTE        ; Yes - Create string entry
2565:	126B  B8      	        CP      B               ; Terminator B found?
2566:	126C  C26012  	        JP      NZ,QTSTLP       ; No - Keep looking
2567:	126F  FE22    	CRTSTE: CP      '"'             ; End with '"'?
2568:	1271  CC5509  	        CALL    Z,GETCHR        ; Yes - Get next character
2569:	1274  E3      	        EX      (SP),HL         ; Starting quote
2570:	1275  23      	        INC     HL              ; First byte of string
2571:	1276  EB      	        EX      DE,HL           ; To DE
2572:	1277  79      	        LD      A,C             ; Get length
2573:	1278  CD4D12  	        CALL    CRTMST          ; Create string entry
2574:	127B  110421  	TSTOPL: LD      DE,TMPSTR       ; Temporary string
2575:	127E  2AF620  	        LD      HL,(TMSTPT)     ; Temporary string pool pointer
2576:	1281  222921  	        LD      (FPREG),HL      ; Save address of string ptr
2577:	1284  3E01    	        LD      A,1
2578:	1286  32F220  	        LD      (TYPE),A        ; Set type to string
2579:	1289  CDFF17  	        CALL    DETHL4          ; Move string to pool
2580:	128C  CDC507  	        CALL    CPDEHL          ; Out of string pool?
2581:	128F  22F620  	        LD      (TMSTPT),HL     ; Save new pointer
2582:	1292  E1      	        POP     HL              ; Restore code string address
2583:	1293  7E      	        LD      A,(HL)          ; Get next code byte
2584:	1294  C0      	        RET     NZ              ; Return if pool OK
2585:	1295  1E1E    	        LD      E,ST            ; ?ST Error
2586:	1297  C31105  	        JP      ERROR           ; String pool overflow
2587:			
2588:	129A  23      	PRNUMS: INC     HL              ; Skip leading space
2589:	129B  CD5912  	PRS:    CALL    CRTST           ; Create string entry for it
2590:	129E  CDDE13  	PRS1:   CALL    GSTRCU          ; Current string to pool
2591:	12A1  CDF317  	        CALL    LOADFP          ; Move string block to BCDE
2592:	12A4  1C      	        INC     E               ; Length + 1
2593:	12A5  1D      	PRSLP:  DEC     E               ; Count characters
2594:	12A6  C8      	        RET     Z               ; End of string
2595:	12A7  0A      	        LD      A,(BC)          ; Get byte to output
2596:	12A8  CDD607  	        CALL    OUTC            ; Output character in A
2597:	12AB  FE0D    	        CP      CR              ; Return?
2598:	12AD  CC070C  	        CALL    Z,DONULL        ; Yes - Do nulls
2599:	12B0  03      	        INC     BC              ; Next byte in string
2600:	12B1  C3A512  	        JP      PRSLP           ; More characters to output
2601:			
2602:	12B4  B7      	TESTR:  OR      A               ; Test if enough room
2603:	12B5  0E      	        .DB     0EH             ; No garbage collection done
2604:	12B6  F1      	GRBDON: POP     AF              ; Garbage collection done
2605:	12B7  F5      	        PUSH    AF              ; Save status
2606:	12B8  2A9F20  	        LD      HL,(STRSPC)     ; Bottom of string space in use
2607:	12BB  EB      	        EX      DE,HL           ; To DE
2608:	12BC  2A0821  	        LD      HL,(STRBOT)     ; Bottom of string area
2609:	12BF  2F      	        CPL                     ; Negate length (Top down)
2610:	12C0  4F      	        LD      C,A             ; -Length to BC
2611:	12C1  06FF    	        LD      B,-1            ; BC = -ve length of string
2612:	12C3  09      	        ADD     HL,BC           ; Add to bottom of space in use
2613:	12C4  23      	        INC     HL              ; Plus one for 2's complement
2614:	12C5  CDC507  	        CALL    CPDEHL          ; Below string RAM area?
2615:	12C8  DAD212  	        JP      C,TESTOS        ; Tidy up if not done else err
2616:	12CB  220821  	        LD      (STRBOT),HL     ; Save new bottom of area
2617:	12CE  23      	        INC     HL              ; Point to first byte of string
2618:	12CF  EB      	        EX      DE,HL           ; Address to DE
2619:	12D0  F1      	POPAF:  POP     AF              ; Throw away status push
2620:	12D1  C9      	        RET
2621:			
2622:	12D2  F1      	TESTOS: POP     AF              ; Garbage collect been done?
2623:	12D3  1E1A    	        LD      E,OS            ; ?OS Error
2624:	12D5  CA1105  	        JP      Z,ERROR         ; Yes - Not enough string apace
2625:	12D8  BF      	        CP      A               ; Flag garbage collect done
2626:	12D9  F5      	        PUSH    AF              ; Save status
2627:	12DA  01B612  	        LD      BC,GRBDON       ; Garbage collection done
2628:	12DD  C5      	        PUSH    BC              ; Save for RETurn
2629:	12DE  2AF420  	GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
2630:	12E1  220821  	GARBLP: LD      (STRBOT),HL     ; Reset string pointer
2631:	12E4  210000  	        LD      HL,0
2632:	12E7  E5      	        PUSH    HL              ; Flag no string found
2633:	12E8  2A9F20  	        LD      HL,(STRSPC)     ; Get bottom of string space
2634:	12EB  E5      	        PUSH    HL              ; Save bottom of string space
2635:	12EC  21F820  	        LD      HL,TMSTPL       ; Temporary string pool
2636:	12EF  EB      	GRBLP:  EX      DE,HL
2637:	12F0  2AF620  	        LD      HL,(TMSTPT)     ; Temporary string pool pointer
2638:	12F3  EB      	        EX      DE,HL
2639:	12F4  CDC507  	        CALL    CPDEHL          ; Temporary string pool done?
2640:	12F7  01EF12  	        LD      BC,GRBLP        ; Loop until string pool done
2641:	12FA  C24313  	        JP      NZ,STPOOL       ; No - See if in string area
2642:	12FD  2A1B21  	        LD      HL,(PROGND)     ; Start of simple variables
2643:	1300  EB      	SMPVAR: EX      DE,HL
2644:	1301  2A1D21  	        LD      HL,(VAREND)     ; End of simple variables
2645:	1304  EB      	        EX      DE,HL
2646:	1305  CDC507  	        CALL    CPDEHL          ; All simple strings done?
2647:	1308  CA1613  	        JP      Z,ARRLP         ; Yes - Do string arrays
2648:	130B  7E      	        LD      A,(HL)          ; Get type of variable
2649:	130C  23      	        INC     HL
2650:	130D  23      	        INC     HL
2651:	130E  B7      	        OR      A               ; "S" flag set if string
2652:	130F  CD4613  	        CALL    STRADD          ; See if string in string area
2653:	1312  C30013  	        JP      SMPVAR          ; Loop until simple ones done
2654:			
2655:	1315  C1      	GNXARY: POP     BC              ; Scrap address of this array
2656:	1316  EB      	ARRLP:  EX      DE,HL
2657:	1317  2A1F21  	        LD      HL,(ARREND)     ; End of string arrays
2658:	131A  EB      	        EX      DE,HL
2659:	131B  CDC507  	        CALL    CPDEHL          ; All string arrays done?
2660:	131E  CA6C13  	        JP      Z,SCNEND        ; Yes - Move string if found
2661:	1321  CDF317  	        CALL    LOADFP          ; Get array name to BCDE
2662:	1324  7B      	        LD      A,E             ; Get type of array     
2663:	1325  E5      	        PUSH    HL              ; Save address of num of dim'ns
2664:	1326  09      	        ADD     HL,BC           ; Start of next array
2665:	1327  B7      	        OR      A               ; Test type of array
2666:	1328  F21513  	        JP      P,GNXARY        ; Numeric array - Ignore it
2667:	132B  220A21  	        LD      (CUROPR),HL     ; Save address of next array
2668:	132E  E1      	        POP     HL              ; Get address of num of dim'ns
2669:	132F  4E      	        LD      C,(HL)          ; BC = Number of dimensions
2670:	1330  0600    	        LD      B,0
2671:	1332  09      	        ADD     HL,BC           ; Two bytes per dimension size
2672:	1333  09      	        ADD     HL,BC
2673:	1334  23      	        INC     HL              ; Plus one for number of dim'ns
2674:	1335  EB      	GRBARY: EX      DE,HL
2675:	1336  2A0A21  	        LD      HL,(CUROPR)     ; Get address of next array
2676:	1339  EB      	        EX      DE,HL
2677:	133A  CDC507  	        CALL    CPDEHL          ; Is this array finished?
2678:	133D  CA1613  	        JP      Z,ARRLP         ; Yes - Get next one
2679:	1340  013513  	        LD      BC,GRBARY       ; Loop until array all done
2680:	1343  C5      	STPOOL: PUSH    BC              ; Save return address
2681:	1344  F680    	        OR      80H             ; Flag string type
2682:	1346  7E      	STRADD: LD      A,(HL)          ; Get string length
2683:	1347  23      	        INC     HL
2684:	1348  23      	        INC     HL
2685:	1349  5E      	        LD      E,(HL)          ; Get LSB of string address
2686:	134A  23      	        INC     HL
2687:	134B  56      	        LD      D,(HL)          ; Get MSB of string address
2688:	134C  23      	        INC     HL
2689:	134D  F0      	        RET     P               ; Not a string - Return
2690:	134E  B7      	        OR      A               ; Set flags on string length
2691:	134F  C8      	        RET     Z               ; Null string - Return
2692:	1350  44      	        LD      B,H             ; Save variable pointer
2693:	1351  4D      	        LD      C,L
2694:	1352  2A0821  	        LD      HL,(STRBOT)     ; Bottom of new area
2695:	1355  CDC507  	        CALL    CPDEHL          ; String been done?
2696:	1358  60      	        LD      H,B             ; Restore variable pointer
2697:	1359  69      	        LD      L,C
2698:	135A  D8      	        RET     C               ; String done - Ignore
2699:	135B  E1      	        POP     HL              ; Return address
2700:	135C  E3      	        EX      (SP),HL         ; Lowest available string area
2701:	135D  CDC507  	        CALL    CPDEHL          ; String within string area?
2702:	1360  E3      	        EX      (SP),HL         ; Lowest available string area
2703:	1361  E5      	        PUSH    HL              ; Re-save return address
2704:	1362  60      	        LD      H,B             ; Restore variable pointer
2705:	1363  69      	        LD      L,C
2706:	1364  D0      	        RET     NC              ; Outside string area - Ignore
2707:	1365  C1      	        POP     BC              ; Get return , Throw 2 away
2708:	1366  F1      	        POP     AF              ; 
2709:	1367  F1      	        POP     AF              ; 
2710:	1368  E5      	        PUSH    HL              ; Save variable pointer
2711:	1369  D5      	        PUSH    DE              ; Save address of current
2712:	136A  C5      	        PUSH    BC              ; Put back return address
2713:	136B  C9      	        RET                     ; Go to it
2714:			
2715:	136C  D1      	SCNEND: POP     DE              ; Addresses of strings
2716:	136D  E1      	        POP     HL              ; 
2717:	136E  7D      	        LD      A,L             ; HL = 0 if no more to do
2718:	136F  B4      	        OR      H
2719:	1370  C8      	        RET     Z               ; No more to do - Return
2720:	1371  2B      	        DEC     HL
2721:	1372  46      	        LD      B,(HL)          ; MSB of address of string
2722:	1373  2B      	        DEC     HL
2723:	1374  4E      	        LD      C,(HL)          ; LSB of address of string
2724:	1375  E5      	        PUSH    HL              ; Save variable address
2725:	1376  2B      	        DEC     HL
2726:	1377  2B      	        DEC     HL
2727:	1378  6E      	        LD      L,(HL)          ; HL = Length of string
2728:	1379  2600    	        LD      H,0
2729:	137B  09      	        ADD     HL,BC           ; Address of end of string+1
2730:	137C  50      	        LD      D,B             ; String address to DE
2731:	137D  59      	        LD      E,C
2732:	137E  2B      	        DEC     HL              ; Last byte in string
2733:	137F  44      	        LD      B,H             ; Address to BC
2734:	1380  4D      	        LD      C,L
2735:	1381  2A0821  	        LD      HL,(STRBOT)     ; Current bottom of string area
2736:	1384  CDCC04  	        CALL    MOVSTR          ; Move string to new address
2737:	1387  E1      	        POP     HL              ; Restore variable address
2738:	1388  71      	        LD      (HL),C          ; Save new LSB of address
2739:	1389  23      	        INC     HL
2740:	138A  70      	        LD      (HL),B          ; Save new MSB of address
2741:	138B  69      	        LD      L,C             ; Next string area+1 to HL
2742:	138C  60      	        LD      H,B
2743:	138D  2B      	        DEC     HL              ; Next string area address
2744:	138E  C3E112  	        JP      GARBLP          ; Look for more strings
2745:			
2746:	1391  C5      	CONCAT: PUSH    BC              ; Save prec' opr & code string
2747:	1392  E5      	        PUSH    HL              ; 
2748:	1393  2A2921  	        LD      HL,(FPREG)      ; Get first string
2749:	1396  E3      	        EX      (SP),HL         ; Save first string
2750:	1397  CD4B0E  	        CALL    OPRND           ; Get second string
2751:	139A  E3      	        EX      (SP),HL         ; Restore first string
2752:	139B  CDC60D  	        CALL    TSTSTR          ; Make sure it's a string
2753:	139E  7E      	        LD      A,(HL)          ; Get length of second string
2754:	139F  E5      	        PUSH    HL              ; Save first string
2755:	13A0  2A2921  	        LD      HL,(FPREG)      ; Get second string
2756:	13A3  E5      	        PUSH    HL              ; Save second string
2757:	13A4  86      	        ADD     A,(HL)          ; Add length of second string
2758:	13A5  1E1C    	        LD      E,LS            ; ?LS Error
2759:	13A7  DA1105  	        JP      C,ERROR         ; String too long - Error
2760:	13AA  CD4A12  	        CALL    MKTMST          ; Make temporary string
2761:	13AD  D1      	        POP     DE              ; Get second string to DE
2762:	13AE  CDE213  	        CALL    GSTRDE          ; Move to string pool if needed
2763:	13B1  E3      	        EX      (SP),HL         ; Get first string
2764:	13B2  CDE113  	        CALL    GSTRHL          ; Move to string pool if needed
2765:	13B5  E5      	        PUSH    HL              ; Save first string
2766:	13B6  2A0621  	        LD      HL,(TMPSTR+2)   ; Temporary string address
2767:	13B9  EB      	        EX      DE,HL           ; To DE
2768:	13BA  CDC813  	        CALL    SSTSA           ; First string to string area
2769:	13BD  CDC813  	        CALL    SSTSA           ; Second string to string area
2770:	13C0  21E00D  	        LD      HL,EVAL2        ; Return to evaluation loop
2771:	13C3  E3      	        EX      (SP),HL         ; Save return,get code string
2772:	13C4  E5      	        PUSH    HL              ; Save code string address
2773:	13C5  C37B12  	        JP      TSTOPL          ; To temporary string to pool
2774:			
2775:	13C8  E1      	SSTSA:  POP     HL              ; Return address
2776:	13C9  E3      	        EX      (SP),HL         ; Get string block,save return
2777:	13CA  7E      	        LD      A,(HL)          ; Get length of string
2778:	13CB  23      	        INC     HL
2779:	13CC  23      	        INC     HL
2780:	13CD  4E      	        LD      C,(HL)          ; Get LSB of string address
2781:	13CE  23      	        INC     HL
2782:	13CF  46      	        LD      B,(HL)          ; Get MSB of string address
2783:	13D0  6F      	        LD      L,A             ; Length to L
2784:	13D1  2C      	TOSTRA: INC     L               ; INC - DECed after
2785:	13D2  2D      	TSALP:  DEC     L               ; Count bytes moved
2786:	13D3  C8      	        RET     Z               ; End of string - Return
2787:	13D4  0A      	        LD      A,(BC)          ; Get source
2788:	13D5  12      	        LD      (DE),A          ; Save destination
2789:	13D6  03      	        INC     BC              ; Next source
2790:	13D7  13      	        INC     DE              ; Next destination
2791:	13D8  C3D213  	        JP      TSALP           ; Loop until string moved
2792:			
2793:	13DB  CDC60D  	GETSTR: CALL    TSTSTR          ; Make sure it's a string
2794:	13DE  2A2921  	GSTRCU: LD      HL,(FPREG)      ; Get current string
2795:	13E1  EB      	GSTRHL: EX      DE,HL           ; Save DE
2796:	13E2  CDFC13  	GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
2797:	13E5  EB      	        EX      DE,HL           ; Restore DE
2798:	13E6  C0      	        RET     NZ              ; No - Return
2799:	13E7  D5      	        PUSH    DE              ; Save string
2800:	13E8  50      	        LD      D,B             ; String block address to DE
2801:	13E9  59      	        LD      E,C
2802:	13EA  1B      	        DEC     DE              ; Point to length
2803:	13EB  4E      	        LD      C,(HL)          ; Get string length
2804:	13EC  2A0821  	        LD      HL,(STRBOT)     ; Current bottom of string area
2805:	13EF  CDC507  	        CALL    CPDEHL          ; Last one in string area?
2806:	13F2  C2FA13  	        JP      NZ,POPHL        ; No - Return
2807:	13F5  47      	        LD      B,A             ; Clear B (A=0)
2808:	13F6  09      	        ADD     HL,BC           ; Remove string from str' area
2809:	13F7  220821  	        LD      (STRBOT),HL     ; Save new bottom of str' area
2810:	13FA  E1      	POPHL:  POP     HL              ; Restore string
2811:	13FB  C9      	        RET
2812:			
2813:	13FC  2AF620  	BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
2814:	13FF  2B      	        DEC     HL              ; Back
2815:	1400  46      	        LD      B,(HL)          ; Get MSB of address
2816:	1401  2B      	        DEC     HL              ; Back
2817:	1402  4E      	        LD      C,(HL)          ; Get LSB of address
2818:	1403  2B      	        DEC     HL              ; Back
2819:	1404  2B      	        DEC     HL              ; Back
2820:	1405  CDC507  	        CALL    CPDEHL          ; String last in string pool?
2821:	1408  C0      	        RET     NZ              ; Yes - Leave it
2822:	1409  22F620  	        LD      (TMSTPT),HL     ; Save new string pool top
2823:	140C  C9      	        RET
2824:			
2825:	140D  018C11  	LEN:    LD      BC,PASSA        ; To return integer A
2826:	1410  C5      	        PUSH    BC              ; Save address
2827:	1411  CDDB13  	GETLEN: CALL    GETSTR          ; Get string and its length
2828:	1414  AF      	        XOR     A
2829:	1415  57      	        LD      D,A             ; Clear D
2830:	1416  32F220  	        LD      (TYPE),A        ; Set type to numeric
2831:	1419  7E      	        LD      A,(HL)          ; Get length of string
2832:	141A  B7      	        OR      A               ; Set status flags
2833:	141B  C9      	        RET
2834:			
2835:	141C  018C11  	ASC:    LD      BC,PASSA        ; To return integer A
2836:	141F  C5      	        PUSH    BC              ; Save address
2837:	1420  CD1114  	GTFLNM: CALL    GETLEN          ; Get length of string
2838:	1423  CA1C0A  	        JP      Z,FCERR         ; Null string - Error
2839:	1426  23      	        INC     HL
2840:	1427  23      	        INC     HL
2841:	1428  5E      	        LD      E,(HL)          ; Get LSB of address
2842:	1429  23      	        INC     HL
2843:	142A  56      	        LD      D,(HL)          ; Get MSB of address
2844:	142B  1A      	        LD      A,(DE)          ; Get first byte of string
2845:	142C  C9      	        RET
2846:			
2847:	142D  3E01    	CHR:    LD      A,1             ; One character string
2848:	142F  CD4A12  	        CALL    MKTMST          ; Make a temporary string
2849:	1432  CD2615  	        CALL    MAKINT          ; Make it integer A
2850:	1435  2A0621  	        LD      HL,(TMPSTR+2)   ; Get address of string
2851:	1438  73      	        LD      (HL),E          ; Save character
2852:	1439  C1      	TOPOOL: POP     BC              ; Clean up stack
2853:	143A  C37B12  	        JP      TSTOPL          ; Temporary string to pool
2854:			
2855:	143D  CDD614  	LEFT:   CALL    LFRGNM          ; Get number and ending ")"
2856:	1440  AF      	        XOR     A               ; Start at first byte in string
2857:	1441  E3      	RIGHT1: EX      (SP),HL         ; Save code string,Get string
2858:	1442  4F      	        LD      C,A             ; Starting position in string
2859:	1443  E5      	MID1:   PUSH    HL              ; Save string block address
2860:	1444  7E      	        LD      A,(HL)          ; Get length of string
2861:	1445  B8      	        CP      B               ; Compare with number given
2862:	1446  DA4B14  	        JP      C,ALLFOL        ; All following bytes required
2863:	1449  78      	        LD      A,B             ; Get new length
2864:	144A  11      	        .DB     11H             ; Skip "LD C,0"
2865:	144B  0E00    	ALLFOL: LD      C,0             ; First byte of string
2866:	144D  C5      	        PUSH    BC              ; Save position in string
2867:	144E  CDB412  	        CALL    TESTR           ; See if enough string space
2868:	1451  C1      	        POP     BC              ; Get position in string
2869:	1452  E1      	        POP     HL              ; Restore string block address
2870:	1453  E5      	        PUSH    HL              ; And re-save it
2871:	1454  23      	        INC     HL
2872:	1455  23      	        INC     HL
2873:	1456  46      	        LD      B,(HL)          ; Get LSB of address
2874:	1457  23      	        INC     HL
2875:	1458  66      	        LD      H,(HL)          ; Get MSB of address
2876:	1459  68      	        LD      L,B             ; HL = address of string
2877:	145A  0600    	        LD      B,0             ; BC = starting address
2878:	145C  09      	        ADD     HL,BC           ; Point to that byte
2879:	145D  44      	        LD      B,H             ; BC = source string
2880:	145E  4D      	        LD      C,L
2881:	145F  CD4D12  	        CALL    CRTMST          ; Create a string entry
2882:	1462  6F      	        LD      L,A             ; Length of new string
2883:	1463  CDD113  	        CALL    TOSTRA          ; Move string to string area
2884:	1466  D1      	        POP     DE              ; Clear stack
2885:	1467  CDE213  	        CALL    GSTRDE          ; Move to string pool if needed
2886:	146A  C37B12  	        JP      TSTOPL          ; Temporary string to pool
2887:			
2888:	146D  CDD614  	RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
2889:	1470  D1      	        POP     DE              ; Get string length
2890:	1471  D5      	        PUSH    DE              ; And re-save
2891:	1472  1A      	        LD      A,(DE)          ; Get length
2892:	1473  90      	        SUB     B               ; Move back N bytes
2893:	1474  C34114  	        JP      RIGHT1          ; Go and get sub-string
2894:			
2895:	1477  EB      	MID:    EX      DE,HL           ; Get code string address
2896:	1478  7E      	        LD      A,(HL)          ; Get next byte ',' or ")"
2897:	1479  CDDB14  	        CALL    MIDNUM          ; Get number supplied
2898:	147C  04      	        INC     B               ; Is it character zero?
2899:	147D  05      	        DEC     B
2900:	147E  CA1C0A  	        JP      Z,FCERR         ; Yes - Error
2901:	1481  C5      	        PUSH    BC              ; Save starting position
2902:	1482  1EFF    	        LD      E,255           ; All of string
2903:	1484  FE29    	        CP      ')'             ; Any length given?
2904:	1486  CA9014  	        JP      Z,RSTSTR        ; No - Rest of string
2905:	1489  CDCB07  	        CALL    CHKSYN          ; Make sure ',' follows
2906:	148C  2C      	        .DB     ','
2907:	148D  CD2315  	        CALL    GETINT          ; Get integer 0-255
2908:	1490  CDCB07  	RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
2909:	1493  29      	        .DB     ")"
2910:	1494  F1      	        POP     AF              ; Restore starting position
2911:	1495  E3      	        EX      (SP),HL         ; Get string,8ave code string
2912:	1496  014314  	        LD      BC,MID1         ; Continuation of MID$ routine
2913:	1499  C5      	        PUSH    BC              ; Save for return
2914:	149A  3D      	        DEC     A               ; Starting position-1
2915:	149B  BE      	        CP      (HL)            ; Compare with length
2916:	149C  0600    	        LD      B,0             ; Zero bytes length
2917:	149E  D0      	        RET     NC              ; Null string if start past end
2918:	149F  4F      	        LD      C,A             ; Save starting position-1
2919:	14A0  7E      	        LD      A,(HL)          ; Get length of string
2920:	14A1  91      	        SUB     C               ; Subtract start
2921:	14A2  BB      	        CP      E               ; Enough string for it?
2922:	14A3  47      	        LD      B,A             ; Save maximum length available
2923:	14A4  D8      	        RET     C               ; Truncate string if needed
2924:	14A5  43      	        LD      B,E             ; Set specified length
2925:	14A6  C9      	        RET                     ; Go and create string
2926:			
2927:	14A7  CD1114  	VAL:    CALL    GETLEN          ; Get length of string
2928:	14AA  CAC415  	        JP      Z,RESZER        ; Result zero
2929:	14AD  5F      	        LD      E,A             ; Save length
2930:	14AE  23      	        INC     HL
2931:	14AF  23      	        INC     HL
2932:	14B0  7E      	        LD      A,(HL)          ; Get LSB of address
2933:	14B1  23      	        INC     HL
2934:	14B2  66      	        LD      H,(HL)          ; Get MSB of address
2935:	14B3  6F      	        LD      L,A             ; HL = String address
2936:	14B4  E5      	        PUSH    HL              ; Save string address
2937:	14B5  19      	        ADD     HL,DE
2938:	14B6  46      	        LD      B,(HL)          ; Get end of string+1 byte
2939:	14B7  72      	        LD      (HL),D          ; Zero it to terminate
2940:	14B8  E3      	        EX      (SP),HL         ; Save string end,get start
2941:	14B9  C5      	        PUSH    BC              ; Save end+1 byte
2942:	14BA  7E      	        LD      A,(HL)          ; Get starting byte
2943:	14BB  FE24    	        CP      '$'             ; Hex number indicated? [function added]
2944:	14BD  C2C514  	        JP      NZ,VAL1
2945:	14C0  CDEF1C  	        CALL    HEXTFP          ; Convert Hex to FPREG
2946:	14C3  180D    	        JR      VAL3
2947:	14C5  FE25    	VAL1:   CP	'%'             ; Binary number indicated? [function added]
2948:	14C7  C2CF14  	    JP	NZ,VAL2
2949:	14CA  CD5F1D  	    CALL	BINTFP		; Convert Bin to FPREG
2950:	14CD  1803    	    JR	VAL3
2951:	14CF  CDAB18  	VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
2952:	14D2  C1      	VAL3:   POP     BC              ; Restore end+1 byte
2953:	14D3  E1      	        POP     HL              ; Restore end+1 address
2954:	14D4  70      	        LD      (HL),B          ; Put back original byte
2955:	14D5  C9      	        RET
2956:			
2957:	14D6  EB      	LFRGNM: EX      DE,HL           ; Code string address to HL
2958:	14D7  CDCB07  	        CALL    CHKSYN          ; Make sure ")" follows
2959:	14DA  29      	        .DB     ")"
2960:	14DB  C1      	MIDNUM: POP     BC              ; Get return address
2961:	14DC  D1      	        POP     DE              ; Get number supplied
2962:	14DD  C5      	        PUSH    BC              ; Re-save return address
2963:	14DE  43      	        LD      B,E             ; Number to B
2964:	14DF  C9      	        RET
2965:			
2966:	14E0  CD2615  	INP:    CALL    MAKINT          ; Make it integer A
2967:	14E3  328420  	        LD      (INPORT),A      ; Set input port
2968:	14E6  CD8320  	        CALL    INPSUB          ; Get input from port
2969:	14E9  C38C11  	        JP      PASSA           ; Return integer A
2970:			
2971:	14EC  CD1015  	POUT:   CALL    SETIO           ; Set up port number
2972:	14EF  C34B20  	        JP      OUTSUB          ; Output data and return
2973:			
2974:	14F2  CD1015  	WAIT:   CALL    SETIO           ; Set up port number
2975:	14F5  F5      	        PUSH    AF              ; Save AND mask
2976:	14F6  1E00    	        LD      E,0             ; Assume zero if none given
2977:	14F8  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
2978:	14F9  CD5509  	        CALL    GETCHR          ; Get next character
2979:	14FC  CA0615  	        JP      Z,NOXOR         ; No XOR byte given
2980:	14FF  CDCB07  	        CALL    CHKSYN          ; Make sure ',' follows
2981:	1502  2C      	        .DB     ','
2982:	1503  CD2315  	        CALL    GETINT          ; Get integer 0-255 to XOR with
2983:	1506  C1      	NOXOR:  POP     BC              ; Restore AND mask
2984:	1507  CD8320  	WAITLP: CALL    INPSUB          ; Get input
2985:	150A  AB      	        XOR     E               ; Flip selected bits
2986:	150B  A0      	        AND     B               ; Result non-zero?
2987:	150C  CA0715  	        JP      Z,WAITLP        ; No = keep waiting
2988:	150F  C9      	        RET
2989:			
2990:	1510  CD2315  	SETIO:  CALL    GETINT          ; Get integer 0-255
2991:	1513  328420  	        LD      (INPORT),A      ; Set input port
2992:	1516  324C20  	        LD      (OTPORT),A      ; Set output port
2993:	1519  CDCB07  	        CALL    CHKSYN          ; Make sure ',' follows
2994:	151C  2C      	        .DB     ','
2995:	151D  C32315  	        JP      GETINT          ; Get integer 0-255 and return
2996:			
2997:	1520  CD5509  	FNDNUM: CALL    GETCHR          ; Get next character
2998:	1523  CDC20D  	GETINT: CALL    GETNUM          ; Get a number from 0 to 255
2999:	1526  CD010A  	MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
3000:	1529  7A      	        LD      A,D             ; Get MSB of number
3001:	152A  B7      	        OR      A               ; Zero?
3002:	152B  C21C0A  	        JP      NZ,FCERR        ; No - Error
3003:	152E  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
3004:	152F  CD5509  	        CALL    GETCHR          ; Get next character
3005:	1532  7B      	        LD      A,E             ; Get number to A
3006:	1533  C9      	        RET
3007:			
3008:	1534  CD070A  	PEEK:   CALL    DEINT           ; Get memory address
3009:	1537  1A      	        LD      A,(DE)          ; Get byte in memory
3010:	1538  C38C11  	        JP      PASSA           ; Return integer A
3011:			
3012:	153B  CDC20D  	POKE:   CALL    GETNUM          ; Get memory address
3013:	153E  CD070A  	        CALL    DEINT           ; Get integer -32768 to 3276
3014:	1541  D5      	        PUSH    DE              ; Save memory address
3015:	1542  CDCB07  	        CALL    CHKSYN          ; Make sure ',' follows
3016:	1545  2C      	        .DB     ','
3017:	1546  CD2315  	        CALL    GETINT          ; Get integer 0-255
3018:	1549  D1      	        POP     DE              ; Restore memory address
3019:	154A  12      	        LD      (DE),A          ; Load it into memory
3020:	154B  C9      	        RET
3021:			
3022:	154C  21221A  	ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
3023:	154F  CDF317  	ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
3024:	1552  C35E15  	        JP      FPADD           ; Add BCDE to FPREG
3025:			
3026:	1555  CDF317  	SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
3027:	1558  21      	        .DB     21H             ; Skip "POP BC" and "POP DE"
3028:	1559  C1      	PSUB:   POP     BC              ; Get FP number from stack
3029:	155A  D1      	        POP     DE
3030:	155B  CDCD17  	SUBCDE: CALL    INVSGN          ; Negate FPREG
3031:	155E  78      	FPADD:  LD      A,B             ; Get FP exponent
3032:	155F  B7      	        OR      A               ; Is number zero?
3033:	1560  C8      	        RET     Z               ; Yes - Nothing to add
3034:	1561  3A2C21  	        LD      A,(FPEXP)       ; Get FPREG exponent
3035:	1564  B7      	        OR      A               ; Is this number zero?
3036:	1565  CAE517  	        JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3037:	1568  90      	        SUB     B               ; BCDE number larger?
3038:	1569  D27815  	        JP      NC,NOSWAP       ; No - Don't swap them
3039:	156C  2F      	        CPL                     ; Two's complement
3040:	156D  3C      	        INC     A               ;  FP exponent
3041:	156E  EB      	        EX      DE,HL
3042:	156F  CDD517  	        CALL    STAKFP          ; Put FPREG on stack
3043:	1572  EB      	        EX      DE,HL
3044:	1573  CDE517  	        CALL    FPBCDE          ; Move BCDE to FPREG
3045:	1576  C1      	        POP     BC              ; Restore number from stack
3046:	1577  D1      	        POP     DE
3047:	1578  FE19    	NOSWAP: CP      24+1            ; Second number insignificant?
3048:	157A  D0      	        RET     NC              ; Yes - First number is result
3049:	157B  F5      	        PUSH    AF              ; Save number of bits to scale
3050:	157C  CD0A18  	        CALL    SIGNS           ; Set MSBs & sign of result
3051:	157F  67      	        LD      H,A             ; Save sign of result
3052:	1580  F1      	        POP     AF              ; Restore scaling factor
3053:	1581  CD2316  	        CALL    SCALE           ; Scale BCDE to same exponent
3054:	1584  B4      	        OR      H               ; Result to be positive?
3055:	1585  212921  	        LD      HL,FPREG        ; Point to FPREG
3056:	1588  F29E15  	        JP      P,MINCDE        ; No - Subtract FPREG from CDE
3057:	158B  CD0316  	        CALL    PLUCDE          ; Add FPREG to CDE
3058:	158E  D2E415  	        JP      NC,RONDUP       ; No overflow - Round it up
3059:	1591  23      	        INC     HL              ; Point to exponent
3060:	1592  34      	        INC     (HL)            ; Increment it
3061:	1593  CA0C05  	        JP      Z,OVERR         ; Number overflowed - Error
3062:	1596  2E01    	        LD      L,1             ; 1 bit to shift right
3063:	1598  CD3916  	        CALL    SHRT1           ; Shift result right
3064:	159B  C3E415  	        JP      RONDUP          ; Round it up
3065:			
3066:	159E  AF      	MINCDE: XOR     A               ; Clear A and carry
3067:	159F  90      	        SUB     B               ; Negate exponent
3068:	15A0  47      	        LD      B,A             ; Re-save exponent
3069:	15A1  7E      	        LD      A,(HL)          ; Get LSB of FPREG
3070:	15A2  9B      	        SBC     A, E            ; Subtract LSB of BCDE
3071:	15A3  5F      	        LD      E,A             ; Save LSB of BCDE
3072:	15A4  23      	        INC     HL
3073:	15A5  7E      	        LD      A,(HL)          ; Get NMSB of FPREG
3074:	15A6  9A      	        SBC     A,D             ; Subtract NMSB of BCDE
3075:	15A7  57      	        LD      D,A             ; Save NMSB of BCDE
3076:	15A8  23      	        INC     HL
3077:	15A9  7E      	        LD      A,(HL)          ; Get MSB of FPREG
3078:	15AA  99      	        SBC     A,C             ; Subtract MSB of BCDE
3079:	15AB  4F      	        LD      C,A             ; Save MSB of BCDE
3080:	15AC  DC0F16  	CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
3081:			
3082:	15AF  68      	BNORM:  LD      L,B             ; L = Exponent
3083:	15B0  63      	        LD      H,E             ; H = LSB
3084:	15B1  AF      	        XOR     A
3085:	15B2  47      	BNRMLP: LD      B,A             ; Save bit count
3086:	15B3  79      	        LD      A,C             ; Get MSB
3087:	15B4  B7      	        OR      A               ; Is it zero?
3088:	15B5  C2D115  	        JP      NZ,PNORM        ; No - Do it bit at a time
3089:	15B8  4A      	        LD      C,D             ; MSB = NMSB
3090:	15B9  54      	        LD      D,H             ; NMSB= LSB
3091:	15BA  65      	        LD      H,L             ; LSB = VLSB
3092:	15BB  6F      	        LD      L,A             ; VLSB= 0
3093:	15BC  78      	        LD      A,B             ; Get exponent
3094:	15BD  D608    	        SUB     8               ; Count 8 bits
3095:	15BF  FEE0    	        CP      -24-8           ; Was number zero?
3096:	15C1  C2B215  	        JP      NZ,BNRMLP       ; No - Keep normalising
3097:	15C4  AF      	RESZER: XOR     A               ; Result is zero
3098:	15C5  322C21  	SAVEXP: LD      (FPEXP),A       ; Save result as zero
3099:	15C8  C9      	        RET
3100:			
3101:	15C9  05      	NORMAL: DEC     B               ; Count bits
3102:	15CA  29      	        ADD     HL,HL           ; Shift HL left
3103:	15CB  7A      	        LD      A,D             ; Get NMSB
3104:	15CC  17      	        RLA                     ; Shift left with last bit
3105:	15CD  57      	        LD      D,A             ; Save NMSB
3106:	15CE  79      	        LD      A,C             ; Get MSB
3107:	15CF  8F      	        ADC     A,A             ; Shift left with last bit
3108:	15D0  4F      	        LD      C,A             ; Save MSB
3109:	15D1  F2C915  	PNORM:  JP      P,NORMAL        ; Not done - Keep going
3110:	15D4  78      	        LD      A,B             ; Number of bits shifted
3111:	15D5  5C      	        LD      E,H             ; Save HL in EB
3112:	15D6  45      	        LD      B,L
3113:	15D7  B7      	        OR      A               ; Any shifting done?
3114:	15D8  CAE415  	        JP      Z,RONDUP        ; No - Round it up
3115:	15DB  212C21  	        LD      HL,FPEXP        ; Point to exponent
3116:	15DE  86      	        ADD     A,(HL)          ; Add shifted bits
3117:	15DF  77      	        LD      (HL),A          ; Re-save exponent
3118:	15E0  D2C415  	        JP      NC,RESZER       ; Underflow - Result is zero
3119:	15E3  C8      	        RET     Z               ; Result is zero
3120:	15E4  78      	RONDUP: LD      A,B             ; Get VLSB of number
3121:	15E5  212C21  	RONDB:  LD      HL,FPEXP        ; Point to exponent
3122:	15E8  B7      	        OR      A               ; Any rounding?
3123:	15E9  FCF615  	        CALL    M,FPROND        ; Yes - Round number up
3124:	15EC  46      	        LD      B,(HL)          ; B = Exponent
3125:	15ED  23      	        INC     HL
3126:	15EE  7E      	        LD      A,(HL)          ; Get sign of result
3127:	15EF  E680    	        AND     10000000B       ; Only bit 7 needed
3128:	15F1  A9      	        XOR     C               ; Set correct sign
3129:	15F2  4F      	        LD      C,A             ; Save correct sign in number
3130:	15F3  C3E517  	        JP      FPBCDE          ; Move BCDE to FPREG
3131:			
3132:	15F6  1C      	FPROND: INC     E               ; Round LSB
3133:	15F7  C0      	        RET     NZ              ; Return if ok
3134:	15F8  14      	        INC     D               ; Round NMSB
3135:	15F9  C0      	        RET     NZ              ; Return if ok
3136:	15FA  0C      	        INC     C               ; Round MSB
3137:	15FB  C0      	        RET     NZ              ; Return if ok
3138:	15FC  0E80    	        LD      C,80H           ; Set normal value
3139:	15FE  34      	        INC     (HL)            ; Increment exponent
3140:	15FF  C0      	        RET     NZ              ; Return if ok
3141:	1600  C30C05  	        JP      OVERR           ; Overflow error
3142:			
3143:	1603  7E      	PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
3144:	1604  83      	        ADD     A,E             ; Add LSB of BCDE
3145:	1605  5F      	        LD      E,A             ; Save LSB of BCDE
3146:	1606  23      	        INC     HL
3147:	1607  7E      	        LD      A,(HL)          ; Get NMSB of FPREG
3148:	1608  8A      	        ADC     A,D             ; Add NMSB of BCDE
3149:	1609  57      	        LD      D,A             ; Save NMSB of BCDE
3150:	160A  23      	        INC     HL
3151:	160B  7E      	        LD      A,(HL)          ; Get MSB of FPREG
3152:	160C  89      	        ADC     A,C             ; Add MSB of BCDE
3153:	160D  4F      	        LD      C,A             ; Save MSB of BCDE
3154:	160E  C9      	        RET
3155:			
3156:	160F  212D21  	COMPL:  LD      HL,SGNRES       ; Sign of result
3157:	1612  7E      	        LD      A,(HL)          ; Get sign of result
3158:	1613  2F      	        CPL                     ; Negate it
3159:	1614  77      	        LD      (HL),A          ; Put it back
3160:	1615  AF      	        XOR     A
3161:	1616  6F      	        LD      L,A             ; Set L to zero
3162:	1617  90      	        SUB     B               ; Negate exponent,set carry
3163:	1618  47      	        LD      B,A             ; Re-save exponent
3164:	1619  7D      	        LD      A,L             ; Load zero
3165:	161A  9B      	        SBC     A,E             ; Negate LSB
3166:	161B  5F      	        LD      E,A             ; Re-save LSB
3167:	161C  7D      	        LD      A,L             ; Load zero
3168:	161D  9A      	        SBC     A,D             ; Negate NMSB
3169:	161E  57      	        LD      D,A             ; Re-save NMSB
3170:	161F  7D      	        LD      A,L             ; Load zero
3171:	1620  99      	        SBC     A,C             ; Negate MSB
3172:	1621  4F      	        LD      C,A             ; Re-save MSB
3173:	1622  C9      	        RET
3174:			
3175:	1623  0600    	SCALE:  LD      B,0             ; Clear underflow
3176:	1625  D608    	SCALLP: SUB     8               ; 8 bits (a whole byte)?
3177:	1627  DA3216  	        JP      C,SHRITE        ; No - Shift right A bits
3178:	162A  43      	        LD      B,E             ; <- Shift
3179:	162B  5A      	        LD      E,D             ; <- right
3180:	162C  51      	        LD      D,C             ; <- eight
3181:	162D  0E00    	        LD      C,0             ; <- bits
3182:	162F  C32516  	        JP      SCALLP          ; More bits to shift
3183:			
3184:	1632  C609    	SHRITE: ADD     A,8+1           ; Adjust count
3185:	1634  6F      	        LD      L,A             ; Save bits to shift
3186:	1635  AF      	SHRLP:  XOR     A               ; Flag for all done
3187:	1636  2D      	        DEC     L               ; All shifting done?
3188:	1637  C8      	        RET     Z               ; Yes - Return
3189:	1638  79      	        LD      A,C             ; Get MSB
3190:	1639  1F      	SHRT1:  RRA                     ; Shift it right
3191:	163A  4F      	        LD      C,A             ; Re-save
3192:	163B  7A      	        LD      A,D             ; Get NMSB
3193:	163C  1F      	        RRA                     ; Shift right with last bit
3194:	163D  57      	        LD      D,A             ; Re-save it
3195:	163E  7B      	        LD      A,E             ; Get LSB
3196:	163F  1F      	        RRA                     ; Shift right with last bit
3197:	1640  5F      	        LD      E,A             ; Re-save it
3198:	1641  78      	        LD      A,B             ; Get underflow
3199:	1642  1F      	        RRA                     ; Shift right with last bit
3200:	1643  47      	        LD      B,A             ; Re-save underflow
3201:	1644  C33516  	        JP      SHRLP           ; More bits to do
3202:			
3203:	1647  00000081	UNITY:  .DB     000H,000H,000H,081H  ; 1.00000
3204:			
3205:	164B  03      	LOGTAB: .DB     3                    ; Table used by LOG
3206:	164C  AA561980	        .DB     0AAH,056H,019H,080H  ; 0.59898
3207:	1650  F1227680	        .DB     0F1H,022H,076H,080H  ; 0.96147
3208:	1654  45AA3882	        .DB     045H,0AAH,038H,082H  ; 2.88539
3209:			
3210:	1658  CDA417  	LOG:    CALL    TSTSGN          ; Test sign of value
3211:	165B  B7      	        OR      A
3212:	165C  EA1C0A  	        JP      PE,FCERR        ; ?FC Error if <= zero
3213:	165F  212C21  	        LD      HL,FPEXP        ; Point to exponent
3214:	1662  7E      	        LD      A,(HL)          ; Get exponent
3215:	1663  013580  	        LD      BC,8035H        ; BCDE = SQR(1/2)
3216:	1666  11F304  	        LD      DE,04F3H
3217:	1669  90      	        SUB     B               ; Scale value to be < 1
3218:	166A  F5      	        PUSH    AF              ; Save scale factor
3219:	166B  70      	        LD      (HL),B          ; Save new exponent
3220:	166C  D5      	        PUSH    DE              ; Save SQR(1/2)
3221:	166D  C5      	        PUSH    BC
3222:	166E  CD5E15  	        CALL    FPADD           ; Add SQR(1/2) to value
3223:	1671  C1      	        POP     BC              ; Restore SQR(1/2)
3224:	1672  D1      	        POP     DE
3225:	1673  04      	        INC     B               ; Make it SQR(2)
3226:	1674  CDFA16  	        CALL    DVBCDE          ; Divide by SQR(2)
3227:	1677  214716  	        LD      HL,UNITY        ; Point to 1.
3228:	167A  CD5515  	        CALL    SUBPHL          ; Subtract FPREG from 1
3229:	167D  214B16  	        LD      HL,LOGTAB       ; Coefficient table
3230:	1680  CDEC1A  	        CALL    SUMSER          ; Evaluate sum of series
3231:	1683  018080  	        LD      BC,8080H        ; BCDE = -0.5
3232:	1686  110000  	        LD      DE,0000H
3233:	1689  CD5E15  	        CALL    FPADD           ; Subtract 0.5 from FPREG
3234:	168C  F1      	        POP     AF              ; Restore scale factor
3235:	168D  CD1F19  	        CALL    RSCALE          ; Re-scale number
3236:	1690  013180  	MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
3237:	1693  111872  	        LD      DE,7218H
3238:	1696  21      	        .DB     21H             ; Skip "POP BC" and "POP DE"
3239:			
3240:	1697  C1      	MULT:   POP     BC              ; Get number from stack
3241:	1698  D1      	        POP     DE
3242:	1699  CDA417  	FPMULT: CALL    TSTSGN          ; Test sign of FPREG
3243:	169C  C8      	        RET     Z               ; Return zero if zero
3244:	169D  2E00    	        LD      L,0             ; Flag add exponents
3245:	169F  CD6217  	        CALL    ADDEXP          ; Add exponents
3246:	16A2  79      	        LD      A,C             ; Get MSB of multiplier
3247:	16A3  323B21  	        LD      (MULVAL),A      ; Save MSB of multiplier
3248:	16A6  EB      	        EX      DE,HL
3249:	16A7  223C21  	        LD      (MULVAL+1),HL   ; Save rest of multiplier
3250:	16AA  010000  	        LD      BC,0            ; Partial product (BCDE) = zero
3251:	16AD  50      	        LD      D,B
3252:	16AE  58      	        LD      E,B
3253:	16AF  21AF15  	        LD      HL,BNORM        ; Address of normalise
3254:	16B2  E5      	        PUSH    HL              ; Save for return
3255:	16B3  21BB16  	        LD      HL,MULT8        ; Address of 8 bit multiply
3256:	16B6  E5      	        PUSH    HL              ; Save for NMSB,MSB
3257:	16B7  E5      	        PUSH    HL              ; 
3258:	16B8  212921  	        LD      HL,FPREG        ; Point to number
3259:	16BB  7E      	MULT8:  LD      A,(HL)          ; Get LSB of number
3260:	16BC  23      	        INC     HL              ; Point to NMSB
3261:	16BD  B7      	        OR      A               ; Test LSB
3262:	16BE  CAE716  	        JP      Z,BYTSFT        ; Zero - shift to next byte
3263:	16C1  E5      	        PUSH    HL              ; Save address of number
3264:	16C2  2E08    	        LD      L,8             ; 8 bits to multiply by
3265:	16C4  1F      	MUL8LP: RRA                     ; Shift LSB right
3266:	16C5  67      	        LD      H,A             ; Save LSB
3267:	16C6  79      	        LD      A,C             ; Get MSB
3268:	16C7  D2D516  	        JP      NC,NOMADD       ; Bit was zero - Don't add
3269:	16CA  E5      	        PUSH    HL              ; Save LSB and count
3270:	16CB  2A3C21  	        LD      HL,(MULVAL+1)   ; Get LSB and NMSB
3271:	16CE  19      	        ADD     HL,DE           ; Add NMSB and LSB
3272:	16CF  EB      	        EX      DE,HL           ; Leave sum in DE
3273:	16D0  E1      	        POP     HL              ; Restore MSB and count
3274:	16D1  3A3B21  	        LD      A,(MULVAL)      ; Get MSB of multiplier
3275:	16D4  89      	        ADC     A,C             ; Add MSB
3276:	16D5  1F      	NOMADD: RRA                     ; Shift MSB right
3277:	16D6  4F      	        LD      C,A             ; Re-save MSB
3278:	16D7  7A      	        LD      A,D             ; Get NMSB
3279:	16D8  1F      	        RRA                     ; Shift NMSB right
3280:	16D9  57      	        LD      D,A             ; Re-save NMSB
3281:	16DA  7B      	        LD      A,E             ; Get LSB
3282:	16DB  1F      	        RRA                     ; Shift LSB right
3283:	16DC  5F      	        LD      E,A             ; Re-save LSB
3284:	16DD  78      	        LD      A,B             ; Get VLSB
3285:	16DE  1F      	        RRA                     ; Shift VLSB right
3286:	16DF  47      	        LD      B,A             ; Re-save VLSB
3287:	16E0  2D      	        DEC     L               ; Count bits multiplied
3288:	16E1  7C      	        LD      A,H             ; Get LSB of multiplier
3289:	16E2  C2C416  	        JP      NZ,MUL8LP       ; More - Do it
3290:	16E5  E1      	POPHRT: POP     HL              ; Restore address of number
3291:	16E6  C9      	        RET
3292:			
3293:	16E7  43      	BYTSFT: LD      B,E             ; Shift partial product left
3294:	16E8  5A      	        LD      E,D
3295:	16E9  51      	        LD      D,C
3296:	16EA  4F      	        LD      C,A
3297:	16EB  C9      	        RET
3298:			
3299:	16EC  CDD517  	DIV10:  CALL    STAKFP          ; Save FPREG on stack
3300:	16EF  012084  	        LD      BC,8420H        ; BCDE = 10.
3301:	16F2  110000  	        LD      DE,0000H
3302:	16F5  CDE517  	        CALL    FPBCDE          ; Move 10 to FPREG
3303:			
3304:	16F8  C1      	DIV:    POP     BC              ; Get number from stack
3305:	16F9  D1      	        POP     DE
3306:	16FA  CDA417  	DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
3307:	16FD  CA0005  	        JP      Z,DZERR         ; Error if division by zero
3308:	1700  2EFF    	        LD      L,-1            ; Flag subtract exponents
3309:	1702  CD6217  	        CALL    ADDEXP          ; Subtract exponents
3310:	1705  34      	        INC     (HL)            ; Add 2 to exponent to adjust
3311:	1706  34      	        INC     (HL)
3312:	1707  2B      	        DEC     HL              ; Point to MSB
3313:	1708  7E      	        LD      A,(HL)          ; Get MSB of dividend
3314:	1709  325720  	        LD      (DIV3),A        ; Save for subtraction
3315:	170C  2B      	        DEC     HL
3316:	170D  7E      	        LD      A,(HL)          ; Get NMSB of dividend
3317:	170E  325320  	        LD      (DIV2),A        ; Save for subtraction
3318:	1711  2B      	        DEC     HL
3319:	1712  7E      	        LD      A,(HL)          ; Get MSB of dividend
3320:	1713  324F20  	        LD      (DIV1),A        ; Save for subtraction
3321:	1716  41      	        LD      B,C             ; Get MSB
3322:	1717  EB      	        EX      DE,HL           ; NMSB,LSB to HL
3323:	1718  AF      	        XOR     A
3324:	1719  4F      	        LD      C,A             ; Clear MSB of quotient
3325:	171A  57      	        LD      D,A             ; Clear NMSB of quotient
3326:	171B  5F      	        LD      E,A             ; Clear LSB of quotient
3327:	171C  325A20  	        LD      (DIV4),A        ; Clear overflow count
3328:	171F  E5      	DIVLP:  PUSH    HL              ; Save divisor
3329:	1720  C5      	        PUSH    BC
3330:	1721  7D      	        LD      A,L             ; Get LSB of number
3331:	1722  CD4E20  	        CALL    DIVSUP          ; Subt' divisor from dividend
3332:	1725  DE00    	        SBC     A,0             ; Count for overflows
3333:	1727  3F      	        CCF
3334:	1728  D23217  	        JP      NC,RESDIV       ; Restore divisor if borrow
3335:	172B  325A20  	        LD      (DIV4),A        ; Re-save overflow count
3336:	172E  F1      	        POP     AF              ; Scrap divisor
3337:	172F  F1      	        POP     AF
3338:	1730  37      	        SCF                     ; Set carry to
3339:	1731  D2      	        .DB     0D2H            ; Skip "POP BC" and "POP HL"
3340:			
3341:	1732  C1      	RESDIV: POP     BC              ; Restore divisor
3342:	1733  E1      	        POP     HL
3343:	1734  79      	        LD      A,C             ; Get MSB of quotient
3344:	1735  3C      	        INC     A
3345:	1736  3D      	        DEC     A
3346:	1737  1F      	        RRA                     ; Bit 0 to bit 7
3347:	1738  FAE515  	        JP      M,RONDB        ; Done - Normalise result
3348:	173B  17      	        RLA                     ; Restore carry
3349:	173C  7B      	        LD      A,E             ; Get LSB of quotient
3350:	173D  17      	        RLA                     ; Double it
3351:	173E  5F      	        LD      E,A             ; Put it back
3352:	173F  7A      	        LD      A,D             ; Get NMSB of quotient
3353:	1740  17      	        RLA                     ; Double it
3354:	1741  57      	        LD      D,A             ; Put it back
3355:	1742  79      	        LD      A,C             ; Get MSB of quotient
3356:	1743  17      	        RLA                     ; Double it
3357:	1744  4F      	        LD      C,A             ; Put it back
3358:	1745  29      	        ADD     HL,HL           ; Double NMSB,LSB of divisor
3359:	1746  78      	        LD      A,B             ; Get MSB of divisor
3360:	1747  17      	        RLA                     ; Double it
3361:	1748  47      	        LD      B,A             ; Put it back
3362:	1749  3A5A20  	        LD      A,(DIV4)        ; Get VLSB of quotient
3363:	174C  17      	        RLA                     ; Double it
3364:	174D  325A20  	        LD      (DIV4),A        ; Put it back
3365:	1750  79      	        LD      A,C             ; Get MSB of quotient
3366:	1751  B2      	        OR      D               ; Merge NMSB
3367:	1752  B3      	        OR      E               ; Merge LSB
3368:	1753  C21F17  	        JP      NZ,DIVLP        ; Not done - Keep dividing
3369:	1756  E5      	        PUSH    HL              ; Save divisor
3370:	1757  212C21  	        LD      HL,FPEXP        ; Point to exponent
3371:	175A  35      	        DEC     (HL)            ; Divide by 2
3372:	175B  E1      	        POP     HL              ; Restore divisor
3373:	175C  C21F17  	        JP      NZ,DIVLP        ; Ok - Keep going
3374:	175F  C30C05  	        JP      OVERR           ; Overflow error
3375:			
3376:	1762  78      	ADDEXP: LD      A,B             ; Get exponent of dividend
3377:	1763  B7      	        OR      A               ; Test it
3378:	1764  CA8617  	        JP      Z,OVTST3        ; Zero - Result zero
3379:	1767  7D      	        LD      A,L             ; Get add/subtract flag
3380:	1768  212C21  	        LD      HL,FPEXP        ; Point to exponent
3381:	176B  AE      	        XOR     (HL)            ; Add or subtract it
3382:	176C  80      	        ADD     A,B             ; Add the other exponent
3383:	176D  47      	        LD      B,A             ; Save new exponent
3384:	176E  1F      	        RRA                     ; Test exponent for overflow
3385:	176F  A8      	        XOR     B
3386:	1770  78      	        LD      A,B             ; Get exponent
3387:	1771  F28517  	        JP      P,OVTST2        ; Positive - Test for overflow
3388:	1774  C680    	        ADD     A,80H           ; Add excess 128
3389:	1776  77      	        LD      (HL),A          ; Save new exponent
3390:	1777  CAE516  	        JP      Z,POPHRT        ; Zero - Result zero
3391:	177A  CD0A18  	        CALL    SIGNS           ; Set MSBs and sign of result
3392:	177D  77      	        LD      (HL),A          ; Save new exponent
3393:	177E  2B      	        DEC     HL              ; Point to MSB
3394:	177F  C9      	        RET
3395:			
3396:	1780  CDA417  	OVTST1: CALL    TSTSGN          ; Test sign of FPREG
3397:	1783  2F      	        CPL                     ; Invert sign
3398:	1784  E1      	        POP     HL              ; Clean up stack
3399:	1785  B7      	OVTST2: OR      A               ; Test if new exponent zero
3400:	1786  E1      	OVTST3: POP     HL              ; Clear off return address
3401:	1787  F2C415  	        JP      P,RESZER        ; Result zero
3402:	178A  C30C05  	        JP      OVERR           ; Overflow error
3403:			
3404:	178D  CDF017  	MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
3405:	1790  78      	        LD      A,B             ; Get exponent
3406:	1791  B7      	        OR      A               ; Is it zero?
3407:	1792  C8      	        RET     Z               ; Yes - Result is zero
3408:	1793  C602    	        ADD     A,2             ; Multiply by 4
3409:	1795  DA0C05  	        JP      C,OVERR         ; Overflow - ?OV Error
3410:	1798  47      	        LD      B,A             ; Re-save exponent
3411:	1799  CD5E15  	        CALL    FPADD           ; Add BCDE to FPREG (Times 5)
3412:	179C  212C21  	        LD      HL,FPEXP        ; Point to exponent
3413:	179F  34      	        INC     (HL)            ; Double number (Times 10)
3414:	17A0  C0      	        RET     NZ              ; Ok - Return
3415:	17A1  C30C05  	        JP      OVERR           ; Overflow error
3416:			
3417:	17A4  3A2C21  	TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
3418:	17A7  B7      	        OR      A
3419:	17A8  C8      	        RET     Z               ; RETurn if number is zero
3420:	17A9  3A2B21  	        LD      A,(FPREG+2)     ; Get MSB of FPREG
3421:	17AC  FE      	        .DB     0FEH            ; Test sign
3422:	17AD  2F      	RETREL: CPL                     ; Invert sign
3423:	17AE  17      	        RLA                     ; Sign bit to carry
3424:	17AF  9F      	FLGDIF: SBC     A,A             ; Carry to all bits of A
3425:	17B0  C0      	        RET     NZ              ; Return -1 if negative
3426:	17B1  3C      	        INC     A               ; Bump to +1
3427:	17B2  C9      	        RET                     ; Positive - Return +1
3428:			
3429:	17B3  CDA417  	SGN:    CALL    TSTSGN          ; Test sign of FPREG
3430:	17B6  0688    	FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
3431:	17B8  110000  	        LD      DE,0            ; Zero NMSB and LSB
3432:	17BB  212C21  	RETINT: LD      HL,FPEXP        ; Point to exponent
3433:	17BE  4F      	        LD      C,A             ; CDE = MSB,NMSB and LSB
3434:	17BF  70      	        LD      (HL),B          ; Save exponent
3435:	17C0  0600    	        LD      B,0             ; CDE = integer to normalise
3436:	17C2  23      	        INC     HL              ; Point to sign of result
3437:	17C3  3680    	        LD      (HL),80H        ; Set sign of result
3438:	17C5  17      	        RLA                     ; Carry = sign of integer
3439:	17C6  C3AC15  	        JP      CONPOS          ; Set sign of result
3440:			
3441:	17C9  CDA417  	ABS:    CALL    TSTSGN          ; Test sign of FPREG
3442:	17CC  F0      	        RET     P               ; Return if positive
3443:	17CD  212B21  	INVSGN: LD      HL,FPREG+2      ; Point to MSB
3444:	17D0  7E      	        LD      A,(HL)          ; Get sign of mantissa
3445:	17D1  EE80    	        XOR     80H             ; Invert sign of mantissa
3446:	17D3  77      	        LD      (HL),A          ; Re-save sign of mantissa
3447:	17D4  C9      	        RET
3448:			
3449:	17D5  EB      	STAKFP: EX      DE,HL           ; Save code string address
3450:	17D6  2A2921  	        LD      HL,(FPREG)      ; LSB,NLSB of FPREG
3451:	17D9  E3      	        EX      (SP),HL         ; Stack them,get return
3452:	17DA  E5      	        PUSH    HL              ; Re-save return
3453:	17DB  2A2B21  	        LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
3454:	17DE  E3      	        EX      (SP),HL         ; Stack them,get return
3455:	17DF  E5      	        PUSH    HL              ; Re-save return
3456:	17E0  EB      	        EX      DE,HL           ; Restore code string address
3457:	17E1  C9      	        RET
3458:			
3459:	17E2  CDF317  	PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
3460:	17E5  EB      	FPBCDE: EX      DE,HL           ; Save code string address
3461:	17E6  222921  	        LD      (FPREG),HL      ; Save LSB,NLSB of number
3462:	17E9  60      	        LD      H,B             ; Exponent of number
3463:	17EA  69      	        LD      L,C             ; MSB of number
3464:	17EB  222B21  	        LD      (FPREG+2),HL    ; Save MSB and exponent
3465:	17EE  EB      	        EX      DE,HL           ; Restore code string address
3466:	17EF  C9      	        RET
3467:			
3468:	17F0  212921  	BCDEFP: LD      HL,FPREG        ; Point to FPREG
3469:	17F3  5E      	LOADFP: LD      E,(HL)          ; Get LSB of number
3470:	17F4  23      	        INC     HL
3471:	17F5  56      	        LD      D,(HL)          ; Get NMSB of number
3472:	17F6  23      	        INC     HL
3473:	17F7  4E      	        LD      C,(HL)          ; Get MSB of number
3474:	17F8  23      	        INC     HL
3475:	17F9  46      	        LD      B,(HL)          ; Get exponent of number
3476:	17FA  23      	INCHL:  INC     HL              ; Used for conditional "INC HL"
3477:	17FB  C9      	        RET
3478:			
3479:	17FC  112921  	FPTHL:  LD      DE,FPREG        ; Point to FPREG
3480:	17FF  0604    	DETHL4: LD      B,4             ; 4 bytes to move
3481:	1801  1A      	DETHLB: LD      A,(DE)          ; Get source
3482:	1802  77      	        LD      (HL),A          ; Save destination
3483:	1803  13      	        INC     DE              ; Next source
3484:	1804  23      	        INC     HL              ; Next destination
3485:	1805  05      	        DEC     B               ; Count bytes
3486:	1806  C20118  	        JP      NZ,DETHLB       ; Loop if more
3487:	1809  C9      	        RET
3488:			
3489:	180A  212B21  	SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
3490:	180D  7E      	        LD      A,(HL)          ; Get MSB
3491:	180E  07      	        RLCA                    ; Old sign to carry
3492:	180F  37      	        SCF                     ; Set MSBit
3493:	1810  1F      	        RRA                     ; Set MSBit of MSB
3494:	1811  77      	        LD      (HL),A          ; Save new MSB
3495:	1812  3F      	        CCF                     ; Complement sign
3496:	1813  1F      	        RRA                     ; Old sign to carry
3497:	1814  23      	        INC     HL
3498:	1815  23      	        INC     HL
3499:	1816  77      	        LD      (HL),A          ; Set sign of result
3500:	1817  79      	        LD      A,C             ; Get MSB
3501:	1818  07      	        RLCA                    ; Old sign to carry
3502:	1819  37      	        SCF                     ; Set MSBit
3503:	181A  1F      	        RRA                     ; Set MSBit of MSB
3504:	181B  4F      	        LD      C,A             ; Save MSB
3505:	181C  1F      	        RRA
3506:	181D  AE      	        XOR     (HL)            ; New sign of result
3507:	181E  C9      	        RET
3508:			
3509:	181F  78      	CMPNUM: LD      A,B             ; Get exponent of number
3510:	1820  B7      	        OR      A
3511:	1821  CAA417  	        JP      Z,TSTSGN        ; Zero - Test sign of FPREG
3512:	1824  21AD17  	        LD      HL,RETREL       ; Return relation routine
3513:	1827  E5      	        PUSH    HL              ; Save for return
3514:	1828  CDA417  	        CALL    TSTSGN          ; Test sign of FPREG
3515:	182B  79      	        LD      A,C             ; Get MSB of number
3516:	182C  C8      	        RET     Z               ; FPREG zero - Number's MSB
3517:	182D  212B21  	        LD      HL,FPREG+2      ; MSB of FPREG
3518:	1830  AE      	        XOR     (HL)            ; Combine signs
3519:	1831  79      	        LD      A,C             ; Get MSB of number
3520:	1832  F8      	        RET     M               ; Exit if signs different
3521:	1833  CD3918  	        CALL    CMPFP           ; Compare FP numbers
3522:	1836  1F      	        RRA                     ; Get carry to sign
3523:	1837  A9      	        XOR     C               ; Combine with MSB of number
3524:	1838  C9      	        RET
3525:			
3526:	1839  23      	CMPFP:  INC     HL              ; Point to exponent
3527:	183A  78      	        LD      A,B             ; Get exponent
3528:	183B  BE      	        CP      (HL)            ; Compare exponents
3529:	183C  C0      	        RET     NZ              ; Different
3530:	183D  2B      	        DEC     HL              ; Point to MBS
3531:	183E  79      	        LD      A,C             ; Get MSB
3532:	183F  BE      	        CP      (HL)            ; Compare MSBs
3533:	1840  C0      	        RET     NZ              ; Different
3534:	1841  2B      	        DEC     HL              ; Point to NMSB
3535:	1842  7A      	        LD      A,D             ; Get NMSB
3536:	1843  BE      	        CP      (HL)            ; Compare NMSBs
3537:	1844  C0      	        RET     NZ              ; Different
3538:	1845  2B      	        DEC     HL              ; Point to LSB
3539:	1846  7B      	        LD      A,E             ; Get LSB
3540:	1847  96      	        SUB     (HL)            ; Compare LSBs
3541:	1848  C0      	        RET     NZ              ; Different
3542:	1849  E1      	        POP     HL              ; Drop RETurn
3543:	184A  E1      	        POP     HL              ; Drop another RETurn
3544:	184B  C9      	        RET
3545:			
3546:	184C  47      	FPINT:  LD      B,A             ; <- Move
3547:	184D  4F      	        LD      C,A             ; <- exponent
3548:	184E  57      	        LD      D,A             ; <- to all
3549:	184F  5F      	        LD      E,A             ; <- bits
3550:	1850  B7      	        OR      A               ; Test exponent
3551:	1851  C8      	        RET     Z               ; Zero - Return zero
3552:	1852  E5      	        PUSH    HL              ; Save pointer to number
3553:	1853  CDF017  	        CALL    BCDEFP          ; Move FPREG to BCDE
3554:	1856  CD0A18  	        CALL    SIGNS           ; Set MSBs & sign of result
3555:	1859  AE      	        XOR     (HL)            ; Combine with sign of FPREG
3556:	185A  67      	        LD      H,A             ; Save combined signs
3557:	185B  FC7018  	        CALL    M,DCBCDE        ; Negative - Decrement BCDE
3558:	185E  3E98    	        LD      A,80H+24        ; 24 bits
3559:	1860  90      	        SUB     B               ; Bits to shift
3560:	1861  CD2316  	        CALL    SCALE           ; Shift BCDE
3561:	1864  7C      	        LD      A,H             ; Get combined sign
3562:	1865  17      	        RLA                     ; Sign to carry
3563:	1866  DCF615  	        CALL    C,FPROND        ; Negative - Round number up
3564:	1869  0600    	        LD      B,0             ; Zero exponent
3565:	186B  DC0F16  	        CALL    C,COMPL         ; If negative make positive
3566:	186E  E1      	        POP     HL              ; Restore pointer to number
3567:	186F  C9      	        RET
3568:			
3569:	1870  1B      	DCBCDE: DEC     DE              ; Decrement BCDE
3570:	1871  7A      	        LD      A,D             ; Test LSBs
3571:	1872  A3      	        AND     E
3572:	1873  3C      	        INC     A
3573:	1874  C0      	        RET     NZ              ; Exit if LSBs not FFFF
3574:	1875  0B      	        DEC     BC              ; Decrement MSBs
3575:	1876  C9      	        RET
3576:			
3577:	1877  212C21  	INT:    LD      HL,FPEXP        ; Point to exponent
3578:	187A  7E      	        LD      A,(HL)          ; Get exponent
3579:	187B  FE98    	        CP      80H+24          ; Integer accuracy only?
3580:	187D  3A2921  	        LD      A,(FPREG)       ; Get LSB
3581:	1880  D0      	        RET     NC              ; Yes - Already integer
3582:	1881  7E      	        LD      A,(HL)          ; Get exponent
3583:	1882  CD4C18  	        CALL    FPINT           ; F.P to integer
3584:	1885  3698    	        LD      (HL),80H+24     ; Save 24 bit integer
3585:	1887  7B      	        LD      A,E             ; Get LSB of number
3586:	1888  F5      	        PUSH    AF              ; Save LSB
3587:	1889  79      	        LD      A,C             ; Get MSB of number
3588:	188A  17      	        RLA                     ; Sign to carry
3589:	188B  CDAC15  	        CALL    CONPOS          ; Set sign of result
3590:	188E  F1      	        POP     AF              ; Restore LSB of number
3591:	188F  C9      	        RET
3592:			
3593:	1890  210000  	MLDEBC: LD      HL,0            ; Clear partial product
3594:	1893  78      	        LD      A,B             ; Test multiplier
3595:	1894  B1      	        OR      C
3596:	1895  C8      	        RET     Z               ; Return zero if zero
3597:	1896  3E10    	        LD      A,16            ; 16 bits
3598:	1898  29      	MLDBLP: ADD     HL,HL           ; Shift P.P left
3599:	1899  DAD010  	        JP      C,BSERR         ; ?BS Error if overflow
3600:	189C  EB      	        EX      DE,HL
3601:	189D  29      	        ADD     HL,HL           ; Shift multiplier left
3602:	189E  EB      	        EX      DE,HL
3603:	189F  D2A618  	        JP      NC,NOMLAD       ; Bit was zero - No add
3604:	18A2  09      	        ADD     HL,BC           ; Add multiplicand
3605:	18A3  DAD010  	        JP      C,BSERR         ; ?BS Error if overflow
3606:	18A6  3D      	NOMLAD: DEC     A               ; Count bits
3607:	18A7  C29818  	        JP      NZ,MLDBLP       ; More
3608:	18AA  C9      	        RET
3609:			
3610:	18AB  FE2D    	ASCTFP: CP      '-'             ; Negative?
3611:	18AD  F5      	        PUSH    AF              ; Save it and flags
3612:	18AE  CAB718  	        JP      Z,CNVNUM        ; Yes - Convert number
3613:	18B1  FE2B    	        CP      '+'             ; Positive?
3614:	18B3  CAB718  	        JP      Z,CNVNUM        ; Yes - Convert number
3615:	18B6  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
3616:	18B7  CDC415  	CNVNUM: CALL    RESZER          ; Set result to zero
3617:	18BA  47      	        LD      B,A             ; Digits after point counter
3618:	18BB  57      	        LD      D,A             ; Sign of exponent
3619:	18BC  5F      	        LD      E,A             ; Exponent of ten
3620:	18BD  2F      	        CPL
3621:	18BE  4F      	        LD      C,A             ; Before or after point flag
3622:	18BF  CD5509  	MANLP:  CALL    GETCHR          ; Get next character
3623:	18C2  DA0819  	        JP      C,ADDIG         ; Digit - Add to number
3624:	18C5  FE2E    	        CP      '.'
3625:	18C7  CAE318  	        JP      Z,DPOINT        ; '.' - Flag point
3626:	18CA  FE45    	        CP      'E'
3627:	18CC  C2E718  	        JP      NZ,CONEXP       ; Not 'E' - Scale number
3628:	18CF  CD5509  	        CALL    GETCHR          ; Get next character
3629:	18D2  CDFB0E  	        CALL    SGNEXP          ; Get sign of exponent
3630:	18D5  CD5509  	EXPLP:  CALL    GETCHR          ; Get next character
3631:	18D8  DA2A19  	        JP      C,EDIGIT        ; Digit - Add to exponent
3632:	18DB  14      	        INC     D               ; Is sign negative?
3633:	18DC  C2E718  	        JP      NZ,CONEXP       ; No - Scale number
3634:	18DF  AF      	        XOR     A
3635:	18E0  93      	        SUB     E               ; Negate exponent
3636:	18E1  5F      	        LD      E,A             ; And re-save it
3637:	18E2  0C      	        INC     C               ; Flag end of number
3638:	18E3  0C      	DPOINT: INC     C               ; Flag point passed
3639:	18E4  CABF18  	        JP      Z,MANLP         ; Zero - Get another digit
3640:	18E7  E5      	CONEXP: PUSH    HL              ; Save code string address
3641:	18E8  7B      	        LD      A,E             ; Get exponent
3642:	18E9  90      	        SUB     B               ; Subtract digits after point
3643:	18EA  F40019  	SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
3644:	18ED  F2F618  	        JP      P,ENDCON        ; Positive - All done
3645:	18F0  F5      	        PUSH    AF              ; Save number of times to /10
3646:	18F1  CDEC16  	        CALL    DIV10           ; Divide by 10
3647:	18F4  F1      	        POP     AF              ; Restore count
3648:	18F5  3C      	        INC     A               ; Count divides
3649:			
3650:	18F6  C2EA18  	ENDCON: JP      NZ,SCALMI       ; More to do
3651:	18F9  D1      	        POP     DE              ; Restore code string address
3652:	18FA  F1      	        POP     AF              ; Restore sign of number
3653:	18FB  CCCD17  	        CALL    Z,INVSGN        ; Negative - Negate number
3654:	18FE  EB      	        EX      DE,HL           ; Code string address to HL
3655:	18FF  C9      	        RET
3656:			
3657:	1900  C8      	SCALPL: RET     Z               ; Exit if no scaling needed
3658:	1901  F5      	MULTEN: PUSH    AF              ; Save count
3659:	1902  CD8D17  	        CALL    MLSP10          ; Multiply number by 10
3660:	1905  F1      	        POP     AF              ; Restore count
3661:	1906  3D      	        DEC     A               ; Count multiplies
3662:	1907  C9      	        RET
3663:			
3664:	1908  D5      	ADDIG:  PUSH    DE              ; Save sign of exponent
3665:	1909  57      	        LD      D,A             ; Save digit
3666:	190A  78      	        LD      A,B             ; Get digits after point
3667:	190B  89      	        ADC     A,C             ; Add one if after point
3668:	190C  47      	        LD      B,A             ; Re-save counter
3669:	190D  C5      	        PUSH    BC              ; Save point flags
3670:	190E  E5      	        PUSH    HL              ; Save code string address
3671:	190F  D5      	        PUSH    DE              ; Save digit
3672:	1910  CD8D17  	        CALL    MLSP10          ; Multiply number by 10
3673:	1913  F1      	        POP     AF              ; Restore digit
3674:	1914  D630    	        SUB     '0'             ; Make it absolute
3675:	1916  CD1F19  	        CALL    RSCALE          ; Re-scale number
3676:	1919  E1      	        POP     HL              ; Restore code string address
3677:	191A  C1      	        POP     BC              ; Restore point flags
3678:	191B  D1      	        POP     DE              ; Restore sign of exponent
3679:	191C  C3BF18  	        JP      MANLP           ; Get another digit
3680:			
3681:	191F  CDD517  	RSCALE: CALL    STAKFP          ; Put number on stack
3682:	1922  CDB617  	        CALL    FLGREL          ; Digit to add to FPREG
3683:	1925  C1      	PADD:   POP     BC              ; Restore number
3684:	1926  D1      	        POP     DE
3685:	1927  C35E15  	        JP      FPADD           ; Add BCDE to FPREG and return
3686:			
3687:	192A  7B      	EDIGIT: LD      A,E             ; Get digit
3688:	192B  07      	        RLCA                    ; Times 2
3689:	192C  07      	        RLCA                    ; Times 4
3690:	192D  83      	        ADD     A,E             ; Times 5
3691:	192E  07      	        RLCA                    ; Times 10
3692:	192F  86      	        ADD     A,(HL)          ; Add next digit
3693:	1930  D630    	        SUB     '0'             ; Make it absolute
3694:	1932  5F      	        LD      E,A             ; Save new digit
3695:	1933  C3D518  	        JP      EXPLP           ; Look for another digit
3696:			
3697:	1936  E5      	LINEIN: PUSH    HL              ; Save code string address
3698:	1937  219504  	        LD      HL,INMSG        ; Output " in "
3699:	193A  CD9B12  	        CALL    PRS             ; Output string at HL
3700:	193D  E1      	        POP     HL              ; Restore code string address
3701:	193E  EB      	PRNTHL: EX      DE,HL           ; Code string address to DE
3702:	193F  AF      	        XOR     A
3703:	1940  0698    	        LD      B,80H+24        ; 24 bits
3704:	1942  CDBB17  	        CALL    RETINT          ; Return the integer
3705:	1945  219A12  	        LD      HL,PRNUMS       ; Print number string
3706:	1948  E5      	        PUSH    HL              ; Save for return
3707:	1949  212E21  	NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
3708:	194C  E5      	        PUSH    HL              ; Save for return
3709:	194D  CDA417  	        CALL    TSTSGN          ; Test sign of FPREG
3710:	1950  3620    	        LD      (HL),' '        ; Space at start
3711:	1952  F25719  	        JP      P,SPCFST        ; Positive - Space to start
3712:	1955  362D    	        LD      (HL),'-'        ; '-' sign at start
3713:	1957  23      	SPCFST: INC     HL              ; First byte of number
3714:	1958  3630    	        LD      (HL),'0'        ; '0' if zero
3715:	195A  CA0D1A  	        JP      Z,JSTZER        ; Return '0' if zero
3716:	195D  E5      	        PUSH    HL              ; Save buffer address
3717:	195E  FCCD17  	        CALL    M,INVSGN        ; Negate FPREG if negative
3718:	1961  AF      	        XOR     A               ; Zero A
3719:	1962  F5      	        PUSH    AF              ; Save it
3720:	1963  CD131A  	        CALL    RNGTST          ; Test number is in range
3721:	1966  014391  	SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
3722:	1969  11F84F  	        LD      DE,4FF8H
3723:	196C  CD1F18  	        CALL    CMPNUM          ; Compare numbers
3724:	196F  B7      	        OR      A
3725:	1970  E28419  	        JP      PO,INRNG        ; > 99999.9 - Sort it out
3726:	1973  F1      	        POP     AF              ; Restore count
3727:	1974  CD0119  	        CALL    MULTEN          ; Multiply by ten
3728:	1977  F5      	        PUSH    AF              ; Re-save count
3729:	1978  C36619  	        JP      SIXDIG          ; Test it again
3730:			
3731:	197B  CDEC16  	GTSIXD: CALL    DIV10           ; Divide by 10
3732:	197E  F1      	        POP     AF              ; Get count
3733:	197F  3C      	        INC     A               ; Count divides
3734:	1980  F5      	        PUSH    AF              ; Re-save count
3735:	1981  CD131A  	        CALL    RNGTST          ; Test number is in range
3736:	1984  CD4C15  	INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
3737:	1987  3C      	        INC     A
3738:	1988  CD4C18  	        CALL    FPINT           ; F.P to integer
3739:	198B  CDE517  	        CALL    FPBCDE          ; Move BCDE to FPREG
3740:	198E  010603  	        LD      BC,0306H        ; 1E+06 to 1E-03 range
3741:	1991  F1      	        POP     AF              ; Restore count
3742:	1992  81      	        ADD     A,C             ; 6 digits before point
3743:	1993  3C      	        INC     A               ; Add one
3744:	1994  FAA019  	        JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
3745:	1997  FE08    	        CP      6+1+1           ; More than 999999 ?
3746:	1999  D2A019  	        JP      NC,MAKNUM       ; Yes - Do it in 'E' form
3747:	199C  3C      	        INC     A               ; Adjust for exponent
3748:	199D  47      	        LD      B,A             ; Exponent of number
3749:	199E  3E02    	        LD      A,2             ; Make it zero after
3750:			
3751:	19A0  3D      	MAKNUM: DEC     A               ; Adjust for digits to do
3752:	19A1  3D      	        DEC     A
3753:	19A2  E1      	        POP     HL              ; Restore buffer address
3754:	19A3  F5      	        PUSH    AF              ; Save count
3755:	19A4  11261A  	        LD      DE,POWERS       ; Powers of ten
3756:	19A7  05      	        DEC     B               ; Count digits before point
3757:	19A8  C2B119  	        JP      NZ,DIGTXT       ; Not zero - Do number
3758:	19AB  362E    	        LD      (HL),'.'        ; Save point
3759:	19AD  23      	        INC     HL              ; Move on
3760:	19AE  3630    	        LD      (HL),'0'        ; Save zero
3761:	19B0  23      	        INC     HL              ; Move on
3762:	19B1  05      	DIGTXT: DEC     B               ; Count digits before point
3763:	19B2  362E    	        LD      (HL),'.'        ; Save point in case
3764:	19B4  CCFA17  	        CALL    Z,INCHL         ; Last digit - move on
3765:	19B7  C5      	        PUSH    BC              ; Save digits before point
3766:	19B8  E5      	        PUSH    HL              ; Save buffer address
3767:	19B9  D5      	        PUSH    DE              ; Save powers of ten
3768:	19BA  CDF017  	        CALL    BCDEFP          ; Move FPREG to BCDE
3769:	19BD  E1      	        POP     HL              ; Powers of ten table
3770:	19BE  062F    	        LD      B, '0'-1        ; ASCII '0' - 1
3771:	19C0  04      	TRYAGN: INC     B               ; Count subtractions
3772:	19C1  7B      	        LD      A,E             ; Get LSB
3773:	19C2  96      	        SUB     (HL)            ; Subtract LSB
3774:	19C3  5F      	        LD      E,A             ; Save LSB
3775:	19C4  23      	        INC     HL
3776:	19C5  7A      	        LD      A,D             ; Get NMSB
3777:	19C6  9E      	        SBC     A,(HL)          ; Subtract NMSB
3778:	19C7  57      	        LD      D,A             ; Save NMSB
3779:	19C8  23      	        INC     HL
3780:	19C9  79      	        LD      A,C             ; Get MSB
3781:	19CA  9E      	        SBC     A,(HL)          ; Subtract MSB
3782:	19CB  4F      	        LD      C,A             ; Save MSB
3783:	19CC  2B      	        DEC     HL              ; Point back to start
3784:	19CD  2B      	        DEC     HL
3785:	19CE  D2C019  	        JP      NC,TRYAGN       ; No overflow - Try again
3786:	19D1  CD0316  	        CALL    PLUCDE          ; Restore number
3787:	19D4  23      	        INC     HL              ; Start of next number
3788:	19D5  CDE517  	        CALL    FPBCDE          ; Move BCDE to FPREG
3789:	19D8  EB      	        EX      DE,HL           ; Save point in table
3790:	19D9  E1      	        POP     HL              ; Restore buffer address
3791:	19DA  70      	        LD      (HL),B          ; Save digit in buffer
3792:	19DB  23      	        INC     HL              ; And move on
3793:	19DC  C1      	        POP     BC              ; Restore digit count
3794:	19DD  0D      	        DEC     C               ; Count digits
3795:	19DE  C2B119  	        JP      NZ,DIGTXT       ; More - Do them
3796:	19E1  05      	        DEC     B               ; Any decimal part?
3797:	19E2  CAF119  	        JP      Z,DOEBIT        ; No - Do 'E' bit
3798:	19E5  2B      	SUPTLZ: DEC     HL              ; Move back through buffer
3799:	19E6  7E      	        LD      A,(HL)          ; Get character
3800:	19E7  FE30    	        CP      '0'             ; '0' character?
3801:	19E9  CAE519  	        JP      Z,SUPTLZ        ; Yes - Look back for more
3802:	19EC  FE2E    	        CP      '.'             ; A decimal point?
3803:	19EE  C4FA17  	        CALL    NZ,INCHL        ; Move back over digit
3804:			
3805:	19F1  F1      	DOEBIT: POP     AF              ; Get 'E' flag
3806:	19F2  CA101A  	        JP      Z,NOENED        ; No 'E' needed - End buffer
3807:	19F5  3645    	        LD      (HL),'E'        ; Put 'E' in buffer
3808:	19F7  23      	        INC     HL              ; And move on
3809:	19F8  362B    	        LD      (HL),'+'        ; Put '+' in buffer
3810:	19FA  F2011A  	        JP      P,OUTEXP        ; Positive - Output exponent
3811:	19FD  362D    	        LD      (HL),'-'        ; Put '-' in buffer
3812:	19FF  2F      	        CPL                     ; Negate exponent
3813:	1A00  3C      	        INC     A
3814:	1A01  062F    	OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
3815:	1A03  04      	EXPTEN: INC     B               ; Count subtractions
3816:	1A04  D60A    	        SUB     10              ; Tens digit
3817:	1A06  D2031A  	        JP      NC,EXPTEN       ; More to do
3818:	1A09  C63A    	        ADD     A,'0'+10        ; Restore and make ASCII
3819:	1A0B  23      	        INC     HL              ; Move on
3820:	1A0C  70      	        LD      (HL),B          ; Save MSB of exponent
3821:	1A0D  23      	JSTZER: INC     HL              ;
3822:	1A0E  77      	        LD      (HL),A          ; Save LSB of exponent
3823:	1A0F  23      	        INC     HL
3824:	1A10  71      	NOENED: LD      (HL),C          ; Mark end of buffer
3825:	1A11  E1      	        POP     HL              ; Restore code string address
3826:	1A12  C9      	        RET
3827:			
3828:	1A13  017494  	RNGTST: LD      BC,9474H        ; BCDE = 999999.
3829:	1A16  11F723  	        LD      DE,23F7H
3830:	1A19  CD1F18  	        CALL    CMPNUM          ; Compare numbers
3831:	1A1C  B7      	        OR      A
3832:	1A1D  E1      	        POP     HL              ; Return address to HL
3833:	1A1E  E27B19  	        JP      PO,GTSIXD       ; Too big - Divide by ten
3834:	1A21  E9      	        JP      (HL)            ; Otherwise return to caller
3835:			
3836:	1A22  00000080	HALF:   .DB     00H,00H,00H,80H ; 0.5
3837:			
3838:	1A26  A08601  	POWERS: .DB     0A0H,086H,001H  ; 100000
3839:	1A29  102700  	        .DB     010H,027H,000H  ;  10000
3840:	1A2C  E80300  	        .DB     0E8H,003H,000H  ;   1000
3841:	1A2F  640000  	        .DB     064H,000H,000H  ;    100
3842:	1A32  0A0000  	        .DB     00AH,000H,000H  ;     10
3843:	1A35  010000  	        .DB     001H,000H,000H  ;      1
3844:			
3845:	1A38  21CD17  	NEGAFT: LD      HL,INVSGN       ; Negate result
3846:	1A3B  E3      	        EX      (SP),HL         ; To be done after caller
3847:	1A3C  E9      	        JP      (HL)            ; Return to caller
3848:			
3849:	1A3D  CDD517  	SQR:    CALL    STAKFP          ; Put value on stack
3850:	1A40  21221A  	        LD      HL,HALF         ; Set power to 1/2
3851:	1A43  CDE217  	        CALL    PHLTFP          ; Move 1/2 to FPREG
3852:			
3853:	1A46  C1      	POWER:  POP     BC              ; Get base
3854:	1A47  D1      	        POP     DE
3855:	1A48  CDA417  	        CALL    TSTSGN          ; Test sign of power
3856:	1A4B  78      	        LD      A,B             ; Get exponent of base
3857:	1A4C  CA8B1A  	        JP      Z,EXP           ; Make result 1 if zero
3858:	1A4F  F2561A  	        JP      P,POWER1        ; Positive base - Ok
3859:	1A52  B7      	        OR      A               ; Zero to negative power?
3860:	1A53  CA0005  	        JP      Z,DZERR         ; Yes - ?/0 Error
3861:	1A56  B7      	POWER1: OR      A               ; Base zero?
3862:	1A57  CAC515  	        JP      Z,SAVEXP        ; Yes - Return zero
3863:	1A5A  D5      	        PUSH    DE              ; Save base
3864:	1A5B  C5      	        PUSH    BC
3865:	1A5C  79      	        LD      A,C             ; Get MSB of base
3866:	1A5D  F67F    	        OR      01111111B       ; Get sign status
3867:	1A5F  CDF017  	        CALL    BCDEFP          ; Move power to BCDE
3868:	1A62  F2731A  	        JP      P,POWER2        ; Positive base - Ok
3869:	1A65  D5      	        PUSH    DE              ; Save power
3870:	1A66  C5      	        PUSH    BC
3871:	1A67  CD7718  	        CALL    INT             ; Get integer of power
3872:	1A6A  C1      	        POP     BC              ; Restore power
3873:	1A6B  D1      	        POP     DE
3874:	1A6C  F5      	        PUSH    AF              ; MSB of base
3875:	1A6D  CD1F18  	        CALL    CMPNUM          ; Power an integer?
3876:	1A70  E1      	        POP     HL              ; Restore MSB of base
3877:	1A71  7C      	        LD      A,H             ; but don't affect flags
3878:	1A72  1F      	        RRA                     ; Exponent odd or even?
3879:	1A73  E1      	POWER2: POP     HL              ; Restore MSB and exponent
3880:	1A74  222B21  	        LD      (FPREG+2),HL    ; Save base in FPREG
3881:	1A77  E1      	        POP     HL              ; LSBs of base
3882:	1A78  222921  	        LD      (FPREG),HL      ; Save in FPREG
3883:	1A7B  DC381A  	        CALL    C,NEGAFT        ; Odd power - Negate result
3884:	1A7E  CCCD17  	        CALL    Z,INVSGN        ; Negative base - Negate it
3885:	1A81  D5      	        PUSH    DE              ; Save power
3886:	1A82  C5      	        PUSH    BC
3887:	1A83  CD5816  	        CALL    LOG             ; Get LOG of base
3888:	1A86  C1      	        POP     BC              ; Restore power
3889:	1A87  D1      	        POP     DE
3890:	1A88  CD9916  	        CALL    FPMULT          ; Multiply LOG by power
3891:			
3892:	1A8B  CDD517  	EXP:    CALL    STAKFP          ; Put value on stack
3893:	1A8E  013881  	        LD      BC,08138H       ; BCDE = 1/Ln(2)
3894:	1A91  113BAA  	        LD      DE,0AA3BH
3895:	1A94  CD9916  	        CALL    FPMULT          ; Multiply value by 1/LN(2)
3896:	1A97  3A2C21  	        LD      A,(FPEXP)       ; Get exponent
3897:	1A9A  FE88    	        CP      80H+8           ; Is it in range?
3898:	1A9C  D28017  	        JP      NC,OVTST1       ; No - Test for overflow
3899:	1A9F  CD7718  	        CALL    INT             ; Get INT of FPREG
3900:	1AA2  C680    	        ADD     A,80H           ; For excess 128
3901:	1AA4  C602    	        ADD     A,2             ; Exponent > 126?
3902:	1AA6  DA8017  	        JP      C,OVTST1        ; Yes - Test for overflow
3903:	1AA9  F5      	        PUSH    AF              ; Save scaling factor
3904:	1AAA  214716  	        LD      HL,UNITY        ; Point to 1.
3905:	1AAD  CD4F15  	        CALL    ADDPHL          ; Add 1 to FPREG
3906:	1AB0  CD9016  	        CALL    MULLN2          ; Multiply by LN(2)
3907:	1AB3  F1      	        POP     AF              ; Restore scaling factor
3908:	1AB4  C1      	        POP     BC              ; Restore exponent
3909:	1AB5  D1      	        POP     DE
3910:	1AB6  F5      	        PUSH    AF              ; Save scaling factor
3911:	1AB7  CD5B15  	        CALL    SUBCDE          ; Subtract exponent from FPREG
3912:	1ABA  CDCD17  	        CALL    INVSGN          ; Negate result
3913:	1ABD  21CB1A  	        LD      HL,EXPTAB       ; Coefficient table
3914:	1AC0  CDFB1A  	        CALL    SMSER1          ; Sum the series
3915:	1AC3  110000  	        LD      DE,0            ; Zero LSBs
3916:	1AC6  C1      	        POP     BC              ; Scaling factor
3917:	1AC7  4A      	        LD      C,D             ; Zero MSB
3918:	1AC8  C39916  	        JP      FPMULT          ; Scale result to correct value
3919:			
3920:	1ACB  08      	EXPTAB: .DB     8                       ; Table used by EXP
3921:	1ACC  402E9474	        .DB     040H,02EH,094H,074H     ; -1/7! (-1/5040)
3922:	1AD0  704F2E77	        .DB     070H,04FH,02EH,077H     ;  1/6! ( 1/720)
3923:	1AD4  6E02887A	        .DB     06EH,002H,088H,07AH     ; -1/5! (-1/120)
3924:	1AD8  E6A02A7C	        .DB     0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
3925:	1ADC  50AAAA7E	        .DB     050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
3926:	1AE0  FFFF7F7F	        .DB     0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
3927:	1AE4  00008081	        .DB     000H,000H,080H,081H     ; -1/1! (-1/1)
3928:	1AE8  00000081	        .DB     000H,000H,000H,081H     ;  1/0! ( 1/1)
3929:			
3930:	1AEC  CDD517  	SUMSER: CALL    STAKFP          ; Put FPREG on stack
3931:	1AEF  119716  	        LD      DE,MULT         ; Multiply by "X"
3932:	1AF2  D5      	        PUSH    DE              ; To be done after
3933:	1AF3  E5      	        PUSH    HL              ; Save address of table
3934:	1AF4  CDF017  	        CALL    BCDEFP          ; Move FPREG to BCDE
3935:	1AF7  CD9916  	        CALL    FPMULT          ; Square the value
3936:	1AFA  E1      	        POP     HL              ; Restore address of table
3937:	1AFB  CDD517  	SMSER1: CALL    STAKFP          ; Put value on stack
3938:	1AFE  7E      	        LD      A,(HL)          ; Get number of coefficients
3939:	1AFF  23      	        INC     HL              ; Point to start of table
3940:	1B00  CDE217  	        CALL    PHLTFP          ; Move coefficient to FPREG
3941:	1B03  06      	        .DB     06H             ; Skip "POP AF"
3942:	1B04  F1      	SUMLP:  POP     AF              ; Restore count
3943:	1B05  C1      	        POP     BC              ; Restore number
3944:	1B06  D1      	        POP     DE
3945:	1B07  3D      	        DEC     A               ; Cont coefficients
3946:	1B08  C8      	        RET     Z               ; All done
3947:	1B09  D5      	        PUSH    DE              ; Save number
3948:	1B0A  C5      	        PUSH    BC
3949:	1B0B  F5      	        PUSH    AF              ; Save count
3950:	1B0C  E5      	        PUSH    HL              ; Save address in table
3951:	1B0D  CD9916  	        CALL    FPMULT          ; Multiply FPREG by BCDE
3952:	1B10  E1      	        POP     HL              ; Restore address in table
3953:	1B11  CDF317  	        CALL    LOADFP          ; Number at HL to BCDE
3954:	1B14  E5      	        PUSH    HL              ; Save address in table
3955:	1B15  CD5E15  	        CALL    FPADD           ; Add coefficient to FPREG
3956:	1B18  E1      	        POP     HL              ; Restore address in table
3957:	1B19  C3041B  	        JP      SUMLP           ; More coefficients
3958:			
3959:	1B1C  CDA417  	RND:    CALL    TSTSGN          ; Test sign of FPREG
3960:	1B1F  215E20  	        LD      HL,SEED+2       ; Random number seed
3961:	1B22  FA7D1B  	        JP      M,RESEED        ; Negative - Re-seed
3962:	1B25  217F20  	        LD      HL,LSTRND       ; Last random number
3963:	1B28  CDE217  	        CALL    PHLTFP          ; Move last RND to FPREG
3964:	1B2B  215E20  	        LD      HL,SEED+2       ; Random number seed
3965:	1B2E  C8      	        RET     Z               ; Return if RND(0)
3966:	1B2F  86      	        ADD     A,(HL)          ; Add (SEED)+2)
3967:	1B30  E607    	        AND     00000111B       ; 0 to 7
3968:	1B32  0600    	        LD      B,0
3969:	1B34  77      	        LD      (HL),A          ; Re-save seed
3970:	1B35  23      	        INC     HL              ; Move to coefficient table
3971:	1B36  87      	        ADD     A,A             ; 4 bytes
3972:	1B37  87      	        ADD     A,A             ; per entry
3973:	1B38  4F      	        LD      C,A             ; BC = Offset into table
3974:	1B39  09      	        ADD     HL,BC           ; Point to coefficient
3975:	1B3A  CDF317  	        CALL    LOADFP          ; Coefficient to BCDE
3976:	1B3D  CD9916  	        CALL    FPMULT  ;       ; Multiply FPREG by coefficient
3977:	1B40  3A5D20  	        LD      A,(SEED+1)      ; Get (SEED+1)
3978:	1B43  3C      	        INC     A               ; Add 1
3979:	1B44  E603    	        AND     00000011B       ; 0 to 3
3980:	1B46  0600    	        LD      B,0
3981:	1B48  FE01    	        CP      1               ; Is it zero?
3982:	1B4A  88      	        ADC     A,B             ; Yes - Make it 1
3983:	1B4B  325D20  	        LD      (SEED+1),A      ; Re-save seed
3984:	1B4E  21811B  	        LD      HL,RNDTAB-4     ; Addition table
3985:	1B51  87      	        ADD     A,A             ; 4 bytes
3986:	1B52  87      	        ADD     A,A             ; per entry
3987:	1B53  4F      	        LD      C,A             ; BC = Offset into table
3988:	1B54  09      	        ADD     HL,BC           ; Point to value
3989:	1B55  CD4F15  	        CALL    ADDPHL          ; Add value to FPREG
3990:	1B58  CDF017  	RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
3991:	1B5B  7B      	        LD      A,E             ; Get LSB
3992:	1B5C  59      	        LD      E,C             ; LSB = MSB
3993:	1B5D  EE4F    	        XOR     01001111B       ; Fiddle around
3994:	1B5F  4F      	        LD      C,A             ; New MSB
3995:	1B60  3680    	        LD      (HL),80H        ; Set exponent
3996:	1B62  2B      	        DEC     HL              ; Point to MSB
3997:	1B63  46      	        LD      B,(HL)          ; Get MSB
3998:	1B64  3680    	        LD      (HL),80H        ; Make value -0.5
3999:	1B66  215C20  	        LD      HL,SEED         ; Random number seed
4000:	1B69  34      	        INC     (HL)            ; Count seed
4001:	1B6A  7E      	        LD      A,(HL)          ; Get seed
4002:	1B6B  D6AB    	        SUB     171             ; Do it modulo 171
4003:	1B6D  C2741B  	        JP      NZ,RND2         ; Non-zero - Ok
4004:	1B70  77      	        LD      (HL),A          ; Zero seed
4005:	1B71  0C      	        INC     C               ; Fillde about
4006:	1B72  15      	        DEC     D               ; with the
4007:	1B73  1C      	        INC     E               ; number
4008:	1B74  CDAF15  	RND2:   CALL    BNORM           ; Normalise number
4009:	1B77  217F20  	        LD      HL,LSTRND       ; Save random number
4010:	1B7A  C3FC17  	        JP      FPTHL           ; Move FPREG to last and return
4011:			
4012:	1B7D  77      	RESEED: LD      (HL),A          ; Re-seed random numbers
4013:	1B7E  2B      	        DEC     HL
4014:	1B7F  77      	        LD      (HL),A
4015:	1B80  2B      	        DEC     HL
4016:	1B81  77      	        LD      (HL),A
4017:	1B82  C3581B  	        JP      RND1            ; Return RND seed
4018:			
4019:	1B85  68B14668	RNDTAB: .DB  068H,0B1H,046H,068H     ; Table used by RND
4020:	1B89  99E99269	        .DB  099H,0E9H,092H,069H
4021:	1B8D  10D17568	        .DB  010H,0D1H,075H,068H
4022:			
4023:	1B91  21DB1B  	COS:    LD      HL,HALFPI       ; Point to PI/2
4024:	1B94  CD4F15  	        CALL    ADDPHL          ; Add it to PPREG
4025:	1B97  CDD517  	SIN:    CALL    STAKFP          ; Put angle on stack
4026:	1B9A  014983  	        LD      BC,8349H        ; BCDE = 2 PI
4027:	1B9D  11DB0F  	        LD      DE,0FDBH
4028:	1BA0  CDE517  	        CALL    FPBCDE          ; Move 2 PI to FPREG
4029:	1BA3  C1      	        POP     BC              ; Restore angle
4030:	1BA4  D1      	        POP     DE
4031:	1BA5  CDFA16  	        CALL    DVBCDE          ; Divide angle by 2 PI
4032:	1BA8  CDD517  	        CALL    STAKFP          ; Put it on stack
4033:	1BAB  CD7718  	        CALL    INT             ; Get INT of result
4034:	1BAE  C1      	        POP     BC              ; Restore number
4035:	1BAF  D1      	        POP     DE
4036:	1BB0  CD5B15  	        CALL    SUBCDE          ; Make it 0 <= value < 1
4037:	1BB3  21DF1B  	        LD      HL,QUARTR       ; Point to 0.25
4038:	1BB6  CD5515  	        CALL    SUBPHL          ; Subtract value from 0.25
4039:	1BB9  CDA417  	        CALL    TSTSGN          ; Test sign of value
4040:	1BBC  37      	        SCF                     ; Flag positive
4041:	1BBD  F2C71B  	        JP      P,SIN1          ; Positive - Ok
4042:	1BC0  CD4C15  	        CALL    ROUND           ; Add 0.5 to value
4043:	1BC3  CDA417  	        CALL    TSTSGN          ; Test sign of value
4044:	1BC6  B7      	        OR      A               ; Flag negative
4045:	1BC7  F5      	SIN1:   PUSH    AF              ; Save sign
4046:	1BC8  F4CD17  	        CALL    P,INVSGN        ; Negate value if positive
4047:	1BCB  21DF1B  	        LD      HL,QUARTR       ; Point to 0.25
4048:	1BCE  CD4F15  	        CALL    ADDPHL          ; Add 0.25 to value
4049:	1BD1  F1      	        POP     AF              ; Restore sign
4050:	1BD2  D4CD17  	        CALL    NC,INVSGN       ; Negative - Make positive
4051:	1BD5  21E31B  	        LD      HL,SINTAB       ; Coefficient table
4052:	1BD8  C3EC1A  	        JP      SUMSER          ; Evaluate sum of series
4053:			
4054:	1BDB  DB0F4981	HALFPI: .DB  0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
4055:			
4056:	1BDF  0000007F	QUARTR: .DB  000H,000H,000H,07FH     ; 0.25
4057:			
4058:	1BE3  05      	SINTAB: .DB  5                       ; Table used by SIN
4059:	1BE4  BAD71E86	        .DB  0BAH,0D7H,01EH,086H     ; 39.711
4060:	1BE8  64269987	        .DB  064H,026H,099H,087H     ;-76.575
4061:	1BEC  58342387	        .DB  058H,034H,023H,087H     ; 81.602
4062:	1BF0  E05DA586	        .DB  0E0H,05DH,0A5H,086H     ;-41.342
4063:	1BF4  DA0F4983	        .DB  0DAH,00FH,049H,083H     ;  6.2832
4064:			
4065:	1BF8  CDD517  	TAN:    CALL    STAKFP          ; Put angle on stack
4066:	1BFB  CD971B  	        CALL    SIN             ; Get SIN of angle
4067:	1BFE  C1      	        POP     BC              ; Restore angle
4068:	1BFF  E1      	        POP     HL
4069:	1C00  CDD517  	        CALL    STAKFP          ; Save SIN of angle
4070:	1C03  EB      	        EX      DE,HL           ; BCDE = Angle
4071:	1C04  CDE517  	        CALL    FPBCDE          ; Angle to FPREG
4072:	1C07  CD911B  	        CALL    COS             ; Get COS of angle
4073:	1C0A  C3F816  	        JP      DIV             ; TAN = SIN / COS
4074:			
4075:	1C0D  CDA417  	ATN:    CALL    TSTSGN          ; Test sign of value
4076:	1C10  FC381A  	        CALL    M,NEGAFT        ; Negate result after if -ve
4077:	1C13  FCCD17  	        CALL    M,INVSGN        ; Negate value if -ve
4078:	1C16  3A2C21  	        LD      A,(FPEXP)       ; Get exponent
4079:	1C19  FE81    	        CP      81H             ; Number less than 1?
4080:	1C1B  DA2A1C  	        JP      C,ATN1          ; Yes - Get arc tangnt
4081:	1C1E  010081  	        LD      BC,8100H        ; BCDE = 1
4082:	1C21  51      	        LD      D,C
4083:	1C22  59      	        LD      E,C
4084:	1C23  CDFA16  	        CALL    DVBCDE          ; Get reciprocal of number
4085:	1C26  215515  	        LD      HL,SUBPHL       ; Sub angle from PI/2
4086:	1C29  E5      	        PUSH    HL              ; Save for angle > 1
4087:	1C2A  21341C  	ATN1:   LD      HL,ATNTAB       ; Coefficient table
4088:	1C2D  CDEC1A  	        CALL    SUMSER          ; Evaluate sum of series
4089:	1C30  21DB1B  	        LD      HL,HALFPI       ; PI/2 - angle in case > 1
4090:	1C33  C9      	        RET                     ; Number > 1 - Sub from PI/2
4091:			
4092:	1C34  09      	ATNTAB: .DB  9                       ; Table used by ATN
4093:	1C35  4AD73B78	        .DB  04AH,0D7H,03BH,078H     ; 1/17
4094:	1C39  026E847B	        .DB  002H,06EH,084H,07BH     ;-1/15
4095:	1C3D  FEC12F7C	        .DB  0FEH,0C1H,02FH,07CH     ; 1/13
4096:	1C41  74319A7D	        .DB  074H,031H,09AH,07DH     ;-1/11
4097:	1C45  843D5A7D	        .DB  084H,03DH,05AH,07DH     ; 1/9
4098:	1C49  C87F917E	        .DB  0C8H,07FH,091H,07EH     ;-1/7
4099:	1C4D  E4BB4C7E	        .DB  0E4H,0BBH,04CH,07EH     ; 1/5
4100:	1C51  6CAAAA7F	        .DB  06CH,0AAH,0AAH,07FH     ;-1/3
4101:	1C55  00000081	        .DB  000H,000H,000H,081H     ; 1/1
4102:			
4103:			
4104:	1C59  C9      	ARET:   RET                     ; A RETurn instruction
4105:			
4106:	1C5A  D7      	GETINP: RST     10H             ;input a character
4107:	1C5B  C9      	        RET
4108:			
4109:	1C5C          	CLS: 
4110:	1C5C  3E0C    	        LD      A,CS            ; ASCII Clear screen
4111:	1C5E  C3961D  	        JP      MONOUT          ; Output character
4112:			
4113:	1C61  CD2315  	WIDTH:  CALL    GETINT          ; Get integer 0-255
4114:	1C64  7B      	        LD      A,E             ; Width to A
4115:	1C65  328720  	        LD      (LWIDTH),A      ; Set width
4116:	1C68  C9      	        RET
4117:			
4118:	1C69  CDC20D  	LINES:  CALL    GETNUM          ; Get a number
4119:	1C6C  CD070A  	        CALL    DEINT           ; Get integer -32768 to 32767
4120:	1C6F  ED538B20	        LD      (LINESC),DE     ; Set lines counter
4121:	1C73  ED538D20	        LD      (LINESN),DE     ; Set lines number
4122:	1C77  C9      	        RET
4123:			
4124:	1C78  CD070A  	DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
4125:	1C7B  D5      	        PUSH    DE              ; Save number
4126:	1C7C  E1      	        POP     HL              ; Number to HL
4127:	1C7D  46      	        LD      B,(HL)          ; Get LSB of contents
4128:	1C7E  23      	        INC     HL
4129:	1C7F  7E      	        LD      A,(HL)          ; Get MSB of contents
4130:	1C80  C37D11  	        JP      ABPASS          ; Return integer AB
4131:			
4132:	1C83  CDC20D  	DOKE:   CALL    GETNUM          ; Get a number
4133:	1C86  CD070A  	        CALL    DEINT           ; Get integer -32768 to 32767
4134:	1C89  D5      	        PUSH    DE              ; Save address
4135:	1C8A  CDCB07  	        CALL    CHKSYN          ; Make sure ',' follows
4136:	1C8D  2C      	        .DB     ','
4137:	1C8E  CDC20D  	        CALL    GETNUM          ; Get a number
4138:	1C91  CD070A  	        CALL    DEINT           ; Get integer -32768 to 32767
4139:	1C94  E3      	        EX      (SP),HL         ; Save value,get address
4140:	1C95  73      	        LD      (HL),E          ; Save LSB of value
4141:	1C96  23      	        INC     HL
4142:	1C97  72      	        LD      (HL),D          ; Save MSB of value
4143:	1C98  E1      	        POP     HL              ; Restore code string address
4144:	1C99  C9      	        RET
4145:			
4146:			
4147:			; HEX$(nn) Convert 16 bit number to Hexadecimal string
4148:			
4149:	1C9A  CDC50D  	HEX:    CALL    TSTNUM          ; Verify it's a number
4150:	1C9D  CD070A  	        CALL    DEINT           ; Get integer -32768 to 32767
4151:	1CA0  C5      	        PUSH    BC              ; Save contents of BC
4152:	1CA1  212E21  	        LD      HL,PBUFF
4153:	1CA4  7A      	        LD      A,D             ; Get high order into A
4154:	1CA5  FE00    	        CP      0H
4155:	1CA7  280C    	        JR      Z,HEX2          ; Skip output if both high digits are zero
4156:	1CA9  CDD21C  	        CALL    BYT2ASC         ; Convert D to ASCII
4157:	1CAC  78      	        LD      A,B
4158:	1CAD  FE30    	        CP      '0'
4159:	1CAF  2802    	        JR      Z,HEX1          ; Don't store high digit if zero
4160:	1CB1  70      	        LD      (HL),B          ; Store it to PBUFF
4161:	1CB2  23      	        INC     HL              ; Next location
4162:	1CB3  71      	HEX1:   LD      (HL),C          ; Store C to PBUFF+1
4163:	1CB4  23      	        INC     HL              ; Next location
4164:	1CB5  7B      	HEX2:   LD      A,E             ; Get lower byte
4165:	1CB6  CDD21C  	        CALL    BYT2ASC         ; Convert E to ASCII
4166:	1CB9  7A      	        LD      A,D
4167:	1CBA  FE00    	        CP      0H
4168:	1CBC  2005    	        JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
4169:	1CBE  78      	        LD      A,B
4170:	1CBF  FE30    	        CP      '0'             ; If high digit of lower byte is zero then don't print
4171:	1CC1  2802    	        JR      Z,HEX4
4172:	1CC3  70      	HEX3:   LD      (HL),B          ; to PBUFF+2
4173:	1CC4  23      	        INC     HL              ; Next location
4174:	1CC5  71      	HEX4:   LD      (HL),C          ; to PBUFF+3
4175:	1CC6  23      	        INC     HL              ; PBUFF+4 to zero
4176:	1CC7  AF      	        XOR     A               ; Terminating character
4177:	1CC8  77      	        LD      (HL),A          ; Store zero to terminate
4178:	1CC9  23      	        INC     HL              ; Make sure PBUFF is terminated
4179:	1CCA  77      	        LD      (HL),A          ; Store the double zero there
4180:	1CCB  C1      	        POP     BC              ; Get BC back
4181:	1CCC  212E21  	        LD      HL,PBUFF        ; Reset to start of PBUFF
4182:	1CCF  C32B12  	        JP      STR1            ; Convert the PBUFF to a string and return it
4183:			
4184:	1CD2  47      	BYT2ASC LD      B,A             ; Save original value
4185:	1CD3  E60F    	        AND     0FH             ; Strip off upper nybble
4186:	1CD5  FE0A    	        CP      0AH             ; 0-9?
4187:	1CD7  3802    	        JR      C,ADD30         ; If A-F, add 7 more
4188:	1CD9  C607    	        ADD     A,07H           ; Bring value up to ASCII A-F
4189:	1CDB  C630    	ADD30   ADD     A,30H           ; And make ASCII
4190:	1CDD  4F      	        LD      C,A             ; Save converted char to C
4191:	1CDE  78      	        LD      A,B             ; Retrieve original value
4192:	1CDF  0F      	        RRCA                    ; and Rotate it right
4193:	1CE0  0F      	        RRCA
4194:	1CE1  0F      	        RRCA
4195:	1CE2  0F      	        RRCA
4196:	1CE3  E60F    	        AND     0FH             ; Mask off upper nybble
4197:	1CE5  FE0A    	        CP      0AH             ; 0-9? < A hex?
4198:	1CE7  3802    	        JR      C,ADD301        ; Skip Add 7
4199:	1CE9  C607    	        ADD     A,07H           ; Bring it up to ASCII A-F
4200:	1CEB  C630    	ADD301  ADD     A,30H           ; And make it full ASCII
4201:	1CED  47      	        LD      B,A             ; Store high order byte
4202:	1CEE  C9      	        RET
4203:			
4204:			; Convert "&Hnnnn" to FPREG
4205:			; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
4206:			; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
4207:	1CEF  EB      	HEXTFP  EX      DE,HL           ; Move code string pointer to DE
4208:	1CF0  210000  	        LD      HL,0000H        ; Zero out the value
4209:	1CF3  CD081D  	        CALL    GETHEX          ; Check the number for valid hex
4210:	1CF6  DA281D  	        JP      C,HXERR         ; First value wasn't hex, HX error
4211:	1CF9  1805    	        JR      HEXLP1          ; Convert first character
4212:	1CFB  CD081D  	HEXLP   CALL    GETHEX          ; Get second and addtional characters
4213:	1CFE  381F    	        JR      C,HEXIT         ; Exit if not a hex character
4214:	1D00  29      	HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
4215:	1D01  29      	        ADD     HL,HL
4216:	1D02  29      	        ADD     HL,HL
4217:	1D03  29      	        ADD     HL,HL
4218:	1D04  B5      	        OR      L               ; Add in D0-D3 into L
4219:	1D05  6F      	        LD      L,A             ; Save new value
4220:	1D06  18F3    	        JR      HEXLP           ; And continue until all hex characters are in
4221:			
4222:	1D08  13      	GETHEX  INC     DE              ; Next location
4223:	1D09  1A      	        LD      A,(DE)          ; Load character at pointer
4224:	1D0A  FE20    	        CP      ' '
4225:	1D0C  CA081D  	        JP      Z,GETHEX        ; Skip spaces
4226:	1D0F  D630    	        SUB     30H             ; Get absolute value
4227:	1D11  D8      	        RET     C               ; < "0", error
4228:	1D12  FE0A    	        CP      0AH
4229:	1D14  3805    	        JR      C,NOSUB7        ; Is already in the range 0-9
4230:	1D16  D607    	        SUB     07H             ; Reduce to A-F
4231:	1D18  FE0A    	        CP      0AH             ; Value should be $0A-$0F at this point
4232:	1D1A  D8      	        RET     C               ; CY set if was :            ; < = > ? @
4233:	1D1B  FE10    	NOSUB7  CP      10H             ; > Greater than "F"?
4234:	1D1D  3F      	        CCF
4235:	1D1E  C9      	        RET                     ; CY set if it wasn't valid hex
4236:			
4237:	1D1F  EB      	HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
4238:	1D20  7A      	        LD      A,D             ; Load DE into AC
4239:	1D21  4B      	        LD      C,E             ; For prep to 
4240:	1D22  E5      	        PUSH    HL
4241:	1D23  CD7C11  	        CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4242:	1D26  E1      	        POP     HL
4243:	1D27  C9      	        RET
4244:			
4245:	1D28  1E26    	HXERR:  LD      E,HE            ; ?HEX Error
4246:	1D2A  C31105  	        JP      ERROR
4247:			
4248:			; BIN$(NN) Convert integer to a 1-16 char binary string
4249:	1D2D  CDC50D  	BIN:    CALL    TSTNUM          ; Verify it's a number
4250:	1D30  CD070A  	        CALL    DEINT           ; Get integer -32768 to 32767
4251:	1D33  C5      	BIN2:   PUSH    BC              ; Save contents of BC
4252:	1D34  212E21  	        LD      HL,PBUFF
4253:	1D37  0611    	        LD      B,17            ; One higher than max char count
4254:	1D39          	ZEROSUP:                        ; Suppress leading zeros
4255:	1D39  05      	        DEC     B               ; Max 16 chars
4256:	1D3A  78      	        LD      A,B
4257:	1D3B  FE01    	        CP      01H
4258:	1D3D  2808    	        JR      Z,BITOUT        ; Always output at least one character
4259:	1D3F  CB13    	        RL      E
4260:	1D41  CB12    	        RL      D
4261:	1D43  30F4    	        JR      NC,ZEROSUP
4262:	1D45  1804    	        JR      BITOUT2
4263:	1D47          	BITOUT:
4264:	1D47  CB13    	        RL      E
4265:	1D49  CB12    	        RL      D               ; Top bit now in carry
4266:	1D4B          	BITOUT2:
4267:	1D4B  3E30    	        LD      A,'0'           ; Char for '0'
4268:	1D4D  CE00    	        ADC     A,0             ; If carry set then '0' --> '1'
4269:	1D4F  77      	        LD      (HL),A
4270:	1D50  23      	        INC     HL
4271:	1D51  05      	        DEC     B
4272:	1D52  20F3    	        JR      NZ,BITOUT
4273:	1D54  AF      	        XOR     A               ; Terminating character
4274:	1D55  77      	        LD      (HL),A          ; Store zero to terminate
4275:	1D56  23      	        INC     HL              ; Make sure PBUFF is terminated
4276:	1D57  77      	        LD      (HL),A          ; Store the double zero there
4277:	1D58  C1      	        POP     BC
4278:	1D59  212E21  	        LD      HL,PBUFF
4279:	1D5C  C32B12  	        JP      STR1
4280:			
4281:			; Convert "&Bnnnn" to FPREG
4282:			; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
4283:	1D5F  EB      	BINTFP: EX      DE,HL           ; Move code string pointer to DE
4284:	1D60  210000  	        LD      HL,0000H        ; Zero out the value
4285:	1D63  CD7C1D  	        CALL    CHKBIN          ; Check the number for valid bin
4286:	1D66  DA8A1D  	        JP      C,BINERR        ; First value wasn't bin, HX error
4287:	1D69  D630    	BINIT:  SUB     '0'
4288:	1D6B  29      	        ADD     HL,HL           ; Rotate HL left
4289:	1D6C  B5      	        OR      L
4290:	1D6D  6F      	        LD      L,A
4291:	1D6E  CD7C1D  	        CALL    CHKBIN          ; Get second and addtional characters
4292:	1D71  30F6    	        JR      NC,BINIT        ; Process if a bin character
4293:	1D73  EB      	        EX      DE,HL           ; Value into DE, Code string into HL
4294:	1D74  7A      	        LD      A,D             ; Load DE into AC
4295:	1D75  4B      	        LD      C,E             ; For prep to 
4296:	1D76  E5      	        PUSH    HL
4297:	1D77  CD7C11  	        CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4298:	1D7A  E1      	        POP     HL
4299:	1D7B  C9      	        RET
4300:			
4301:			; Char is in A, NC if char is 0 or 1
4302:	1D7C  13      	CHKBIN: INC     DE
4303:	1D7D  1A      	        LD      A,(DE)
4304:	1D7E  FE20    	        CP      ' '
4305:	1D80  CA7C1D  	        JP      Z,CHKBIN        ; Skip spaces
4306:	1D83  FE30    	        CP      '0'             ; Set C if < '0'
4307:	1D85  D8      	        RET     C
4308:	1D86  FE32    	        CP      '2'
4309:	1D88  3F      	        CCF                     ; Set C if > '1'
4310:	1D89  C9      	        RET
4311:			
4312:	1D8A  1E28    	BINERR: LD      E,BN            ; ?BIN Error
4313:	1D8C  C31105  	        JP      ERROR
4314:			
4315:			
4316:	1D8F  DD21FFFF	JJUMP1: LD      IX,-1           ; Flag cold start
4317:	1D93  C36101  	        JP      CSTART          ; Go and initialise
4318:			
4319:	1D96  C30800  	MONOUT: JP      0008H           ; output a char
4320:			
4321:			
4322:	1D99  76      	MONITR: HALT
4323:			        ;JP      0000H           ; Restart (Normally Monitor Start)
4324:			
4325:			
4326:	1D9A  3E00    	INITST: LD      A,0             ; Clear break flag
4327:	1D9C  329220  	        LD      (BRKFLG),A
4328:	1D9F  C36801  	        JP      INIT
4329:			
4330:	1DA2  ED45    	ARETN:  RETN                    ; Return from NMI
4331:			
4332:			
4333:	1DA4  F5      	TSTBIT: PUSH    AF              ; Save bit mask
4334:	1DA5  A0      	        AND     B               ; Get common bits
4335:	1DA6  C1      	        POP     BC              ; Restore bit mask
4336:	1DA7  B8      	        CP      B               ; Same bit set?
4337:	1DA8  3E00    	        LD      A,0             ; Return 0 in A
4338:	1DAA  C9      	        RET
4339:			
4340:	1DAB  CDD607  	OUTNCR: CALL    OUTC            ; Output character in A
4341:	1DAE  C3FD0B  	        JP      PRNTCRLF        ; Output CRLF
4342:			
4343:	1DB1          	.end



Statistics:

     4	passes
     0	jr promotions
   636	symbols
  7265	bytes



Symbol Table:

ABPASS          117D      4477
ABS             17C9      6089
ACCSUM           9E6      2534
ACPASS          117C      4476
ADD30           1CDB      7387
ADD301          1CEB      7403
ADDEXP          1762      5986
ADDIG           1908      6408
ADDPHL          154F      5455
ALLFOL          144B      5195
ANTVLU           CE6      3302
ARET            1C59      7257
ARETN           1DA2      7586
ARLDSV          109D      4253
ARREND         =211F      8479
ARRLP           1316      4886
ASC             141C      5148
ASCTFP          18AB      6315
ASPCS            C48      3144
ATN             1C0D      7181
ATN1            1C2A      7210
ATNTAB          1C34      7220
ATOH             A21      2593
BADINP           C6D      3181
BAKSTK           4A6      1190
BAKTMP          13FC      5116
BASTXT         =20A3      8355
BCDEFP          17F0      6128
BFREE            1FD      509
BIN             1D2D      7469
BIN2            1D33      7475
BINERR          1D8A      7562
BINIT           1D69      7529
BINTFP          1D5F      7519
BITOUT          1D47      7495
BITOUT2         1D4B      7499
BKSP           =08        8
BN             =28        40
BNORM           15AF      5551
BNRMLP          15B2      5554
BRK              998      2456
BRKFLG         =2092      8338
BRKLIN         =2113      8467
BRKMSG           4A0      1184
BRKRET           1F7      503
BS             =10        16
BSERR           10D0      4304
BUFFER         =20A6      8358
BYT2ASC         1CD2      7378
BYTSFT          16E7      5863
CFEVAL          1033      4147
CHARTY           FE1      4065
CHEKFN          1214      4628
CHKBIN          1D7C      7548
CHKLTR           9F3      2547
CHKSTK           4DA      1242
CHKSUM         =208F      8335
CHKSYN           7CB      1995
CHKTYP           DC7      3527
CHR             142D      5165
CLEAR            A46      2630
CLOTST           800      2048
CLREG            62F      1583
CLRPTR           60A      1546
CLS             1C5C      7260
CMPFP           1839      6201
CMPLG1           F47      3911
CMPLOG           F45      3909
CMPNUM          181F      6175
CMPRES           F89      3977
CMPSTR           F71      3953
CN             =20        32
CNVNUM          18B7      6327
COLD             150      336
COMMAN         =2088      8328
COMPL           160F      5647
CONCAT          1391      5009
CONEXP          18E7      6375
CONPOS          15AC      5548
CONT             9CB      2507
CONTAD         =2119      8473
CONVAR           EB2      3762
COPY             170      368
COS             1B91      7057
COUNT            870      2160
CPDEHL           7C5      1989
CPYLIT           701      1793
CR             =0D        13
CRARLP          10F0      4336
CREARY          10D5      4309
CRESTR           B45      2885
CRNCLP           662      1634
CRTMST          124D      4685
CRTST           1259      4697
CRTSTE          126F      4719
CRUNCH           659      1625
CS             =0C        12
CSTART           161      353
CTLOFG         =208A      8330
CTRLC          =03        3
CTRLG          =07        7
CTRLO          =0F        15
CTRLQ          =11        17
CTRLR          =12        18
CTRLS          =13        19
CTRLU          =15        21
CUROPR         =210A      8458
CURPOS         =20F0      8432
DATA             AEC      2796
DATFLG         =20F3      8435
DATLIN         =210E      8462
DATSNR           4F7      1271
DCBCDE          1870      6256
DD             =12        18
DDERR            506      1286
DEEK            1C78      7288
DEF             1191      4497
DEFSIZ          10F8      4344
DEINT            A07      2567
DEL            =7F        127
DELCHR           731      1841
DEPINT           A01      2561
DETHL4          17FF      6143
DETHLB          1801      6145
DIGTXT          19B1      6577
DIM              FB3      4019
DIMRET           FAA      4010
DINPOS           7FA      2042
DIV             16F8      5880
DIV1           =204F      8271
DIV10           16EC      5868
DIV2           =2053      8275
DIV3           =2057      8279
DIV4           =205A      8282
DIVLP           171F      5919
DIVSUP         =204E      8270
DOAGN            648      1608
DOCOM            C19      3097
DODEL            711      1809
DOEBIT          19F1      6641
DOFN            11BE      4542
DOKE            1C83      7299
DONULL           C07      3079
DOSPC            C43      3139
DOTAB            C30      3120
DPOINT          18E3      6371
DTSTR           125D      4701
DVBCDE          16FA      5882
DZ             =14        20
DZERR            500      1280
ECHDEL           725      1829
EDIGIT          192A      6442
ENDBUF           708      1800
ENDCON          18F6      6390
ENDDIM          1157      4439
ENDINP           BF8      3064
ENDNAM           FD5      4053
ENDPRG           9A7      2471
ENFMEM           4E3      1251
ERRIN            531      1329
ERRLIN         =2117      8471
ERRMSG           48E      1166
ERROR            511      1297
ERRORS           404      1028
ESC            =1B        27
EVAL             DD4      3540
EVAL1            DD7      3543
EVAL2            DE0      3552
EVAL3            DE3      3555
EVLPAR           E99      3737
EVNOT            F93      3987
EXCUTE           935      2357
EXP             1A8B      6795
EXPLP           18D5      6357
EXPTAB          1ACB      6859
EXPTEN          1A03      6659
EXTIG            D42      3394
FANDT            D6C      3436
FC             =08        8
FCERR            A1C      2588
FDTLP            D53      3411
FINDEL          1133      4403
FLGDIF          17AF      6063
FLGREL          17B6      6070
FNARG          =2125      8485
FNCTAB           24E      590
FNDARY          10A3      4259
FNDELP          1138      4408
FNDEND           5DD      1501
FNDNUM          1520      5408
FNDTOK           84F      2127
FNDVAR          101A      4122
FNDWRD           68C      1676
FNOFST           EC3      3779
FNRGNM         =2123      8483
FNTHR           1028      4136
FNVAL            EEA      3818
FOPRND           E0C      3596
FOR              89C      2204
FORFLG         =2110      8464
FORFND           8CC      2252
FORSLP           8B0      2224
FPADD           155E      5470
FPBCDE          17E5      6117
FPEXP          =212C      8492
FPINT           184C      6220
FPMULT          1699      5785
FPREG          =2129      8489
FPROND          15F6      5622
FPSINT           9FB      2555
FPTHL           17FC      6140
FRE             115B      4443
FRENUM          1177      4471
FRMEVL           EB5      3765
GARBGE          12DE      4830
GARBLP          12E1      4833
GETCHR           955      2389
GETCMD           555      1365
GETHEX          1D08      7432
GETINP          1C5A      7258
GETINT          1523      5411
GETLEN          1411      5137
GETLIN           742      1858
GETLN            A22      2594
GETNUM           DC2      3522
GETNXT           6A7      1703
GETSTR          13DB      5083
GETVAR           FB8      4024
GNXARY          1315      4885
GOFUNC           EF2      3826
GOSUB            A98      2712
GOTO             AA9      2729
GRBARY          1335      4917
GRBDON          12B6      4790
GRBLP           12EF      4847
GSTRCU          13DE      5086
GSTRDE          13E2      5090
GSTRHL          13E1      5089
GTFLNM          1420      5152
GTFNAM           FBD      4029
GTLNLP           A25      2597
GTSIXD          197B      6523
GTVLUS           CBE      3262
HALF            1A22      6690
HALFPI          1BDB      7131
HE             =26        38
HEX             1C9A      7322
HEX1            1CB3      7347
HEX2            1CB5      7349
HEX3            1CC3      7363
HEX4            1CC5      7365
HEXIT           1D1F      7455
HEXLP           1CFB      7419
HEXLP1          1D00      7424
HEXTFP          1CEF      7407
HXERR           1D28      7464
ID             =16        22
IDTEST          1206      4614
IF               B7B      2939
IFGO             B89      2953
IFJMP            93C      2364
INCHL           17FA      6138
INCLEN           7F6      2038
INDFND           4C0      1216
INEWLN           5A5      1445
INIT             168      360
INITAB           42E      1070
INITBE           48E      1166
INITST          1D9A      7578
INMSG            495      1173
INP             14E0      5344
INPBIN           D10      3344
INPBRK           9A4      2468
INPORT         =2084      8324
INPSUB         =2083      8323
INPUT            C7E      3198
INRNG           1984      6532
INT             1877      6263
INTVAR           619      1561
INVSGN          17CD      6093
ITMSEP           D01      3329
JJUMP1          1D8F      7567
JSTZER          1A0D      6669
KILFOR           DB2      3506
KILIN            73C      1852
LCRFLG         =20F1      8433
LEFT            143D      5181
LEN             140D      5133
LET              B03      2819
LETNUM           B56      2902
LETSTR           B1E      2846
LF             =0A        10
LFRGNM          14D6      5334
LINEAT         =20A1      8353
LINEIN          1936      6454
LINES           1C69      7273
LINESC         =208B      8331
LINESN         =208D      8333
LINFND           58E      1422
LIST             811      2065
LISTLP           81D      2077
LOADFP          17F3      6131
LOG             1658      5720
LOGTAB          164B      5707
LOKFOR           4AA      1194
LOOPST         =210C      8460
LS             =1C        28
LSTBIN         =2111      8465
LSTLP2           83D      2109
LSTLP3           840      2112
LSTRAM         =20F4      8436
LSTRND         =207F      8319
LTSTND           D1B      3355
LWIDTH         =2087      8327
MAKINT          1526      5414
MAKNUM          19A0      6560
MANLP           18BF      6335
MATCH            6D9      1753
MEMMSG           243      579
MID             1477      5239
MID1            1443      5187
MIDNUM          14DB      5339
MINCDE          159E      5534
MINUS            EA1      3745
MKTMST          124A      4682
MLDBLP          1898      6296
MLDEBC          1890      6288
MLOOP            198      408
MLSP10          178D      6029
MO             =24        36
MONITR          1D99      7577
MONOUT          1D96      7574
MORDT            D27      3367
MORINP           74B      1867
MOVBUF           5C4      1476
MOVDIR           6E1      1761
MOVLP            4CF      1231
MOVSTR           4CC      1228
MOVUP            4C9      1225
MRPRNT           B9B      2971
MSIZE            185      389
MUL8LP          16C4      5828
MULLN2          1690      5776
MULT            1697      5783
MULT8           16BB      5819
MULTEN          1901      6401
MULVAL         =213B      8507
MVSTPT           B4D      2893
NEDMOR           CBA      3258
NEGAFT          1A38      6712
NEW              609      1545
NEXITM           C53      3155
NEXT             D77      3447
NEXT1            D7A      3450
NF             =00        0
NFERR            503      1283
NMIFLG         =2091      8337
NOCHNG           6D1      1745
NOENED          1A10      6672
NOLIN            9BA      2490
NOMADD          16D5      5845
NOMLAD          18A6      6310
NOPMPT           C98      3224
NORMAL          15C9      5577
NOSPC            6C8      1736
NOSUB7          1D1B      7451
NOSWAP          1578      5496
NOTAMP           E76      3702
NOTSTR           FF0      4080
NOXOR           1506      5382
NSCFOR          1000      4096
NULFLG         =2089      8329
NULL             9DE      2526
NULLP            C0E      3086
NULLS          =2086      8326
NUMASC          1949      6473
NXTARY          10B7      4279
NXTBYT           6B7      1719
NXTCHR           6F8      1784
NXTDAT         =2121      8481
NXTDTA           AEB      2795
NXTITM           CB2      3250
NXTOPR         =2115      8469
NXTSTL           AF2      2802
NXTSTT           AF5      2805
OD             =06        6
OKMSG            49A      1178
OM             =0C        12
OMERR            4F2      1266
ON               B5D      2909
ONGO             B6C      2924
ONGOLP           B6D      2925
ONJMP            93D      2365
OPNPAR           DD0      3536
OPRND            E4B      3659
OS             =1A        26
OTKLN            739      1849
OTPORT         =204C      8268
OUTC             7D6      2006
OUTEXP          1A01      6657
OUTIT            7B7      1975
OUTNBS           7BD      1981
OUTNCR          1DAB      7595
OUTSUB         =204B      8267
OUTWRD           859      2137
OV             =0A        10
OVERR            50C      1292
OVTST1          1780      6016
OVTST2          1785      6021
OVTST3          1786      6022
PADD            1925      6437
PAND             F0C      3852
PASSA           118C      4492
PBUFF          =212E      8494
PEEK            1534      5428
PEND             99F      2463
PHLTFP          17E2      6114
PLUCDE          1603      5635
PNORM           15D1      5585
POINT          =2096      8342
POKE            153B      5435
POPAF           12D0      4816
POPHL           13FA      5114
POPHRT          16E5      5861
POPNOK           547      1351
POR              F0B      3851
POR1             F2E      3886
POS             1189      4489
POSINT           9FE      2558
POUT            14EC      5356
POWER           1A46      6726
POWER1          1A56      6742
POWER2          1A73      6771
POWERS          1A26      6694
PRINT            B9F      2975
PRITAB           3EF      1007
PRNTCRLF         BFD      3069
PRNTHL          193E      6462
PRNTLP           BA2      2978
PRNTNB           BE5      3045
PRNTOK           548      1352
PRNTST           BE9      3049
PRNUMS          129A      4762
PROCES           764      1892
PROGND         =211B      8475
PROGST         =213E      8510
PROMPT           64C      1612
PRS             129B      4763
PRS1            129E      4766
PRSLP           12A5      4773
PSET           =2099      8345
PSUB            1559      5465
PTRLP            5D1      1489
PUTBUF           7A3      1955
PUTCTL           7A8      1960
PUTFID           911      2321
QTSTLP          1260      4704
QTSTR           125A      4698
QUARTR          1BDF      7135
RAMSTART       =2000      8192
READ             CAD      3245
READFG         =2112      8466
REDO             C5A      3162
REM              AEE      2798
RESDIV          1732      5938
RESEED          1B7D      7037
RESET          =209C      8348
RESTNL           97A      2426
RESTOR           965      2405
RESZER          15C4      5572
RETADR          1067      4199
RETINT          17BB      6075
RETLIN           AE6      2790
RETNAD           6DD      1757
RETNUL          106A      4202
RETNUM           EAD      3757
RETREL          17AD      6061
RETURN           AC7      2759
RG             =04        4
RIGHT           146D      5229
RIGHT1          1441      5185
RINPUT         =2093      8339
RLTLP            DF0      3568
RND             1B1C      6940
RND1            1B58      7000
RND2            1B74      7028
RNDTAB          1B85      7045
RNGTST          1A13      6675
RONDB           15E5      5605
RONDUP          15E4      5604
ROUND           154C      5452
RSCALE          191F      6431
RSLNBK           893      2195
RSTSTR          1490      5264
RUN              A8C      2700
RUNCNT           915      2325
RUNFST           615      1557
RUNLIN           AA8      2728
SAVEXP          15C5      5573
SAVSTP           908      2312
SAVSTR          1235      4661
SBSCPT          1075      4213
SCALE           1623      5667
SCALLP          1625      5669
SCALMI          18EA      6378
SCALPL          1900      6400
SCNEND          136C      4972
SCPTLP          107B      4219
SEARCH           6A5      1701
SEED           =205C      8284
SETIO           1510      5392
SETLIN           867      2151
SETLIT           6EF      1775
SETPTR           5CC      1484
SETTOP           1BC      444
SFTPRG           596      1430
SGN             17B3      6067
SGNEXP           EFB      3835
SGNRES         =212D      8493
SHRITE          1632      5682
SHRLP           1635      5685
SHRT1           1639      5689
SIGNON           20C      524
SIGNS           180A      6154
SIN             1B97      7063
SIN1            1BC7      7111
SINTAB          1BE3      7139
SIXDIG          1966      6502
SMPVAR          1300      4864
SMSER1          1AFB      6907
SN             =02        2
SNERR            4FD      1277
SPCFST          1957      6487
SPCLP            C4C      3148
SQR             1A3D      6717
SRCHLN           5E9      1513
SRCHLP           5EC      1516
SSTSA           13C8      5064
ST             =1E        30
STACK          =20AB      8363
STAKFP          17D5      6101
STALL            98E      2446
STARTB           156      342
STKTHS           E34      3636
STLOOK         =21A2      8610
STOP             99D      2461
STORED           A69      2665
STPOOL          1343      4931
STR             1225      4645
STR1            122B      4651
STRADD          1346      4934
STRBOT         =2108      8456
STRENT           D04      3332
STRSPC         =209F      8351
STTLIN           BF0      3056
SUBCDE          155B      5467
SUBPHL          1555      5461
SUMLP           1B04      6916
SUMSER          1AEC      6892
SUPTLZ          19E5      6629
SVNAM2           FD4      4052
SVSTAD          1253      4691
TAN             1BF8      7160
TESTOS          12D2      4818
TESTR           12B4      4788
TM             =18        24
TMERR            50F      1295
TMPSTR         =2104      8452
TMSTPL         =20F8      8440
TMSTPT         =20F6      8438
TOPOOL          1439      5177
TOSTRA          13D1      5073
TRYAGN          19C0      6592
TSALP           13D2      5074
TSTBIT          1DA4      7588
TSTBRK           980      2432
TSTMEM           1AA      426
TSTNUM           DC5      3525
TSTOPL          127B      4731
TSTRED           F33      3891
TSTREM           6F2      1778
TSTSGN          17A4      6052
TSTSTR           DC6      3526
TTYLIN           742      1858
TYPE           =20F2      8434
UF             =22        34
UFERR            509      1289
UL             =0E        14
ULERR            AC2      2754
UNITY           1647      5703
UPDATA           97B      2427
USR            =2048      8264
VAL             14A7      5287
VAL1            14C5      5317
VAL2            14CF      5327
VAL3            14D2      5330
VAREND         =211D      8477
WAIT            14F2      5362
WAITLP          1507      5383
WARM             153      339
WARMST           1F4      500
WIDTH           1C61      7265
WORDS            286      646
WORDTB           3A5      933
WRKSPC         =2045      8261
ZDATA          =83        131
ZDIV           =AF        175
ZEND           =80        128
ZEQUAL         =B4        180
ZERARY          1116      4374
ZERBYT         = 499      1177
ZEROLP          1059      4185
ZEROSUP         1D39      7481
ZFN            =A7        167
ZFOR           =81        129
ZGOSUB         =8C        140
ZGOTO          =88        136
ZGTR           =B3        179
ZLEFT          =CF        207
ZLTH           =B5        181
ZMINUS         =AD        173
ZNEW           =A4        164
ZNOT           =AA        170
ZONELP           C27      3111
ZOR            =B2        178
ZPLUS          =AC        172
ZPOINT         =C7        199
ZPRINT         =9E        158
ZREM           =8E        142
ZSGN           =B6        182
ZSPC           =A8        168
ZSTEP          =AB        171
ZTAB           =A5        165
ZTHEN          =A9        169
ZTIMES         =AE        174
ZTO            =A6        166
