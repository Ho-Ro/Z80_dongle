   1:			;==================================================================================
   2:			; The updates to the original BASIC within this file are copyright Grant Searle
   3:			;
   4:			; You have permission to use this for NON COMMERCIAL USE ONLY
   5:			; If you wish to use it elsewhere, please include an acknowledgement to myself.
   6:			;
   7:			; http://searle.hostei.com/grant/index.html
   8:			;
   9:			; eMail: home.micros01@btinternet.com
  10:			;
  11:			; If the above don't work, please perform an Internet search to see if I have
  12:			; updated the web page hosting service.
  13:			;
  14:			;==================================================================================
  15:			
  16:			; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
  17:			; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
  18:			; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
  19:			; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
  20:			; the original ROM code (checksum A934H). PA
  21:			
  22:			; GENERAL EQUATES
  23:			
  24:	0003          	CTRLC   .EQU   03H             ; Control "C"
  25:	0007          	CTRLG   .EQU   07H             ; Control "G"
  26:	0008          	BKSP    .EQU   08H             ; Back space
  27:	000A          	LF      .EQU   0AH             ; Line feed
  28:	000C          	CS      .EQU   0CH             ; Clear screen
  29:	000D          	CR      .EQU   0DH             ; Carriage return
  30:	000F          	CTRLO   .EQU   0FH             ; Control "O"
  31:	0011          	CTRLQ   .EQU   11H             ; Control "Q"
  32:	0012          	CTRLR   .EQU   12H             ; Control "R"
  33:	0013          	CTRLS   .EQU   13H             ; Control "S"
  34:	0015          	CTRLU   .EQU   15H             ; Control "U"
  35:	0018          	CAN     .EQU   18H             ; Cancel Control 'X'
  36:	001B          	ESC     .EQU   1BH             ; Escape
  37:	0020          	SPACE   .EQU   20H             ; Space
  38:	007F          	DEL     .EQU   7FH             ; Delete
  39:			
  40:	2000          	ROMSIZE .EQU    2000H
  41:	2000          	RAMSTRT .EQU    ROMSIZE
  42:	1A00          	RAMSIZE .EQU    1A00H          ; use 6.5K RAM from dongle
  43:	3A00          	RAMEND  .EQU    RAMSTRT + RAMSIZE
  44:			
  45:			
  46:			; BASIC WORK SPACE LOCATIONS
  47:			
  48:	2000          	        .ORG   RAMSTRT
  49:			
  50:	2000          	WRKSPC  .ds     3       ; .EQU   2000H           ; BASIC Work space
  51:	2003          	USRJP   .ds     3       ; .EQU   2003H = 8195    ; "USR (x)" jump
  52:	2006          	OUTSUB  .ds     3       ; .EQU   WRKSPC + 6H     ; "OUT p,n"
  53:	2007          	OTPORT  .equ    OUTSUB+1 ; .EQU   WRKSPC + 7H     ; Port (p)
  54:	2009          	DIVSUP  .ds     14      ; .EQU   WRKSPC + 9H     ; Division support routine
  55:	200A          	DIV1    .equ    DIVSUP+1  ; .EQU   WRKSPC + 0AH    ; <- Values
  56:	200E          	DIV2    .equ    DIVSUP+5  ; .EQU   WRKSPC + 0EH    ; <-   to
  57:	2012          	DIV3    .equ    DIVSUP+9  ; .EQU   WRKSPC + 12H    ; <-   be
  58:	2015          	DIV4    .equ    DIVSUP+12 ; .EQU   WRKSPC + 15H    ; <-inserted
  59:	2017          	SEED    .ds     35       ; .EQU   WRKSPC + 17H    ; Random number seed
  60:	203A          	LSTRND  .ds     4       ; .EQU   WRKSPC + 3AH    ; Last random number
  61:	203E          	INPSUB  .ds     3       ; .EQU   WRKSPC + 3EH    ; #INP (x)" Routine
  62:	203F          	INPORT  .equ    INPSUB+1 ; .EQU   WRKSPC + 3FH    ; PORT (x)
  63:	2041          	NULLS   .ds     1       ; .EQU   WRKSPC + 41H    ; Number of nulls
  64:	2042          	LWIDTH  .ds     1       ; .EQU   WRKSPC + 42H    ; Terminal width
  65:	2043          	COMMAN  .ds     1       ; .EQU   WRKSPC + 43H    ; Width for commas
  66:	2044          	NULFLG  .ds     1       ; .EQU   WRKSPC + 44H    ; Null after input byte flag
  67:	2045          	CTLOFG  .ds     1       ; .EQU   WRKSPC + 45H    ; Control "O" flag
  68:	2046          	LINESC  .ds     2       ; .EQU   WRKSPC + 46H    ; Lines counter
  69:	2048          	LINESN  .ds     2       ; .EQU   WRKSPC + 48H    ; Lines number
  70:	204A          	CHKSUM  .ds     2       ; .EQU   WRKSPC + 4AH    ; Array load/save check sum
  71:	204C          	NMIFLG  .ds     1       ; .EQU   WRKSPC + 4CH    ; Flag for NMI break routine
  72:	204D          	BRKFLG  .ds     1       ; .EQU   WRKSPC + 4DH    ; Break flag
  73:	204E          	RINPUT  .ds     3       ; .EQU   WRKSPC + 4EH    ; Input reflection
  74:	2051          	POINT   .ds     3       ; .EQU   WRKSPC + 51H    ; "POINT" reflection (unused)
  75:	2054          	PSET    .ds     3       ; .EQU   WRKSPC + 54H    ; "SET"   reflection
  76:	2057          	RESET   .ds     3       ; .EQU   WRKSPC + 57H    ; "RESET" reflection
  77:	205A          	STRSPC  .ds     2       ; .EQU   WRKSPC + 5AH    ; Bottom of string space
  78:	205C          	LINEAT  .ds     2       ; .EQU   WRKSPC + 5CH    ; Current line number
  79:	205E          	BASTXT  .ds     2       ; .EQU   WRKSPC + 5EH    ; Pointer to start of program
  80:	2060          	        .ds     1
  81:	2061          	BUFFER  .ds     74      ; .EQU   WRKSPC + 61H    ; Input buffer
  82:	20A7          	STACK   .equ    BUFFER+70 ;.EQU   WRKSPC + 66H   ; Initial stack
  83:	20AB          	CURPOS  .ds     1       ; .EQU   WRKSPC + 0ABH   ; Character position on line
  84:	20AC          	LCRFLG  .ds     1       ; .EQU   WRKSPC + 0ACH   ; Locate/Create flag
  85:	20AD          	TYPE    .ds     1       ; .EQU   WRKSPC + 0ADH   ; Data type flag
  86:	20AE          	DATFLG  .ds     1       ; .EQU   WRKSPC + 0AEH   ; Literal statement flag
  87:	20AF          	LSTRAM  .ds     2       ; .EQU   WRKSPC + 0AFH   ; Last available RAM
  88:	20B1          	TMSTPT  .ds     2       ; .EQU   WRKSPC + 0B1H   ; Temporary string pointer
  89:	20B3          	TMSTPL  .ds     12      ; .EQU   WRKSPC + 0B3H   ; Temporary string pool
  90:	20BF          	TMPSTR  .ds     4       ; .EQU   WRKSPC + 0BFH   ; Temporary string
  91:	20C3          	STRBOT  .ds     2       ; .EQU   WRKSPC + 0C3H   ; Bottom of string space
  92:	20C5          	CUROPR  .ds     2       ; .EQU   WRKSPC + 0C5H   ; Current operator in EVAL
  93:	20C7          	LOOPST  .ds     2       ; .EQU   WRKSPC + 0C7H   ; First statement of loop
  94:	20C9          	DATLIN  .ds     2       ; .EQU   WRKSPC + 0C9H   ; Line of current DATA item
  95:	20CB          	FORFLG  .ds     1       ; .EQU   WRKSPC + 0CBH   ; "FOR" loop flag
  96:	20CC          	LSTBIN  .ds     1       ; .EQU   WRKSPC + 0CCH   ; Last byte entered
  97:	20CD          	READFG  .ds     1       ; .EQU   WRKSPC + 0CDH   ; Read/Input flag
  98:	20CE          	BRKLIN  .ds     2       ; .EQU   WRKSPC + 0CEH   ; Line of break
  99:	20D0          	NXTOPR  .ds     2       ; .EQU   WRKSPC + 0D0H   ; Next operator in EVAL
 100:	20D2          	ERRLIN  .ds     2       ; .EQU   WRKSPC + 0D2H   ; Line of error
 101:	20D4          	CONTAD  .ds     2       ; .EQU   WRKSPC + 0D4H   ; Where to CONTinue
 102:	20D6          	PROGND  .ds     2       ; .EQU   WRKSPC + 0D6H   ; End of program
 103:	20D8          	VAREND  .ds     2       ; .EQU   WRKSPC + 0D8H   ; End of variables
 104:	20DA          	ARREND  .ds     2       ; .EQU   WRKSPC + 0DAH   ; End of arrays
 105:	20DC          	NXTDAT  .ds     2       ; .EQU   WRKSPC + 0DCH   ; Next data item
 106:	20DE          	FNRGNM  .ds     2       ; .EQU   WRKSPC + 0DEH   ; Name of FN argument
 107:	20E0          	FNARG   .ds     4       ; .EQU   WRKSPC + 0E0H   ; FN argument value
 108:	20E4          	FPREG   .ds     4       ; .EQU   WRKSPC + 0E4H   ; Floating point register
 109:	20E7          	FPEXP   .EQU   FPREG + 3       ; Floating point exponent
 110:	20E8          	SGNRES  .ds     1       ; .EQU   WRKSPC + 0E8H   ; Sign of result
 111:	20E9          	PBUFF   .ds     13      ; .EQU   WRKSPC + 0E9H   ; Number print buffer
 112:	20F6          	MULVAL  .ds     3       ; .EQU   WRKSPC + 0F6H   ; Multiplier
 113:	20F9          	PROGST  .ds     1       ; .EQU   WRKSPC + 0F9H   ; Start of program text area
 114:			
 115:	2200          	STLOOK  .EQU   WRKSPC + 0200H   ; Start of memory test
 116:			
 117:			; BASIC ERROR CODE VALUES
 118:			
 119:	0000          	NF      .EQU   00H             ; NEXT without FOR
 120:	0002          	SN      .EQU   02H             ; Syntax error
 121:	0004          	RG      .EQU   04H             ; RETURN without GOSUB
 122:	0006          	OD      .EQU   06H             ; Out of DATA
 123:	0008          	FC      .EQU   08H             ; Function call error
 124:	000A          	OV      .EQU   0AH             ; Overflow
 125:	000C          	OM      .EQU   0CH             ; Out of memory
 126:	000E          	UL      .EQU   0EH             ; Undefined line number
 127:	0010          	BS      .EQU   10H             ; Bad subscript
 128:	0012          	DD      .EQU   12H             ; Re-DIMensioned array
 129:	0014          	DZ      .EQU   14H             ; Division by zero (/0)
 130:	0016          	ID      .EQU   16H             ; Illegal direct
 131:	0018          	TM      .EQU   18H             ; Type miss-match
 132:	001A          	OS      .EQU   1AH             ; Out of string space
 133:	001C          	LS      .EQU   1CH             ; String too long
 134:	001E          	ST      .EQU   1EH             ; String formula too complex
 135:	0020          	CN      .EQU   20H             ; Can't CONTinue
 136:	0022          	UF      .EQU   22H             ; UnDEFined FN function
 137:	0024          	MO      .EQU   24H             ; Missing operand
 138:	0026          	HE      .EQU   26H             ; HEX error
 139:	0028          	BN      .EQU   28H             ; BIN error
 140:			
 141:			
 142:	0100          	        .ORG   0100H
 143:			
 144:	0100  C30C01  	COLD:   JP      CSTART          ; Jump for cold start
 145:	0103  C3A101  	WARM:   JP      WARMST          ; Jump for warm start
 146:			
 147:			; USR(X) at 0x2048 = 8264 is called with a single argument.
 148:			; Get the int16_t argument in DE by calling DEINT.
 149:			; Put return int16_t value in AB and call ABPASS.
 150:			;
 151:	0106  C38D09  	        JP      DEINT           ; Get int16_t argument in DE
 152:	0109  C30311  	        JP      ABPASS          ; Return int16_t result in AB
 153:			
 154:	010C  21A720  	CSTART: LD      HL,STACK        ; End of BUFFER RAM
 155:	010F  F9      	        LD      SP,HL           ; Set up a temporary stack
 156:			
 157:	0110  3E00    	INITST: LD      A,0             ; Clear break flag
 158:	0112  324D20  	        LD      (BRKFLG),A
 159:			
 160:	0115  11E203  	INIT:   LD      DE,INITAB       ; Initialise workspace
 161:	0118  0663    	        LD      B,INITBE-INITAB+3 ; Bytes to copy
 162:	011A  210020  	        LD      HL,WRKSPC       ; Into workspace RAM
 163:	011D  1A      	COPY:   LD      A,(DE)          ; Get source
 164:	011E  77      	        LD      (HL),A          ; To destination
 165:	011F  23      	        INC     HL              ; Next destination
 166:	0120  13      	        INC     DE              ; Next source
 167:	0121  05      	        DEC     B               ; Count bytes
 168:	0122  C21D01  	        JP      NZ,COPY         ; More to move
 169:	0125  F9      	        LD      SP,HL           ; Temporary stack
 170:	0126  CDE305  	        CALL    CLREG           ; Clear registers and stack
 171:	0129  CD830B  	        CALL    PRNTCRLF        ; Output CRLF
 172:	012C  32AA20  	        LD      (BUFFER+72+1),A ; Mark end of buffer
 173:	012F  32F920  	        LD      (PROGST),A      ; Initialise program area
 174:			
 175:	0132  21F701  	MSIZE:  LD      HL,MEMMSG       ; Point to message
 176:	0135  CD2112  	        CALL    PRS             ; Output "Memory size"
 177:	0138  CD0006  	        CALL    PROMPT          ; Get input with '?'
 178:	013B  CDD508  	        CALL    GETCHR          ; Get next character
 179:	013E  B7      	        OR      A               ; Set flags
 180:	013F  C25701  	        JP      NZ,TSTMEM       ; If number - Test if RAM there
 181:	0142  210021  	        LD      HL,(STLOOK-1)&0FF00H ; Point to start of free
 182:	0145  24      	MLOOP:  INC     H               ; Next 256 byte range
 183:	0146  7C      	        LD      A,H             ; Above address FFFF ?
 184:	0147  B7      	        OR      A
 185:	0148  CA6901  	        JP      Z,SETTOP        ; Yes - 64K RAM
 186:	014B  7E      	        LD      A,(HL)          ; Get contents
 187:	014C  47      	        LD      B,A             ; Save it
 188:	014D  2F      	        CPL                     ; Flip all bits
 189:	014E  77      	        LD      (HL),A          ; Put it back
 190:	014F  BE      	        CP      (HL)            ; RAM there if same
 191:	0150  70      	        LD      (HL),B          ; Restore old contents
 192:	0151  CA4501  	        JP      Z,MLOOP         ; If RAM - test next ram section
 193:	0154  C36901  	        JP      SETTOP          ; Top of RAM found
 194:			
 195:	0157  CDA709  	TSTMEM: CALL    ATOH            ; Get high memory into DE
 196:	015A  B7      	        OR      A               ; Set flags on last byte
 197:	015B  C2B104  	        JP      NZ,SNERR        ; ?SN Error if bad character
 198:	015E  EB      	        EX      DE,HL           ; Address into HL
 199:	015F  2B      	        DEC     HL              ; Back one byte
 200:	0160  3ED9    	        LD      A,11011001B     ; Test byte
 201:	0162  46      	        LD      B,(HL)          ; Get old contents
 202:	0163  77      	        LD      (HL),A          ; Load test byte
 203:	0164  BE      	        CP      (HL)            ; RAM there if same
 204:	0165  70      	        LD      (HL),B          ; Restore old contents
 205:	0166  C23201  	        JP      NZ,MSIZE        ; Ask again if no RAM
 206:			
 207:	0169  2B      	SETTOP: DEC     HL              ; Back one byte
 208:	016A  11FF21  	        LD      DE,STLOOK-1     ; See if enough RAM
 209:	016D  CD4507  	        CALL    CPDEHL          ; Compare DE with HL
 210:	0170  DA3201  	        JP      C,MSIZE         ; Ask again if not enough RAM
 211:	0173  11CEFF  	        LD      DE,0-50         ; 50 Bytes string space
 212:	0176  22AF20  	        LD      (LSTRAM),HL     ; Save last available RAM
 213:	0179  19      	        ADD     HL,DE           ; Allocate string space
 214:	017A  225A20  	        LD      (STRSPC),HL     ; Save string space
 215:	017D  CDBE05  	        CALL    CLRPTR          ; Clear program area
 216:	0180  2A5A20  	        LD      HL,(STRSPC)     ; Get end of memory
 217:	0183  11EFFF  	        LD      DE,0-17         ; Offset for free bytes
 218:	0186  19      	        ADD     HL,DE           ; Adjust HL
 219:	0187  11F920  	        LD      DE,PROGST       ; Start of program text
 220:	018A  7D      	        LD      A,L             ; Get LSB
 221:	018B  93      	        SUB     E               ; Adjust it
 222:	018C  6F      	        LD      L,A             ; Re-save
 223:	018D  7C      	        LD      A,H             ; Get MSB
 224:	018E  9A      	        SBC     A,D             ; Adjust it
 225:	018F  67      	        LD      H,A             ; Re-save
 226:	0190  E5      	        PUSH    HL              ; Save bytes free
 227:	0191  21B901  	        LD      HL,SIGNON       ; Sign-on message
 228:	0194  CD2112  	        CALL    PRS             ; Output string
 229:	0197  E1      	        POP     HL              ; Get bytes free back
 230:	0198  CDC418  	        CALL    PRNTHL          ; Output amount of free memory
 231:	019B  21AA01  	        LD      HL,BFREE        ; " Bytes free" message
 232:	019E  CD2112  	        CALL    PRS             ; Output string
 233:			
 234:	01A1  31A720  	WARMST: LD      SP,STACK        ; Temporary stack
 235:	01A4  CDE305  	BRKRET: CALL    CLREG           ; Clear registers and stack
 236:	01A7  C3FC04  	        JP      PRNTOK          ; Go to get command line
 237:			
 238:	01AA  20427974	BFREE:  .DB  " Bytes free",CR,LF,0,0
	      65732066
	      7265650D
	      0A0000
 239:			
 240:	01B9  4E415343	SIGNON: .DB  "NASCOM ROM BASIC Ver 4.7b",CR,LF
	      4F4D2052
	      4F4D2042
	      41534943
	      20566572
	      20342E37
	      620D0A
 241:	01D4  436F7079	        .DB  "Copyright (C) 1978 by Microsoft",CR,LF,0,0
	      72696768
	      74202843
	      29203139
	      37382062
	      79204D69
	      63726F73
	      6F66740D
	      0A0000
 242:			
 243:	01F7  4D656D6F	MEMMSG: .DB  "Memory top",0
	      72792074
	      6F7000
 244:			
 245:			; FUNCTION ADDRESS TABLE
 246:			
 247:	0202  3917    	FNCTAB: .DW     SGN
 248:	0204  FD17    	        .DW     INT
 249:	0206  4F17    	        .DW     ABS
 250:	0208  271D    	        .DW     USR
 251:	020A  E110    	        .DW     FRE
 252:	020C  6614    	        .DW     INP
 253:	020E  0F11    	        .DW     POS
 254:	0210  C319    	        .DW     SQR
 255:	0212  A21A    	        .DW     RND
 256:	0214  DE15    	        .DW     LOG
 257:	0216  111A    	        .DW     EXP
 258:	0218  171B    	        .DW     COS
 259:	021A  1D1B    	        .DW     SIN
 260:	021C  7E1B    	        .DW     TAN
 261:	021E  931B    	        .DW     ATN
 262:	0220  BA14    	        .DW     PEEK
 263:	0222  001C    	        .DW     DEEK
 264:	0224  5120    	        .DW     POINT
 265:	0226  9313    	        .DW     LEN
 266:	0228  AB11    	        .DW     STR
 267:	022A  2D14    	        .DW     VAL
 268:	022C  A213    	        .DW     ASC
 269:	022E  B313    	        .DW     CHR
 270:	0230  221C    	        .DW     HEX
 271:	0232  B51C    	        .DW     BIN
 272:	0234  C313    	        .DW     LEFT
 273:	0236  F313    	        .DW     RIGHT
 274:	0238  FD13    	        .DW     MID
 275:			
 276:			; RESERVED WORD LIST
 277:			
 278:	023A  C54E44  	WORDS:  .DB     'E' + 80H,"ND"
 279:	023D  C64F52  	        .DB     'F' + 80H,"OR"
 280:	0240  CE455854	        .DB     'N' + 80H,"EXT"
 281:	0244  C4415441	        .DB     'D' + 80H,"ATA"
 282:	0248  C94E5055	        .DB     'I' + 80H,"NPUT"
	      54
 283:	024D  C4494D  	        .DB     'D' + 80H,"IM"
 284:	0250  D2454144	        .DB     'R' + 80H,"EAD"
 285:	0254  CC4554  	        .DB     'L' + 80H,"ET"
 286:	0257  C74F544F	        .DB     'G' + 80H,"OTO"
 287:	025B  D2554E  	        .DB     'R' + 80H,"UN"
 288:	025E  C946    	        .DB     'I' + 80H,"F"
 289:	0260  D2455354	        .DB     'R' + 80H,"ESTORE"
	      4F5245
 290:	0267  C74F5355	        .DB     'G' + 80H,"OSUB"
	      42
 291:	026C  D2455455	        .DB     'R' + 80H,"ETURN"
	      524E
 292:	0272  D2454D  	        .DB     'R' + 80H,"EM"
 293:	0275  D3544F50	        .DB     'S' + 80H,"TOP"
 294:	0279  CF5554  	        .DB     'O' + 80H,"UT"
 295:	027C  CF4E    	        .DB     'O' + 80H,"N"
 296:	027E  CE554C4C	        .DB     'N' + 80H,"ULL"
 297:	0282  D7414954	        .DB     'W' + 80H,"AIT"
 298:	0286  C44546  	        .DB     'D' + 80H,"EF"
 299:	0289  D04F4B45	        .DB     'P' + 80H,"OKE"
 300:	028D  C44F4B45	        .DB     'D' + 80H,"OKE"
 301:	0291  D3435245	        .DB     'S' + 80H,"CREEN"
	      454E
 302:	0297  CC494E45	        .DB     'L' + 80H,"INES"
	      53
 303:	029C  C34C53  	        .DB     'C' + 80H,"LS"
 304:	029F  D7494454	        .DB     'W' + 80H,"IDTH"
	      48
 305:	02A4  CD4F4E49	        .DB     'M' + 80H,"ONITOR"
	      544F52
 306:	02AB  D34554  	        .DB     'S' + 80H,"ET"
 307:	02AE  D2455345	        .DB     'R' + 80H,"ESET"
	      54
 308:	02B3  D052494E	        .DB     'P' + 80H,"RINT"
	      54
 309:	02B8  C34F4E54	        .DB     'C' + 80H,"ONT"
 310:	02BC  CC495354	        .DB     'L' + 80H,"IST"
 311:	02C0  C34C4541	        .DB     'C' + 80H,"LEAR"
	      52
 312:	02C5  C34C4F41	        .DB     'C' + 80H,"LOAD"
	      44
 313:	02CA  C3534156	        .DB     'C' + 80H,"SAVE"
	      45
 314:	02CF  CE4557  	        .DB     'N' + 80H,"EW"
 315:			
 316:	02D2  D4414228	        .DB     'T' + 80H,"AB("
 317:	02D6  D44F    	        .DB     'T' + 80H,"O"
 318:	02D8  C64E    	        .DB     'F' + 80H,"N"
 319:	02DA  D3504328	        .DB     'S' + 80H,"PC("
 320:	02DE  D448454E	        .DB     'T' + 80H,"HEN"
 321:	02E2  CE4F54  	        .DB     'N' + 80H,"OT"
 322:	02E5  D3544550	        .DB     'S' + 80H,"TEP"
 323:			
 324:	02E9  AB      	        .DB     '+' + 80H
 325:	02EA  AD      	        .DB     '-' + 80H
 326:	02EB  AA      	        .DB     '*' + 80H
 327:	02EC  AF      	        .DB     '/' + 80H
 328:	02ED  DE      	        .DB     '^' + 80H
 329:	02EE  C14E44  	        .DB     'A' + 80H,"ND"
 330:	02F1  CF52    	        .DB     'O' + 80H,"R"
 331:	02F3  BE      	        .DB     '>' + 80H
 332:	02F4  BD      	        .DB     '=' + 80H
 333:	02F5  BC      	        .DB     '<' + 80H
 334:			
 335:	02F6  D3474E  	        .DB     'S' + 80H,"GN"
 336:	02F9  C94E54  	        .DB     'I' + 80H,"NT"
 337:	02FC  C14253  	        .DB     'A' + 80H,"BS"
 338:	02FF  D55352  	        .DB     'U' + 80H,"SR"
 339:	0302  C65245  	        .DB     'F' + 80H,"RE"
 340:	0305  C94E50  	        .DB     'I' + 80H,"NP"
 341:	0308  D04F53  	        .DB     'P' + 80H,"OS"
 342:	030B  D35152  	        .DB     'S' + 80H,"QR"
 343:	030E  D24E44  	        .DB     'R' + 80H,"ND"
 344:	0311  CC4F47  	        .DB     'L' + 80H,"OG"
 345:	0314  C55850  	        .DB     'E' + 80H,"XP"
 346:	0317  C34F53  	        .DB     'C' + 80H,"OS"
 347:	031A  D3494E  	        .DB     'S' + 80H,"IN"
 348:	031D  D4414E  	        .DB     'T' + 80H,"AN"
 349:	0320  C1544E  	        .DB     'A' + 80H,"TN"
 350:	0323  D045454B	        .DB     'P' + 80H,"EEK"
 351:	0327  C445454B	        .DB     'D' + 80H,"EEK"
 352:	032B  D04F494E	        .DB     'P' + 80H,"OINT"
	      54
 353:	0330  CC454E  	        .DB     'L' + 80H,"EN"
 354:	0333  D3545224	        .DB     'S' + 80H,"TR$"
 355:	0337  D6414C  	        .DB     'V' + 80H,"AL"
 356:	033A  C15343  	        .DB     'A' + 80H,"SC"
 357:	033D  C3485224	        .DB     'C' + 80H,"HR$"
 358:	0341  C8455824	        .DB     'H' + 80H,"EX$"
 359:	0345  C2494E24	        .DB     'B' + 80H,"IN$"
 360:	0349  CC454654	        .DB     'L' + 80H,"EFT$"
	      24
 361:	034E  D2494748	        .DB     'R' + 80H,"IGHT$"
	      5424
 362:	0354  CD494424	        .DB     'M' + 80H,"ID$"
 363:	0358  80      	        .DB     80H             ; End of list marker
 364:			
 365:			; KEYWORD ADDRESS TABLE
 366:			
 367:	0359  2509    	WORDTB: .DW     PEND
 368:	035B  1C08    	        .DW     FOR
 369:	035D  FD0C    	        .DW     NEXT
 370:	035F  720A    	        .DW     DATA
 371:	0361  040C    	        .DW     INPUT
 372:	0363  390F    	        .DW     DIM
 373:	0365  330C    	        .DW     READ
 374:	0367  890A    	        .DW     LET
 375:	0369  2F0A    	        .DW     GOTO
 376:	036B  120A    	        .DW     RUN
 377:	036D  010B    	        .DW     IF
 378:	036F  E508    	        .DW     RESTOR
 379:	0371  1E0A    	        .DW     GOSUB
 380:	0373  4D0A    	        .DW     RETURN
 381:	0375  740A    	        .DW     REM
 382:	0377  2309    	        .DW     STOP
 383:	0379  7214    	        .DW     POUT
 384:	037B  E30A    	        .DW     ON
 385:	037D  6409    	        .DW     NULL
 386:	037F  7814    	        .DW     WAIT
 387:	0381  1711    	        .DW     DEF
 388:	0383  C114    	        .DW     POKE
 389:	0385  0B1C    	        .DW     DOKE
 390:	0387  740A    	        .DW     REM             ;SCREEN
 391:	0389  F11B    	        .DW     LINES
 392:	038B  E41B    	        .DW     CLS
 393:	038D  E91B    	        .DW     WIDTH
 394:	038F  171D    	        .DW     MONITR
 395:	0391  5420    	        .DW     PSET
 396:	0393  5720    	        .DW     RESET
 397:	0395  250B    	        .DW     PRINT
 398:	0397  5109    	        .DW     CONT
 399:	0399  9107    	        .DW     LIST
 400:	039B  CC09    	        .DW     CLEAR
 401:	039D  740A    	        .DW     REM             ;CLOAD
 402:	039F  740A    	        .DW     REM             ;CSAVE
 403:	03A1  BD05    	        .DW     NEW
 404:			
 405:			; RESERVED WORD TOKEN VALUES
 406:			
 407:	0080          	ZEND    .EQU    080H            ; END
 408:	0081          	ZFOR    .EQU    081H            ; FOR
 409:	0083          	ZDATA   .EQU    083H            ; DATA
 410:	0088          	ZGOTO   .EQU    088H            ; GOTO
 411:	008C          	ZGOSUB  .EQU    08CH            ; GOSUB
 412:	008E          	ZREM    .EQU    08EH            ; REM
 413:	009E          	ZPRINT  .EQU    09EH            ; PRINT
 414:	00A4          	ZNEW    .EQU    0A4H            ; NEW
 415:			
 416:	00A5          	ZTAB    .EQU    0A5H            ; TAB
 417:	00A6          	ZTO     .EQU    0A6H            ; TO
 418:	00A7          	ZFN     .EQU    0A7H            ; FN
 419:	00A8          	ZSPC    .EQU    0A8H            ; SPC
 420:	00A9          	ZTHEN   .EQU    0A9H            ; THEN
 421:	00AA          	ZNOT    .EQU    0AAH            ; NOT
 422:	00AB          	ZSTEP   .EQU    0ABH            ; STEP
 423:			
 424:	00AC          	ZPLUS   .EQU    0ACH            ; +
 425:	00AD          	ZMINUS  .EQU    0ADH            ; -
 426:	00AE          	ZTIMES  .EQU    0AEH            ; *
 427:	00AF          	ZDIV    .EQU    0AFH            ; /
 428:	00B2          	ZOR     .EQU    0B2H            ; OR
 429:	00B3          	ZGTR    .EQU    0B3H            ; >
 430:	00B4          	ZEQUAL  .EQU    0B4H            ; M
 431:	00B5          	ZLTH    .EQU    0B5H            ; <
 432:	00B6          	ZSGN    .EQU    0B6H            ; SGN
 433:	00C7          	ZPOINT  .EQU    0C7H            ; POINT
 434:	00CF          	ZLEFT   .EQU    0CDH +2         ; LEFT$
 435:			
 436:			; ARITHMETIC PRECEDENCE TABLE
 437:			
 438:	03A3  79      	PRITAB: .DB     79H             ; Precedence value
 439:	03A4  AB18    	        .DW     PADD            ; FPREG = <last> + FPREG
 440:			
 441:	03A6  79      	        .DB     79H             ; Precedence value
 442:	03A7  DF14    	        .DW     PSUB            ; FPREG = <last> - FPREG
 443:			
 444:	03A9  7C      	        .DB     7CH             ; Precedence value
 445:	03AA  1D16    	        .DW     MULT            ; PPREG = <last> * FPREG
 446:			
 447:	03AC  7C      	        .DB     7CH             ; Precedence value
 448:	03AD  7E16    	        .DW     DIV             ; FPREG = <last> / FPREG
 449:			
 450:	03AF  7F      	        .DB     7FH             ; Precedence value
 451:	03B0  CC19    	        .DW     POWER           ; FPREG = <last> ^ FPREG
 452:			
 453:	03B2  50      	        .DB     50H             ; Precedence value
 454:	03B3  920E    	        .DW     PAND            ; FPREG = <last> AND FPREG
 455:			
 456:	03B5  46      	        .DB     46H             ; Precedence value
 457:	03B6  910E    	        .DW     POR             ; FPREG = <last> OR FPREG
 458:			
 459:			; BASIC ERROR CODE LIST
 460:			
 461:	03B8  4E46    	ERRORS: .DB     "NF"            ; NEXT without FOR
 462:	03BA  534E    	        .DB     "SN"            ; Syntax error
 463:	03BC  5247    	        .DB     "RG"            ; RETURN without GOSUB
 464:	03BE  4F44    	        .DB     "OD"            ; Out of DATA
 465:	03C0  4643    	        .DB     "FC"            ; Illegal function call
 466:	03C2  4F56    	        .DB     "OV"            ; Overflow error
 467:	03C4  4F4D    	        .DB     "OM"            ; Out of memory
 468:	03C6  554C    	        .DB     "UL"            ; Undefined line
 469:	03C8  4253    	        .DB     "BS"            ; Bad subscript
 470:	03CA  4444    	        .DB     "DD"            ; Re-DIMensioned array
 471:	03CC  2F30    	        .DB     "/0"            ; Division by zero
 472:	03CE  4944    	        .DB     "ID"            ; Illegal direct
 473:	03D0  544D    	        .DB     "TM"            ; Type mis-match
 474:	03D2  4F53    	        .DB     "OS"            ; Out of string space
 475:	03D4  4C53    	        .DB     "LS"            ; String too long
 476:	03D6  5354    	        .DB     "ST"            ; String formula too complex
 477:	03D8  434E    	        .DB     "CN"            ; Can't CONTinue
 478:	03DA  5546    	        .DB     "UF"            ; Undefined FN function
 479:	03DC  4D4F    	        .DB     "MO"            ; Missing operand
 480:	03DE  4858    	        .DB     "HX"            ; HEX error
 481:	03E0  424E    	        .DB     "BN"            ; BIN error
 482:			
 483:			; INITIALISATION TABLE -------------------------------------------------------
 484:			
 485:	03E2  C3A101  	INITAB: JP      WARMST          ; Warm start jump
 486:	03E5  C3EA03  	        JP      ITBRET          ; "USR (X)" jump -> RET
 487:	03E8  D300    	        OUT     (0),A           ; "OUT p,n" skeleton
 488:	03EA  C9      	ITBRET: RET
 489:	03EB  D600    	        SUB     0               ; Division support routine
 490:	03ED  6F      	        LD      L,A
 491:	03EE  7C      	        LD      A,H
 492:	03EF  DE00    	        SBC     A,0
 493:	03F1  67      	        LD      H,A
 494:	03F2  78      	        LD      A,B
 495:	03F3  DE00    	        SBC     A,0
 496:	03F5  47      	        LD      B,A
 497:	03F6  3E00    	        LD      A,0
 498:	03F8  C9      	        RET
 499:	03F9  000000  	        .DB     0,0,0                   ; Random number seed table used by RND
 500:	03FC  354ACA99	        .DB     035H,04AH,0CAH,099H     ;-2.65145E+07
 501:	0400  391C7698	        .DB     039H,01CH,076H,098H     ; 1.61291E+07
 502:	0404  2295B398	        .DB     022H,095H,0B3H,098H     ;-1.17691E+07
 503:	0408  0ADD4798	        .DB     00AH,0DDH,047H,098H     ; 1.30983E+07
 504:	040C  53D19999	        .DB     053H,0D1H,099H,099H     ;-2-01612E+07
 505:	0410  0A1A9F98	        .DB     00AH,01AH,09FH,098H     ;-1.04269E+07
 506:	0414  65BCCD98	        .DB     065H,0BCH,0CDH,098H     ;-1.34831E+07
 507:	0418  D6773E98	        .DB     0D6H,077H,03EH,098H     ; 1.24825E+07
 508:	041C  52C74F80	        .DB     052H,0C7H,04FH,080H     ; Last random number
 509:	0420  DB00    	        IN      A,(0)           ; INP (x) skeleton
 510:	0422  C9      	        RET
 511:	0423  01      	        .DB     1               ; NULLS number (1)
 512:	0424  FF      	        .DB     255             ; Terminal width (255 = no auto CRLF)
 513:	0425  64      	        .DB     100             ; Width for commas -> 8 columns
 514:	0426  00      	        .DB     0               ; No nulls after input bytes
 515:	0427  00      	        .DB     0               ; Output enabled (^O off)
 516:	0428  1400    	        .DW     20              ; Initial lines counter
 517:	042A  1400    	        .DW     20              ; Initial lines number
 518:	042C  0000    	        .DW     0               ; Array load/save check sum
 519:	042E  00      	        .DB     0               ; Break not by NMI
 520:	042F  00      	        .DB     0               ; Break flag
 521:	0430  C3E206  	        JP      TTYLIN          ; Input reflection (set to TTY)
 522:	0433  C30000  	        JP      0000H           ; POINT(X) reflection unused
 523:	0436  C30000  	        JP      0000H           ; SET reflection
 524:	0439  C30000  	        JP      0000H          	; RESET reflection
 525:	043C  0022    	        .DW     STLOOK          ; Temp string space
 526:	043E  FEFF    	        .DW     -2              ; Current line number (cold)
 527:	0440  FA20    	        .DW     PROGST+1        ; Start of program text
 528:	0442          	INITBE:
 529:			
 530:			; END OF INITIALISATION TABLE ---------------------------------------------------
 531:			
 532:	0442  20457272	ERRMSG: .DB     " Error",0
	      6F7200
 533:	0449  20696E20	INMSG:  .DB     " in ",0
	      00
 534:	044D          	ZERBYT  .EQU    $-1             ; A zero byte
 535:	044E  4F6B0D0A	OKMSG:  .DB     "Ok",CR,LF,0,0
	      0000
 536:	0454  42726561	BRKMSG: .DB     "Break",0
	      6B00
 537:			
 538:	045A  210400  	BAKSTK: LD      HL,4            ; Look for "FOR" block with
 539:	045D  39      	        ADD     HL,SP           ; same index as specified
 540:	045E  7E      	LOKFOR: LD      A,(HL)          ; Get block ID
 541:	045F  23      	        INC     HL              ; Point to index address
 542:	0460  FE81    	        CP      ZFOR            ; Is it a "FOR" token
 543:	0462  C0      	        RET     NZ              ; No - exit
 544:	0463  4E      	        LD      C,(HL)          ; BC = Address of "FOR" index
 545:	0464  23      	        INC     HL
 546:	0465  46      	        LD      B,(HL)
 547:	0466  23      	        INC     HL              ; Point to sign of STEP
 548:	0467  E5      	        PUSH    HL              ; Save pointer to sign
 549:	0468  69      	        LD      L,C             ; HL = address of "FOR" index
 550:	0469  60      	        LD      H,B
 551:	046A  7A      	        LD      A,D             ; See if an index was specified
 552:	046B  B3      	        OR      E               ; DE = 0 if no index specified
 553:	046C  EB      	        EX      DE,HL           ; Specified index into HL
 554:	046D  CA7404  	        JP      Z,INDFND        ; Skip if no index given
 555:	0470  EB      	        EX      DE,HL           ; Index back into DE
 556:	0471  CD4507  	        CALL    CPDEHL          ; Compare index with one given
 557:	0474  010D00  	INDFND: LD      BC,16-3         ; Offset to next block
 558:	0477  E1      	        POP     HL              ; Restore pointer to sign
 559:	0478  C8      	        RET     Z               ; Return if block found
 560:	0479  09      	        ADD     HL,BC           ; Point to next block
 561:	047A  C35E04  	        JP      LOKFOR          ; Keep on looking
 562:			
 563:	047D  CD9704  	MOVUP:  CALL    ENFMEM          ; See if enough memory
 564:	0480  C5      	MOVSTR: PUSH    BC              ; Save end of source
 565:	0481  E3      	        EX      (SP),HL         ; Swap source and dest" end
 566:	0482  C1      	        POP     BC              ; Get end of destination
 567:	0483  CD4507  	MOVLP:  CALL    CPDEHL          ; See if list moved
 568:	0486  7E      	        LD      A,(HL)          ; Get byte
 569:	0487  02      	        LD      (BC),A          ; Move it
 570:	0488  C8      	        RET     Z               ; Exit if all done
 571:	0489  0B      	        DEC     BC              ; Next byte to move to
 572:	048A  2B      	        DEC     HL              ; Next byte to move
 573:	048B  C38304  	        JP      MOVLP           ; Loop until all bytes moved
 574:			
 575:	048E  E5      	CHKSTK: PUSH    HL              ; Save code string address
 576:	048F  2ADA20  	        LD      HL,(ARREND)     ; Lowest free memory
 577:	0492  0600    	        LD      B,0             ; BC = Number of levels to test
 578:	0494  09      	        ADD     HL,BC           ; 2 Bytes for each level
 579:	0495  09      	        ADD     HL,BC
 580:	0496  3E      	        .DB     3EH             ; Skip "PUSH HL"
 581:	0497  E5      	ENFMEM: PUSH    HL              ; Save code string address
 582:	0498  3ED0    	        LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
 583:	049A  95      	        SUB     L
 584:	049B  6F      	        LD      L,A
 585:	049C  3EFF    	        LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
 586:	049E  9C      	        SBC     A,H
 587:	049F  DAA604  	        JP      C,OMERR         ; Not enough - ?OM Error
 588:	04A2  67      	        LD      H,A
 589:	04A3  39      	        ADD     HL,SP           ; Test if stack is overflowed
 590:	04A4  E1      	        POP     HL              ; Restore code string address
 591:	04A5  D8      	        RET     C               ; Return if enough mmory
 592:	04A6  1E0C    	OMERR:  LD      E,OM            ; ?OM Error
 593:	04A8  C3C504  	        JP      ERROR
 594:			
 595:	04AB  2AC920  	DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
 596:	04AE  225C20  	        LD      (LINEAT),HL     ; Save as current line
 597:	04B1  1E02    	SNERR:  LD      E,SN            ; ?SN Error
 598:	04B3  01      	        .DB     01H             ; Skip "LD E,DZ"
 599:	04B4  1E14    	DZERR:  LD      E,DZ            ; ?/0 Error
 600:	04B6  01      	        .DB     01H             ; Skip "LD E,NF"
 601:	04B7  1E00    	NFERR:  LD      E,NF            ; ?NF Error
 602:	04B9  01      	        .DB     01H             ; Skip "LD E,DD"
 603:	04BA  1E12    	DDERR:  LD      E,DD            ; ?DD Error
 604:	04BC  01      	        .DB     01H             ; Skip "LD E,UF"
 605:	04BD  1E22    	UFERR:  LD      E,UF            ; ?UF Error
 606:	04BF  01      	        .DB     01H             ; Skip "LD E,OV
 607:	04C0  1E0A    	OVERR:  LD      E,OV            ; ?OV Error
 608:	04C2  01      	        .DB     01H             ; Skip "LD E,TM"
 609:	04C3  1E18    	TMERR:  LD      E,TM            ; ?TM Error
 610:			
 611:	04C5  CDE305  	ERROR:  CALL    CLREG           ; Clear registers and stack
 612:	04C8  324520  	        LD      (CTLOFG),A      ; Enable output (A is 0)
 613:	04CB  CD760B  	        CALL    STTLIN          ; Start new line
 614:	04CE  21B803  	        LD      HL,ERRORS       ; Point to error codes
 615:	04D1  57      	        LD      D,A             ; D = 0 (A is 0)
 616:	04D2  3E3F    	        LD      A,'?'
 617:	04D4  CD5607  	        CALL    OUTC            ; Output '?'
 618:	04D7  19      	        ADD     HL,DE           ; Offset to correct error code
 619:	04D8  7E      	        LD      A,(HL)          ; First character
 620:	04D9  CD5607  	        CALL    OUTC            ; Output it
 621:	04DC  CDD508  	        CALL    GETCHR          ; Get next character
 622:	04DF  CD5607  	        CALL    OUTC            ; Output it
 623:	04E2  214204  	        LD      HL,ERRMSG       ; "Error" message
 624:	04E5  CD2112  	ERRIN:  CALL    PRS             ; Output message
 625:	04E8  2A5C20  	        LD      HL,(LINEAT)     ; Get line of error
 626:	04EB  11FEFF  	        LD      DE,-2           ; Cold start error if -2
 627:	04EE  CD4507  	        CALL    CPDEHL          ; See if cold start error
 628:	04F1  CA0C01  	        JP      Z,CSTART        ; Cold start error - Restart
 629:	04F4  7C      	        LD      A,H             ; Was it a direct error?
 630:	04F5  A5      	        AND     L               ; Line = -1 if direct error
 631:	04F6  3C      	        INC     A
 632:	04F7  C4BC18  	        CALL    NZ,LINEIN       ; No - output line of error
 633:	04FA  3E      	        .DB     3EH             ; Skip "POP BC"
 634:	04FB  C1      	POPNOK: POP     BC              ; Drop address in input buffer
 635:			
 636:	04FC  AF      	PRNTOK: XOR     A               ; Output "Ok" and get command
 637:	04FD  324520  	        LD      (CTLOFG),A      ; Enable output
 638:	0500  CD760B  	        CALL    STTLIN          ; Start new line
 639:	0503  214E04  	        LD      HL,OKMSG        ; "Ok" message
 640:	0506  CD2112  	        CALL    PRS             ; Output "Ok"
 641:	0509  21FFFF  	GETCMD: LD      HL,-1           ; Flag direct mode
 642:	050C  225C20  	        LD      (LINEAT),HL     ; Save as current line
 643:	050F  CDE206  	        CALL    GETLIN          ; Get an input line
 644:	0512  DA0905  	        JP      C,GETCMD        ; Get line again if break
 645:	0515  CDD508  	        CALL    GETCHR          ; Get first character
 646:	0518  3C      	        INC     A               ; Test if end of line
 647:	0519  3D      	        DEC     A               ; Without affecting Carry
 648:	051A  CA0905  	        JP      Z,GETCMD        ; Nothing entered - Get another
 649:	051D  F5      	        PUSH    AF              ; Save Carry status
 650:	051E  CDA709  	        CALL    ATOH            ; Get line number into DE
 651:	0521  D5      	        PUSH    DE              ; Save line number
 652:	0522  CD0D06  	        CALL    CRUNCH          ; Tokenise rest of line
 653:	0525  47      	        LD      B,A             ; Length of tokenised line
 654:	0526  D1      	        POP     DE              ; Restore line number
 655:	0527  F1      	        POP     AF              ; Restore Carry
 656:	0528  D2B508  	        JP      NC,EXCUTE       ; No line number - Direct mode
 657:	052B  D5      	        PUSH    DE              ; Save line number
 658:	052C  C5      	        PUSH    BC              ; Save length of tokenised line
 659:	052D  AF      	        XOR     A
 660:	052E  32CC20  	        LD      (LSTBIN),A      ; Clear last byte input
 661:	0531  CDD508  	        CALL    GETCHR          ; Get next character
 662:	0534  B7      	        OR      A               ; Set flags
 663:	0535  F5      	        PUSH    AF              ; And save them
 664:	0536  CD9D05  	        CALL    SRCHLN          ; Search for line number in DE
 665:	0539  DA4205  	        JP      C,LINFND        ; Jump if line found
 666:	053C  F1      	        POP     AF              ; Get status
 667:	053D  F5      	        PUSH    AF              ; And re-save
 668:	053E  CA480A  	        JP      Z,ULERR         ; Nothing after number - Error
 669:	0541  B7      	        OR      A               ; Clear Carry
 670:	0542  C5      	LINFND: PUSH    BC              ; Save address of line in prog
 671:	0543  D25905  	        JP      NC,INEWLN       ; Line not found - Insert new
 672:	0546  EB      	        EX      DE,HL           ; Next line address in DE
 673:	0547  2AD620  	        LD      HL,(PROGND)     ; End of program
 674:	054A  1A      	SFTPRG: LD      A,(DE)          ; Shift rest of program down
 675:	054B  02      	        LD      (BC),A
 676:	054C  03      	        INC     BC              ; Next destination
 677:	054D  13      	        INC     DE              ; Next source
 678:	054E  CD4507  	        CALL    CPDEHL          ; All done?
 679:	0551  C24A05  	        JP      NZ,SFTPRG       ; More to do
 680:	0554  60      	        LD      H,B             ; HL - New end of program
 681:	0555  69      	        LD      L,C
 682:	0556  22D620  	        LD      (PROGND),HL     ; Update end of program
 683:			
 684:	0559  D1      	INEWLN: POP     DE              ; Get address of line,
 685:	055A  F1      	        POP     AF              ; Get status
 686:	055B  CA8005  	        JP      Z,SETPTR        ; No text - Set up pointers
 687:	055E  2AD620  	        LD      HL,(PROGND)     ; Get end of program
 688:	0561  E3      	        EX      (SP),HL         ; Get length of input line
 689:	0562  C1      	        POP     BC              ; End of program to BC
 690:	0563  09      	        ADD     HL,BC           ; Find new end
 691:	0564  E5      	        PUSH    HL              ; Save new end
 692:	0565  CD7D04  	        CALL    MOVUP           ; Make space for line
 693:	0568  E1      	        POP     HL              ; Restore new end
 694:	0569  22D620  	        LD      (PROGND),HL     ; Update end of program pointer
 695:	056C  EB      	        EX      DE,HL           ; Get line to move up in HL
 696:	056D  74      	        LD      (HL),H          ; Save MSB
 697:	056E  D1      	        POP     DE              ; Get new line number
 698:	056F  23      	        INC     HL              ; Skip pointer
 699:	0570  23      	        INC     HL
 700:	0571  73      	        LD      (HL),E          ; Save LSB of line number
 701:	0572  23      	        INC     HL
 702:	0573  72      	        LD      (HL),D          ; Save MSB of line number
 703:	0574  23      	        INC     HL              ; To first byte in line
 704:	0575  116120  	        LD      DE,BUFFER       ; Copy buffer to program
 705:	0578  1A      	MOVBUF: LD      A,(DE)          ; Get source
 706:	0579  77      	        LD      (HL),A          ; Save destinations
 707:	057A  23      	        INC     HL              ; Next source
 708:	057B  13      	        INC     DE              ; Next destination
 709:	057C  B7      	        OR      A               ; Done?
 710:	057D  C27805  	        JP      NZ,MOVBUF       ; No - Repeat
 711:	0580  CDC905  	SETPTR: CALL    RUNFST          ; Set line pointers
 712:	0583  23      	        INC     HL              ; To LSB of pointer
 713:	0584  EB      	        EX      DE,HL           ; Address to DE
 714:	0585  62      	PTRLP:  LD      H,D             ; Address to HL
 715:	0586  6B      	        LD      L,E
 716:	0587  7E      	        LD      A,(HL)          ; Get LSB of pointer
 717:	0588  23      	        INC     HL              ; To MSB of pointer
 718:	0589  B6      	        OR      (HL)            ; Compare with MSB pointer
 719:	058A  CA0905  	        JP      Z,GETCMD        ; Get command line if end
 720:	058D  23      	        INC     HL              ; To LSB of line number
 721:	058E  23      	        INC     HL              ; Skip line number
 722:	058F  23      	        INC     HL              ; Point to first byte in line
 723:	0590  AF      	        XOR     A               ; Looking for 00 byte
 724:	0591  BE      	FNDEND: CP      (HL)            ; Found end of line?
 725:	0592  23      	        INC     HL              ; Move to next byte
 726:	0593  C29105  	        JP      NZ,FNDEND       ; No - Keep looking
 727:	0596  EB      	        EX      DE,HL           ; Next line address to HL
 728:	0597  73      	        LD      (HL),E          ; Save LSB of pointer
 729:	0598  23      	        INC     HL
 730:	0599  72      	        LD      (HL),D          ; Save MSB of pointer
 731:	059A  C38505  	        JP      PTRLP           ; Do next line
 732:			
 733:	059D  2A5E20  	SRCHLN: LD      HL,(BASTXT)     ; Start of program text
 734:	05A0  44      	SRCHLP: LD      B,H             ; BC = Address to look at
 735:	05A1  4D      	        LD      C,L
 736:	05A2  7E      	        LD      A,(HL)          ; Get address of next line
 737:	05A3  23      	        INC     HL
 738:	05A4  B6      	        OR      (HL)            ; End of program found?
 739:	05A5  2B      	        DEC     HL
 740:	05A6  C8      	        RET     Z               ; Yes - Line not found
 741:	05A7  23      	        INC     HL
 742:	05A8  23      	        INC     HL
 743:	05A9  7E      	        LD      A,(HL)          ; Get LSB of line number
 744:	05AA  23      	        INC     HL
 745:	05AB  66      	        LD      H,(HL)          ; Get MSB of line number
 746:	05AC  6F      	        LD      L,A
 747:	05AD  CD4507  	        CALL    CPDEHL          ; Compare with line in DE
 748:	05B0  60      	        LD      H,B             ; HL = Start of this line
 749:	05B1  69      	        LD      L,C
 750:	05B2  7E      	        LD      A,(HL)          ; Get LSB of next line address
 751:	05B3  23      	        INC     HL
 752:	05B4  66      	        LD      H,(HL)          ; Get MSB of next line address
 753:	05B5  6F      	        LD      L,A             ; Next line to HL
 754:	05B6  3F      	        CCF
 755:	05B7  C8      	        RET     Z               ; Lines found - Exit
 756:	05B8  3F      	        CCF
 757:	05B9  D0      	        RET     NC              ; Line not found,at line after
 758:	05BA  C3A005  	        JP      SRCHLP          ; Keep looking
 759:			
 760:	05BD  C0      	NEW:    RET     NZ              ; Return if any more on line
 761:	05BE  2A5E20  	CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
 762:	05C1  AF      	        XOR     A               ; Set program area to empty
 763:	05C2  77      	        LD      (HL),A          ; Save LSB = 00
 764:	05C3  23      	        INC     HL
 765:	05C4  77      	        LD      (HL),A          ; Save MSB = 00
 766:	05C5  23      	        INC     HL
 767:	05C6  22D620  	        LD      (PROGND),HL     ; Set program end
 768:			
 769:	05C9  2A5E20  	RUNFST: LD      HL,(BASTXT)     ; Clear all variables
 770:	05CC  2B      	        DEC     HL
 771:			
 772:	05CD  22CE20  	INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
 773:	05D0  2AAF20  	        LD      HL,(LSTRAM)     ; Get end of RAM
 774:	05D3  22C320  	        LD      (STRBOT),HL     ; Clear string space
 775:	05D6  AF      	        XOR     A
 776:	05D7  CDE508  	        CALL    RESTOR          ; Reset DATA pointers
 777:	05DA  2AD620  	        LD      HL,(PROGND)     ; Get end of program
 778:	05DD  22D820  	        LD      (VAREND),HL     ; Clear variables
 779:	05E0  22DA20  	        LD      (ARREND),HL     ; Clear arrays
 780:			
 781:	05E3  C1      	CLREG:  POP     BC              ; Save return address
 782:	05E4  2A5A20  	        LD      HL,(STRSPC)     ; Get end of working RAN
 783:	05E7  F9      	        LD      SP,HL           ; Set stack
 784:	05E8  21B320  	        LD      HL,TMSTPL       ; Temporary string pool
 785:	05EB  22B120  	        LD      (TMSTPT),HL     ; Reset temporary string ptr
 786:	05EE  AF      	        XOR     A               ; A = 00
 787:	05EF  6F      	        LD      L,A             ; HL = 0000
 788:	05F0  67      	        LD      H,A
 789:	05F1  22D420  	        LD      (CONTAD),HL     ; No CONTinue
 790:	05F4  32CB20  	        LD      (FORFLG),A      ; Clear FOR flag
 791:	05F7  22DE20  	        LD      (FNRGNM),HL     ; Clear FN argument
 792:	05FA  E5      	        PUSH    HL              ; HL = 0000
 793:	05FB  C5      	        PUSH    BC              ; Put back return
 794:	05FC  2ACE20  	DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
 795:	05FF  C9      	        RET                     ; Return to execution driver
 796:			
 797:	0600  3E3F    	PROMPT: LD      A,'?'           ; '?'
 798:	0602  CD5607  	        CALL    OUTC            ; Output character
 799:	0605  3E20    	        LD      A,' '           ; Space
 800:	0607  CD5607  	        CALL    OUTC            ; Output character
 801:	060A  C34E20  	        JP      RINPUT          ; Get input line
 802:			
 803:	060D  AF      	CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
 804:	060E  32AE20  	        LD      (DATFLG),A      ; Reset literal flag
 805:	0611  0E05    	        LD      C,2+3           ; 2 byte number and 3 nulls
 806:	0613  116120  	        LD      DE,BUFFER       ; Start of input buffer
 807:	0616  7E      	CRNCLP: LD      A,(HL)          ; Get byte
 808:	0617  FE20    	        CP      ' '             ; Is it a space?
 809:	0619  CA9506  	        JP      Z,MOVDIR        ; Yes - Copy direct
 810:	061C  47      	        LD      B,A             ; Save character
 811:	061D  FE22    	        CP      '"'             ; Is it a quote?
 812:	061F  CAB506  	        JP      Z,CPYLIT        ; Yes - Copy literal string
 813:	0622  B7      	        OR      A               ; Is it end of buffer?
 814:	0623  CABC06  	        JP      Z,ENDBUF        ; Yes - End buffer
 815:	0626  3AAE20  	        LD      A,(DATFLG)      ; Get data type
 816:	0629  B7      	        OR      A               ; Literal?
 817:	062A  7E      	        LD      A,(HL)          ; Get byte to copy
 818:	062B  C29506  	        JP      NZ,MOVDIR       ; Literal - Copy direct
 819:	062E  FE3F    	        CP      '?'             ; Is it '?' short for PRINT
 820:	0630  3E9E    	        LD      A,ZPRINT        ; "PRINT" token
 821:	0632  CA9506  	        JP      Z,MOVDIR        ; Yes - replace it
 822:	0635  7E      	        LD      A,(HL)          ; Get byte again
 823:	0636  FE30    	        CP      '0'             ; Is it less than '0'
 824:	0638  DA4006  	        JP      C,FNDWRD        ; Yes - Look for reserved words
 825:	063B  FE3C    	        CP      60; ";"+1           ; Is it "0123456789:;" ?
 826:	063D  DA9506  	        JP      C,MOVDIR        ; Yes - copy it direct
 827:	0640  D5      	FNDWRD: PUSH    DE              ; Look for reserved words
 828:	0641  113902  	        LD      DE,WORDS-1      ; Point to table
 829:	0644  C5      	        PUSH    BC              ; Save count
 830:	0645  019106  	        LD      BC,RETNAD       ; Where to return to
 831:	0648  C5      	        PUSH    BC              ; Save return address
 832:	0649  067F    	        LD      B,ZEND-1        ; First token value -1
 833:	064B  7E      	        LD      A,(HL)          ; Get byte
 834:	064C  FE61    	        CP      'a'             ; Less than 'a' ?
 835:	064E  DA5906  	        JP      C,SEARCH        ; Yes - search for words
 836:	0651  FE7B    	        CP      'z'+1           ; Greater than 'z' ?
 837:	0653  D25906  	        JP      NC,SEARCH       ; Yes - search for words
 838:	0656  E65F    	        AND     01011111B       ; Force upper case
 839:	0658  77      	        LD      (HL),A          ; Replace byte
 840:	0659  4E      	SEARCH: LD      C,(HL)          ; Search for a word
 841:	065A  EB      	        EX      DE,HL
 842:	065B  23      	GETNXT: INC     HL              ; Get next reserved word
 843:	065C  B6      	        OR      (HL)            ; Start of word?
 844:	065D  F25B06  	        JP      P,GETNXT        ; No - move on
 845:	0660  04      	        INC     B               ; Increment token value
 846:	0661  7E      	        LD      A, (HL)         ; Get byte from table
 847:	0662  E67F    	        AND     01111111B       ; Strip bit 7
 848:	0664  C8      	        RET     Z               ; Return if end of list
 849:	0665  B9      	        CP      C               ; Same character as in buffer?
 850:	0666  C25B06  	        JP      NZ,GETNXT       ; No - get next word
 851:	0669  EB      	        EX      DE,HL
 852:	066A  E5      	        PUSH    HL              ; Save start of word
 853:			
 854:	066B  13      	NXTBYT: INC     DE              ; Look through rest of word
 855:	066C  1A      	        LD      A,(DE)          ; Get byte from table
 856:	066D  B7      	        OR      A               ; End of word ?
 857:	066E  FA8D06  	        JP      M,MATCH         ; Yes - Match found
 858:	0671  4F      	        LD      C,A             ; Save it
 859:	0672  78      	        LD      A,B             ; Get token value
 860:	0673  FE88    	        CP      ZGOTO           ; Is it "GOTO" token ?
 861:	0675  C27C06  	        JP      NZ,NOSPC        ; No - Don't allow spaces
 862:	0678  CDD508  	        CALL    GETCHR          ; Get next character
 863:	067B  2B      	        DEC     HL              ; Cancel increment from GETCHR
 864:	067C  23      	NOSPC:  INC     HL              ; Next byte
 865:	067D  7E      	        LD      A,(HL)          ; Get byte
 866:	067E  FE61    	        CP      'a'             ; Less than 'a' ?
 867:	0680  DA8506  	        JP      C,NOCHNG        ; Yes - don't change
 868:	0683  E65F    	        AND     01011111B       ; Make upper case
 869:	0685  B9      	NOCHNG: CP      C               ; Same as in buffer ?
 870:	0686  CA6B06  	        JP      Z,NXTBYT        ; Yes - keep testing
 871:	0689  E1      	        POP     HL              ; Get back start of word
 872:	068A  C35906  	        JP      SEARCH          ; Look at next word
 873:			
 874:	068D  48      	MATCH:  LD      C,B             ; Word found - Save token value
 875:	068E  F1      	        POP     AF              ; Throw away return
 876:	068F  EB      	        EX      DE,HL
 877:	0690  C9      	        RET                     ; Return to "RETNAD"
 878:	0691  EB      	RETNAD: EX      DE,HL           ; Get address in string
 879:	0692  79      	        LD      A,C             ; Get token value
 880:	0693  C1      	        POP     BC              ; Restore buffer length
 881:	0694  D1      	        POP     DE              ; Get destination address
 882:	0695  23      	MOVDIR: INC     HL              ; Next source in buffer
 883:	0696  12      	        LD      (DE),A          ; Put byte in buffer
 884:	0697  13      	        INC     DE              ; Move up buffer
 885:	0698  0C      	        INC     C               ; Increment length of buffer
 886:	0699  D63A    	        SUB     ':'             ; End of statement?
 887:	069B  CAA306  	        JP      Z,SETLIT        ; Jump if multi-statement line
 888:	069E  FE49    	        CP      ZDATA-3AH       ; Is it DATA statement ?
 889:	06A0  C2A606  	        JP      NZ,TSTREM       ; No - see if REM
 890:	06A3  32AE20  	SETLIT: LD      (DATFLG),A      ; Set literal flag
 891:	06A6  D654    	TSTREM: SUB     ZREM-3AH        ; Is it REM?
 892:	06A8  C21606  	        JP      NZ,CRNCLP       ; No - Leave flag
 893:	06AB  47      	        LD      B,A             ; Copy rest of buffer
 894:	06AC  7E      	NXTCHR: LD      A,(HL)          ; Get byte
 895:	06AD  B7      	        OR      A               ; End of line ?
 896:	06AE  CABC06  	        JP      Z,ENDBUF        ; Yes - Terminate buffer
 897:	06B1  B8      	        CP      B               ; End of statement ?
 898:	06B2  CA9506  	        JP      Z,MOVDIR        ; Yes - Get next one
 899:	06B5  23      	CPYLIT: INC     HL              ; Move up source string
 900:	06B6  12      	        LD      (DE),A          ; Save in destination
 901:	06B7  0C      	        INC     C               ; Increment length
 902:	06B8  13      	        INC     DE              ; Move up destination
 903:	06B9  C3AC06  	        JP      NXTCHR          ; Repeat
 904:			
 905:	06BC  216020  	ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
 906:	06BF  12      	        LD      (DE),A          ; Mark end of buffer (A = 00)
 907:	06C0  13      	        INC     DE
 908:	06C1  12      	        LD      (DE),A          ; A = 00
 909:	06C2  13      	        INC     DE
 910:	06C3  12      	        LD      (DE),A          ; A = 00
 911:	06C4  C9      	        RET
 912:			
 913:	06C5  05      	DELCHR: DEC     B               ; Count bytes in buffer
 914:	06C6  2B      	        DEC     HL              ; Back space buffer
 915:	06C7  3E08    	        LD      A,BKSP
 916:	06C9  CD5607  	        CALL    OUTC            ; Back one char
 917:	06CC  3E20    	        LD      A,SPACE
 918:	06CE  CD5607  	        CALL    OUTC            ; Overwrite char
 919:	06D1  3E08    	        LD      A,BKSP
 920:	06D3  CD5607  	        CALL    OUTC            ; Back one char
 921:	06D6  C2E706  	        JP      NZ,MORINP       ; Not end - Get more
 922:	06D9  CD5607  	OTKLN:  CALL    OUTC            ; Output character in A
 923:	06DC  CD830B  	KILIN:  CALL    PRNTCRLF        ; Output CRLF
 924:	06DF  C3E206  	        JP      TTYLIN          ; Get line again
 925:			
 926:	06E2          	GETLIN:
 927:	06E2  216120  	TTYLIN: LD      HL,BUFFER       ; Get a line by character
 928:	06E5  0601    	        LD      B,1             ; Set buffer as empty
 929:	06E7  CD8007  	MORINP: CALL    CLOTST          ; Get character and test ^O
 930:	06EA  4F      	        LD      C,A             ; Save character in C
 931:	06EB  79      	PROCES: LD      A,C             ; Get character
 932:	06EC  FE03    	        CP      CTRLC           ; Is it control "C"?
 933:	06EE  CC830B  	        CALL    Z,PRNTCRLF      ; Yes - Output CRLF
 934:	06F1  37      	        SCF                     ; Flag break
 935:	06F2  C8      	        RET     Z               ; Return if control "C"
 936:	06F3  FE0D    	        CP      CR              ; Is it enter?
 937:	06F5  CA7E0B  	        JP      Z,ENDINP        ; Yes - Terminate input
 938:	06F8  FE15    	        CP      CTRLU           ; Is it control "U"?
 939:	06FA  CADC06  	        JP      Z,KILIN         ; Yes - Get another line
 940:	06FD  FE18    	        CP      CAN             ; Is it "kill line"?
 941:	06FF  CADC06  	        JP      Z,KILIN ;OTKLN         ; Yes - Kill line
 942:	0702  FE7F    	        CP      DEL             ; Is it delete?
 943:	0704  CAC506  	        JP      Z,DELCHR        ; Yes - Delete character
 944:	0707  FE08    	        CP      BKSP            ; Is it backspace?
 945:	0709  CAC506  	        JP      Z,DELCHR        ; Yes - Delete character
 946:	070C  FE12    	        CP      CTRLR           ; Is it control "R"?
 947:	070E  C22507  	        JP      NZ,PUTBUF       ; No - Put in buffer
 948:	0711  C5      	        PUSH    BC              ; Save buffer length
 949:	0712  D5      	        PUSH    DE              ; Save DE
 950:	0713  E5      	        PUSH    HL              ; Save buffer address
 951:	0714  3600    	        LD      (HL),0          ; Mark end of buffer
 952:	0716  CD211D  	        CALL    OUTNCR          ; Output and do CRLF
 953:	0719  216120  	        LD      HL,BUFFER       ; Point to buffer start
 954:	071C  CD2112  	        CALL    PRS             ; Output buffer
 955:	071F  E1      	        POP     HL              ; Restore buffer address
 956:	0720  D1      	        POP     DE              ; Restore DE
 957:	0721  C1      	        POP     BC              ; Restore buffer length
 958:	0722  C3E706  	        JP      MORINP          ; Get another character
 959:			
 960:	0725  FE20    	PUTBUF: CP      ' '             ; Is it a control code?
 961:	0727  DAE706  	        JP      C,MORINP        ; Yes - Ignore
 962:	072A  78      	PUTCTL: LD      A,B             ; Get number of bytes in buffer
 963:	072B  FE49    	        CP      72+1            ; Test for line overflow
 964:	072D  DA3807  	        JP      C,PUTB1         ; No, carry on
 965:	0730  3E07    	        LD      A,CTRLG         ; Set a bell
 966:	0732  CD5607  	        CALL    OUTC            ; Ring bell if buffer full
 967:	0735  C3E706  	        JP      MORINP          ;
 968:	0738  79      	PUTB1:  LD      A,C             ; Get character
 969:	0739  71      	        LD      (HL),C          ; Save in buffer
 970:	073A  32CC20  	        LD      (LSTBIN),A      ; Save last input byte
 971:	073D  23      	        INC     HL              ; Move up buffer
 972:	073E  04      	        INC     B               ; Increment length
 973:	073F  CD5607  	OUTIT:  CALL    OUTC            ; Output the character entered
 974:	0742  C3E706  	        JP      MORINP          ; Get another character
 975:			
 976:	0745  7C      	CPDEHL: LD      A,H             ; Get H
 977:	0746  92      	        SUB     D               ; Compare with D
 978:	0747  C0      	        RET     NZ              ; Different - Exit
 979:	0748  7D      	        LD      A,L             ; Get L
 980:	0749  93      	        SUB     E               ; Compare with E
 981:	074A  C9      	        RET                     ; Return status
 982:			
 983:	074B  7E      	CHKSYN: LD      A,(HL)          ; Check syntax of character
 984:	074C  E3      	        EX      (SP),HL         ; Address of test byte
 985:	074D  BE      	        CP      (HL)            ; Same as in code string?
 986:	074E  23      	        INC     HL              ; Return address
 987:	074F  E3      	        EX      (SP),HL         ; Put it back
 988:	0750  CAD508  	        JP      Z,GETCHR        ; Yes - Get next character
 989:	0753  C3B104  	        JP      SNERR           ; Different - ?SN Error
 990:			
 991:	0756  F5      	OUTC:   PUSH    AF              ; Save character
 992:	0757  3A4520  	        LD      A,(CTLOFG)      ; Get control "O" flag
 993:	075A  B7      	        OR      A               ; Is it set?
 994:	075B  C25612  	        JP      NZ,POPAF        ; Yes - don't output
 995:	075E  F1      	        POP     AF              ; Restore character
 996:	075F  C5      	        PUSH    BC              ; Save buffer length
 997:	0760  F5      	        PUSH    AF              ; Save character
 998:	0761  FE20    	        CP      ' '             ; Is it a control code?
 999:	0763  DA7A07  	        JP      C,DINPOS        ; Yes - Don't INC POS(X)
1000:	0766  3A4220  	        LD      A,(LWIDTH)      ; Get line width
1001:	0769  47      	        LD      B,A             ; To B
1002:	076A  3AAB20  	        LD      A,(CURPOS)      ; Get cursor position
1003:	076D  04      	        INC     B               ; Width 255?
1004:	076E  CA7607  	        JP      Z,INCLEN        ; Yes - No width limit
1005:	0771  05      	        DEC     B               ; Restore width
1006:	0772  B8      	        CP      B               ; At end of line?
1007:	0773  CC830B  	        CALL    Z,PRNTCRLF      ; Yes - output CRLF
1008:	0776  3C      	INCLEN: INC     A               ; Move on one character
1009:	0777  32AB20  	        LD      (CURPOS),A      ; Save new position
1010:	077A  F1      	DINPOS: POP     AF              ; Restore character
1011:	077B  C1      	        POP     BC              ; Restore buffer length
1012:	077C  CD331D  	        CALL    CHROUT          ; Send it
1013:	077F  C9      	        RET
1014:			
1015:	0780  CDE01B  	CLOTST: CALL    GETINP          ; Get input character
1016:	0783  E67F    	        AND     01111111B       ; Strip bit 7
1017:	0785  FE0F    	        CP      CTRLO           ; Is it control "O"?
1018:	0787  C0      	        RET     NZ              ; No don't flip flag
1019:	0788  3A4520  	        LD      A,(CTLOFG)      ; Get flag
1020:	078B  2F      	        CPL                     ; Flip it
1021:	078C  324520  	        LD      (CTLOFG),A      ; Put it back
1022:	078F  AF      	        XOR     A               ; Null character
1023:	0790  C9      	        RET
1024:			
1025:	0791  CDA709  	LIST:   CALL    ATOH            ; ASCII number to DE
1026:	0794  C0      	        RET     NZ              ; Return if anything extra
1027:	0795  C1      	        POP     BC              ; Rubbish - Not needed
1028:	0796  CD9D05  	        CALL    SRCHLN          ; Search for line number in DE
1029:	0799  C5      	        PUSH    BC              ; Save address of line
1030:	079A  CDE707  	        CALL    SETLIN          ; Set up lines counter
1031:	079D  E1      	LISTLP: POP     HL              ; Restore address of line
1032:	079E  4E      	        LD      C,(HL)          ; Get LSB of next line
1033:	079F  23      	        INC     HL
1034:	07A0  46      	        LD      B,(HL)          ; Get MSB of next line
1035:	07A1  23      	        INC     HL
1036:	07A2  78      	        LD      A,B             ; BC = 0 (End of program)?
1037:	07A3  B1      	        OR      C
1038:	07A4  CAFC04  	        JP      Z,PRNTOK        ; Yes - Go to command mode
1039:	07A7  CDF007  	        CALL    COUNT           ; Count lines
1040:	07AA  CD0009  	        CALL    TSTBRK          ; Test for break key
1041:	07AD  C5      	        PUSH    BC              ; Save address of next line
1042:	07AE  CD830B  	        CALL    PRNTCRLF        ; Output CRLF
1043:	07B1  5E      	        LD      E,(HL)          ; Get LSB of line number
1044:	07B2  23      	        INC     HL
1045:	07B3  56      	        LD      D,(HL)          ; Get MSB of line number
1046:	07B4  23      	        INC     HL
1047:	07B5  E5      	        PUSH    HL              ; Save address of line start
1048:	07B6  EB      	        EX      DE,HL           ; Line number to HL
1049:	07B7  CDC418  	        CALL    PRNTHL          ; Output line number in decimal
1050:	07BA  3E20    	        LD      A,' '           ; Space after line number
1051:	07BC  E1      	        POP     HL              ; Restore start of line address
1052:	07BD  CD5607  	LSTLP2: CALL    OUTC            ; Output character in A
1053:	07C0  7E      	LSTLP3: LD      A,(HL)          ; Get next byte in line
1054:	07C1  B7      	        OR      A               ; End of line?
1055:	07C2  23      	        INC     HL              ; To next byte in line
1056:	07C3  CA9D07  	        JP      Z,LISTLP        ; Yes - get next line
1057:	07C6  F2BD07  	        JP      P,LSTLP2        ; No token - output it
1058:	07C9  D67F    	        SUB     ZEND-1          ; Find and output word
1059:	07CB  4F      	        LD      C,A             ; Token offset+1 to C
1060:	07CC  113A02  	        LD      DE,WORDS        ; Reserved word list
1061:	07CF  1A      	FNDTOK: LD      A,(DE)          ; Get character in list
1062:	07D0  13      	        INC     DE              ; Move on to next
1063:	07D1  B7      	        OR      A               ; Is it start of word?
1064:	07D2  F2CF07  	        JP      P,FNDTOK        ; No - Keep looking for word
1065:	07D5  0D      	        DEC     C               ; Count words
1066:	07D6  C2CF07  	        JP      NZ,FNDTOK       ; Not there - keep looking
1067:	07D9  E67F    	OUTWRD: AND     01111111B       ; Strip bit 7
1068:	07DB  CD5607  	        CALL    OUTC            ; Output first character
1069:	07DE  1A      	        LD      A,(DE)          ; Get next character
1070:	07DF  13      	        INC     DE              ; Move on to next
1071:	07E0  B7      	        OR      A               ; Is it end of word?
1072:	07E1  F2D907  	        JP      P,OUTWRD        ; No - output the rest
1073:	07E4  C3C007  	        JP      LSTLP3          ; Next byte in line
1074:			
1075:	07E7  E5      	SETLIN: PUSH    HL              ; Set up LINES counter
1076:	07E8  2A4820  	        LD      HL,(LINESN)     ; Get LINES number
1077:	07EB  224620  	        LD      (LINESC),HL     ; Save in LINES counter
1078:	07EE  E1      	        POP     HL
1079:	07EF  C9      	        RET
1080:			
1081:	07F0  E5      	COUNT:  PUSH    HL              ; Save code string address
1082:	07F1  D5      	        PUSH    DE
1083:	07F2  2A4620  	        LD      HL,(LINESC)     ; Get LINES counter
1084:	07F5  11FFFF  	        LD      DE,-1
1085:	07F8  ED5A    	        ADC     HL,DE           ; Decrement
1086:	07FA  224620  	        LD      (LINESC),HL     ; Put it back
1087:	07FD  D1      	        POP     DE
1088:	07FE  E1      	        POP     HL              ; Restore code string address
1089:	07FF  F0      	        RET     P               ; Return if more lines to go
1090:	0800  E5      	        PUSH    HL              ; Save code string address
1091:	0801  2A4820  	        LD      HL,(LINESN)     ; Get LINES number
1092:	0804  224620  	        LD      (LINESC),HL     ; Reset LINES counter
1093:	0807  CDE01B  	        CALL    GETINP          ; Get input character
1094:	080A  FE03    	        CP      CTRLC           ; Is it control "C"?
1095:	080C  CA1308  	        JP      Z,RSLNBK        ; Yes - Reset LINES and break
1096:	080F  E1      	        POP     HL              ; Restore code string address
1097:	0810  C3F007  	        JP      COUNT           ; Keep on counting
1098:			
1099:	0813  2A4820  	RSLNBK: LD      HL,(LINESN)     ; Get LINES number
1100:	0816  224620  	        LD      (LINESC),HL     ; Reset LINES counter
1101:	0819  C3A401  	        JP      BRKRET          ; Go and output "Break"
1102:			
1103:	081C  3E64    	FOR:    LD      A,64H           ; Flag "FOR" assignment
1104:	081E  32CB20  	        LD      (FORFLG),A      ; Save "FOR" flag
1105:	0821  CD890A  	        CALL    LET             ; Set up initial index
1106:	0824  C1      	        POP     BC              ; Drop RETurn address
1107:	0825  E5      	        PUSH    HL              ; Save code string address
1108:	0826  CD720A  	        CALL    DATA            ; Get next statement address
1109:	0829  22C720  	        LD      (LOOPST),HL     ; Save it for start of loop
1110:	082C  210200  	        LD      HL,2            ; Offset for "FOR" block
1111:	082F  39      	        ADD     HL,SP           ; Point to it
1112:	0830  CD5E04  	FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
1113:	0833  D1      	        POP     DE              ; Get code string address
1114:	0834  C24C08  	        JP      NZ,FORFND       ; No nesting found
1115:	0837  09      	        ADD     HL,BC           ; Move into "FOR" block
1116:	0838  D5      	        PUSH    DE              ; Save code string address
1117:	0839  2B      	        DEC     HL
1118:	083A  56      	        LD      D,(HL)          ; Get MSB of loop statement
1119:	083B  2B      	        DEC     HL
1120:	083C  5E      	        LD      E,(HL)          ; Get LSB of loop statement
1121:	083D  23      	        INC     HL
1122:	083E  23      	        INC     HL
1123:	083F  E5      	        PUSH    HL              ; Save block address
1124:	0840  2AC720  	        LD      HL,(LOOPST)     ; Get address of loop statement
1125:	0843  CD4507  	        CALL    CPDEHL          ; Compare the FOR loops
1126:	0846  E1      	        POP     HL              ; Restore block address
1127:	0847  C23008  	        JP      NZ,FORSLP       ; Different FORs - Find another
1128:	084A  D1      	        POP     DE              ; Restore code string address
1129:	084B  F9      	        LD      SP,HL           ; Remove all nested loops
1130:			
1131:	084C  EB      	FORFND: EX      DE,HL           ; Code string address to HL
1132:	084D  0E08    	        LD      C,8
1133:	084F  CD8E04  	        CALL    CHKSTK          ; Check for 8 levels of stack
1134:	0852  E5      	        PUSH    HL              ; Save code string address
1135:	0853  2AC720  	        LD      HL,(LOOPST)     ; Get first statement of loop
1136:	0856  E3      	        EX      (SP),HL         ; Save and restore code string
1137:	0857  E5      	        PUSH    HL              ; Re-save code string address
1138:	0858  2A5C20  	        LD      HL,(LINEAT)     ; Get current line number
1139:	085B  E3      	        EX      (SP),HL         ; Save and restore code string
1140:	085C  CD4B0D  	        CALL    TSTNUM          ; Make sure it's a number
1141:	085F  CD4B07  	        CALL    CHKSYN          ; Make sure "TO" is next
1142:	0862  A6      	        .DB     ZTO             ; "TO" token
1143:	0863  CD480D  	        CALL    GETNUM          ; Get "TO" expression value
1144:	0866  E5      	        PUSH    HL              ; Save code string address
1145:	0867  CD7617  	        CALL    BCDEFP          ; Move "TO" value to BCDE
1146:	086A  E1      	        POP     HL              ; Restore code string address
1147:	086B  C5      	        PUSH    BC              ; Save "TO" value in block
1148:	086C  D5      	        PUSH    DE
1149:	086D  010081  	        LD      BC,8100H        ; BCDE - 1 (default STEP)
1150:	0870  51      	        LD      D,C             ; C=0
1151:	0871  5A      	        LD      E,D             ; D=0
1152:	0872  7E      	        LD      A,(HL)          ; Get next byte in code string
1153:	0873  FEAB    	        CP      ZSTEP           ; See if "STEP" is stated
1154:	0875  3E01    	        LD      A,1             ; Sign of step = 1
1155:	0877  C28808  	        JP      NZ,SAVSTP       ; No STEP given - Default to 1
1156:	087A  CDD508  	        CALL    GETCHR          ; Jump over "STEP" token
1157:	087D  CD480D  	        CALL    GETNUM          ; Get step value
1158:	0880  E5      	        PUSH    HL              ; Save code string address
1159:	0881  CD7617  	        CALL    BCDEFP          ; Move STEP to BCDE
1160:	0884  CD2A17  	        CALL    TSTSGN          ; Test sign of FPREG
1161:	0887  E1      	        POP     HL              ; Restore code string address
1162:	0888  C5      	SAVSTP: PUSH    BC              ; Save the STEP value in block
1163:	0889  D5      	        PUSH    DE
1164:	088A  F5      	        PUSH    AF              ; Save sign of STEP
1165:	088B  33      	        INC     SP              ; Don't save flags
1166:	088C  E5      	        PUSH    HL              ; Save code string address
1167:	088D  2ACE20  	        LD      HL,(BRKLIN)     ; Get address of index variable
1168:	0890  E3      	        EX      (SP),HL         ; Save and restore code string
1169:	0891  0681    	PUTFID: LD      B,ZFOR          ; "FOR" block marker
1170:	0893  C5      	        PUSH    BC              ; Save it
1171:	0894  33      	        INC     SP              ; Don't save C
1172:			
1173:	0895  CD0009  	RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
1174:	0898  22CE20  	        LD      (BRKLIN),HL     ; Save code address for break
1175:	089B  7E      	        LD      A,(HL)          ; Get next byte in code string
1176:	089C  FE3A    	        CP      ':'             ; Multi statement line?
1177:	089E  CAB508  	        JP      Z,EXCUTE        ; Yes - Execute it
1178:	08A1  B7      	        OR      A               ; End of line?
1179:	08A2  C2B104  	        JP      NZ,SNERR        ; No - Syntax error
1180:	08A5  23      	        INC     HL              ; Point to address of next line
1181:	08A6  7E      	        LD      A,(HL)          ; Get LSB of line pointer
1182:	08A7  23      	        INC     HL
1183:	08A8  B6      	        OR      (HL)            ; Is it zero (End of prog)?
1184:	08A9  CA2D09  	        JP      Z,ENDPRG        ; Yes - Terminate execution
1185:	08AC  23      	        INC     HL              ; Point to line number
1186:	08AD  5E      	        LD      E,(HL)          ; Get LSB of line number
1187:	08AE  23      	        INC     HL
1188:	08AF  56      	        LD      D,(HL)          ; Get MSB of line number
1189:	08B0  EB      	        EX      DE,HL           ; Line number to HL
1190:	08B1  225C20  	        LD      (LINEAT),HL     ; Save as current line number
1191:	08B4  EB      	        EX      DE,HL           ; Line number back to DE
1192:	08B5  CDD508  	EXCUTE: CALL    GETCHR          ; Get key word
1193:	08B8  119508  	        LD      DE,RUNCNT       ; Where to RETurn to
1194:	08BB  D5      	        PUSH    DE              ; Save for RETurn
1195:	08BC  C8      	IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
1196:	08BD  D680    	ONJMP:  SUB     ZEND            ; Is it a token?
1197:	08BF  DA890A  	        JP      C,LET           ; No - try to assign it
1198:	08C2  FE25    	        CP      ZNEW+1-ZEND     ; END to NEW ?
1199:	08C4  D2B104  	        JP      NC,SNERR        ; Not a key word - ?SN Error
1200:	08C7  07      	        RLCA                    ; Double it
1201:	08C8  4F      	        LD      C,A             ; BC = Offset into table
1202:	08C9  0600    	        LD      B,0
1203:	08CB  EB      	        EX      DE,HL           ; Save code string address
1204:	08CC  215903  	        LD      HL,WORDTB       ; Keyword address table
1205:	08CF  09      	        ADD     HL,BC           ; Point to routine address
1206:	08D0  4E      	        LD      C,(HL)          ; Get LSB of routine address
1207:	08D1  23      	        INC     HL
1208:	08D2  46      	        LD      B,(HL)          ; Get MSB of routine address
1209:	08D3  C5      	        PUSH    BC              ; Save routine address
1210:	08D4  EB      	        EX      DE,HL           ; Restore code string address
1211:			
1212:	08D5  23      	GETCHR: INC     HL              ; Point to next character
1213:	08D6  7E      	        LD      A,(HL)          ; Get next code string byte
1214:	08D7  FE3A    	        CP      ':'             ; Z if ':'
1215:	08D9  D0      	        RET     NC              ; NC if > "9"
1216:	08DA  FE20    	        CP      ' '
1217:	08DC  CAD508  	        JP      Z,GETCHR        ; Skip over spaces
1218:	08DF  FE30    	        CP      '0'
1219:	08E1  3F      	        CCF                     ; NC if < '0'
1220:	08E2  3C      	        INC     A               ; Test for zero - Leave carry
1221:	08E3  3D      	        DEC     A               ; Z if Null
1222:	08E4  C9      	        RET
1223:			
1224:	08E5  EB      	RESTOR: EX      DE,HL           ; Save code string address
1225:	08E6  2A5E20  	        LD      HL,(BASTXT)     ; Point to start of program
1226:	08E9  CAFA08  	        JP      Z,RESTNL        ; Just RESTORE - reset pointer
1227:	08EC  EB      	        EX      DE,HL           ; Restore code string address
1228:	08ED  CDA709  	        CALL    ATOH            ; Get line number to DE
1229:	08F0  E5      	        PUSH    HL              ; Save code string address
1230:	08F1  CD9D05  	        CALL    SRCHLN          ; Search for line number in DE
1231:	08F4  60      	        LD      H,B             ; HL = Address of line
1232:	08F5  69      	        LD      L,C
1233:	08F6  D1      	        POP     DE              ; Restore code string address
1234:	08F7  D2480A  	        JP      NC,ULERR        ; ?UL Error if not found
1235:	08FA  2B      	RESTNL: DEC     HL              ; Byte before DATA statement
1236:	08FB  22DC20  	UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
1237:	08FE  EB      	        EX      DE,HL           ; Restore code string address
1238:	08FF  C9      	        RET
1239:			
1240:			
1241:	0900  CD371D  	TSTBRK: CALL    CHKIN           ; Check input status
1242:	0903  C8      	        RET     Z               ; No key, go back
1243:	0904  CD351D  	        CALL    CHRIN           ; Get the key into A
1244:	0907  FE1B    	        CP      ESC             ; Escape key?
1245:	0909  2813    	        JR      Z,BRK           ; Yes, break
1246:	090B  FE03    	        CP      CTRLC           ; <Ctrl-C>
1247:	090D  280F    	        JR      Z,BRK           ; Yes, break
1248:	090F  FE13    	        CP      CTRLS           ; Stop scrolling?
1249:	0911  C0      	        RET     NZ              ; Other key, ignore
1250:			
1251:			
1252:	0912  CD351D  	STALL:  CALL    CHRIN           ; Wait for key
1253:	0915  FE11    	        CP      CTRLQ           ; Resume scrolling?
1254:	0917  C8      	        RET     Z              ; Release the chokehold
1255:	0918  FE03    	        CP      CTRLC           ; Second break?
1256:	091A  2807    	        JR      Z,STOP          ; Break during hold exits prog
1257:	091C  18F4    	        JR      STALL           ; Loop until <Ctrl-Q> or <brk>
1258:			
1259:	091E  3EFF    	BRK     LD      A,0FFH          ; Set BRKFLG
1260:	0920  324D20  	        LD      (BRKFLG),A      ; Store it
1261:			
1262:			
1263:	0923  C0      	STOP:   RET     NZ              ; Exit if anything else
1264:	0924  F6      	        .DB     0F6H            ; Flag "STOP"
1265:	0925  C0      	PEND:   RET     NZ              ; Exit if anything else
1266:	0926  22CE20  	        LD      (BRKLIN),HL     ; Save point of break
1267:	0929  21      	        .DB     21H             ; Skip "OR 11111111B"
1268:	092A  F6FF    	INPBRK: OR      11111111B       ; Flag "Break" wanted
1269:	092C  C1      	        POP     BC              ; Return not needed and more
1270:	092D  2A5C20  	ENDPRG: LD      HL,(LINEAT)     ; Get current line number
1271:	0930  F5      	        PUSH    AF              ; Save STOP / END status
1272:	0931  7D      	        LD      A,L             ; Is it direct break?
1273:	0932  A4      	        AND     H
1274:	0933  3C      	        INC     A               ; Line is -1 if direct break
1275:	0934  CA4009  	        JP      Z,NOLIN         ; Yes - No line number
1276:	0937  22D220  	        LD      (ERRLIN),HL     ; Save line of break
1277:	093A  2ACE20  	        LD      HL,(BRKLIN)     ; Get point of break
1278:	093D  22D420  	        LD      (CONTAD),HL     ; Save point to CONTinue
1279:	0940  AF      	NOLIN:  XOR     A
1280:	0941  324520  	        LD      (CTLOFG),A      ; Enable output
1281:	0944  CD760B  	        CALL    STTLIN          ; Start a new line
1282:	0947  F1      	        POP     AF              ; Restore STOP / END status
1283:	0948  215404  	        LD      HL,BRKMSG       ; "Break" message
1284:	094B  C2E504  	        JP      NZ,ERRIN        ; "in line" wanted?
1285:	094E  C3FC04  	        JP      PRNTOK          ; Go to command mode
1286:			
1287:	0951  2AD420  	CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
1288:	0954  7C      	        LD      A,H             ; Is it zero?
1289:	0955  B5      	        OR      L
1290:	0956  1E20    	        LD      E,CN            ; ?CN Error
1291:	0958  CAC504  	        JP      Z,ERROR         ; Yes - output "?CN Error"
1292:	095B  EB      	        EX      DE,HL           ; Save code string address
1293:	095C  2AD220  	        LD      HL,(ERRLIN)     ; Get line of last break
1294:	095F  225C20  	        LD      (LINEAT),HL     ; Set up current line number
1295:	0962  EB      	        EX      DE,HL           ; Restore code string address
1296:	0963  C9      	        RET                     ; CONTinue where left off
1297:			
1298:	0964  CDA914  	NULL:   CALL    GETINT          ; Get integer 0-255
1299:	0967  C0      	        RET     NZ              ; Return if bad value
1300:	0968  324120  	        LD      (NULLS),A       ; Set nulls number
1301:	096B  C9      	        RET
1302:			
1303:			
1304:	096C  E5      	ACCSUM: PUSH    HL              ; Save address in array
1305:	096D  2A4A20  	        LD      HL,(CHKSUM)     ; Get check sum
1306:	0970  0600    	        LD      B,0             ; BC - Value of byte
1307:	0972  4F      	        LD      C,A
1308:	0973  09      	        ADD     HL,BC           ; Add byte to check sum
1309:	0974  224A20  	        LD      (CHKSUM),HL     ; Re-save check sum
1310:	0977  E1      	        POP     HL              ; Restore address in array
1311:	0978  C9      	        RET
1312:			
1313:	0979  7E      	CHKLTR: LD      A,(HL)          ; Get byte
1314:	097A  FE41    	        CP      'A'             ; < 'a' ?
1315:	097C  D8      	        RET     C               ; Carry set if not letter
1316:	097D  FE5B    	        CP      'Z'+1           ; > 'z' ?
1317:	097F  3F      	        CCF
1318:	0980  C9      	        RET                     ; Carry set if not letter
1319:			
1320:	0981  CDD508  	FPSINT: CALL    GETCHR          ; Get next character
1321:	0984  CD480D  	POSINT: CALL    GETNUM          ; Get integer 0 to 32767
1322:	0987  CD2A17  	DEPINT: CALL    TSTSGN          ; Test sign of FPREG
1323:	098A  FAA209  	        JP      M,FCERR         ; Negative - ?FC Error
1324:	098D  3AE720  	DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
1325:	0990  FE90    	        CP      80H+16          ; Exponent in range (16 bits)?
1326:	0992  DAD217  	        JP      C,FPINT         ; Yes - convert it
1327:	0995  018090  	        LD      BC,9080H        ; BCDE = -32768
1328:	0998  110000  	        LD      DE,0000
1329:	099B  E5      	        PUSH    HL              ; Save code string address
1330:	099C  CDA517  	        CALL    CMPNUM          ; Compare FPREG with BCDE
1331:	099F  E1      	        POP     HL              ; Restore code string address
1332:	09A0  51      	        LD      D,C             ; MSB to D
1333:	09A1  C8      	        RET     Z               ; Return if in range
1334:	09A2  1E08    	FCERR:  LD      E,FC            ; ?FC Error
1335:	09A4  C3C504  	        JP      ERROR           ; Output error-
1336:			
1337:	09A7  2B      	ATOH:   DEC     HL              ; ASCII number to DE binary
1338:	09A8  110000  	GETLN:  LD      DE,0            ; Get number to DE
1339:	09AB  CDD508  	GTLNLP: CALL    GETCHR          ; Get next character
1340:	09AE  D0      	        RET     NC              ; Exit if not a digit
1341:	09AF  E5      	        PUSH    HL              ; Save code string address
1342:	09B0  F5      	        PUSH    AF              ; Save digit
1343:	09B1  219819  	        LD      HL,65529/10     ; Largest number 65529
1344:	09B4  CD4507  	        CALL    CPDEHL          ; Number in range?
1345:	09B7  DAB104  	        JP      C,SNERR         ; No - ?SN Error
1346:	09BA  62      	        LD      H,D             ; HL = Number
1347:	09BB  6B      	        LD      L,E
1348:	09BC  19      	        ADD     HL,DE           ; Times 2
1349:	09BD  29      	        ADD     HL,HL           ; Times 4
1350:	09BE  19      	        ADD     HL,DE           ; Times 5
1351:	09BF  29      	        ADD     HL,HL           ; Times 10
1352:	09C0  F1      	        POP     AF              ; Restore digit
1353:	09C1  D630    	        SUB     '0'             ; Make it 0 to 9
1354:	09C3  5F      	        LD      E,A             ; DE = Value of digit
1355:	09C4  1600    	        LD      D,0
1356:	09C6  19      	        ADD     HL,DE           ; Add to number
1357:	09C7  EB      	        EX      DE,HL           ; Number to DE
1358:	09C8  E1      	        POP     HL              ; Restore code string address
1359:	09C9  C3AB09  	        JP      GTLNLP          ; Go to next character
1360:			
1361:	09CC  CACD05  	CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
1362:	09CF  CD8409  	        CALL    POSINT          ; Get integer 0 to 32767 to DE
1363:	09D2  2B      	        DEC     HL              ; Cancel increment
1364:	09D3  CDD508  	        CALL    GETCHR          ; Get next character
1365:	09D6  E5      	        PUSH    HL              ; Save code string address
1366:	09D7  2AAF20  	        LD      HL,(LSTRAM)     ; Get end of RAM
1367:	09DA  CAEF09  	        JP      Z,STORED        ; No value given - Use stored
1368:	09DD  E1      	        POP     HL              ; Restore code string address
1369:	09DE  CD4B07  	        CALL    CHKSYN          ; Check for comma
1370:	09E1  2C      	        .DB     ','
1371:	09E2  D5      	        PUSH    DE              ; Save number
1372:	09E3  CD8409  	        CALL    POSINT          ; Get integer 0 to 32767
1373:	09E6  2B      	        DEC     HL              ; Cancel increment
1374:	09E7  CDD508  	        CALL    GETCHR          ; Get next character
1375:	09EA  C2B104  	        JP      NZ,SNERR        ; ?SN Error if more on line
1376:	09ED  E3      	        EX      (SP),HL         ; Save code string address
1377:	09EE  EB      	        EX      DE,HL           ; Number to DE
1378:	09EF  7D      	STORED: LD      A,L             ; Get LSB of new RAM top
1379:	09F0  93      	        SUB     E               ; Subtract LSB of string space
1380:	09F1  5F      	        LD      E,A             ; Save LSB
1381:	09F2  7C      	        LD      A,H             ; Get MSB of new RAM top
1382:	09F3  9A      	        SBC     A,D             ; Subtract MSB of string space
1383:	09F4  57      	        LD      D,A             ; Save MSB
1384:	09F5  DAA604  	        JP      C,OMERR         ; ?OM Error if not enough mem
1385:	09F8  E5      	        PUSH    HL              ; Save RAM top
1386:	09F9  2AD620  	        LD      HL,(PROGND)     ; Get program end
1387:	09FC  012800  	        LD      BC,40           ; 40 Bytes minimum working RAM
1388:	09FF  09      	        ADD     HL,BC           ; Get lowest address
1389:	0A00  CD4507  	        CALL    CPDEHL          ; Enough memory?
1390:	0A03  D2A604  	        JP      NC,OMERR        ; No - ?OM Error
1391:	0A06  EB      	        EX      DE,HL           ; RAM top to HL
1392:	0A07  225A20  	        LD      (STRSPC),HL     ; Set new string space
1393:	0A0A  E1      	        POP     HL              ; End of memory to use
1394:	0A0B  22AF20  	        LD      (LSTRAM),HL     ; Set new top of RAM
1395:	0A0E  E1      	        POP     HL              ; Restore code string address
1396:	0A0F  C3CD05  	        JP      INTVAR          ; Initialise variables
1397:			
1398:	0A12  CAC905  	RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
1399:	0A15  CDCD05  	        CALL    INTVAR          ; Initialise variables
1400:	0A18  019508  	        LD      BC,RUNCNT       ; Execution driver loop
1401:	0A1B  C32E0A  	        JP      RUNLIN          ; RUN from line number
1402:			
1403:	0A1E  0E03    	GOSUB:  LD      C,3             ; 3 Levels of stack needed
1404:	0A20  CD8E04  	        CALL    CHKSTK          ; Check for 3 levels of stack
1405:	0A23  C1      	        POP     BC              ; Get return address
1406:	0A24  E5      	        PUSH    HL              ; Save code string for RETURN
1407:	0A25  E5      	        PUSH    HL              ; And for GOSUB routine
1408:	0A26  2A5C20  	        LD      HL,(LINEAT)     ; Get current line
1409:	0A29  E3      	        EX      (SP),HL         ; Into stack - Code string out
1410:	0A2A  3E8C    	        LD      A,ZGOSUB        ; "GOSUB" token
1411:	0A2C  F5      	        PUSH    AF              ; Save token
1412:	0A2D  33      	        INC     SP              ; Don't save flags
1413:			
1414:	0A2E  C5      	RUNLIN: PUSH    BC              ; Save return address
1415:	0A2F  CDA709  	GOTO:   CALL    ATOH            ; ASCII number to DE binary
1416:	0A32  CD740A  	        CALL    REM             ; Get end of line
1417:	0A35  E5      	        PUSH    HL              ; Save end of line
1418:	0A36  2A5C20  	        LD      HL,(LINEAT)     ; Get current line
1419:	0A39  CD4507  	        CALL    CPDEHL          ; Line after current?
1420:	0A3C  E1      	        POP     HL              ; Restore end of line
1421:	0A3D  23      	        INC     HL              ; Start of next line
1422:	0A3E  DCA005  	        CALL    C,SRCHLP        ; Line is after current line
1423:	0A41  D49D05  	        CALL    NC,SRCHLN       ; Line is before current line
1424:	0A44  60      	        LD      H,B             ; Set up code string address
1425:	0A45  69      	        LD      L,C
1426:	0A46  2B      	        DEC     HL              ; Incremented after
1427:	0A47  D8      	        RET     C               ; Line found
1428:	0A48  1E0E    	ULERR:  LD      E,UL            ; ?UL Error
1429:	0A4A  C3C504  	        JP      ERROR           ; Output error message
1430:			
1431:	0A4D  C0      	RETURN: RET     NZ              ; Return if not just RETURN
1432:	0A4E  16FF    	        LD      D,-1            ; Flag "GOSUB" search
1433:	0A50  CD5A04  	        CALL    BAKSTK          ; Look "GOSUB" block
1434:	0A53  F9      	        LD      SP,HL           ; Kill all FORs in subroutine
1435:	0A54  FE8C    	        CP      ZGOSUB          ; Test for "GOSUB" token
1436:	0A56  1E04    	        LD      E,RG            ; ?RG Error
1437:	0A58  C2C504  	        JP      NZ,ERROR        ; Error if no "GOSUB" found
1438:	0A5B  E1      	        POP     HL              ; Get RETURN line number
1439:	0A5C  225C20  	        LD      (LINEAT),HL     ; Save as current
1440:	0A5F  23      	        INC     HL              ; Was it from direct statement?
1441:	0A60  7C      	        LD      A,H
1442:	0A61  B5      	        OR      L               ; Return to line
1443:	0A62  C26C0A  	        JP      NZ,RETLIN       ; No - Return to line
1444:	0A65  3ACC20  	        LD      A,(LSTBIN)      ; Any INPUT in subroutine?
1445:	0A68  B7      	        OR      A               ; If so buffer is corrupted
1446:	0A69  C2FB04  	        JP      NZ,POPNOK       ; Yes - Go to command mode
1447:	0A6C  219508  	RETLIN: LD      HL,RUNCNT       ; Execution driver loop
1448:	0A6F  E3      	        EX      (SP),HL         ; Into stack - Code string out
1449:	0A70  3E      	        .DB     3EH             ; Skip "POP HL"
1450:	0A71  E1      	NXTDTA: POP     HL              ; Restore code string address
1451:			
1452:	0A72  013A    	DATA:   .DB     01H,3AH         ; ':' End of statement
1453:	0A74  0E00    	REM:    LD      C,0             ; 00  End of statement
1454:	0A76  0600    	        LD      B,0
1455:	0A78  79      	NXTSTL: LD      A,C             ; Statement and byte
1456:	0A79  48      	        LD      C,B
1457:	0A7A  47      	        LD      B,A             ; Statement end byte
1458:	0A7B  7E      	NXTSTT: LD      A,(HL)          ; Get byte
1459:	0A7C  B7      	        OR      A               ; End of line?
1460:	0A7D  C8      	        RET     Z               ; Yes - Exit
1461:	0A7E  B8      	        CP      B               ; End of statement?
1462:	0A7F  C8      	        RET     Z               ; Yes - Exit
1463:	0A80  23      	        INC     HL              ; Next byte
1464:	0A81  FE22    	        CP      '"'             ; Literal string?
1465:	0A83  CA780A  	        JP      Z,NXTSTL        ; Yes - Look for another '"'
1466:	0A86  C37B0A  	        JP      NXTSTT          ; Keep looking
1467:			
1468:	0A89  CD3E0F  	LET:    CALL    GETVAR          ; Get variable name
1469:	0A8C  CD4B07  	        CALL    CHKSYN          ; Make sure "=" follows
1470:	0A8F  B4      	        .DB     ZEQUAL          ; "=" token
1471:	0A90  D5      	        PUSH    DE              ; Save address of variable
1472:	0A91  3AAD20  	        LD      A,(TYPE)        ; Get data type
1473:	0A94  F5      	        PUSH    AF              ; Save type
1474:	0A95  CD5A0D  	        CALL    EVAL            ; Evaluate expression
1475:	0A98  F1      	        POP     AF              ; Restore type
1476:	0A99  E3      	        EX      (SP),HL         ; Save code - Get var addr
1477:	0A9A  22CE20  	        LD      (BRKLIN),HL     ; Save address of variable
1478:	0A9D  1F      	        RRA                     ; Adjust type
1479:	0A9E  CD4D0D  	        CALL    CHKTYP          ; Check types are the same
1480:	0AA1  CADC0A  	        JP      Z,LETNUM        ; Numeric - Move value
1481:	0AA4  E5      	LETSTR: PUSH    HL              ; Save address of string var
1482:	0AA5  2AE420  	        LD      HL,(FPREG)      ; Pointer to string entry
1483:	0AA8  E5      	        PUSH    HL              ; Save it on stack
1484:	0AA9  23      	        INC     HL              ; Skip over length
1485:	0AAA  23      	        INC     HL
1486:	0AAB  5E      	        LD      E,(HL)          ; LSB of string address
1487:	0AAC  23      	        INC     HL
1488:	0AAD  56      	        LD      D,(HL)          ; MSB of string address
1489:	0AAE  2A5E20  	        LD      HL,(BASTXT)     ; Point to start of program
1490:	0AB1  CD4507  	        CALL    CPDEHL          ; Is string before program?
1491:	0AB4  D2CB0A  	        JP      NC,CRESTR       ; Yes - Create string entry
1492:	0AB7  2A5A20  	        LD      HL,(STRSPC)     ; Point to string space
1493:	0ABA  CD4507  	        CALL    CPDEHL          ; Is string literal in program?
1494:	0ABD  D1      	        POP     DE              ; Restore address of string
1495:	0ABE  D2D30A  	        JP      NC,MVSTPT       ; Yes - Set up pointer
1496:	0AC1  21BF20  	        LD      HL,TMPSTR       ; Temporary string pool
1497:	0AC4  CD4507  	        CALL    CPDEHL          ; Is string in temporary pool?
1498:	0AC7  D2D30A  	        JP      NC,MVSTPT       ; No - Set up pointer
1499:	0ACA  3E      	        .DB     3EH             ; Skip "POP DE"
1500:	0ACB  D1      	CRESTR: POP     DE              ; Restore address of string
1501:	0ACC  CD8213  	        CALL    BAKTMP          ; Back to last tmp-str entry
1502:	0ACF  EB      	        EX      DE,HL           ; Address of string entry
1503:	0AD0  CDBB11  	        CALL    SAVSTR          ; Save string in string area
1504:	0AD3  CD8213  	MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
1505:	0AD6  E1      	        POP     HL              ; Get string pointer
1506:	0AD7  CD8517  	        CALL    DETHL4          ; Move string pointer to var
1507:	0ADA  E1      	        POP     HL              ; Restore code string address
1508:	0ADB  C9      	        RET
1509:			
1510:	0ADC  E5      	LETNUM: PUSH    HL              ; Save address of variable
1511:	0ADD  CD8217  	        CALL    FPTHL           ; Move value to variable
1512:	0AE0  D1      	        POP     DE              ; Restore address of variable
1513:	0AE1  E1      	        POP     HL              ; Restore code string address
1514:	0AE2  C9      	        RET
1515:			
1516:	0AE3  CDA914  	ON:     CALL    GETINT          ; Get integer 0-255
1517:	0AE6  7E      	        LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
1518:	0AE7  47      	        LD      B,A             ; Save in B
1519:	0AE8  FE8C    	        CP      ZGOSUB          ; "GOSUB" token?
1520:	0AEA  CAF20A  	        JP      Z,ONGO          ; Yes - Find line number
1521:	0AED  CD4B07  	        CALL    CHKSYN          ; Make sure it's "GOTO"
1522:	0AF0  88      	        .DB     ZGOTO           ; "GOTO" token
1523:	0AF1  2B      	        DEC     HL              ; Cancel increment
1524:	0AF2  4B      	ONGO:   LD      C,E             ; Integer of branch value
1525:	0AF3  0D      	ONGOLP: DEC     C               ; Count branches
1526:	0AF4  78      	        LD      A,B             ; Get "GOTO" or "GOSUB" token
1527:	0AF5  CABD08  	        JP      Z,ONJMP         ; Go to that line if right one
1528:	0AF8  CDA809  	        CALL    GETLN           ; Get line number to DE
1529:	0AFB  FE2C    	        CP      ','             ; Another line number?
1530:	0AFD  C0      	        RET     NZ              ; No - Drop through
1531:	0AFE  C3F30A  	        JP      ONGOLP          ; Yes - loop
1532:			
1533:	0B01  CD5A0D  	IF:     CALL    EVAL            ; Evaluate expression
1534:	0B04  7E      	        LD      A,(HL)          ; Get token
1535:	0B05  FE88    	        CP      ZGOTO           ; "GOTO" token?
1536:	0B07  CA0F0B  	        JP      Z,IFGO          ; Yes - Get line
1537:	0B0A  CD4B07  	        CALL    CHKSYN          ; Make sure it's "THEN"
1538:	0B0D  A9      	        .DB     ZTHEN           ; "THEN" token
1539:	0B0E  2B      	        DEC     HL              ; Cancel increment
1540:	0B0F  CD4B0D  	IFGO:   CALL    TSTNUM          ; Make sure it's numeric
1541:	0B12  CD2A17  	        CALL    TSTSGN          ; Test state of expression
1542:	0B15  CA740A  	        JP      Z,REM           ; False - Drop through
1543:	0B18  CDD508  	        CALL    GETCHR          ; Get next character
1544:	0B1B  DA2F0A  	        JP      C,GOTO          ; Number - GOTO that line
1545:	0B1E  C3BC08  	        JP      IFJMP           ; Otherwise do statement
1546:			
1547:	0B21  2B      	MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
1548:	0B22  CDD508  	        CALL    GETCHR          ; Get next character
1549:	0B25  CA830B  	PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
1550:	0B28  C8      	PRNTLP: RET     Z               ; End of list - Exit
1551:	0B29  FEA5    	        CP      ZTAB            ; "TAB(" token?
1552:	0B2B  CAB60B  	        JP      Z,DOTAB         ; Yes - Do TAB routine
1553:	0B2E  FEA8    	        CP      ZSPC            ; "SPC(" token?
1554:	0B30  CAB60B  	        JP      Z,DOTAB         ; Yes - Do SPC routine
1555:	0B33  E5      	        PUSH    HL              ; Save code string address
1556:	0B34  FE2C    	        CP      ','             ; Comma?
1557:	0B36  CA9F0B  	        JP      Z,DOCOM         ; Yes - Move to next zone
1558:	0B39  FE3B    	        CP      59 ;";"         ; Semi-colon?
1559:	0B3B  CAD90B  	        JP      Z,NEXITM        ; Do semi-colon routine
1560:	0B3E  C1      	        POP     BC              ; Code string address to BC
1561:	0B3F  CD5A0D  	        CALL    EVAL            ; Evaluate expression
1562:	0B42  E5      	        PUSH    HL              ; Save code string address
1563:	0B43  3AAD20  	        LD      A,(TYPE)        ; Get variable type
1564:	0B46  B7      	        OR      A               ; Is it a string variable?
1565:	0B47  C26F0B  	        JP      NZ,PRNTST       ; Yes - Output string contents
1566:	0B4A  CDCF18  	        CALL    NUMASC          ; Convert number to text
1567:	0B4D  CDDF11  	        CALL    CRTST           ; Create temporary string
1568:	0B50  3620    	        LD      (HL),' '        ; Followed by a space
1569:	0B52  2AE420  	        LD      HL,(FPREG)      ; Get length of output
1570:	0B55  34      	        INC     (HL)            ; Plus 1 for the space
1571:	0B56  2AE420  	        LD      HL,(FPREG)      ; < Not needed >
1572:	0B59  3A4220  	        LD      A,(LWIDTH)      ; Get width of line
1573:	0B5C  47      	        LD      B,A             ; To B
1574:	0B5D  04      	        INC     B               ; Width 255 (No limit)?
1575:	0B5E  CA6B0B  	        JP      Z,PRNTNB        ; Yes - Output number string
1576:	0B61  04      	        INC     B               ; Adjust it
1577:	0B62  3AAB20  	        LD      A,(CURPOS)      ; Get cursor position
1578:	0B65  86      	        ADD     A,(HL)          ; Add length of string
1579:	0B66  3D      	        DEC     A               ; Adjust it
1580:	0B67  B8      	        CP      B               ; Will output fit on this line?
1581:	0B68  D4830B  	        CALL    NC,PRNTCRLF     ; No - CRLF first
1582:	0B6B  CD2412  	PRNTNB: CALL    PRS1            ; Output string at (HL)
1583:	0B6E  AF      	        XOR     A               ; Skip CALL by setting 'z' flag
1584:	0B6F  C42412  	PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
1585:	0B72  E1      	        POP     HL              ; Restore code string address
1586:	0B73  C3210B  	        JP      MRPRNT          ; See if more to PRINT
1587:			
1588:	0B76  3AAB20  	STTLIN: LD      A,(CURPOS)      ; Make sure on new line
1589:	0B79  B7      	        OR      A               ; Already at start?
1590:	0B7A  C8      	        RET     Z               ; Yes - Do nothing
1591:	0B7B  C3830B  	        JP      PRNTCRLF        ; Start a new line
1592:			
1593:	0B7E  3600    	ENDINP: LD      (HL),0          ; Mark end of buffer
1594:	0B80  216020  	        LD      HL,BUFFER-1     ; Point to buffer
1595:	0B83  3E0D    	PRNTCRLF: LD    A,CR            ; Load a CR
1596:	0B85  CD5607  	        CALL    OUTC            ; Output character
1597:	0B88  3E0A    	        LD      A,LF            ; Load a LF
1598:	0B8A  CD5607  	        CALL    OUTC            ; Output character
1599:	0B8D  AF      	DONULL: XOR     A               ; Set to position 0
1600:	0B8E  32AB20  	        LD      (CURPOS),A      ; Store it
1601:	0B91  3A4120  	        LD      A,(NULLS)       ; Get number of nulls
1602:	0B94  3D      	NULLP:  DEC     A               ; Count them
1603:	0B95  C8      	        RET     Z               ; Return if done
1604:	0B96  F5      	        PUSH    AF              ; Save count
1605:	0B97  AF      	        XOR     A               ; Load a null
1606:	0B98  CD5607  	        CALL    OUTC            ; Output it
1607:	0B9B  F1      	        POP     AF              ; Restore count
1608:	0B9C  C3940B  	        JP      NULLP           ; Keep counting
1609:			
1610:	0B9F  3A4320  	DOCOM:  LD      A,(COMMAN)      ; Get comma width
1611:	0BA2  47      	        LD      B,A             ; Save in B
1612:	0BA3  3AAB20  	        LD      A,(CURPOS)      ; Get current position
1613:	0BA6  B8      	        CP      B               ; Within the limit?
1614:	0BA7  D4830B  	        CALL    NC,PRNTCRLF     ; No - output CRLF
1615:	0BAA  D2D90B  	        JP      NC,NEXITM       ; Get next item
1616:	0BAD  D60E    	ZONELP: SUB     14              ; Next zone of 14 characters
1617:	0BAF  D2AD0B  	        JP      NC,ZONELP       ; Repeat if more zones
1618:	0BB2  2F      	        CPL                     ; Number of spaces to output
1619:	0BB3  C3CE0B  	        JP      ASPCS           ; Output them
1620:			
1621:	0BB6  F5      	DOTAB:  PUSH    AF              ; Save token
1622:	0BB7  CDA614  	        CALL    FNDNUM          ; Evaluate expression
1623:	0BBA  CD4B07  	        CALL    CHKSYN          ; Make sure ")" follows
1624:	0BBD  29      	        .DB     ")"
1625:	0BBE  2B      	        DEC     HL              ; Back space on to ")"
1626:	0BBF  F1      	        POP     AF              ; Restore token
1627:	0BC0  D6A8    	        SUB     ZSPC            ; Was it "SPC(" ?
1628:	0BC2  E5      	        PUSH    HL              ; Save code string address
1629:	0BC3  CAC90B  	        JP      Z,DOSPC         ; Yes - Do 'E' spaces
1630:	0BC6  3AAB20  	        LD      A,(CURPOS)      ; Get current position
1631:	0BC9  2F      	DOSPC:  CPL                     ; Number of spaces to print to
1632:	0BCA  83      	        ADD     A,E             ; Total number to print
1633:	0BCB  D2D90B  	        JP      NC,NEXITM       ; TAB < Current POS(X)
1634:	0BCE  3C      	ASPCS:  INC     A               ; Output A spaces
1635:	0BCF  47      	        LD      B,A             ; Save number to print
1636:	0BD0  3E20    	        LD      A,' '           ; Space
1637:	0BD2  CD5607  	SPCLP:  CALL    OUTC            ; Output character in A
1638:	0BD5  05      	        DEC     B               ; Count them
1639:	0BD6  C2D20B  	        JP      NZ,SPCLP        ; Repeat if more
1640:	0BD9  E1      	NEXITM: POP     HL              ; Restore code string address
1641:	0BDA  CDD508  	        CALL    GETCHR          ; Get next character
1642:	0BDD  C3280B  	        JP      PRNTLP          ; More to print
1643:			
1644:	0BE0  3F526564	REDO:   .DB     "?Redo from start",CR,LF,0
	      6F206672
	      6F6D2073
	      74617274
	      0D0A00
1645:			
1646:	0BF3  3ACD20  	BADINP: LD      A,(READFG)      ; READ or INPUT?
1647:	0BF6  B7      	        OR      A
1648:	0BF7  C2AB04  	        JP      NZ,DATSNR       ; READ - ?SN Error
1649:	0BFA  C1      	        POP     BC              ; Throw away code string addr
1650:	0BFB  21E00B  	        LD      HL,REDO         ; "Redo from start" message
1651:	0BFE  CD2112  	        CALL    PRS             ; Output string
1652:	0C01  C3FC05  	        JP      DOAGN           ; Do last INPUT again
1653:			
1654:	0C04  CD8C11  	INPUT:  CALL    IDTEST          ; Test for illegal direct
1655:	0C07  7E      	        LD      A,(HL)          ; Get character after "INPUT"
1656:	0C08  FE22    	        CP      '"'             ; Is there a prompt string?
1657:	0C0A  3E00    	        LD      A,0             ; Clear A and leave flags
1658:	0C0C  324520  	        LD      (CTLOFG),A      ; Enable output
1659:	0C0F  C21E0C  	        JP      NZ,NOPMPT       ; No prompt - get input
1660:	0C12  CDE011  	        CALL    QTSTR           ; Get string terminated by '"'
1661:	0C15  CD4B07  	        CALL    CHKSYN          ; Check for ';' after prompt
1662:	0C18  3B      	        .DB     ';'
1663:	0C19  E5      	        PUSH    HL              ; Save code string address
1664:	0C1A  CD2412  	        CALL    PRS1            ; Output prompt string
1665:	0C1D  3E      	        .DB     3EH             ; Skip "PUSH HL"
1666:	0C1E  E5      	NOPMPT: PUSH    HL              ; Save code string address
1667:	0C1F  CD0006  	        CALL    PROMPT          ; Get input with "? " prompt
1668:	0C22  C1      	        POP     BC              ; Restore code string address
1669:	0C23  DA2A09  	        JP      C,INPBRK        ; Break pressed - Exit
1670:	0C26  23      	        INC     HL              ; Next byte
1671:	0C27  7E      	        LD      A,(HL)          ; Get it
1672:	0C28  B7      	        OR      A               ; End of line?
1673:	0C29  2B      	        DEC     HL              ; Back again
1674:	0C2A  C5      	        PUSH    BC              ; Re-save code string address
1675:	0C2B  CA710A  	        JP      Z,NXTDTA        ; Yes - Find next DATA stmt
1676:	0C2E  362C    	        LD      (HL),','        ; Store comma as separator
1677:	0C30  C3380C  	        JP      NXTITM          ; Get next item
1678:			
1679:	0C33  E5      	READ:   PUSH    HL              ; Save code string address
1680:	0C34  2ADC20  	        LD      HL,(NXTDAT)     ; Next DATA statement
1681:	0C37  F6      	        .DB     0F6H            ; Flag "READ"
1682:	0C38  AF      	NXTITM: XOR     A               ; Flag "INPUT"
1683:	0C39  32CD20  	        LD      (READFG),A      ; Save "READ"/"INPUT" flag
1684:	0C3C  E3      	        EX      (SP),HL         ; Get code str' , Save pointer
1685:	0C3D  C3440C  	        JP      GTVLUS          ; Get values
1686:			
1687:	0C40  CD4B07  	NEDMOR: CALL    CHKSYN          ; Check for comma between items
1688:	0C43  2C      	        .DB     ','
1689:	0C44  CD3E0F  	GTVLUS: CALL    GETVAR          ; Get variable name
1690:	0C47  E3      	        EX      (SP),HL         ; Save code str" , Get pointer
1691:	0C48  D5      	        PUSH    DE              ; Save variable address
1692:	0C49  7E      	        LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
1693:	0C4A  FE2C    	        CP      ','             ; Comma?
1694:	0C4C  CA6C0C  	        JP      Z,ANTVLU        ; Yes - Get another value
1695:	0C4F  3ACD20  	        LD      A,(READFG)      ; Is it READ?
1696:	0C52  B7      	        OR      A
1697:	0C53  C2D90C  	        JP      NZ,FDTLP        ; Yes - Find next DATA stmt
1698:	0C56  3E3F    	        LD      A,'?'           ; More INPUT needed
1699:	0C58  CD5607  	        CALL    OUTC            ; Output character
1700:	0C5B  CD0006  	        CALL    PROMPT          ; Get INPUT with prompt
1701:	0C5E  D1      	        POP     DE              ; Variable address
1702:	0C5F  C1      	        POP     BC              ; Code string address
1703:	0C60  DA2A09  	        JP      C,INPBRK        ; Break pressed
1704:	0C63  23      	        INC     HL              ; Point to next DATA byte
1705:	0C64  7E      	        LD      A,(HL)          ; Get byte
1706:	0C65  B7      	        OR      A               ; Is it zero (No input) ?
1707:	0C66  2B      	        DEC     HL              ; Back space INPUT pointer
1708:	0C67  C5      	        PUSH    BC              ; Save code string address
1709:	0C68  CA710A  	        JP      Z,NXTDTA        ; Find end of buffer
1710:	0C6B  D5      	        PUSH    DE              ; Save variable address
1711:	0C6C  3AAD20  	ANTVLU: LD      A,(TYPE)        ; Check data type
1712:	0C6F  B7      	        OR      A               ; Is it numeric?
1713:	0C70  CA960C  	        JP      Z,INPBIN        ; Yes - Convert to binary
1714:	0C73  CDD508  	        CALL    GETCHR          ; Get next character
1715:	0C76  57      	        LD      D,A             ; Save input character
1716:	0C77  47      	        LD      B,A             ; Again
1717:	0C78  FE22    	        CP      '"'             ; Start of literal sting?
1718:	0C7A  CA8A0C  	        JP      Z,STRENT        ; Yes - Create string entry
1719:	0C7D  3ACD20  	        LD      A,(READFG)      ; "READ" or "INPUT" ?
1720:	0C80  B7      	        OR      A
1721:	0C81  57      	        LD      D,A             ; Save 00 if "INPUT"
1722:	0C82  CA870C  	        JP      Z,ITMSEP        ; "INPUT" - End with 00
1723:	0C85  163A    	        LD      D,':'           ; "DATA" - End with 00 or ':'
1724:	0C87  062C    	ITMSEP: LD      B,','           ; Item separator
1725:	0C89  2B      	        DEC     HL              ; Back space for DTSTR
1726:	0C8A  CDE311  	STRENT: CALL    DTSTR           ; Get string terminated by D
1727:	0C8D  EB      	        EX      DE,HL           ; String address to DE
1728:	0C8E  21A10C  	        LD      HL,LTSTND       ; Where to go after LETSTR
1729:	0C91  E3      	        EX      (SP),HL         ; Save HL , get input pointer
1730:	0C92  D5      	        PUSH    DE              ; Save address of string
1731:	0C93  C3A40A  	        JP      LETSTR          ; Assign string to variable
1732:			
1733:	0C96  CDD508  	INPBIN: CALL    GETCHR          ; Get next character
1734:	0C99  CD3118  	        CALL    ASCTFP          ; Convert ASCII to FP number
1735:	0C9C  E3      	        EX      (SP),HL         ; Save input ptr, Get var addr
1736:	0C9D  CD8217  	        CALL    FPTHL           ; Move FPREG to variable
1737:	0CA0  E1      	        POP     HL              ; Restore input pointer
1738:	0CA1  2B      	LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
1739:	0CA2  CDD508  	        CALL    GETCHR          ; Get next character
1740:	0CA5  CAAD0C  	        JP      Z,MORDT         ; End of line - More needed?
1741:	0CA8  FE2C    	        CP      ','             ; Another value?
1742:	0CAA  C2F30B  	        JP      NZ,BADINP       ; No - Bad input
1743:	0CAD  E3      	MORDT:  EX      (SP),HL         ; Get code string address
1744:	0CAE  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
1745:	0CAF  CDD508  	        CALL    GETCHR          ; Get next character
1746:	0CB2  C2400C  	        JP      NZ,NEDMOR       ; More needed - Get it
1747:	0CB5  D1      	        POP     DE              ; Restore DATA pointer
1748:	0CB6  3ACD20  	        LD      A,(READFG)      ; "READ" or "INPUT" ?
1749:	0CB9  B7      	        OR      A
1750:	0CBA  EB      	        EX      DE,HL           ; DATA pointer to HL
1751:	0CBB  C2FB08  	        JP      NZ,UPDATA       ; Update DATA pointer if "READ"
1752:	0CBE  D5      	        PUSH    DE              ; Save code string address
1753:	0CBF  B6      	        OR      (HL)            ; More input given?
1754:	0CC0  21C80C  	        LD      HL,EXTIG        ; "?Extra ignored" message
1755:	0CC3  C42112  	        CALL    NZ,PRS          ; Output string if extra given
1756:	0CC6  E1      	        POP     HL              ; Restore code string address
1757:	0CC7  C9      	        RET
1758:			
1759:	0CC8  3F457874	EXTIG:  .DB     "?Extra ignored",CR,LF,0
	      72612069
	      676E6F72
	      65640D0A
	      00
1760:			
1761:	0CD9  CD720A  	FDTLP:  CALL    DATA            ; Get next statement
1762:	0CDC  B7      	        OR      A               ; End of line?
1763:	0CDD  C2F20C  	        JP      NZ,FANDT        ; No - See if DATA statement
1764:	0CE0  23      	        INC     HL
1765:	0CE1  7E      	        LD      A,(HL)          ; End of program?
1766:	0CE2  23      	        INC     HL
1767:	0CE3  B6      	        OR      (HL)            ; 00 00 Ends program
1768:	0CE4  1E06    	        LD      E,OD            ; ?OD Error
1769:	0CE6  CAC504  	        JP      Z,ERROR         ; Yes - Out of DATA
1770:	0CE9  23      	        INC     HL
1771:	0CEA  5E      	        LD      E,(HL)          ; LSB of line number
1772:	0CEB  23      	        INC     HL
1773:	0CEC  56      	        LD      D,(HL)          ; MSB of line number
1774:	0CED  EB      	        EX      DE,HL
1775:	0CEE  22C920  	        LD      (DATLIN),HL     ; Set line of current DATA item
1776:	0CF1  EB      	        EX      DE,HL
1777:	0CF2  CDD508  	FANDT:  CALL    GETCHR          ; Get next character
1778:	0CF5  FE83    	        CP      ZDATA           ; "DATA" token
1779:	0CF7  C2D90C  	        JP      NZ,FDTLP        ; No "DATA" - Keep looking
1780:	0CFA  C36C0C  	        JP      ANTVLU          ; Found - Convert input
1781:			
1782:	0CFD  110000  	NEXT:   LD      DE,0            ; In case no index given
1783:	0D00  C43E0F  	NEXT1:  CALL    NZ,GETVAR       ; Get index address
1784:	0D03  22CE20  	        LD      (BRKLIN),HL     ; Save code string address
1785:	0D06  CD5A04  	        CALL    BAKSTK          ; Look for "FOR" block
1786:	0D09  C2B704  	        JP      NZ,NFERR        ; No "FOR" - ?NF Error
1787:	0D0C  F9      	        LD      SP,HL           ; Clear nested loops
1788:	0D0D  D5      	        PUSH    DE              ; Save index address
1789:	0D0E  7E      	        LD      A,(HL)          ; Get sign of STEP
1790:	0D0F  23      	        INC     HL
1791:	0D10  F5      	        PUSH    AF              ; Save sign of STEP
1792:	0D11  D5      	        PUSH    DE              ; Save index address
1793:	0D12  CD6817  	        CALL    PHLTFP          ; Move index value to FPREG
1794:	0D15  E3      	        EX      (SP),HL         ; Save address of TO value
1795:	0D16  E5      	        PUSH    HL              ; Save address of index
1796:	0D17  CDD514  	        CALL    ADDPHL          ; Add STEP to index value
1797:	0D1A  E1      	        POP     HL              ; Restore address of index
1798:	0D1B  CD8217  	        CALL    FPTHL           ; Move value to index variable
1799:	0D1E  E1      	        POP     HL              ; Restore address of TO value
1800:	0D1F  CD7917  	        CALL    LOADFP          ; Move TO value to BCDE
1801:	0D22  E5      	        PUSH    HL              ; Save address of line of FOR
1802:	0D23  CDA517  	        CALL    CMPNUM          ; Compare index with TO value
1803:	0D26  E1      	        POP     HL              ; Restore address of line num
1804:	0D27  C1      	        POP     BC              ; Address of sign of STEP
1805:	0D28  90      	        SUB     B               ; Compare with expected sign
1806:	0D29  CD7917  	        CALL    LOADFP          ; BC = Loop stmt,DE = Line num
1807:	0D2C  CA380D  	        JP      Z,KILFOR        ; Loop finished - Terminate it
1808:	0D2F  EB      	        EX      DE,HL           ; Loop statement line number
1809:	0D30  225C20  	        LD      (LINEAT),HL     ; Set loop line number
1810:	0D33  69      	        LD      L,C             ; Set code string to loop
1811:	0D34  60      	        LD      H,B
1812:	0D35  C39108  	        JP      PUTFID          ; Put back "FOR" and continue
1813:			
1814:	0D38  F9      	KILFOR: LD      SP,HL           ; Remove "FOR" block
1815:	0D39  2ACE20  	        LD      HL,(BRKLIN)     ; Code string after "NEXT"
1816:	0D3C  7E      	        LD      A,(HL)          ; Get next byte in code string
1817:	0D3D  FE2C    	        CP      ','             ; More NEXTs ?
1818:	0D3F  C29508  	        JP      NZ,RUNCNT       ; No - Do next statement
1819:	0D42  CDD508  	        CALL    GETCHR          ; Position to index name
1820:	0D45  CD000D  	        CALL    NEXT1           ; Re-enter NEXT routine
1821:			; < will not RETurn to here , Exit to RUNCNT or Loop >
1822:			
1823:	0D48  CD5A0D  	GETNUM: CALL    EVAL            ; Get a numeric expression
1824:	0D4B  F6      	TSTNUM: .DB     0F6H            ; Clear carry (numeric)
1825:	0D4C  37      	TSTSTR: SCF                     ; Set carry (string)
1826:	0D4D  3AAD20  	CHKTYP: LD      A,(TYPE)        ; Check types match
1827:	0D50  8F      	        ADC     A,A             ; Expected + actual
1828:	0D51  B7      	        OR      A               ; Clear carry , set parity
1829:	0D52  E8      	        RET     PE              ; Even parity - Types match
1830:	0D53  C3C304  	        JP      TMERR           ; Different types - Error
1831:			
1832:	0D56  CD4B07  	OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
1833:	0D59  28      	        .DB  "("
1834:	0D5A  2B      	EVAL:   DEC     HL              ; Evaluate expression & save
1835:	0D5B  1600    	        LD      D,0             ; Precedence value
1836:	0D5D  D5      	EVAL1:  PUSH    DE              ; Save precedence
1837:	0D5E  0E01    	        LD      C,1
1838:	0D60  CD8E04  	        CALL    CHKSTK          ; Check for 1 level of stack
1839:	0D63  CDD10D  	        CALL    OPRND           ; Get next expression value
1840:	0D66  22D020  	EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
1841:	0D69  2AD020  	EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
1842:	0D6C  C1      	        POP     BC              ; Precedence value and operator
1843:	0D6D  78      	        LD      A,B             ; Get precedence value
1844:	0D6E  FE78    	        CP      78H             ; "AND" or "OR" ?
1845:	0D70  D44B0D  	        CALL    NC,TSTNUM       ; No - Make sure it's a number
1846:	0D73  7E      	        LD      A,(HL)          ; Get next operator / function
1847:	0D74  1600    	        LD      D,0             ; Clear Last relation
1848:	0D76  D6B3    	RLTLP:  SUB     ZGTR            ; ">" Token
1849:	0D78  DA920D  	        JP      C,FOPRND        ; + - * / ^ AND OR - Test it
1850:	0D7B  FE03    	        CP      ZLTH+1-ZGTR     ; < = >
1851:	0D7D  D2920D  	        JP      NC,FOPRND       ; Function - Call it
1852:	0D80  FE01    	        CP      ZEQUAL-ZGTR     ; "="
1853:	0D82  17      	        RLA                     ; <- Test for legal
1854:	0D83  AA      	        XOR     D               ; <- combinations of < = >
1855:	0D84  BA      	        CP      D               ; <- by combining last token
1856:	0D85  57      	        LD      D,A             ; <- with current one
1857:	0D86  DAB104  	        JP      C,SNERR         ; Error if "<<' '==" or ">>"
1858:	0D89  22C520  	        LD      (CUROPR),HL     ; Save address of current token
1859:	0D8C  CDD508  	        CALL    GETCHR          ; Get next character
1860:	0D8F  C3760D  	        JP      RLTLP           ; Treat the two as one
1861:			
1862:	0D92  7A      	FOPRND: LD      A,D             ; < = > found ?
1863:	0D93  B7      	        OR      A
1864:	0D94  C2B90E  	        JP      NZ,TSTRED       ; Yes - Test for reduction
1865:	0D97  7E      	        LD      A,(HL)          ; Get operator token
1866:	0D98  22C520  	        LD      (CUROPR),HL     ; Save operator address
1867:	0D9B  D6AC    	        SUB     ZPLUS           ; Operator or function?
1868:	0D9D  D8      	        RET     C               ; Neither - Exit
1869:	0D9E  FE07    	        CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
1870:	0DA0  D0      	        RET     NC              ; No - Exit
1871:	0DA1  5F      	        LD      E,A             ; Coded operator
1872:	0DA2  3AAD20  	        LD      A,(TYPE)        ; Get data type
1873:	0DA5  3D      	        DEC     A               ; FF = numeric , 00 = string
1874:	0DA6  B3      	        OR      E               ; Combine with coded operator
1875:	0DA7  7B      	        LD      A,E             ; Get coded operator
1876:	0DA8  CA1713  	        JP      Z,CONCAT        ; String concatenation
1877:	0DAB  07      	        RLCA                    ; Times 2
1878:	0DAC  83      	        ADD     A,E             ; Times 3
1879:	0DAD  5F      	        LD      E,A             ; To DE (D is 0)
1880:	0DAE  21A303  	        LD      HL,PRITAB       ; Precedence table
1881:	0DB1  19      	        ADD     HL,DE           ; To the operator concerned
1882:	0DB2  78      	        LD      A,B             ; Last operator precedence
1883:	0DB3  56      	        LD      D,(HL)          ; Get evaluation precedence
1884:	0DB4  BA      	        CP      D               ; Compare with eval precedence
1885:	0DB5  D0      	        RET     NC              ; Exit if higher precedence
1886:	0DB6  23      	        INC     HL              ; Point to routine address
1887:	0DB7  CD4B0D  	        CALL    TSTNUM          ; Make sure it's a number
1888:			
1889:	0DBA  C5      	STKTHS: PUSH    BC              ; Save last precedence & token
1890:	0DBB  01690D  	        LD      BC,EVAL3        ; Where to go on prec' break
1891:	0DBE  C5      	        PUSH    BC              ; Save on stack for return
1892:	0DBF  43      	        LD      B,E             ; Save operator
1893:	0DC0  4A      	        LD      C,D             ; Save precedence
1894:	0DC1  CD5B17  	        CALL    STAKFP          ; Move value to stack
1895:	0DC4  58      	        LD      E,B             ; Restore operator
1896:	0DC5  51      	        LD      D,C             ; Restore precedence
1897:	0DC6  4E      	        LD      C,(HL)          ; Get LSB of routine address
1898:	0DC7  23      	        INC     HL
1899:	0DC8  46      	        LD      B,(HL)          ; Get MSB of routine address
1900:	0DC9  23      	        INC     HL
1901:	0DCA  C5      	        PUSH    BC              ; Save routine address
1902:	0DCB  2AC520  	        LD      HL,(CUROPR)     ; Address of current operator
1903:	0DCE  C35D0D  	        JP      EVAL1           ; Loop until prec' break
1904:			
1905:	0DD1  AF      	OPRND:  XOR     A               ; Get operand routine
1906:	0DD2  32AD20  	        LD      (TYPE),A        ; Set numeric expected
1907:	0DD5  CDD508  	        CALL    GETCHR          ; Get next character
1908:	0DD8  1E24    	        LD      E,MO            ; ?MO Error
1909:	0DDA  CAC504  	        JP      Z,ERROR         ; No operand - Error
1910:	0DDD  DA3118  	        JP      C,ASCTFP        ; Number - Get value
1911:	0DE0  CD7909  	        CALL    CHKLTR          ; See if a letter
1912:	0DE3  D2380E  	        JP      NC,CONVAR       ; Letter - Find variable
1913:	0DE6  FE26    	        CP      '&'             ; &H = HEX, &B = BINARY
1914:	0DE8  2012    	        JR      NZ, NOTAMP
1915:	0DEA  CDD508  	        CALL    GETCHR          ; Get next character
1916:	0DED  FE48    	        CP      'H'             ; Hex number indicated? [function added]
1917:	0DEF  CA771C  	        JP      Z,HEXTFP        ; Convert Hex to FPREG
1918:	0DF2  FE42    	        CP      'B'             ; Binary number indicated? [function added]
1919:	0DF4  CAE71C  	        JP      Z,BINTFP        ; Convert Bin to FPREG
1920:	0DF7  1E02    	        LD      E,SN            ; If neither then a ?SN Error
1921:	0DF9  CAC504  	        JP      Z,ERROR         ; 
1922:	0DFC  FEAC    	NOTAMP: CP      ZPLUS           ; '+' Token ?
1923:	0DFE  CAD10D  	        JP      Z,OPRND         ; Yes - Look for operand
1924:	0E01  FE2E    	        CP      '.'             ; '.' ?
1925:	0E03  CA3118  	        JP      Z,ASCTFP        ; Yes - Create FP number
1926:	0E06  FEAD    	        CP      ZMINUS          ; '-' Token ?
1927:	0E08  CA270E  	        JP      Z,MINUS         ; Yes - Do minus
1928:	0E0B  FE22    	        CP      '"'             ; Literal string ?
1929:	0E0D  CAE011  	        JP      Z,QTSTR         ; Get string terminated by '"'
1930:	0E10  FEAA    	        CP      ZNOT            ; "NOT" Token ?
1931:	0E12  CA190F  	        JP      Z,EVNOT         ; Yes - Eval NOT expression
1932:	0E15  FEA7    	        CP      ZFN             ; "FN" Token ?
1933:	0E17  CA4411  	        JP      Z,DOFN          ; Yes - Do FN routine
1934:	0E1A  D6B6    	        SUB     ZSGN            ; Is it a function?
1935:	0E1C  D2490E  	        JP      NC,FNOFST       ; Yes - Evaluate function
1936:	0E1F  CD560D  	EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
1937:	0E22  CD4B07  	        CALL    CHKSYN          ; Make sure ")" follows
1938:	0E25  29      	        .DB     ")"
1939:	0E26  C9      	        RET
1940:			
1941:	0E27  167D    	MINUS:  LD      D,7DH           ; '-' precedence
1942:	0E29  CD5D0D  	        CALL    EVAL1           ; Evaluate until prec' break
1943:	0E2C  2AD020  	        LD      HL,(NXTOPR)     ; Get next operator address
1944:	0E2F  E5      	        PUSH    HL              ; Save next operator address
1945:	0E30  CD5317  	        CALL    INVSGN          ; Negate value
1946:	0E33  CD4B0D  	RETNUM: CALL    TSTNUM          ; Make sure it's a number
1947:	0E36  E1      	        POP     HL              ; Restore next operator address
1948:	0E37  C9      	        RET
1949:			
1950:	0E38  CD3E0F  	CONVAR: CALL    GETVAR          ; Get variable address to DE
1951:	0E3B  E5      	FRMEVL: PUSH    HL              ; Save code string address
1952:	0E3C  EB      	        EX      DE,HL           ; Variable address to HL
1953:	0E3D  22E420  	        LD      (FPREG),HL      ; Save address of variable
1954:	0E40  3AAD20  	        LD      A,(TYPE)        ; Get type
1955:	0E43  B7      	        OR      A               ; Numeric?
1956:	0E44  CC6817  	        CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
1957:	0E47  E1      	        POP     HL              ; Restore code string address
1958:	0E48  C9      	        RET
1959:			
1960:	0E49  0600    	FNOFST: LD      B,0             ; Get address of function
1961:	0E4B  07      	        RLCA                    ; Double function offset
1962:	0E4C  4F      	        LD      C,A             ; BC = Offset in function table
1963:	0E4D  C5      	        PUSH    BC              ; Save adjusted token value
1964:	0E4E  CDD508  	        CALL    GETCHR          ; Get next character
1965:	0E51  79      	        LD      A,C             ; Get adjusted token value
1966:	0E52  FE31    	        CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
1967:	0E54  DA700E  	        JP      C,FNVAL         ; No - Do function
1968:	0E57  CD560D  	        CALL    OPNPAR          ; Evaluate expression  (X,...
1969:	0E5A  CD4B07  	        CALL    CHKSYN          ; Make sure ',' follows
1970:	0E5D  2C      	        .DB     ','
1971:	0E5E  CD4C0D  	        CALL    TSTSTR          ; Make sure it's a string
1972:	0E61  EB      	        EX      DE,HL           ; Save code string address
1973:	0E62  2AE420  	        LD      HL,(FPREG)      ; Get address of string
1974:	0E65  E3      	        EX      (SP),HL         ; Save address of string
1975:	0E66  E5      	        PUSH    HL              ; Save adjusted token value
1976:	0E67  EB      	        EX      DE,HL           ; Restore code string address
1977:	0E68  CDA914  	        CALL    GETINT          ; Get integer 0-255
1978:	0E6B  EB      	        EX      DE,HL           ; Save code string address
1979:	0E6C  E3      	        EX      (SP),HL         ; Save integer,HL = adj' token
1980:	0E6D  C3780E  	        JP      GOFUNC          ; Jump to string function
1981:			
1982:	0E70  CD1F0E  	FNVAL:  CALL    EVLPAR          ; Evaluate expression
1983:	0E73  E3      	        EX      (SP),HL         ; HL = Adjusted token value
1984:	0E74  11330E  	        LD      DE,RETNUM       ; Return number from function
1985:	0E77  D5      	        PUSH    DE              ; Save on stack
1986:	0E78  010202  	GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
1987:	0E7B  09      	        ADD     HL,BC           ; Point to right address
1988:	0E7C  4E      	        LD      C,(HL)          ; Get LSB of address
1989:	0E7D  23      	        INC     HL              ;
1990:	0E7E  66      	        LD      H,(HL)          ; Get MSB of address
1991:	0E7F  69      	        LD      L,C             ; Address to HL
1992:	0E80  E9      	        JP      (HL)            ; Jump to function
1993:			
1994:	0E81  15      	SGNEXP: DEC     D               ; Dee to flag negative exponent
1995:	0E82  FEAD    	        CP      ZMINUS          ; '-' token ?
1996:	0E84  C8      	        RET     Z               ; Yes - Return
1997:	0E85  FE2D    	        CP      '-'             ; '-' ASCII ?
1998:	0E87  C8      	        RET     Z               ; Yes - Return
1999:	0E88  14      	        INC     D               ; Inc to flag positive exponent
2000:	0E89  FE2B    	        CP      '+'             ; '+' ASCII ?
2001:	0E8B  C8      	        RET     Z               ; Yes - Return
2002:	0E8C  FEAC    	        CP      ZPLUS           ; '+' token ?
2003:	0E8E  C8      	        RET     Z               ; Yes - Return
2004:	0E8F  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
2005:	0E90  C9      	        RET                     ; Return "NZ"
2006:			
2007:	0E91  F6      	POR:    .DB     0F6H            ; Flag "OR"
2008:	0E92  AF      	PAND:   XOR     A               ; Flag "AND"
2009:	0E93  F5      	        PUSH    AF              ; Save "AND" / "OR" flag
2010:	0E94  CD4B0D  	        CALL    TSTNUM          ; Make sure it's a number
2011:	0E97  CD8D09  	        CALL    DEINT           ; Get integer -32768 to 32767
2012:	0E9A  F1      	        POP     AF              ; Restore "AND" / "OR" flag
2013:	0E9B  EB      	        EX      DE,HL           ; <- Get last
2014:	0E9C  C1      	        POP     BC              ; <-  value
2015:	0E9D  E3      	        EX      (SP),HL         ; <-  from
2016:	0E9E  EB      	        EX      DE,HL           ; <-  stack
2017:	0E9F  CD6B17  	        CALL    FPBCDE          ; Move last value to FPREG
2018:	0EA2  F5      	        PUSH    AF              ; Save "AND" / "OR" flag
2019:	0EA3  CD8D09  	        CALL    DEINT           ; Get integer -32768 to 32767
2020:	0EA6  F1      	        POP     AF              ; Restore "AND" / "OR" flag
2021:	0EA7  C1      	        POP     BC              ; Get value
2022:	0EA8  79      	        LD      A,C             ; Get LSB
2023:	0EA9  210211  	        LD      HL,ACPASS       ; Address of save AC as current
2024:	0EAC  C2B40E  	        JP      NZ,POR1         ; Jump if OR
2025:	0EAF  A3      	        AND     E               ; "AND" LSBs
2026:	0EB0  4F      	        LD      C,A             ; Save LSB
2027:	0EB1  78      	        LD      A,B             ; Get MBS
2028:	0EB2  A2      	        AND     D               ; "AND" MSBs
2029:	0EB3  E9      	        JP      (HL)            ; Save AC as current (ACPASS)
2030:			
2031:	0EB4  B3      	POR1:   OR      E               ; "OR" LSBs
2032:	0EB5  4F      	        LD      C,A             ; Save LSB
2033:	0EB6  78      	        LD      A,B             ; Get MSB
2034:	0EB7  B2      	        OR      D               ; "OR" MSBs
2035:	0EB8  E9      	        JP      (HL)            ; Save AC as current (ACPASS)
2036:			
2037:	0EB9  21CB0E  	TSTRED: LD      HL,CMPLOG       ; Logical compare routine
2038:	0EBC  3AAD20  	        LD      A,(TYPE)        ; Get data type
2039:	0EBF  1F      	        RRA                     ; Carry set = string
2040:	0EC0  7A      	        LD      A,D             ; Get last precedence value
2041:	0EC1  17      	        RLA                     ; Times 2 plus carry
2042:	0EC2  5F      	        LD      E,A             ; To E
2043:	0EC3  1664    	        LD      D,64H           ; Relational precedence
2044:	0EC5  78      	        LD      A,B             ; Get current precedence
2045:	0EC6  BA      	        CP      D               ; Compare with last
2046:	0EC7  D0      	        RET     NC              ; Eval if last was rel' or log'
2047:	0EC8  C3BA0D  	        JP      STKTHS          ; Stack this one and get next
2048:			
2049:	0ECB  CD0E    	CMPLOG: .DW     CMPLG1          ; Compare two values / strings
2050:	0ECD  79      	CMPLG1: LD      A,C             ; Get data type
2051:	0ECE  B7      	        OR      A
2052:	0ECF  1F      	        RRA
2053:	0ED0  C1      	        POP     BC              ; Get last expression to BCDE
2054:	0ED1  D1      	        POP     DE
2055:	0ED2  F5      	        PUSH    AF              ; Save status
2056:	0ED3  CD4D0D  	        CALL    CHKTYP          ; Check that types match
2057:	0ED6  210F0F  	        LD      HL,CMPRES       ; Result to comparison
2058:	0ED9  E5      	        PUSH    HL              ; Save for RETurn
2059:	0EDA  CAA517  	        JP      Z,CMPNUM        ; Compare values if numeric
2060:	0EDD  AF      	        XOR     A               ; Compare two strings
2061:	0EDE  32AD20  	        LD      (TYPE),A        ; Set type to numeric
2062:	0EE1  D5      	        PUSH    DE              ; Save string name
2063:	0EE2  CD6413  	        CALL    GSTRCU          ; Get current string
2064:	0EE5  7E      	        LD      A,(HL)          ; Get length of string
2065:	0EE6  23      	        INC     HL
2066:	0EE7  23      	        INC     HL
2067:	0EE8  4E      	        LD      C,(HL)          ; Get LSB of address
2068:	0EE9  23      	        INC     HL
2069:	0EEA  46      	        LD      B,(HL)          ; Get MSB of address
2070:	0EEB  D1      	        POP     DE              ; Restore string name
2071:	0EEC  C5      	        PUSH    BC              ; Save address of string
2072:	0EED  F5      	        PUSH    AF              ; Save length of string
2073:	0EEE  CD6813  	        CALL    GSTRDE          ; Get second string
2074:	0EF1  CD7917  	        CALL    LOADFP          ; Get address of second string
2075:	0EF4  F1      	        POP     AF              ; Restore length of string 1
2076:	0EF5  57      	        LD      D,A             ; Length to D
2077:	0EF6  E1      	        POP     HL              ; Restore address of string 1
2078:	0EF7  7B      	CMPSTR: LD      A,E             ; Bytes of string 2 to do
2079:	0EF8  B2      	        OR      D               ; Bytes of string 1 to do
2080:	0EF9  C8      	        RET     Z               ; Exit if all bytes compared
2081:	0EFA  7A      	        LD      A,D             ; Get bytes of string 1 to do
2082:	0EFB  D601    	        SUB     1
2083:	0EFD  D8      	        RET     C               ; Exit if end of string 1
2084:	0EFE  AF      	        XOR     A
2085:	0EFF  BB      	        CP      E               ; Bytes of string 2 to do
2086:	0F00  3C      	        INC     A
2087:	0F01  D0      	        RET     NC              ; Exit if end of string 2
2088:	0F02  15      	        DEC     D               ; Count bytes in string 1
2089:	0F03  1D      	        DEC     E               ; Count bytes in string 2
2090:	0F04  0A      	        LD      A,(BC)          ; Byte in string 2
2091:	0F05  BE      	        CP      (HL)            ; Compare to byte in string 1
2092:	0F06  23      	        INC     HL              ; Move up string 1
2093:	0F07  03      	        INC     BC              ; Move up string 2
2094:	0F08  CAF70E  	        JP      Z,CMPSTR        ; Same - Try next bytes
2095:	0F0B  3F      	        CCF                     ; Flag difference (">" or "<")
2096:	0F0C  C33517  	        JP      FLGDIF          ; "<" gives -1 , ">" gives +1
2097:			
2098:	0F0F  3C      	CMPRES: INC     A               ; Increment current value
2099:	0F10  8F      	        ADC     A,A             ; Double plus carry
2100:	0F11  C1      	        POP     BC              ; Get other value
2101:	0F12  A0      	        AND     B               ; Combine them
2102:	0F13  C6FF    	        ADD     A,-1            ; Carry set if different
2103:	0F15  9F      	        SBC     A,A             ; 00 - Equal , FF - Different
2104:	0F16  C33C17  	        JP      FLGREL          ; Set current value & continue
2105:			
2106:	0F19  165A    	EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
2107:	0F1B  CD5D0D  	        CALL    EVAL1           ; Eval until precedence break
2108:	0F1E  CD4B0D  	        CALL    TSTNUM          ; Make sure it's a number
2109:	0F21  CD8D09  	        CALL    DEINT           ; Get integer -32768 - 32767
2110:	0F24  7B      	        LD      A,E             ; Get LSB
2111:	0F25  2F      	        CPL                     ; Invert LSB
2112:	0F26  4F      	        LD      C,A             ; Save "NOT" of LSB
2113:	0F27  7A      	        LD      A,D             ; Get MSB
2114:	0F28  2F      	        CPL                     ; Invert MSB
2115:	0F29  CD0211  	        CALL    ACPASS          ; Save AC as current
2116:	0F2C  C1      	        POP     BC              ; Clean up stack
2117:	0F2D  C3690D  	        JP      EVAL3           ; Continue evaluation
2118:			
2119:	0F30  2B      	DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
2120:	0F31  CDD508  	        CALL    GETCHR          ; Get next character
2121:	0F34  C8      	        RET     Z               ; End of DIM statement
2122:	0F35  CD4B07  	        CALL    CHKSYN          ; Make sure ',' follows
2123:	0F38  2C      	        .DB     ','
2124:	0F39  01300F  	DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
2125:	0F3C  C5      	        PUSH    BC              ; Save on stack
2126:	0F3D  F6      	        .DB     0F6H            ; Flag "Create" variable
2127:	0F3E  AF      	GETVAR: XOR     A               ; Find variable address,to DE
2128:	0F3F  32AC20  	        LD      (LCRFLG),A      ; Set locate / create flag
2129:	0F42  46      	        LD      B,(HL)          ; Get First byte of name
2130:	0F43  CD7909  	GTFNAM: CALL    CHKLTR          ; See if a letter
2131:	0F46  DAB104  	        JP      C,SNERR         ; ?SN Error if not a letter
2132:	0F49  AF      	        XOR     A
2133:	0F4A  4F      	        LD      C,A             ; Clear second byte of name
2134:	0F4B  32AD20  	        LD      (TYPE),A        ; Set type to numeric
2135:	0F4E  CDD508  	        CALL    GETCHR          ; Get next character
2136:	0F51  DA5A0F  	        JP      C,SVNAM2        ; Numeric - Save in name
2137:	0F54  CD7909  	        CALL    CHKLTR          ; See if a letter
2138:	0F57  DA670F  	        JP      C,CHARTY        ; Not a letter - Check type
2139:	0F5A  4F      	SVNAM2: LD      C,A             ; Save second byte of name
2140:	0F5B  CDD508  	ENDNAM: CALL    GETCHR          ; Get next character
2141:	0F5E  DA5B0F  	        JP      C,ENDNAM        ; Numeric - Get another
2142:	0F61  CD7909  	        CALL    CHKLTR          ; See if a letter
2143:	0F64  D25B0F  	        JP      NC,ENDNAM       ; Letter - Get another
2144:	0F67  D624    	CHARTY: SUB     '$'             ; String variable?
2145:	0F69  C2760F  	        JP      NZ,NOTSTR       ; No - Numeric variable
2146:	0F6C  3C      	        INC     A               ; A = 1 (string type)
2147:	0F6D  32AD20  	        LD      (TYPE),A        ; Set type to string
2148:	0F70  0F      	        RRCA                    ; A = 80H , Flag for string
2149:	0F71  81      	        ADD     A,C             ; 2nd byte of name has bit 7 on
2150:	0F72  4F      	        LD      C,A             ; Resave second byte on name
2151:	0F73  CDD508  	        CALL    GETCHR          ; Get next character
2152:	0F76  3ACB20  	NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
2153:	0F79  3D      	        DEC     A
2154:	0F7A  CA2310  	        JP      Z,ARLDSV        ; Yes - Get array name
2155:	0F7D  F2860F  	        JP      P,NSCFOR        ; No array with "FOR" or "FN"
2156:	0F80  7E      	        LD      A,(HL)          ; Get byte again
2157:	0F81  D628    	        SUB     '('             ; Subscripted variable?
2158:	0F83  CAFB0F  	        JP      Z,SBSCPT        ; Yes - Sort out subscript
2159:			
2160:	0F86  AF      	NSCFOR: XOR     A               ; Simple variable
2161:	0F87  32CB20  	        LD      (FORFLG),A      ; Clear "FOR" flag
2162:	0F8A  E5      	        PUSH    HL              ; Save code string address
2163:	0F8B  50      	        LD      D,B             ; DE = Variable name to find
2164:	0F8C  59      	        LD      E,C
2165:	0F8D  2ADE20  	        LD      HL,(FNRGNM)     ; FN argument name
2166:	0F90  CD4507  	        CALL    CPDEHL          ; Is it the FN argument?
2167:	0F93  11E020  	        LD      DE,FNARG        ; Point to argument value
2168:	0F96  CA6B16  	        JP      Z,POPHRT        ; Yes - Return FN argument value
2169:	0F99  2AD820  	        LD      HL,(VAREND)     ; End of variables
2170:	0F9C  EB      	        EX      DE,HL           ; Address of end of search
2171:	0F9D  2AD620  	        LD      HL,(PROGND)     ; Start of variables address
2172:	0FA0  CD4507  	FNDVAR: CALL    CPDEHL          ; End of variable list table?
2173:	0FA3  CAB90F  	        JP      Z,CFEVAL        ; Yes - Called from EVAL?
2174:	0FA6  79      	        LD      A,C             ; Get second byte of name
2175:	0FA7  96      	        SUB     (HL)            ; Compare with name in list
2176:	0FA8  23      	        INC     HL              ; Move on to first byte
2177:	0FA9  C2AE0F  	        JP      NZ,FNTHR        ; Different - Find another
2178:	0FAC  78      	        LD      A,B             ; Get first byte of name
2179:	0FAD  96      	        SUB     (HL)            ; Compare with name in list
2180:	0FAE  23      	FNTHR:  INC     HL              ; Move on to LSB of value
2181:	0FAF  CAED0F  	        JP      Z,RETADR        ; Found - Return address
2182:	0FB2  23      	        INC     HL              ; <- Skip
2183:	0FB3  23      	        INC     HL              ; <- over
2184:	0FB4  23      	        INC     HL              ; <- F.P.
2185:	0FB5  23      	        INC     HL              ; <- value
2186:	0FB6  C3A00F  	        JP      FNDVAR          ; Keep looking
2187:			
2188:	0FB9  E1      	CFEVAL: POP     HL              ; Restore code string address
2189:	0FBA  E3      	        EX      (SP),HL         ; Get return address
2190:	0FBB  D5      	        PUSH    DE              ; Save address of variable
2191:	0FBC  113B0E  	        LD      DE,FRMEVL       ; Return address in EVAL
2192:	0FBF  CD4507  	        CALL    CPDEHL          ; Called from EVAL ?
2193:	0FC2  D1      	        POP     DE              ; Restore address of variable
2194:	0FC3  CAF00F  	        JP      Z,RETNUL        ; Yes - Return null variable
2195:	0FC6  E3      	        EX      (SP),HL         ; Put back return
2196:	0FC7  E5      	        PUSH    HL              ; Save code string address
2197:	0FC8  C5      	        PUSH    BC              ; Save variable name
2198:	0FC9  010600  	        LD      BC,6            ; 2 byte name plus 4 byte data
2199:	0FCC  2ADA20  	        LD      HL,(ARREND)     ; End of arrays
2200:	0FCF  E5      	        PUSH    HL              ; Save end of arrays
2201:	0FD0  09      	        ADD     HL,BC           ; Move up 6 bytes
2202:	0FD1  C1      	        POP     BC              ; Source address in BC
2203:	0FD2  E5      	        PUSH    HL              ; Save new end address
2204:	0FD3  CD7D04  	        CALL    MOVUP           ; Move arrays up
2205:	0FD6  E1      	        POP     HL              ; Restore new end address
2206:	0FD7  22DA20  	        LD      (ARREND),HL     ; Set new end address
2207:	0FDA  60      	        LD      H,B             ; End of variables to HL
2208:	0FDB  69      	        LD      L,C
2209:	0FDC  22D820  	        LD      (VAREND),HL     ; Set new end address
2210:			
2211:	0FDF  2B      	ZEROLP: DEC     HL              ; Back through to zero variable
2212:	0FE0  3600    	        LD      (HL),0          ; Zero byte in variable
2213:	0FE2  CD4507  	        CALL    CPDEHL          ; Done them all?
2214:	0FE5  C2DF0F  	        JP      NZ,ZEROLP       ; No - Keep on going
2215:	0FE8  D1      	        POP     DE              ; Get variable name
2216:	0FE9  73      	        LD      (HL),E          ; Store second character
2217:	0FEA  23      	        INC     HL
2218:	0FEB  72      	        LD      (HL),D          ; Store first character
2219:	0FEC  23      	        INC     HL
2220:	0FED  EB      	RETADR: EX      DE,HL           ; Address of variable in DE
2221:	0FEE  E1      	        POP     HL              ; Restore code string address
2222:	0FEF  C9      	        RET
2223:			
2224:	0FF0  32E720  	RETNUL: LD      (FPEXP),A       ; Set result to zero
2225:	0FF3  214D04  	        LD      HL,ZERBYT       ; Also set a null string
2226:	0FF6  22E420  	        LD      (FPREG),HL      ; Save for EVAL
2227:	0FF9  E1      	        POP     HL              ; Restore code string address
2228:	0FFA  C9      	        RET
2229:			
2230:	0FFB  E5      	SBSCPT: PUSH    HL              ; Save code string address
2231:	0FFC  2AAC20  	        LD      HL,(LCRFLG)     ; Locate/Create and Type
2232:	0FFF  E3      	        EX      (SP),HL         ; Save and get code string
2233:	1000  57      	        LD      D,A             ; Zero number of dimensions
2234:	1001  D5      	SCPTLP: PUSH    DE              ; Save number of dimensions
2235:	1002  C5      	        PUSH    BC              ; Save array name
2236:	1003  CD8109  	        CALL    FPSINT          ; Get subscript (0-32767)
2237:	1006  C1      	        POP     BC              ; Restore array name
2238:	1007  F1      	        POP     AF              ; Get number of dimensions
2239:	1008  EB      	        EX      DE,HL
2240:	1009  E3      	        EX      (SP),HL         ; Save subscript value
2241:	100A  E5      	        PUSH    HL              ; Save LCRFLG and TYPE
2242:	100B  EB      	        EX      DE,HL
2243:	100C  3C      	        INC     A               ; Count dimensions
2244:	100D  57      	        LD      D,A             ; Save in D
2245:	100E  7E      	        LD      A,(HL)          ; Get next byte in code string
2246:	100F  FE2C    	        CP      ','             ; Comma (more to come)?
2247:	1011  CA0110  	        JP      Z,SCPTLP        ; Yes - More subscripts
2248:	1014  CD4B07  	        CALL    CHKSYN          ; Make sure ")" follows
2249:	1017  29      	        .DB     ")"
2250:	1018  22D020  	        LD      (NXTOPR),HL     ; Save code string address
2251:	101B  E1      	        POP     HL              ; Get LCRFLG and TYPE
2252:	101C  22AC20  	        LD      (LCRFLG),HL     ; Restore Locate/create & type
2253:	101F  1E00    	        LD      E,0             ; Flag not CSAVE* or CLOAD*
2254:	1021  D5      	        PUSH    DE              ; Save number of dimensions (D)
2255:	1022  11      	        .DB     11H             ; Skip "PUSH HL" and "PUSH AF'
2256:			
2257:	1023  E5      	ARLDSV: PUSH    HL              ; Save code string address
2258:	1024  F5      	        PUSH    AF              ; A = 00 , Flags set = Z,N
2259:	1025  2AD820  	        LD      HL,(VAREND)     ; Start of arrays
2260:	1028  3E      	        .DB     3EH             ; Skip "ADD HL,DE"
2261:	1029  19      	FNDARY: ADD     HL,DE           ; Move to next array start
2262:	102A  EB      	        EX      DE,HL
2263:	102B  2ADA20  	        LD      HL,(ARREND)     ; End of arrays
2264:	102E  EB      	        EX      DE,HL           ; Current array pointer
2265:	102F  CD4507  	        CALL    CPDEHL          ; End of arrays found?
2266:	1032  CA5B10  	        JP      Z,CREARY        ; Yes - Create array
2267:	1035  7E      	        LD      A,(HL)          ; Get second byte of name
2268:	1036  B9      	        CP      C               ; Compare with name given
2269:	1037  23      	        INC     HL              ; Move on
2270:	1038  C23D10  	        JP      NZ,NXTARY       ; Different - Find next array
2271:	103B  7E      	        LD      A,(HL)          ; Get first byte of name
2272:	103C  B8      	        CP      B               ; Compare with name given
2273:	103D  23      	NXTARY: INC     HL              ; Move on
2274:	103E  5E      	        LD      E,(HL)          ; Get LSB of next array address
2275:	103F  23      	        INC     HL
2276:	1040  56      	        LD      D,(HL)          ; Get MSB of next array address
2277:	1041  23      	        INC     HL
2278:	1042  C22910  	        JP      NZ,FNDARY       ; Not found - Keep looking
2279:	1045  3AAC20  	        LD      A,(LCRFLG)      ; Found Locate or Create it?
2280:	1048  B7      	        OR      A
2281:	1049  C2BA04  	        JP      NZ,DDERR        ; Create - ?DD Error
2282:	104C  F1      	        POP     AF              ; Locate - Get number of dim'ns
2283:	104D  44      	        LD      B,H             ; BC Points to array dim'ns
2284:	104E  4D      	        LD      C,L
2285:	104F  CA6B16  	        JP      Z,POPHRT        ; Jump if array load/save
2286:	1052  96      	        SUB     (HL)            ; Same number of dimensions?
2287:	1053  CAB910  	        JP      Z,FINDEL        ; Yes - Find element
2288:	1056  1E10    	BSERR:  LD      E,BS            ; ?BS Error
2289:	1058  C3C504  	        JP      ERROR           ; Output error
2290:			
2291:	105B  110400  	CREARY: LD      DE,4            ; 4 Bytes per entry
2292:	105E  F1      	        POP     AF              ; Array to save or 0 dim'ns?
2293:	105F  CAA209  	        JP      Z,FCERR         ; Yes - ?FC Error
2294:	1062  71      	        LD      (HL),C          ; Save second byte of name
2295:	1063  23      	        INC     HL
2296:	1064  70      	        LD      (HL),B          ; Save first byte of name
2297:	1065  23      	        INC     HL
2298:	1066  4F      	        LD      C,A             ; Number of dimensions to C
2299:	1067  CD8E04  	        CALL    CHKSTK          ; Check if enough memory
2300:	106A  23      	        INC     HL              ; Point to number of dimensions
2301:	106B  23      	        INC     HL
2302:	106C  22C520  	        LD      (CUROPR),HL     ; Save address of pointer
2303:	106F  71      	        LD      (HL),C          ; Set number of dimensions
2304:	1070  23      	        INC     HL
2305:	1071  3AAC20  	        LD      A,(LCRFLG)      ; Locate of Create?
2306:	1074  17      	        RLA                     ; Carry set = Create
2307:	1075  79      	        LD      A,C             ; Get number of dimensions
2308:	1076  010B00  	CRARLP: LD      BC,10+1         ; Default dimension size 10
2309:	1079  D27E10  	        JP      NC,DEFSIZ       ; Locate - Set default size
2310:	107C  C1      	        POP     BC              ; Get specified dimension size
2311:	107D  03      	        INC     BC              ; Include zero element
2312:	107E  71      	DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
2313:	107F  23      	        INC     HL
2314:	1080  70      	        LD      (HL),B          ; Save MSB of dimension size
2315:	1081  23      	        INC     HL
2316:	1082  F5      	        PUSH    AF              ; Save num' of dim'ns an status
2317:	1083  E5      	        PUSH    HL              ; Save address of dim'n size
2318:	1084  CD1618  	        CALL    MLDEBC          ; Multiply DE by BC to find
2319:	1087  EB      	        EX      DE,HL           ; amount of mem needed (to DE)
2320:	1088  E1      	        POP     HL              ; Restore address of dimension
2321:	1089  F1      	        POP     AF              ; Restore number of dimensions
2322:	108A  3D      	        DEC     A               ; Count them
2323:	108B  C27610  	        JP      NZ,CRARLP       ; Do next dimension if more
2324:	108E  F5      	        PUSH    AF              ; Save locate/create flag
2325:	108F  42      	        LD      B,D             ; MSB of memory needed
2326:	1090  4B      	        LD      C,E             ; LSB of memory needed
2327:	1091  EB      	        EX      DE,HL
2328:	1092  19      	        ADD     HL,DE           ; Add bytes to array start
2329:	1093  DAA604  	        JP      C,OMERR         ; Too big - Error
2330:	1096  CD9704  	        CALL    ENFMEM          ; See if enough memory
2331:	1099  22DA20  	        LD      (ARREND),HL     ; Save new end of array
2332:			
2333:	109C  2B      	ZERARY: DEC     HL              ; Back through array data
2334:	109D  3600    	        LD      (HL),0          ; Set array element to zero
2335:	109F  CD4507  	        CALL    CPDEHL          ; All elements zeroed?
2336:	10A2  C29C10  	        JP      NZ,ZERARY       ; No - Keep on going
2337:	10A5  03      	        INC     BC              ; Number of bytes + 1
2338:	10A6  57      	        LD      D,A             ; A=0
2339:	10A7  2AC520  	        LD      HL,(CUROPR)     ; Get address of array
2340:	10AA  5E      	        LD      E,(HL)          ; Number of dimensions
2341:	10AB  EB      	        EX      DE,HL           ; To HL
2342:	10AC  29      	        ADD     HL,HL           ; Two bytes per dimension size
2343:	10AD  09      	        ADD     HL,BC           ; Add number of bytes
2344:	10AE  EB      	        EX      DE,HL           ; Bytes needed to DE
2345:	10AF  2B      	        DEC     HL
2346:	10B0  2B      	        DEC     HL
2347:	10B1  73      	        LD      (HL),E          ; Save LSB of bytes needed
2348:	10B2  23      	        INC     HL
2349:	10B3  72      	        LD      (HL),D          ; Save MSB of bytes needed
2350:	10B4  23      	        INC     HL
2351:	10B5  F1      	        POP     AF              ; Locate / Create?
2352:	10B6  DADD10  	        JP      C,ENDDIM        ; A is 0 , End if create
2353:	10B9  47      	FINDEL: LD      B,A             ; Find array element
2354:	10BA  4F      	        LD      C,A
2355:	10BB  7E      	        LD      A,(HL)          ; Number of dimensions
2356:	10BC  23      	        INC     HL
2357:	10BD  16      	        .DB     16H             ; Skip "POP HL"
2358:	10BE  E1      	FNDELP: POP     HL              ; Address of next dim' size
2359:	10BF  5E      	        LD      E,(HL)          ; Get LSB of dim'n size
2360:	10C0  23      	        INC     HL
2361:	10C1  56      	        LD      D,(HL)          ; Get MSB of dim'n size
2362:	10C2  23      	        INC     HL
2363:	10C3  E3      	        EX      (SP),HL         ; Save address - Get index
2364:	10C4  F5      	        PUSH    AF              ; Save number of dim'ns
2365:	10C5  CD4507  	        CALL    CPDEHL          ; Dimension too large?
2366:	10C8  D25610  	        JP      NC,BSERR        ; Yes - ?BS Error
2367:	10CB  E5      	        PUSH    HL              ; Save index
2368:	10CC  CD1618  	        CALL    MLDEBC          ; Multiply previous by size
2369:	10CF  D1      	        POP     DE              ; Index supplied to DE
2370:	10D0  19      	        ADD     HL,DE           ; Add index to pointer
2371:	10D1  F1      	        POP     AF              ; Number of dimensions
2372:	10D2  3D      	        DEC     A               ; Count them
2373:	10D3  44      	        LD      B,H             ; MSB of pointer
2374:	10D4  4D      	        LD      C,L             ; LSB of pointer
2375:	10D5  C2BE10  	        JP      NZ,FNDELP       ; More - Keep going
2376:	10D8  29      	        ADD     HL,HL           ; 4 Bytes per element
2377:	10D9  29      	        ADD     HL,HL
2378:	10DA  C1      	        POP     BC              ; Start of array
2379:	10DB  09      	        ADD     HL,BC           ; Point to element
2380:	10DC  EB      	        EX      DE,HL           ; Address of element to DE
2381:	10DD  2AD020  	ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
2382:	10E0  C9      	        RET
2383:			
2384:	10E1  2ADA20  	FRE:    LD      HL,(ARREND)     ; Start of free memory
2385:	10E4  EB      	        EX      DE,HL           ; To DE
2386:	10E5  210000  	        LD      HL,0            ; End of free memory
2387:	10E8  39      	        ADD     HL,SP           ; Current stack value
2388:	10E9  3AAD20  	        LD      A,(TYPE)        ; Dummy argument type
2389:	10EC  B7      	        OR      A
2390:	10ED  CAFD10  	        JP      Z,FRENUM        ; Numeric - Free variable space
2391:	10F0  CD6413  	        CALL    GSTRCU          ; Current string to pool
2392:	10F3  CD6412  	        CALL    GARBGE          ; Garbage collection
2393:	10F6  2A5A20  	        LD      HL,(STRSPC)     ; Bottom of string space in use
2394:	10F9  EB      	        EX      DE,HL           ; To DE
2395:	10FA  2AC320  	        LD      HL,(STRBOT)     ; Bottom of string space
2396:	10FD  7D      	FRENUM: LD      A,L             ; Get LSB of end
2397:	10FE  93      	        SUB     E               ; Subtract LSB of beginning
2398:	10FF  4F      	        LD      C,A             ; Save difference if C
2399:	1100  7C      	        LD      A,H             ; Get MSB of end
2400:	1101  9A      	        SBC     A,D             ; Subtract MSB of beginning
2401:	1102  41      	ACPASS: LD      B,C             ; Return integer AC
2402:	1103  50      	ABPASS: LD      D,B             ; Return integer AB
2403:	1104  1E00    	        LD      E,0
2404:	1106  21AD20  	        LD      HL,TYPE         ; Point to type
2405:	1109  73      	        LD      (HL),E          ; Set type to numeric
2406:	110A  0690    	        LD      B,80H+16        ; 16 bit integer
2407:	110C  C34117  	        JP      RETINT          ; Return the integr
2408:			
2409:	110F  3AAB20  	POS:    LD      A,(CURPOS)      ; Get cursor position
2410:	1112  47      	PASSA:  LD      B,A             ; Put A into AB
2411:	1113  AF      	        XOR     A               ; Zero A
2412:	1114  C30311  	        JP      ABPASS          ; Return integer AB
2413:			
2414:	1117  CD9A11  	DEF:    CALL    CHEKFN          ; Get "FN" and name
2415:	111A  CD8C11  	        CALL    IDTEST          ; Test for illegal direct
2416:	111D  01720A  	        LD      BC,DATA         ; To get next statement
2417:	1120  C5      	        PUSH    BC              ; Save address for RETurn
2418:	1121  D5      	        PUSH    DE              ; Save address of function ptr
2419:	1122  CD4B07  	        CALL    CHKSYN          ; Make sure "(" follows
2420:	1125  28      	        .DB     "("
2421:	1126  CD3E0F  	        CALL    GETVAR          ; Get argument variable name
2422:	1129  E5      	        PUSH    HL              ; Save code string address
2423:	112A  EB      	        EX      DE,HL           ; Argument address to HL
2424:	112B  2B      	        DEC     HL
2425:	112C  56      	        LD      D,(HL)          ; Get first byte of arg name
2426:	112D  2B      	        DEC     HL
2427:	112E  5E      	        LD      E,(HL)          ; Get second byte of arg name
2428:	112F  E1      	        POP     HL              ; Restore code string address
2429:	1130  CD4B0D  	        CALL    TSTNUM          ; Make sure numeric argument
2430:	1133  CD4B07  	        CALL    CHKSYN          ; Make sure ")" follows
2431:	1136  29      	        .DB     ")"
2432:	1137  CD4B07  	        CALL    CHKSYN          ; Make sure "=" follows
2433:	113A  B4      	        .DB     ZEQUAL          ; "=" token
2434:	113B  44      	        LD      B,H             ; Code string address to BC
2435:	113C  4D      	        LD      C,L
2436:	113D  E3      	        EX      (SP),HL         ; Save code str , Get FN ptr
2437:	113E  71      	        LD      (HL),C          ; Save LSB of FN code string
2438:	113F  23      	        INC     HL
2439:	1140  70      	        LD      (HL),B          ; Save MSB of FN code string
2440:	1141  C3D911  	        JP      SVSTAD          ; Save address and do function
2441:			
2442:	1144  CD9A11  	DOFN:   CALL    CHEKFN          ; Make sure FN follows
2443:	1147  D5      	        PUSH    DE              ; Save function pointer address
2444:	1148  CD1F0E  	        CALL    EVLPAR          ; Evaluate expression in "()"
2445:	114B  CD4B0D  	        CALL    TSTNUM          ; Make sure numeric result
2446:	114E  E3      	        EX      (SP),HL         ; Save code str , Get FN ptr
2447:	114F  5E      	        LD      E,(HL)          ; Get LSB of FN code string
2448:	1150  23      	        INC     HL
2449:	1151  56      	        LD      D,(HL)          ; Get MSB of FN code string
2450:	1152  23      	        INC     HL
2451:	1153  7A      	        LD      A,D             ; And function DEFined?
2452:	1154  B3      	        OR      E
2453:	1155  CABD04  	        JP      Z,UFERR         ; No - ?UF Error
2454:	1158  7E      	        LD      A,(HL)          ; Get LSB of argument address
2455:	1159  23      	        INC     HL
2456:	115A  66      	        LD      H,(HL)          ; Get MSB of argument address
2457:	115B  6F      	        LD      L,A             ; HL = Arg variable address
2458:	115C  E5      	        PUSH    HL              ; Save it
2459:	115D  2ADE20  	        LD      HL,(FNRGNM)     ; Get old argument name
2460:	1160  E3      	        EX      (SP),HL ;       ; Save old , Get new
2461:	1161  22DE20  	        LD      (FNRGNM),HL     ; Set new argument name
2462:	1164  2AE220  	        LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2463:	1167  E5      	        PUSH    HL              ; Save it
2464:	1168  2AE020  	        LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
2465:	116B  E5      	        PUSH    HL              ; Save it
2466:	116C  21E020  	        LD      HL,FNARG        ; HL = Value of argument
2467:	116F  D5      	        PUSH    DE              ; Save FN code string address
2468:	1170  CD8217  	        CALL    FPTHL           ; Move FPREG to argument
2469:	1173  E1      	        POP     HL              ; Get FN code string address
2470:	1174  CD480D  	        CALL    GETNUM          ; Get value from function
2471:	1177  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
2472:	1178  CDD508  	        CALL    GETCHR          ; Get next character
2473:	117B  C2B104  	        JP      NZ,SNERR        ; Bad character in FN - Error
2474:	117E  E1      	        POP     HL              ; Get MSB,EXP of old arg
2475:	117F  22E020  	        LD      (FNARG),HL      ; Restore it
2476:	1182  E1      	        POP     HL              ; Get LSB,NLSB of old arg
2477:	1183  22E220  	        LD      (FNARG+2),HL    ; Restore it
2478:	1186  E1      	        POP     HL              ; Get name of old arg
2479:	1187  22DE20  	        LD      (FNRGNM),HL     ; Restore it
2480:	118A  E1      	        POP     HL              ; Restore code string address
2481:	118B  C9      	        RET
2482:			
2483:	118C  E5      	IDTEST: PUSH    HL              ; Save code string address
2484:	118D  2A5C20  	        LD      HL,(LINEAT)     ; Get current line number
2485:	1190  23      	        INC     HL              ; -1 means direct statement
2486:	1191  7C      	        LD      A,H
2487:	1192  B5      	        OR      L
2488:	1193  E1      	        POP     HL              ; Restore code string address
2489:	1194  C0      	        RET     NZ              ; Return if in program
2490:	1195  1E16    	        LD      E,ID            ; ?ID Error
2491:	1197  C3C504  	        JP      ERROR
2492:			
2493:	119A  CD4B07  	CHEKFN: CALL    CHKSYN          ; Make sure FN follows
2494:	119D  A7      	        .DB     ZFN             ; "FN" token
2495:	119E  3E80    	        LD      A,80H
2496:	11A0  32CB20  	        LD      (FORFLG),A      ; Flag FN name to find
2497:	11A3  B6      	        OR      (HL)            ; FN name has bit 7 set
2498:	11A4  47      	        LD      B,A             ; in first byte of name
2499:	11A5  CD430F  	        CALL    GTFNAM          ; Get FN name
2500:	11A8  C34B0D  	        JP      TSTNUM          ; Make sure numeric function
2501:			
2502:	11AB  CD4B0D  	STR:    CALL    TSTNUM          ; Make sure it's a number
2503:	11AE  CDCF18  	        CALL    NUMASC          ; Turn number into text
2504:	11B1  CDDF11  	STR1:   CALL    CRTST           ; Create string entry for it
2505:	11B4  CD6413  	        CALL    GSTRCU          ; Current string to pool
2506:	11B7  01BF13  	        LD      BC,TOPOOL       ; Save in string pool
2507:	11BA  C5      	        PUSH    BC              ; Save address on stack
2508:			
2509:	11BB  7E      	SAVSTR: LD      A,(HL)          ; Get string length
2510:	11BC  23      	        INC     HL
2511:	11BD  23      	        INC     HL
2512:	11BE  E5      	        PUSH    HL              ; Save pointer to string
2513:	11BF  CD3A12  	        CALL    TESTR           ; See if enough string space
2514:	11C2  E1      	        POP     HL              ; Restore pointer to string
2515:	11C3  4E      	        LD      C,(HL)          ; Get LSB of address
2516:	11C4  23      	        INC     HL
2517:	11C5  46      	        LD      B,(HL)          ; Get MSB of address
2518:	11C6  CDD311  	        CALL    CRTMST          ; Create string entry
2519:	11C9  E5      	        PUSH    HL              ; Save pointer to MSB of addr
2520:	11CA  6F      	        LD      L,A             ; Length of string
2521:	11CB  CD5713  	        CALL    TOSTRA          ; Move to string area
2522:	11CE  D1      	        POP     DE              ; Restore pointer to MSB
2523:	11CF  C9      	        RET
2524:			
2525:	11D0  CD3A12  	MKTMST: CALL    TESTR           ; See if enough string space
2526:	11D3  21BF20  	CRTMST: LD      HL,TMPSTR       ; Temporary string
2527:	11D6  E5      	        PUSH    HL              ; Save it
2528:	11D7  77      	        LD      (HL),A          ; Save length of string
2529:	11D8  23      	        INC     HL
2530:	11D9  23      	SVSTAD: INC     HL
2531:	11DA  73      	        LD      (HL),E          ; Save LSB of address
2532:	11DB  23      	        INC     HL
2533:	11DC  72      	        LD      (HL),D          ; Save MSB of address
2534:	11DD  E1      	        POP     HL              ; Restore pointer
2535:	11DE  C9      	        RET
2536:			
2537:	11DF  2B      	CRTST:  DEC     HL              ; DEC - INCed after
2538:	11E0  0622    	QTSTR:  LD      B,'"'           ; Terminating quote
2539:	11E2  50      	        LD      D,B             ; Quote to D
2540:	11E3  E5      	DTSTR:  PUSH    HL              ; Save start
2541:	11E4  0EFF    	        LD      C,-1            ; Set counter to -1
2542:	11E6  23      	QTSTLP: INC     HL              ; Move on
2543:	11E7  7E      	        LD      A,(HL)          ; Get byte
2544:	11E8  0C      	        INC     C               ; Count bytes
2545:	11E9  B7      	        OR      A               ; End of line?
2546:	11EA  CAF511  	        JP      Z,CRTSTE        ; Yes - Create string entry
2547:	11ED  BA      	        CP      D               ; Terminator D found?
2548:	11EE  CAF511  	        JP      Z,CRTSTE        ; Yes - Create string entry
2549:	11F1  B8      	        CP      B               ; Terminator B found?
2550:	11F2  C2E611  	        JP      NZ,QTSTLP       ; No - Keep looking
2551:	11F5  FE22    	CRTSTE: CP      '"'             ; End with '"'?
2552:	11F7  CCD508  	        CALL    Z,GETCHR        ; Yes - Get next character
2553:	11FA  E3      	        EX      (SP),HL         ; Starting quote
2554:	11FB  23      	        INC     HL              ; First byte of string
2555:	11FC  EB      	        EX      DE,HL           ; To DE
2556:	11FD  79      	        LD      A,C             ; Get length
2557:	11FE  CDD311  	        CALL    CRTMST          ; Create string entry
2558:	1201  11BF20  	TSTOPL: LD      DE,TMPSTR       ; Temporary string
2559:	1204  2AB120  	        LD      HL,(TMSTPT)     ; Temporary string pool pointer
2560:	1207  22E420  	        LD      (FPREG),HL      ; Save address of string ptr
2561:	120A  3E01    	        LD      A,1
2562:	120C  32AD20  	        LD      (TYPE),A        ; Set type to string
2563:	120F  CD8517  	        CALL    DETHL4          ; Move string to pool
2564:	1212  CD4507  	        CALL    CPDEHL          ; Out of string pool?
2565:	1215  22B120  	        LD      (TMSTPT),HL     ; Save new pointer
2566:	1218  E1      	        POP     HL              ; Restore code string address
2567:	1219  7E      	        LD      A,(HL)          ; Get next code byte
2568:	121A  C0      	        RET     NZ              ; Return if pool OK
2569:	121B  1E1E    	        LD      E,ST            ; ?ST Error
2570:	121D  C3C504  	        JP      ERROR           ; String pool overflow
2571:			
2572:	1220  23      	PRNUMS: INC     HL              ; Skip leading space
2573:	1221  CDDF11  	PRS:    CALL    CRTST           ; Create string entry for it
2574:	1224  CD6413  	PRS1:   CALL    GSTRCU          ; Current string to pool
2575:	1227  CD7917  	        CALL    LOADFP          ; Move string block to BCDE
2576:	122A  1C      	        INC     E               ; Length + 1
2577:	122B  1D      	PRSLP:  DEC     E               ; Count characters
2578:	122C  C8      	        RET     Z               ; End of string
2579:	122D  0A      	        LD      A,(BC)          ; Get byte to output
2580:	122E  CD5607  	        CALL    OUTC            ; Output character in A
2581:	1231  FE0D    	        CP      CR              ; Return?
2582:	1233  CC8D0B  	        CALL    Z,DONULL        ; Yes - Do nulls
2583:	1236  03      	        INC     BC              ; Next byte in string
2584:	1237  C32B12  	        JP      PRSLP           ; More characters to output
2585:			
2586:	123A  B7      	TESTR:  OR      A               ; Test if enough room
2587:	123B  0E      	        .DB     0EH             ; No garbage collection done
2588:	123C  F1      	GRBDON: POP     AF              ; Garbage collection done
2589:	123D  F5      	        PUSH    AF              ; Save status
2590:	123E  2A5A20  	        LD      HL,(STRSPC)     ; Bottom of string space in use
2591:	1241  EB      	        EX      DE,HL           ; To DE
2592:	1242  2AC320  	        LD      HL,(STRBOT)     ; Bottom of string area
2593:	1245  2F      	        CPL                     ; Negate length (Top down)
2594:	1246  4F      	        LD      C,A             ; -Length to BC
2595:	1247  06FF    	        LD      B,-1            ; BC = -ve length of string
2596:	1249  09      	        ADD     HL,BC           ; Add to bottom of space in use
2597:	124A  23      	        INC     HL              ; Plus one for 2's complement
2598:	124B  CD4507  	        CALL    CPDEHL          ; Below string RAM area?
2599:	124E  DA5812  	        JP      C,TESTOS        ; Tidy up if not done else err
2600:	1251  22C320  	        LD      (STRBOT),HL     ; Save new bottom of area
2601:	1254  23      	        INC     HL              ; Point to first byte of string
2602:	1255  EB      	        EX      DE,HL           ; Address to DE
2603:	1256  F1      	POPAF:  POP     AF              ; Throw away status push
2604:	1257  C9      	        RET
2605:			
2606:	1258  F1      	TESTOS: POP     AF              ; Garbage collect been done?
2607:	1259  1E1A    	        LD      E,OS            ; ?OS Error
2608:	125B  CAC504  	        JP      Z,ERROR         ; Yes - Not enough string apace
2609:	125E  BF      	        CP      A               ; Flag garbage collect done
2610:	125F  F5      	        PUSH    AF              ; Save status
2611:	1260  013C12  	        LD      BC,GRBDON       ; Garbage collection done
2612:	1263  C5      	        PUSH    BC              ; Save for RETurn
2613:	1264  2AAF20  	GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
2614:	1267  22C320  	GARBLP: LD      (STRBOT),HL     ; Reset string pointer
2615:	126A  210000  	        LD      HL,0
2616:	126D  E5      	        PUSH    HL              ; Flag no string found
2617:	126E  2A5A20  	        LD      HL,(STRSPC)     ; Get bottom of string space
2618:	1271  E5      	        PUSH    HL              ; Save bottom of string space
2619:	1272  21B320  	        LD      HL,TMSTPL       ; Temporary string pool
2620:	1275  EB      	GRBLP:  EX      DE,HL
2621:	1276  2AB120  	        LD      HL,(TMSTPT)     ; Temporary string pool pointer
2622:	1279  EB      	        EX      DE,HL
2623:	127A  CD4507  	        CALL    CPDEHL          ; Temporary string pool done?
2624:	127D  017512  	        LD      BC,GRBLP        ; Loop until string pool done
2625:	1280  C2C912  	        JP      NZ,STPOOL       ; No - See if in string area
2626:	1283  2AD620  	        LD      HL,(PROGND)     ; Start of simple variables
2627:	1286  EB      	SMPVAR: EX      DE,HL
2628:	1287  2AD820  	        LD      HL,(VAREND)     ; End of simple variables
2629:	128A  EB      	        EX      DE,HL
2630:	128B  CD4507  	        CALL    CPDEHL          ; All simple strings done?
2631:	128E  CA9C12  	        JP      Z,ARRLP         ; Yes - Do string arrays
2632:	1291  7E      	        LD      A,(HL)          ; Get type of variable
2633:	1292  23      	        INC     HL
2634:	1293  23      	        INC     HL
2635:	1294  B7      	        OR      A               ; "S" flag set if string
2636:	1295  CDCC12  	        CALL    STRADD          ; See if string in string area
2637:	1298  C38612  	        JP      SMPVAR          ; Loop until simple ones done
2638:			
2639:	129B  C1      	GNXARY: POP     BC              ; Scrap address of this array
2640:	129C  EB      	ARRLP:  EX      DE,HL
2641:	129D  2ADA20  	        LD      HL,(ARREND)     ; End of string arrays
2642:	12A0  EB      	        EX      DE,HL
2643:	12A1  CD4507  	        CALL    CPDEHL          ; All string arrays done?
2644:	12A4  CAF212  	        JP      Z,SCNEND        ; Yes - Move string if found
2645:	12A7  CD7917  	        CALL    LOADFP          ; Get array name to BCDE
2646:	12AA  7B      	        LD      A,E             ; Get type of array     
2647:	12AB  E5      	        PUSH    HL              ; Save address of num of dim'ns
2648:	12AC  09      	        ADD     HL,BC           ; Start of next array
2649:	12AD  B7      	        OR      A               ; Test type of array
2650:	12AE  F29B12  	        JP      P,GNXARY        ; Numeric array - Ignore it
2651:	12B1  22C520  	        LD      (CUROPR),HL     ; Save address of next array
2652:	12B4  E1      	        POP     HL              ; Get address of num of dim'ns
2653:	12B5  4E      	        LD      C,(HL)          ; BC = Number of dimensions
2654:	12B6  0600    	        LD      B,0
2655:	12B8  09      	        ADD     HL,BC           ; Two bytes per dimension size
2656:	12B9  09      	        ADD     HL,BC
2657:	12BA  23      	        INC     HL              ; Plus one for number of dim'ns
2658:	12BB  EB      	GRBARY: EX      DE,HL
2659:	12BC  2AC520  	        LD      HL,(CUROPR)     ; Get address of next array
2660:	12BF  EB      	        EX      DE,HL
2661:	12C0  CD4507  	        CALL    CPDEHL          ; Is this array finished?
2662:	12C3  CA9C12  	        JP      Z,ARRLP         ; Yes - Get next one
2663:	12C6  01BB12  	        LD      BC,GRBARY       ; Loop until array all done
2664:	12C9  C5      	STPOOL: PUSH    BC              ; Save return address
2665:	12CA  F680    	        OR      80H             ; Flag string type
2666:	12CC  7E      	STRADD: LD      A,(HL)          ; Get string length
2667:	12CD  23      	        INC     HL
2668:	12CE  23      	        INC     HL
2669:	12CF  5E      	        LD      E,(HL)          ; Get LSB of string address
2670:	12D0  23      	        INC     HL
2671:	12D1  56      	        LD      D,(HL)          ; Get MSB of string address
2672:	12D2  23      	        INC     HL
2673:	12D3  F0      	        RET     P               ; Not a string - Return
2674:	12D4  B7      	        OR      A               ; Set flags on string length
2675:	12D5  C8      	        RET     Z               ; Null string - Return
2676:	12D6  44      	        LD      B,H             ; Save variable pointer
2677:	12D7  4D      	        LD      C,L
2678:	12D8  2AC320  	        LD      HL,(STRBOT)     ; Bottom of new area
2679:	12DB  CD4507  	        CALL    CPDEHL          ; String been done?
2680:	12DE  60      	        LD      H,B             ; Restore variable pointer
2681:	12DF  69      	        LD      L,C
2682:	12E0  D8      	        RET     C               ; String done - Ignore
2683:	12E1  E1      	        POP     HL              ; Return address
2684:	12E2  E3      	        EX      (SP),HL         ; Lowest available string area
2685:	12E3  CD4507  	        CALL    CPDEHL          ; String within string area?
2686:	12E6  E3      	        EX      (SP),HL         ; Lowest available string area
2687:	12E7  E5      	        PUSH    HL              ; Re-save return address
2688:	12E8  60      	        LD      H,B             ; Restore variable pointer
2689:	12E9  69      	        LD      L,C
2690:	12EA  D0      	        RET     NC              ; Outside string area - Ignore
2691:	12EB  C1      	        POP     BC              ; Get return , Throw 2 away
2692:	12EC  F1      	        POP     AF              ; 
2693:	12ED  F1      	        POP     AF              ; 
2694:	12EE  E5      	        PUSH    HL              ; Save variable pointer
2695:	12EF  D5      	        PUSH    DE              ; Save address of current
2696:	12F0  C5      	        PUSH    BC              ; Put back return address
2697:	12F1  C9      	        RET                     ; Go to it
2698:			
2699:	12F2  D1      	SCNEND: POP     DE              ; Addresses of strings
2700:	12F3  E1      	        POP     HL              ; 
2701:	12F4  7D      	        LD      A,L             ; HL = 0 if no more to do
2702:	12F5  B4      	        OR      H
2703:	12F6  C8      	        RET     Z               ; No more to do - Return
2704:	12F7  2B      	        DEC     HL
2705:	12F8  46      	        LD      B,(HL)          ; MSB of address of string
2706:	12F9  2B      	        DEC     HL
2707:	12FA  4E      	        LD      C,(HL)          ; LSB of address of string
2708:	12FB  E5      	        PUSH    HL              ; Save variable address
2709:	12FC  2B      	        DEC     HL
2710:	12FD  2B      	        DEC     HL
2711:	12FE  6E      	        LD      L,(HL)          ; HL = Length of string
2712:	12FF  2600    	        LD      H,0
2713:	1301  09      	        ADD     HL,BC           ; Address of end of string+1
2714:	1302  50      	        LD      D,B             ; String address to DE
2715:	1303  59      	        LD      E,C
2716:	1304  2B      	        DEC     HL              ; Last byte in string
2717:	1305  44      	        LD      B,H             ; Address to BC
2718:	1306  4D      	        LD      C,L
2719:	1307  2AC320  	        LD      HL,(STRBOT)     ; Current bottom of string area
2720:	130A  CD8004  	        CALL    MOVSTR          ; Move string to new address
2721:	130D  E1      	        POP     HL              ; Restore variable address
2722:	130E  71      	        LD      (HL),C          ; Save new LSB of address
2723:	130F  23      	        INC     HL
2724:	1310  70      	        LD      (HL),B          ; Save new MSB of address
2725:	1311  69      	        LD      L,C             ; Next string area+1 to HL
2726:	1312  60      	        LD      H,B
2727:	1313  2B      	        DEC     HL              ; Next string area address
2728:	1314  C36712  	        JP      GARBLP          ; Look for more strings
2729:			
2730:	1317  C5      	CONCAT: PUSH    BC              ; Save prec' opr & code string
2731:	1318  E5      	        PUSH    HL              ; 
2732:	1319  2AE420  	        LD      HL,(FPREG)      ; Get first string
2733:	131C  E3      	        EX      (SP),HL         ; Save first string
2734:	131D  CDD10D  	        CALL    OPRND           ; Get second string
2735:	1320  E3      	        EX      (SP),HL         ; Restore first string
2736:	1321  CD4C0D  	        CALL    TSTSTR          ; Make sure it's a string
2737:	1324  7E      	        LD      A,(HL)          ; Get length of second string
2738:	1325  E5      	        PUSH    HL              ; Save first string
2739:	1326  2AE420  	        LD      HL,(FPREG)      ; Get second string
2740:	1329  E5      	        PUSH    HL              ; Save second string
2741:	132A  86      	        ADD     A,(HL)          ; Add length of second string
2742:	132B  1E1C    	        LD      E,LS            ; ?LS Error
2743:	132D  DAC504  	        JP      C,ERROR         ; String too long - Error
2744:	1330  CDD011  	        CALL    MKTMST          ; Make temporary string
2745:	1333  D1      	        POP     DE              ; Get second string to DE
2746:	1334  CD6813  	        CALL    GSTRDE          ; Move to string pool if needed
2747:	1337  E3      	        EX      (SP),HL         ; Get first string
2748:	1338  CD6713  	        CALL    GSTRHL          ; Move to string pool if needed
2749:	133B  E5      	        PUSH    HL              ; Save first string
2750:	133C  2AC120  	        LD      HL,(TMPSTR+2)   ; Temporary string address
2751:	133F  EB      	        EX      DE,HL           ; To DE
2752:	1340  CD4E13  	        CALL    SSTSA           ; First string to string area
2753:	1343  CD4E13  	        CALL    SSTSA           ; Second string to string area
2754:	1346  21660D  	        LD      HL,EVAL2        ; Return to evaluation loop
2755:	1349  E3      	        EX      (SP),HL         ; Save return,get code string
2756:	134A  E5      	        PUSH    HL              ; Save code string address
2757:	134B  C30112  	        JP      TSTOPL          ; To temporary string to pool
2758:			
2759:	134E  E1      	SSTSA:  POP     HL              ; Return address
2760:	134F  E3      	        EX      (SP),HL         ; Get string block,save return
2761:	1350  7E      	        LD      A,(HL)          ; Get length of string
2762:	1351  23      	        INC     HL
2763:	1352  23      	        INC     HL
2764:	1353  4E      	        LD      C,(HL)          ; Get LSB of string address
2765:	1354  23      	        INC     HL
2766:	1355  46      	        LD      B,(HL)          ; Get MSB of string address
2767:	1356  6F      	        LD      L,A             ; Length to L
2768:	1357  2C      	TOSTRA: INC     L               ; INC - DECed after
2769:	1358  2D      	TSALP:  DEC     L               ; Count bytes moved
2770:	1359  C8      	        RET     Z               ; End of string - Return
2771:	135A  0A      	        LD      A,(BC)          ; Get source
2772:	135B  12      	        LD      (DE),A          ; Save destination
2773:	135C  03      	        INC     BC              ; Next source
2774:	135D  13      	        INC     DE              ; Next destination
2775:	135E  C35813  	        JP      TSALP           ; Loop until string moved
2776:			
2777:	1361  CD4C0D  	GETSTR: CALL    TSTSTR          ; Make sure it's a string
2778:	1364  2AE420  	GSTRCU: LD      HL,(FPREG)      ; Get current string
2779:	1367  EB      	GSTRHL: EX      DE,HL           ; Save DE
2780:	1368  CD8213  	GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
2781:	136B  EB      	        EX      DE,HL           ; Restore DE
2782:	136C  C0      	        RET     NZ              ; No - Return
2783:	136D  D5      	        PUSH    DE              ; Save string
2784:	136E  50      	        LD      D,B             ; String block address to DE
2785:	136F  59      	        LD      E,C
2786:	1370  1B      	        DEC     DE              ; Point to length
2787:	1371  4E      	        LD      C,(HL)          ; Get string length
2788:	1372  2AC320  	        LD      HL,(STRBOT)     ; Current bottom of string area
2789:	1375  CD4507  	        CALL    CPDEHL          ; Last one in string area?
2790:	1378  C28013  	        JP      NZ,POPHL        ; No - Return
2791:	137B  47      	        LD      B,A             ; Clear B (A=0)
2792:	137C  09      	        ADD     HL,BC           ; Remove string from str' area
2793:	137D  22C320  	        LD      (STRBOT),HL     ; Save new bottom of str' area
2794:	1380  E1      	POPHL:  POP     HL              ; Restore string
2795:	1381  C9      	        RET
2796:			
2797:	1382  2AB120  	BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
2798:	1385  2B      	        DEC     HL              ; Back
2799:	1386  46      	        LD      B,(HL)          ; Get MSB of address
2800:	1387  2B      	        DEC     HL              ; Back
2801:	1388  4E      	        LD      C,(HL)          ; Get LSB of address
2802:	1389  2B      	        DEC     HL              ; Back
2803:	138A  2B      	        DEC     HL              ; Back
2804:	138B  CD4507  	        CALL    CPDEHL          ; String last in string pool?
2805:	138E  C0      	        RET     NZ              ; Yes - Leave it
2806:	138F  22B120  	        LD      (TMSTPT),HL     ; Save new string pool top
2807:	1392  C9      	        RET
2808:			
2809:	1393  011211  	LEN:    LD      BC,PASSA        ; To return integer A
2810:	1396  C5      	        PUSH    BC              ; Save address
2811:	1397  CD6113  	GETLEN: CALL    GETSTR          ; Get string and its length
2812:	139A  AF      	        XOR     A
2813:	139B  57      	        LD      D,A             ; Clear D
2814:	139C  32AD20  	        LD      (TYPE),A        ; Set type to numeric
2815:	139F  7E      	        LD      A,(HL)          ; Get length of string
2816:	13A0  B7      	        OR      A               ; Set status flags
2817:	13A1  C9      	        RET
2818:			
2819:	13A2  011211  	ASC:    LD      BC,PASSA        ; To return integer A
2820:	13A5  C5      	        PUSH    BC              ; Save address
2821:	13A6  CD9713  	GTFLNM: CALL    GETLEN          ; Get length of string
2822:	13A9  CAA209  	        JP      Z,FCERR         ; Null string - Error
2823:	13AC  23      	        INC     HL
2824:	13AD  23      	        INC     HL
2825:	13AE  5E      	        LD      E,(HL)          ; Get LSB of address
2826:	13AF  23      	        INC     HL
2827:	13B0  56      	        LD      D,(HL)          ; Get MSB of address
2828:	13B1  1A      	        LD      A,(DE)          ; Get first byte of string
2829:	13B2  C9      	        RET
2830:			
2831:	13B3  3E01    	CHR:    LD      A,1             ; One character string
2832:	13B5  CDD011  	        CALL    MKTMST          ; Make a temporary string
2833:	13B8  CDAC14  	        CALL    MAKINT          ; Make it integer A
2834:	13BB  2AC120  	        LD      HL,(TMPSTR+2)   ; Get address of string
2835:	13BE  73      	        LD      (HL),E          ; Save character
2836:	13BF  C1      	TOPOOL: POP     BC              ; Clean up stack
2837:	13C0  C30112  	        JP      TSTOPL          ; Temporary string to pool
2838:			
2839:	13C3  CD5C14  	LEFT:   CALL    LFRGNM          ; Get number and ending ")"
2840:	13C6  AF      	        XOR     A               ; Start at first byte in string
2841:	13C7  E3      	RIGHT1: EX      (SP),HL         ; Save code string,Get string
2842:	13C8  4F      	        LD      C,A             ; Starting position in string
2843:	13C9  E5      	MID1:   PUSH    HL              ; Save string block address
2844:	13CA  7E      	        LD      A,(HL)          ; Get length of string
2845:	13CB  B8      	        CP      B               ; Compare with number given
2846:	13CC  DAD113  	        JP      C,ALLFOL        ; All following bytes required
2847:	13CF  78      	        LD      A,B             ; Get new length
2848:	13D0  11      	        .DB     11H             ; Skip "LD C,0"
2849:	13D1  0E00    	ALLFOL: LD      C,0             ; First byte of string
2850:	13D3  C5      	        PUSH    BC              ; Save position in string
2851:	13D4  CD3A12  	        CALL    TESTR           ; See if enough string space
2852:	13D7  C1      	        POP     BC              ; Get position in string
2853:	13D8  E1      	        POP     HL              ; Restore string block address
2854:	13D9  E5      	        PUSH    HL              ; And re-save it
2855:	13DA  23      	        INC     HL
2856:	13DB  23      	        INC     HL
2857:	13DC  46      	        LD      B,(HL)          ; Get LSB of address
2858:	13DD  23      	        INC     HL
2859:	13DE  66      	        LD      H,(HL)          ; Get MSB of address
2860:	13DF  68      	        LD      L,B             ; HL = address of string
2861:	13E0  0600    	        LD      B,0             ; BC = starting address
2862:	13E2  09      	        ADD     HL,BC           ; Point to that byte
2863:	13E3  44      	        LD      B,H             ; BC = source string
2864:	13E4  4D      	        LD      C,L
2865:	13E5  CDD311  	        CALL    CRTMST          ; Create a string entry
2866:	13E8  6F      	        LD      L,A             ; Length of new string
2867:	13E9  CD5713  	        CALL    TOSTRA          ; Move string to string area
2868:	13EC  D1      	        POP     DE              ; Clear stack
2869:	13ED  CD6813  	        CALL    GSTRDE          ; Move to string pool if needed
2870:	13F0  C30112  	        JP      TSTOPL          ; Temporary string to pool
2871:			
2872:	13F3  CD5C14  	RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
2873:	13F6  D1      	        POP     DE              ; Get string length
2874:	13F7  D5      	        PUSH    DE              ; And re-save
2875:	13F8  1A      	        LD      A,(DE)          ; Get length
2876:	13F9  90      	        SUB     B               ; Move back N bytes
2877:	13FA  C3C713  	        JP      RIGHT1          ; Go and get sub-string
2878:			
2879:	13FD  EB      	MID:    EX      DE,HL           ; Get code string address
2880:	13FE  7E      	        LD      A,(HL)          ; Get next byte ',' or ")"
2881:	13FF  CD6114  	        CALL    MIDNUM          ; Get number supplied
2882:	1402  04      	        INC     B               ; Is it character zero?
2883:	1403  05      	        DEC     B
2884:	1404  CAA209  	        JP      Z,FCERR         ; Yes - Error
2885:	1407  C5      	        PUSH    BC              ; Save starting position
2886:	1408  1EFF    	        LD      E,255           ; All of string
2887:	140A  FE29    	        CP      ')'             ; Any length given?
2888:	140C  CA1614  	        JP      Z,RSTSTR        ; No - Rest of string
2889:	140F  CD4B07  	        CALL    CHKSYN          ; Make sure ',' follows
2890:	1412  2C      	        .DB     ','
2891:	1413  CDA914  	        CALL    GETINT          ; Get integer 0-255
2892:	1416  CD4B07  	RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
2893:	1419  29      	        .DB     ")"
2894:	141A  F1      	        POP     AF              ; Restore starting position
2895:	141B  E3      	        EX      (SP),HL         ; Get string,8ave code string
2896:	141C  01C913  	        LD      BC,MID1         ; Continuation of MID$ routine
2897:	141F  C5      	        PUSH    BC              ; Save for return
2898:	1420  3D      	        DEC     A               ; Starting position-1
2899:	1421  BE      	        CP      (HL)            ; Compare with length
2900:	1422  0600    	        LD      B,0             ; Zero bytes length
2901:	1424  D0      	        RET     NC              ; Null string if start past end
2902:	1425  4F      	        LD      C,A             ; Save starting position-1
2903:	1426  7E      	        LD      A,(HL)          ; Get length of string
2904:	1427  91      	        SUB     C               ; Subtract start
2905:	1428  BB      	        CP      E               ; Enough string for it?
2906:	1429  47      	        LD      B,A             ; Save maximum length available
2907:	142A  D8      	        RET     C               ; Truncate string if needed
2908:	142B  43      	        LD      B,E             ; Set specified length
2909:	142C  C9      	        RET                     ; Go and create string
2910:			
2911:	142D  CD9713  	VAL:    CALL    GETLEN          ; Get length of string
2912:	1430  CA4A15  	        JP      Z,RESZER        ; Result zero
2913:	1433  5F      	        LD      E,A             ; Save length
2914:	1434  23      	        INC     HL
2915:	1435  23      	        INC     HL
2916:	1436  7E      	        LD      A,(HL)          ; Get LSB of address
2917:	1437  23      	        INC     HL
2918:	1438  66      	        LD      H,(HL)          ; Get MSB of address
2919:	1439  6F      	        LD      L,A             ; HL = String address
2920:	143A  E5      	        PUSH    HL              ; Save string address
2921:	143B  19      	        ADD     HL,DE
2922:	143C  46      	        LD      B,(HL)          ; Get end of string+1 byte
2923:	143D  72      	        LD      (HL),D          ; Zero it to terminate
2924:	143E  E3      	        EX      (SP),HL         ; Save string end,get start
2925:	143F  C5      	        PUSH    BC              ; Save end+1 byte
2926:	1440  7E      	        LD      A,(HL)          ; Get starting byte
2927:	1441  FE24    	        CP      '$'             ; Hex number indicated? [function added]
2928:	1443  C24B14  	        JP      NZ,VAL1
2929:	1446  CD771C  	        CALL    HEXTFP          ; Convert Hex to FPREG
2930:	1449  180D    	        JR      VAL3
2931:	144B  FE25    	VAL1:   CP	'%'             ; Binary number indicated? [function added]
2932:	144D  C25514  	    JP	NZ,VAL2
2933:	1450  CDE71C  	    CALL	BINTFP		; Convert Bin to FPREG
2934:	1453  1803    	    JR	VAL3
2935:	1455  CD3118  	VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
2936:	1458  C1      	VAL3:   POP     BC              ; Restore end+1 byte
2937:	1459  E1      	        POP     HL              ; Restore end+1 address
2938:	145A  70      	        LD      (HL),B          ; Put back original byte
2939:	145B  C9      	        RET
2940:			
2941:	145C  EB      	LFRGNM: EX      DE,HL           ; Code string address to HL
2942:	145D  CD4B07  	        CALL    CHKSYN          ; Make sure ")" follows
2943:	1460  29      	        .DB     ")"
2944:	1461  C1      	MIDNUM: POP     BC              ; Get return address
2945:	1462  D1      	        POP     DE              ; Get number supplied
2946:	1463  C5      	        PUSH    BC              ; Re-save return address
2947:	1464  43      	        LD      B,E             ; Number to B
2948:	1465  C9      	        RET
2949:			
2950:	1466  CDAC14  	INP:    CALL    MAKINT          ; Make it integer A
2951:	1469  323F20  	        LD      (INPORT),A      ; Set input port
2952:	146C  CD3E20  	        CALL    INPSUB          ; Get input from port
2953:	146F  C31211  	        JP      PASSA           ; Return integer A
2954:			
2955:	1472  CD9614  	POUT:   CALL    SETIO           ; Set up port number
2956:	1475  C30620  	        JP      OUTSUB          ; Output data and return
2957:			
2958:	1478  CD9614  	WAIT:   CALL    SETIO           ; Set up port number
2959:	147B  F5      	        PUSH    AF              ; Save AND mask
2960:	147C  1E00    	        LD      E,0             ; Assume zero if none given
2961:	147E  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
2962:	147F  CDD508  	        CALL    GETCHR          ; Get next character
2963:	1482  CA8C14  	        JP      Z,NOXOR         ; No XOR byte given
2964:	1485  CD4B07  	        CALL    CHKSYN          ; Make sure ',' follows
2965:	1488  2C      	        .DB     ','
2966:	1489  CDA914  	        CALL    GETINT          ; Get integer 0-255 to XOR with
2967:	148C  C1      	NOXOR:  POP     BC              ; Restore AND mask
2968:	148D  CD3E20  	WAITLP: CALL    INPSUB          ; Get input
2969:	1490  AB      	        XOR     E               ; Flip selected bits
2970:	1491  A0      	        AND     B               ; Result non-zero?
2971:	1492  CA8D14  	        JP      Z,WAITLP        ; No = keep waiting
2972:	1495  C9      	        RET
2973:			
2974:	1496  CDA914  	SETIO:  CALL    GETINT          ; Get integer 0-255
2975:	1499  323F20  	        LD      (INPORT),A      ; Set input port
2976:	149C  320720  	        LD      (OTPORT),A      ; Set output port
2977:	149F  CD4B07  	        CALL    CHKSYN          ; Make sure ',' follows
2978:	14A2  2C      	        .DB     ','
2979:	14A3  C3A914  	        JP      GETINT          ; Get integer 0-255 and return
2980:			
2981:	14A6  CDD508  	FNDNUM: CALL    GETCHR          ; Get next character
2982:	14A9  CD480D  	GETINT: CALL    GETNUM          ; Get a number from 0 to 255
2983:	14AC  CD8709  	MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
2984:	14AF  7A      	        LD      A,D             ; Get MSB of number
2985:	14B0  B7      	        OR      A               ; Zero?
2986:	14B1  C2A209  	        JP      NZ,FCERR        ; No - Error
2987:	14B4  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
2988:	14B5  CDD508  	        CALL    GETCHR          ; Get next character
2989:	14B8  7B      	        LD      A,E             ; Get number to A
2990:	14B9  C9      	        RET
2991:			
2992:	14BA  CD8D09  	PEEK:   CALL    DEINT           ; Get memory address
2993:	14BD  1A      	        LD      A,(DE)          ; Get byte in memory
2994:	14BE  C31211  	        JP      PASSA           ; Return integer A
2995:			
2996:	14C1  CD480D  	POKE:   CALL    GETNUM          ; Get memory address
2997:	14C4  CD8D09  	        CALL    DEINT           ; Get integer -32768 to 3276
2998:	14C7  D5      	        PUSH    DE              ; Save memory address
2999:	14C8  CD4B07  	        CALL    CHKSYN          ; Make sure ',' follows
3000:	14CB  2C      	        .DB     ','
3001:	14CC  CDA914  	        CALL    GETINT          ; Get integer 0-255
3002:	14CF  D1      	        POP     DE              ; Restore memory address
3003:	14D0  12      	        LD      (DE),A          ; Load it into memory
3004:	14D1  C9      	        RET
3005:			
3006:	14D2  21A819  	ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
3007:	14D5  CD7917  	ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
3008:	14D8  C3E414  	        JP      FPADD           ; Add BCDE to FPREG
3009:			
3010:	14DB  CD7917  	SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
3011:	14DE  21      	        .DB     21H             ; Skip "POP BC" and "POP DE"
3012:	14DF  C1      	PSUB:   POP     BC              ; Get FP number from stack
3013:	14E0  D1      	        POP     DE
3014:	14E1  CD5317  	SUBCDE: CALL    INVSGN          ; Negate FPREG
3015:	14E4  78      	FPADD:  LD      A,B             ; Get FP exponent
3016:	14E5  B7      	        OR      A               ; Is number zero?
3017:	14E6  C8      	        RET     Z               ; Yes - Nothing to add
3018:	14E7  3AE720  	        LD      A,(FPEXP)       ; Get FPREG exponent
3019:	14EA  B7      	        OR      A               ; Is this number zero?
3020:	14EB  CA6B17  	        JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3021:	14EE  90      	        SUB     B               ; BCDE number larger?
3022:	14EF  D2FE14  	        JP      NC,NOSWAP       ; No - Don't swap them
3023:	14F2  2F      	        CPL                     ; Two's complement
3024:	14F3  3C      	        INC     A               ;  FP exponent
3025:	14F4  EB      	        EX      DE,HL
3026:	14F5  CD5B17  	        CALL    STAKFP          ; Put FPREG on stack
3027:	14F8  EB      	        EX      DE,HL
3028:	14F9  CD6B17  	        CALL    FPBCDE          ; Move BCDE to FPREG
3029:	14FC  C1      	        POP     BC              ; Restore number from stack
3030:	14FD  D1      	        POP     DE
3031:	14FE  FE19    	NOSWAP: CP      24+1            ; Second number insignificant?
3032:	1500  D0      	        RET     NC              ; Yes - First number is result
3033:	1501  F5      	        PUSH    AF              ; Save number of bits to scale
3034:	1502  CD9017  	        CALL    SIGNS           ; Set MSBs & sign of result
3035:	1505  67      	        LD      H,A             ; Save sign of result
3036:	1506  F1      	        POP     AF              ; Restore scaling factor
3037:	1507  CDA915  	        CALL    SCALE           ; Scale BCDE to same exponent
3038:	150A  B4      	        OR      H               ; Result to be positive?
3039:	150B  21E420  	        LD      HL,FPREG        ; Point to FPREG
3040:	150E  F22415  	        JP      P,MINCDE        ; No - Subtract FPREG from CDE
3041:	1511  CD8915  	        CALL    PLUCDE          ; Add FPREG to CDE
3042:	1514  D26A15  	        JP      NC,RONDUP       ; No overflow - Round it up
3043:	1517  23      	        INC     HL              ; Point to exponent
3044:	1518  34      	        INC     (HL)            ; Increment it
3045:	1519  CAC004  	        JP      Z,OVERR         ; Number overflowed - Error
3046:	151C  2E01    	        LD      L,1             ; 1 bit to shift right
3047:	151E  CDBF15  	        CALL    SHRT1           ; Shift result right
3048:	1521  C36A15  	        JP      RONDUP          ; Round it up
3049:			
3050:	1524  AF      	MINCDE: XOR     A               ; Clear A and carry
3051:	1525  90      	        SUB     B               ; Negate exponent
3052:	1526  47      	        LD      B,A             ; Re-save exponent
3053:	1527  7E      	        LD      A,(HL)          ; Get LSB of FPREG
3054:	1528  9B      	        SBC     A, E            ; Subtract LSB of BCDE
3055:	1529  5F      	        LD      E,A             ; Save LSB of BCDE
3056:	152A  23      	        INC     HL
3057:	152B  7E      	        LD      A,(HL)          ; Get NMSB of FPREG
3058:	152C  9A      	        SBC     A,D             ; Subtract NMSB of BCDE
3059:	152D  57      	        LD      D,A             ; Save NMSB of BCDE
3060:	152E  23      	        INC     HL
3061:	152F  7E      	        LD      A,(HL)          ; Get MSB of FPREG
3062:	1530  99      	        SBC     A,C             ; Subtract MSB of BCDE
3063:	1531  4F      	        LD      C,A             ; Save MSB of BCDE
3064:	1532  DC9515  	CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
3065:			
3066:	1535  68      	BNORM:  LD      L,B             ; L = Exponent
3067:	1536  63      	        LD      H,E             ; H = LSB
3068:	1537  AF      	        XOR     A
3069:	1538  47      	BNRMLP: LD      B,A             ; Save bit count
3070:	1539  79      	        LD      A,C             ; Get MSB
3071:	153A  B7      	        OR      A               ; Is it zero?
3072:	153B  C25715  	        JP      NZ,PNORM        ; No - Do it bit at a time
3073:	153E  4A      	        LD      C,D             ; MSB = NMSB
3074:	153F  54      	        LD      D,H             ; NMSB= LSB
3075:	1540  65      	        LD      H,L             ; LSB = VLSB
3076:	1541  6F      	        LD      L,A             ; VLSB= 0
3077:	1542  78      	        LD      A,B             ; Get exponent
3078:	1543  D608    	        SUB     8               ; Count 8 bits
3079:	1545  FEE0    	        CP      -24-8           ; Was number zero?
3080:	1547  C23815  	        JP      NZ,BNRMLP       ; No - Keep normalising
3081:	154A  AF      	RESZER: XOR     A               ; Result is zero
3082:	154B  32E720  	SAVEXP: LD      (FPEXP),A       ; Save result as zero
3083:	154E  C9      	        RET
3084:			
3085:	154F  05      	NORMAL: DEC     B               ; Count bits
3086:	1550  29      	        ADD     HL,HL           ; Shift HL left
3087:	1551  7A      	        LD      A,D             ; Get NMSB
3088:	1552  17      	        RLA                     ; Shift left with last bit
3089:	1553  57      	        LD      D,A             ; Save NMSB
3090:	1554  79      	        LD      A,C             ; Get MSB
3091:	1555  8F      	        ADC     A,A             ; Shift left with last bit
3092:	1556  4F      	        LD      C,A             ; Save MSB
3093:	1557  F24F15  	PNORM:  JP      P,NORMAL        ; Not done - Keep going
3094:	155A  78      	        LD      A,B             ; Number of bits shifted
3095:	155B  5C      	        LD      E,H             ; Save HL in EB
3096:	155C  45      	        LD      B,L
3097:	155D  B7      	        OR      A               ; Any shifting done?
3098:	155E  CA6A15  	        JP      Z,RONDUP        ; No - Round it up
3099:	1561  21E720  	        LD      HL,FPEXP        ; Point to exponent
3100:	1564  86      	        ADD     A,(HL)          ; Add shifted bits
3101:	1565  77      	        LD      (HL),A          ; Re-save exponent
3102:	1566  D24A15  	        JP      NC,RESZER       ; Underflow - Result is zero
3103:	1569  C8      	        RET     Z               ; Result is zero
3104:	156A  78      	RONDUP: LD      A,B             ; Get VLSB of number
3105:	156B  21E720  	RONDB:  LD      HL,FPEXP        ; Point to exponent
3106:	156E  B7      	        OR      A               ; Any rounding?
3107:	156F  FC7C15  	        CALL    M,FPROND        ; Yes - Round number up
3108:	1572  46      	        LD      B,(HL)          ; B = Exponent
3109:	1573  23      	        INC     HL
3110:	1574  7E      	        LD      A,(HL)          ; Get sign of result
3111:	1575  E680    	        AND     10000000B       ; Only bit 7 needed
3112:	1577  A9      	        XOR     C               ; Set correct sign
3113:	1578  4F      	        LD      C,A             ; Save correct sign in number
3114:	1579  C36B17  	        JP      FPBCDE          ; Move BCDE to FPREG
3115:			
3116:	157C  1C      	FPROND: INC     E               ; Round LSB
3117:	157D  C0      	        RET     NZ              ; Return if ok
3118:	157E  14      	        INC     D               ; Round NMSB
3119:	157F  C0      	        RET     NZ              ; Return if ok
3120:	1580  0C      	        INC     C               ; Round MSB
3121:	1581  C0      	        RET     NZ              ; Return if ok
3122:	1582  0E80    	        LD      C,80H           ; Set normal value
3123:	1584  34      	        INC     (HL)            ; Increment exponent
3124:	1585  C0      	        RET     NZ              ; Return if ok
3125:	1586  C3C004  	        JP      OVERR           ; Overflow error
3126:			
3127:	1589  7E      	PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
3128:	158A  83      	        ADD     A,E             ; Add LSB of BCDE
3129:	158B  5F      	        LD      E,A             ; Save LSB of BCDE
3130:	158C  23      	        INC     HL
3131:	158D  7E      	        LD      A,(HL)          ; Get NMSB of FPREG
3132:	158E  8A      	        ADC     A,D             ; Add NMSB of BCDE
3133:	158F  57      	        LD      D,A             ; Save NMSB of BCDE
3134:	1590  23      	        INC     HL
3135:	1591  7E      	        LD      A,(HL)          ; Get MSB of FPREG
3136:	1592  89      	        ADC     A,C             ; Add MSB of BCDE
3137:	1593  4F      	        LD      C,A             ; Save MSB of BCDE
3138:	1594  C9      	        RET
3139:			
3140:	1595  21E820  	COMPL:  LD      HL,SGNRES       ; Sign of result
3141:	1598  7E      	        LD      A,(HL)          ; Get sign of result
3142:	1599  2F      	        CPL                     ; Negate it
3143:	159A  77      	        LD      (HL),A          ; Put it back
3144:	159B  AF      	        XOR     A
3145:	159C  6F      	        LD      L,A             ; Set L to zero
3146:	159D  90      	        SUB     B               ; Negate exponent,set carry
3147:	159E  47      	        LD      B,A             ; Re-save exponent
3148:	159F  7D      	        LD      A,L             ; Load zero
3149:	15A0  9B      	        SBC     A,E             ; Negate LSB
3150:	15A1  5F      	        LD      E,A             ; Re-save LSB
3151:	15A2  7D      	        LD      A,L             ; Load zero
3152:	15A3  9A      	        SBC     A,D             ; Negate NMSB
3153:	15A4  57      	        LD      D,A             ; Re-save NMSB
3154:	15A5  7D      	        LD      A,L             ; Load zero
3155:	15A6  99      	        SBC     A,C             ; Negate MSB
3156:	15A7  4F      	        LD      C,A             ; Re-save MSB
3157:	15A8  C9      	        RET
3158:			
3159:	15A9  0600    	SCALE:  LD      B,0             ; Clear underflow
3160:	15AB  D608    	SCALLP: SUB     8               ; 8 bits (a whole byte)?
3161:	15AD  DAB815  	        JP      C,SHRITE        ; No - Shift right A bits
3162:	15B0  43      	        LD      B,E             ; <- Shift
3163:	15B1  5A      	        LD      E,D             ; <- right
3164:	15B2  51      	        LD      D,C             ; <- eight
3165:	15B3  0E00    	        LD      C,0             ; <- bits
3166:	15B5  C3AB15  	        JP      SCALLP          ; More bits to shift
3167:			
3168:	15B8  C609    	SHRITE: ADD     A,8+1           ; Adjust count
3169:	15BA  6F      	        LD      L,A             ; Save bits to shift
3170:	15BB  AF      	SHRLP:  XOR     A               ; Flag for all done
3171:	15BC  2D      	        DEC     L               ; All shifting done?
3172:	15BD  C8      	        RET     Z               ; Yes - Return
3173:	15BE  79      	        LD      A,C             ; Get MSB
3174:	15BF  1F      	SHRT1:  RRA                     ; Shift it right
3175:	15C0  4F      	        LD      C,A             ; Re-save
3176:	15C1  7A      	        LD      A,D             ; Get NMSB
3177:	15C2  1F      	        RRA                     ; Shift right with last bit
3178:	15C3  57      	        LD      D,A             ; Re-save it
3179:	15C4  7B      	        LD      A,E             ; Get LSB
3180:	15C5  1F      	        RRA                     ; Shift right with last bit
3181:	15C6  5F      	        LD      E,A             ; Re-save it
3182:	15C7  78      	        LD      A,B             ; Get underflow
3183:	15C8  1F      	        RRA                     ; Shift right with last bit
3184:	15C9  47      	        LD      B,A             ; Re-save underflow
3185:	15CA  C3BB15  	        JP      SHRLP           ; More bits to do
3186:			
3187:	15CD  00000081	UNITY:  .DB     000H,000H,000H,081H  ; 1.00000
3188:			
3189:	15D1  03      	LOGTAB: .DB     3                    ; Table used by LOG
3190:	15D2  AA561980	        .DB     0AAH,056H,019H,080H  ; 0.59898
3191:	15D6  F1227680	        .DB     0F1H,022H,076H,080H  ; 0.96147
3192:	15DA  45AA3882	        .DB     045H,0AAH,038H,082H  ; 2.88539
3193:			
3194:	15DE  CD2A17  	LOG:    CALL    TSTSGN          ; Test sign of value
3195:	15E1  B7      	        OR      A
3196:	15E2  EAA209  	        JP      PE,FCERR        ; ?FC Error if <= zero
3197:	15E5  21E720  	        LD      HL,FPEXP        ; Point to exponent
3198:	15E8  7E      	        LD      A,(HL)          ; Get exponent
3199:	15E9  013580  	        LD      BC,8035H        ; BCDE = SQR(1/2)
3200:	15EC  11F304  	        LD      DE,04F3H
3201:	15EF  90      	        SUB     B               ; Scale value to be < 1
3202:	15F0  F5      	        PUSH    AF              ; Save scale factor
3203:	15F1  70      	        LD      (HL),B          ; Save new exponent
3204:	15F2  D5      	        PUSH    DE              ; Save SQR(1/2)
3205:	15F3  C5      	        PUSH    BC
3206:	15F4  CDE414  	        CALL    FPADD           ; Add SQR(1/2) to value
3207:	15F7  C1      	        POP     BC              ; Restore SQR(1/2)
3208:	15F8  D1      	        POP     DE
3209:	15F9  04      	        INC     B               ; Make it SQR(2)
3210:	15FA  CD8016  	        CALL    DVBCDE          ; Divide by SQR(2)
3211:	15FD  21CD15  	        LD      HL,UNITY        ; Point to 1.
3212:	1600  CDDB14  	        CALL    SUBPHL          ; Subtract FPREG from 1
3213:	1603  21D115  	        LD      HL,LOGTAB       ; Coefficient table
3214:	1606  CD721A  	        CALL    SUMSER          ; Evaluate sum of series
3215:	1609  018080  	        LD      BC,8080H        ; BCDE = -0.5
3216:	160C  110000  	        LD      DE,0000H
3217:	160F  CDE414  	        CALL    FPADD           ; Subtract 0.5 from FPREG
3218:	1612  F1      	        POP     AF              ; Restore scale factor
3219:	1613  CDA518  	        CALL    RSCALE          ; Re-scale number
3220:	1616  013180  	MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
3221:	1619  111872  	        LD      DE,7218H
3222:	161C  21      	        .DB     21H             ; Skip "POP BC" and "POP DE"
3223:			
3224:	161D  C1      	MULT:   POP     BC              ; Get number from stack
3225:	161E  D1      	        POP     DE
3226:	161F  CD2A17  	FPMULT: CALL    TSTSGN          ; Test sign of FPREG
3227:	1622  C8      	        RET     Z               ; Return zero if zero
3228:	1623  2E00    	        LD      L,0             ; Flag add exponents
3229:	1625  CDE816  	        CALL    ADDEXP          ; Add exponents
3230:	1628  79      	        LD      A,C             ; Get MSB of multiplier
3231:	1629  32F620  	        LD      (MULVAL),A      ; Save MSB of multiplier
3232:	162C  EB      	        EX      DE,HL
3233:	162D  22F720  	        LD      (MULVAL+1),HL   ; Save rest of multiplier
3234:	1630  010000  	        LD      BC,0            ; Partial product (BCDE) = zero
3235:	1633  50      	        LD      D,B
3236:	1634  58      	        LD      E,B
3237:	1635  213515  	        LD      HL,BNORM        ; Address of normalise
3238:	1638  E5      	        PUSH    HL              ; Save for return
3239:	1639  214116  	        LD      HL,MULT8        ; Address of 8 bit multiply
3240:	163C  E5      	        PUSH    HL              ; Save for NMSB,MSB
3241:	163D  E5      	        PUSH    HL              ; 
3242:	163E  21E420  	        LD      HL,FPREG        ; Point to number
3243:	1641  7E      	MULT8:  LD      A,(HL)          ; Get LSB of number
3244:	1642  23      	        INC     HL              ; Point to NMSB
3245:	1643  B7      	        OR      A               ; Test LSB
3246:	1644  CA6D16  	        JP      Z,BYTSFT        ; Zero - shift to next byte
3247:	1647  E5      	        PUSH    HL              ; Save address of number
3248:	1648  2E08    	        LD      L,8             ; 8 bits to multiply by
3249:	164A  1F      	MUL8LP: RRA                     ; Shift LSB right
3250:	164B  67      	        LD      H,A             ; Save LSB
3251:	164C  79      	        LD      A,C             ; Get MSB
3252:	164D  D25B16  	        JP      NC,NOMADD       ; Bit was zero - Don't add
3253:	1650  E5      	        PUSH    HL              ; Save LSB and count
3254:	1651  2AF720  	        LD      HL,(MULVAL+1)   ; Get LSB and NMSB
3255:	1654  19      	        ADD     HL,DE           ; Add NMSB and LSB
3256:	1655  EB      	        EX      DE,HL           ; Leave sum in DE
3257:	1656  E1      	        POP     HL              ; Restore MSB and count
3258:	1657  3AF620  	        LD      A,(MULVAL)      ; Get MSB of multiplier
3259:	165A  89      	        ADC     A,C             ; Add MSB
3260:	165B  1F      	NOMADD: RRA                     ; Shift MSB right
3261:	165C  4F      	        LD      C,A             ; Re-save MSB
3262:	165D  7A      	        LD      A,D             ; Get NMSB
3263:	165E  1F      	        RRA                     ; Shift NMSB right
3264:	165F  57      	        LD      D,A             ; Re-save NMSB
3265:	1660  7B      	        LD      A,E             ; Get LSB
3266:	1661  1F      	        RRA                     ; Shift LSB right
3267:	1662  5F      	        LD      E,A             ; Re-save LSB
3268:	1663  78      	        LD      A,B             ; Get VLSB
3269:	1664  1F      	        RRA                     ; Shift VLSB right
3270:	1665  47      	        LD      B,A             ; Re-save VLSB
3271:	1666  2D      	        DEC     L               ; Count bits multiplied
3272:	1667  7C      	        LD      A,H             ; Get LSB of multiplier
3273:	1668  C24A16  	        JP      NZ,MUL8LP       ; More - Do it
3274:	166B  E1      	POPHRT: POP     HL              ; Restore address of number
3275:	166C  C9      	        RET
3276:			
3277:	166D  43      	BYTSFT: LD      B,E             ; Shift partial product left
3278:	166E  5A      	        LD      E,D
3279:	166F  51      	        LD      D,C
3280:	1670  4F      	        LD      C,A
3281:	1671  C9      	        RET
3282:			
3283:	1672  CD5B17  	DIV10:  CALL    STAKFP          ; Save FPREG on stack
3284:	1675  012084  	        LD      BC,8420H        ; BCDE = 10.
3285:	1678  110000  	        LD      DE,0000H
3286:	167B  CD6B17  	        CALL    FPBCDE          ; Move 10 to FPREG
3287:			
3288:	167E  C1      	DIV:    POP     BC              ; Get number from stack
3289:	167F  D1      	        POP     DE
3290:	1680  CD2A17  	DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
3291:	1683  CAB404  	        JP      Z,DZERR         ; Error if division by zero
3292:	1686  2EFF    	        LD      L,-1            ; Flag subtract exponents
3293:	1688  CDE816  	        CALL    ADDEXP          ; Subtract exponents
3294:	168B  34      	        INC     (HL)            ; Add 2 to exponent to adjust
3295:	168C  34      	        INC     (HL)
3296:	168D  2B      	        DEC     HL              ; Point to MSB
3297:	168E  7E      	        LD      A,(HL)          ; Get MSB of dividend
3298:	168F  321220  	        LD      (DIV3),A        ; Save for subtraction
3299:	1692  2B      	        DEC     HL
3300:	1693  7E      	        LD      A,(HL)          ; Get NMSB of dividend
3301:	1694  320E20  	        LD      (DIV2),A        ; Save for subtraction
3302:	1697  2B      	        DEC     HL
3303:	1698  7E      	        LD      A,(HL)          ; Get MSB of dividend
3304:	1699  320A20  	        LD      (DIV1),A        ; Save for subtraction
3305:	169C  41      	        LD      B,C             ; Get MSB
3306:	169D  EB      	        EX      DE,HL           ; NMSB,LSB to HL
3307:	169E  AF      	        XOR     A
3308:	169F  4F      	        LD      C,A             ; Clear MSB of quotient
3309:	16A0  57      	        LD      D,A             ; Clear NMSB of quotient
3310:	16A1  5F      	        LD      E,A             ; Clear LSB of quotient
3311:	16A2  321520  	        LD      (DIV4),A        ; Clear overflow count
3312:	16A5  E5      	DIVLP:  PUSH    HL              ; Save divisor
3313:	16A6  C5      	        PUSH    BC
3314:	16A7  7D      	        LD      A,L             ; Get LSB of number
3315:	16A8  CD0920  	        CALL    DIVSUP          ; Subt' divisor from dividend
3316:	16AB  DE00    	        SBC     A,0             ; Count for overflows
3317:	16AD  3F      	        CCF
3318:	16AE  D2B816  	        JP      NC,RESDIV       ; Restore divisor if borrow
3319:	16B1  321520  	        LD      (DIV4),A        ; Re-save overflow count
3320:	16B4  F1      	        POP     AF              ; Scrap divisor
3321:	16B5  F1      	        POP     AF
3322:	16B6  37      	        SCF                     ; Set carry to
3323:	16B7  D2      	        .DB     0D2H            ; Skip "POP BC" and "POP HL"
3324:			
3325:	16B8  C1      	RESDIV: POP     BC              ; Restore divisor
3326:	16B9  E1      	        POP     HL
3327:	16BA  79      	        LD      A,C             ; Get MSB of quotient
3328:	16BB  3C      	        INC     A
3329:	16BC  3D      	        DEC     A
3330:	16BD  1F      	        RRA                     ; Bit 0 to bit 7
3331:	16BE  FA6B15  	        JP      M,RONDB        ; Done - Normalise result
3332:	16C1  17      	        RLA                     ; Restore carry
3333:	16C2  7B      	        LD      A,E             ; Get LSB of quotient
3334:	16C3  17      	        RLA                     ; Double it
3335:	16C4  5F      	        LD      E,A             ; Put it back
3336:	16C5  7A      	        LD      A,D             ; Get NMSB of quotient
3337:	16C6  17      	        RLA                     ; Double it
3338:	16C7  57      	        LD      D,A             ; Put it back
3339:	16C8  79      	        LD      A,C             ; Get MSB of quotient
3340:	16C9  17      	        RLA                     ; Double it
3341:	16CA  4F      	        LD      C,A             ; Put it back
3342:	16CB  29      	        ADD     HL,HL           ; Double NMSB,LSB of divisor
3343:	16CC  78      	        LD      A,B             ; Get MSB of divisor
3344:	16CD  17      	        RLA                     ; Double it
3345:	16CE  47      	        LD      B,A             ; Put it back
3346:	16CF  3A1520  	        LD      A,(DIV4)        ; Get VLSB of quotient
3347:	16D2  17      	        RLA                     ; Double it
3348:	16D3  321520  	        LD      (DIV4),A        ; Put it back
3349:	16D6  79      	        LD      A,C             ; Get MSB of quotient
3350:	16D7  B2      	        OR      D               ; Merge NMSB
3351:	16D8  B3      	        OR      E               ; Merge LSB
3352:	16D9  C2A516  	        JP      NZ,DIVLP        ; Not done - Keep dividing
3353:	16DC  E5      	        PUSH    HL              ; Save divisor
3354:	16DD  21E720  	        LD      HL,FPEXP        ; Point to exponent
3355:	16E0  35      	        DEC     (HL)            ; Divide by 2
3356:	16E1  E1      	        POP     HL              ; Restore divisor
3357:	16E2  C2A516  	        JP      NZ,DIVLP        ; Ok - Keep going
3358:	16E5  C3C004  	        JP      OVERR           ; Overflow error
3359:			
3360:	16E8  78      	ADDEXP: LD      A,B             ; Get exponent of dividend
3361:	16E9  B7      	        OR      A               ; Test it
3362:	16EA  CA0C17  	        JP      Z,OVTST3        ; Zero - Result zero
3363:	16ED  7D      	        LD      A,L             ; Get add/subtract flag
3364:	16EE  21E720  	        LD      HL,FPEXP        ; Point to exponent
3365:	16F1  AE      	        XOR     (HL)            ; Add or subtract it
3366:	16F2  80      	        ADD     A,B             ; Add the other exponent
3367:	16F3  47      	        LD      B,A             ; Save new exponent
3368:	16F4  1F      	        RRA                     ; Test exponent for overflow
3369:	16F5  A8      	        XOR     B
3370:	16F6  78      	        LD      A,B             ; Get exponent
3371:	16F7  F20B17  	        JP      P,OVTST2        ; Positive - Test for overflow
3372:	16FA  C680    	        ADD     A,80H           ; Add excess 128
3373:	16FC  77      	        LD      (HL),A          ; Save new exponent
3374:	16FD  CA6B16  	        JP      Z,POPHRT        ; Zero - Result zero
3375:	1700  CD9017  	        CALL    SIGNS           ; Set MSBs and sign of result
3376:	1703  77      	        LD      (HL),A          ; Save new exponent
3377:	1704  2B      	        DEC     HL              ; Point to MSB
3378:	1705  C9      	        RET
3379:			
3380:	1706  CD2A17  	OVTST1: CALL    TSTSGN          ; Test sign of FPREG
3381:	1709  2F      	        CPL                     ; Invert sign
3382:	170A  E1      	        POP     HL              ; Clean up stack
3383:	170B  B7      	OVTST2: OR      A               ; Test if new exponent zero
3384:	170C  E1      	OVTST3: POP     HL              ; Clear off return address
3385:	170D  F24A15  	        JP      P,RESZER        ; Result zero
3386:	1710  C3C004  	        JP      OVERR           ; Overflow error
3387:			
3388:	1713  CD7617  	MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
3389:	1716  78      	        LD      A,B             ; Get exponent
3390:	1717  B7      	        OR      A               ; Is it zero?
3391:	1718  C8      	        RET     Z               ; Yes - Result is zero
3392:	1719  C602    	        ADD     A,2             ; Multiply by 4
3393:	171B  DAC004  	        JP      C,OVERR         ; Overflow - ?OV Error
3394:	171E  47      	        LD      B,A             ; Re-save exponent
3395:	171F  CDE414  	        CALL    FPADD           ; Add BCDE to FPREG (Times 5)
3396:	1722  21E720  	        LD      HL,FPEXP        ; Point to exponent
3397:	1725  34      	        INC     (HL)            ; Double number (Times 10)
3398:	1726  C0      	        RET     NZ              ; Ok - Return
3399:	1727  C3C004  	        JP      OVERR           ; Overflow error
3400:			
3401:	172A  3AE720  	TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
3402:	172D  B7      	        OR      A
3403:	172E  C8      	        RET     Z               ; RETurn if number is zero
3404:	172F  3AE620  	        LD      A,(FPREG+2)     ; Get MSB of FPREG
3405:	1732  FE      	        .DB     0FEH            ; Test sign
3406:	1733  2F      	RETREL: CPL                     ; Invert sign
3407:	1734  17      	        RLA                     ; Sign bit to carry
3408:	1735  9F      	FLGDIF: SBC     A,A             ; Carry to all bits of A
3409:	1736  C0      	        RET     NZ              ; Return -1 if negative
3410:	1737  3C      	        INC     A               ; Bump to +1
3411:	1738  C9      	        RET                     ; Positive - Return +1
3412:			
3413:	1739  CD2A17  	SGN:    CALL    TSTSGN          ; Test sign of FPREG
3414:	173C  0688    	FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
3415:	173E  110000  	        LD      DE,0            ; Zero NMSB and LSB
3416:	1741  21E720  	RETINT: LD      HL,FPEXP        ; Point to exponent
3417:	1744  4F      	        LD      C,A             ; CDE = MSB,NMSB and LSB
3418:	1745  70      	        LD      (HL),B          ; Save exponent
3419:	1746  0600    	        LD      B,0             ; CDE = integer to normalise
3420:	1748  23      	        INC     HL              ; Point to sign of result
3421:	1749  3680    	        LD      (HL),80H        ; Set sign of result
3422:	174B  17      	        RLA                     ; Carry = sign of integer
3423:	174C  C33215  	        JP      CONPOS          ; Set sign of result
3424:			
3425:	174F  CD2A17  	ABS:    CALL    TSTSGN          ; Test sign of FPREG
3426:	1752  F0      	        RET     P               ; Return if positive
3427:	1753  21E620  	INVSGN: LD      HL,FPREG+2      ; Point to MSB
3428:	1756  7E      	        LD      A,(HL)          ; Get sign of mantissa
3429:	1757  EE80    	        XOR     80H             ; Invert sign of mantissa
3430:	1759  77      	        LD      (HL),A          ; Re-save sign of mantissa
3431:	175A  C9      	        RET
3432:			
3433:	175B  EB      	STAKFP: EX      DE,HL           ; Save code string address
3434:	175C  2AE420  	        LD      HL,(FPREG)      ; LSB,NLSB of FPREG
3435:	175F  E3      	        EX      (SP),HL         ; Stack them,get return
3436:	1760  E5      	        PUSH    HL              ; Re-save return
3437:	1761  2AE620  	        LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
3438:	1764  E3      	        EX      (SP),HL         ; Stack them,get return
3439:	1765  E5      	        PUSH    HL              ; Re-save return
3440:	1766  EB      	        EX      DE,HL           ; Restore code string address
3441:	1767  C9      	        RET
3442:			
3443:	1768  CD7917  	PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
3444:	176B  EB      	FPBCDE: EX      DE,HL           ; Save code string address
3445:	176C  22E420  	        LD      (FPREG),HL      ; Save LSB,NLSB of number
3446:	176F  60      	        LD      H,B             ; Exponent of number
3447:	1770  69      	        LD      L,C             ; MSB of number
3448:	1771  22E620  	        LD      (FPREG+2),HL    ; Save MSB and exponent
3449:	1774  EB      	        EX      DE,HL           ; Restore code string address
3450:	1775  C9      	        RET
3451:			
3452:	1776  21E420  	BCDEFP: LD      HL,FPREG        ; Point to FPREG
3453:	1779  5E      	LOADFP: LD      E,(HL)          ; Get LSB of number
3454:	177A  23      	        INC     HL
3455:	177B  56      	        LD      D,(HL)          ; Get NMSB of number
3456:	177C  23      	        INC     HL
3457:	177D  4E      	        LD      C,(HL)          ; Get MSB of number
3458:	177E  23      	        INC     HL
3459:	177F  46      	        LD      B,(HL)          ; Get exponent of number
3460:	1780  23      	INCHL:  INC     HL              ; Used for conditional "INC HL"
3461:	1781  C9      	        RET
3462:			
3463:	1782  11E420  	FPTHL:  LD      DE,FPREG        ; Point to FPREG
3464:	1785  0604    	DETHL4: LD      B,4             ; 4 bytes to move
3465:	1787  1A      	DETHLB: LD      A,(DE)          ; Get source
3466:	1788  77      	        LD      (HL),A          ; Save destination
3467:	1789  13      	        INC     DE              ; Next source
3468:	178A  23      	        INC     HL              ; Next destination
3469:	178B  05      	        DEC     B               ; Count bytes
3470:	178C  C28717  	        JP      NZ,DETHLB       ; Loop if more
3471:	178F  C9      	        RET
3472:			
3473:	1790  21E620  	SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
3474:	1793  7E      	        LD      A,(HL)          ; Get MSB
3475:	1794  07      	        RLCA                    ; Old sign to carry
3476:	1795  37      	        SCF                     ; Set MSBit
3477:	1796  1F      	        RRA                     ; Set MSBit of MSB
3478:	1797  77      	        LD      (HL),A          ; Save new MSB
3479:	1798  3F      	        CCF                     ; Complement sign
3480:	1799  1F      	        RRA                     ; Old sign to carry
3481:	179A  23      	        INC     HL
3482:	179B  23      	        INC     HL
3483:	179C  77      	        LD      (HL),A          ; Set sign of result
3484:	179D  79      	        LD      A,C             ; Get MSB
3485:	179E  07      	        RLCA                    ; Old sign to carry
3486:	179F  37      	        SCF                     ; Set MSBit
3487:	17A0  1F      	        RRA                     ; Set MSBit of MSB
3488:	17A1  4F      	        LD      C,A             ; Save MSB
3489:	17A2  1F      	        RRA
3490:	17A3  AE      	        XOR     (HL)            ; New sign of result
3491:	17A4  C9      	        RET
3492:			
3493:	17A5  78      	CMPNUM: LD      A,B             ; Get exponent of number
3494:	17A6  B7      	        OR      A
3495:	17A7  CA2A17  	        JP      Z,TSTSGN        ; Zero - Test sign of FPREG
3496:	17AA  213317  	        LD      HL,RETREL       ; Return relation routine
3497:	17AD  E5      	        PUSH    HL              ; Save for return
3498:	17AE  CD2A17  	        CALL    TSTSGN          ; Test sign of FPREG
3499:	17B1  79      	        LD      A,C             ; Get MSB of number
3500:	17B2  C8      	        RET     Z               ; FPREG zero - Number's MSB
3501:	17B3  21E620  	        LD      HL,FPREG+2      ; MSB of FPREG
3502:	17B6  AE      	        XOR     (HL)            ; Combine signs
3503:	17B7  79      	        LD      A,C             ; Get MSB of number
3504:	17B8  F8      	        RET     M               ; Exit if signs different
3505:	17B9  CDBF17  	        CALL    CMPFP           ; Compare FP numbers
3506:	17BC  1F      	        RRA                     ; Get carry to sign
3507:	17BD  A9      	        XOR     C               ; Combine with MSB of number
3508:	17BE  C9      	        RET
3509:			
3510:	17BF  23      	CMPFP:  INC     HL              ; Point to exponent
3511:	17C0  78      	        LD      A,B             ; Get exponent
3512:	17C1  BE      	        CP      (HL)            ; Compare exponents
3513:	17C2  C0      	        RET     NZ              ; Different
3514:	17C3  2B      	        DEC     HL              ; Point to MBS
3515:	17C4  79      	        LD      A,C             ; Get MSB
3516:	17C5  BE      	        CP      (HL)            ; Compare MSBs
3517:	17C6  C0      	        RET     NZ              ; Different
3518:	17C7  2B      	        DEC     HL              ; Point to NMSB
3519:	17C8  7A      	        LD      A,D             ; Get NMSB
3520:	17C9  BE      	        CP      (HL)            ; Compare NMSBs
3521:	17CA  C0      	        RET     NZ              ; Different
3522:	17CB  2B      	        DEC     HL              ; Point to LSB
3523:	17CC  7B      	        LD      A,E             ; Get LSB
3524:	17CD  96      	        SUB     (HL)            ; Compare LSBs
3525:	17CE  C0      	        RET     NZ              ; Different
3526:	17CF  E1      	        POP     HL              ; Drop RETurn
3527:	17D0  E1      	        POP     HL              ; Drop another RETurn
3528:	17D1  C9      	        RET
3529:			
3530:	17D2  47      	FPINT:  LD      B,A             ; <- Move
3531:	17D3  4F      	        LD      C,A             ; <- exponent
3532:	17D4  57      	        LD      D,A             ; <- to all
3533:	17D5  5F      	        LD      E,A             ; <- bits
3534:	17D6  B7      	        OR      A               ; Test exponent
3535:	17D7  C8      	        RET     Z               ; Zero - Return zero
3536:	17D8  E5      	        PUSH    HL              ; Save pointer to number
3537:	17D9  CD7617  	        CALL    BCDEFP          ; Move FPREG to BCDE
3538:	17DC  CD9017  	        CALL    SIGNS           ; Set MSBs & sign of result
3539:	17DF  AE      	        XOR     (HL)            ; Combine with sign of FPREG
3540:	17E0  67      	        LD      H,A             ; Save combined signs
3541:	17E1  FCF617  	        CALL    M,DCBCDE        ; Negative - Decrement BCDE
3542:	17E4  3E98    	        LD      A,80H+24        ; 24 bits
3543:	17E6  90      	        SUB     B               ; Bits to shift
3544:	17E7  CDA915  	        CALL    SCALE           ; Shift BCDE
3545:	17EA  7C      	        LD      A,H             ; Get combined sign
3546:	17EB  17      	        RLA                     ; Sign to carry
3547:	17EC  DC7C15  	        CALL    C,FPROND        ; Negative - Round number up
3548:	17EF  0600    	        LD      B,0             ; Zero exponent
3549:	17F1  DC9515  	        CALL    C,COMPL         ; If negative make positive
3550:	17F4  E1      	        POP     HL              ; Restore pointer to number
3551:	17F5  C9      	        RET
3552:			
3553:	17F6  1B      	DCBCDE: DEC     DE              ; Decrement BCDE
3554:	17F7  7A      	        LD      A,D             ; Test LSBs
3555:	17F8  A3      	        AND     E
3556:	17F9  3C      	        INC     A
3557:	17FA  C0      	        RET     NZ              ; Exit if LSBs not FFFF
3558:	17FB  0B      	        DEC     BC              ; Decrement MSBs
3559:	17FC  C9      	        RET
3560:			
3561:	17FD  21E720  	INT:    LD      HL,FPEXP        ; Point to exponent
3562:	1800  7E      	        LD      A,(HL)          ; Get exponent
3563:	1801  FE98    	        CP      80H+24          ; Integer accuracy only?
3564:	1803  3AE420  	        LD      A,(FPREG)       ; Get LSB
3565:	1806  D0      	        RET     NC              ; Yes - Already integer
3566:	1807  7E      	        LD      A,(HL)          ; Get exponent
3567:	1808  CDD217  	        CALL    FPINT           ; F.P to integer
3568:	180B  3698    	        LD      (HL),80H+24     ; Save 24 bit integer
3569:	180D  7B      	        LD      A,E             ; Get LSB of number
3570:	180E  F5      	        PUSH    AF              ; Save LSB
3571:	180F  79      	        LD      A,C             ; Get MSB of number
3572:	1810  17      	        RLA                     ; Sign to carry
3573:	1811  CD3215  	        CALL    CONPOS          ; Set sign of result
3574:	1814  F1      	        POP     AF              ; Restore LSB of number
3575:	1815  C9      	        RET
3576:			
3577:	1816  210000  	MLDEBC: LD      HL,0            ; Clear partial product
3578:	1819  78      	        LD      A,B             ; Test multiplier
3579:	181A  B1      	        OR      C
3580:	181B  C8      	        RET     Z               ; Return zero if zero
3581:	181C  3E10    	        LD      A,16            ; 16 bits
3582:	181E  29      	MLDBLP: ADD     HL,HL           ; Shift P.P left
3583:	181F  DA5610  	        JP      C,BSERR         ; ?BS Error if overflow
3584:	1822  EB      	        EX      DE,HL
3585:	1823  29      	        ADD     HL,HL           ; Shift multiplier left
3586:	1824  EB      	        EX      DE,HL
3587:	1825  D22C18  	        JP      NC,NOMLAD       ; Bit was zero - No add
3588:	1828  09      	        ADD     HL,BC           ; Add multiplicand
3589:	1829  DA5610  	        JP      C,BSERR         ; ?BS Error if overflow
3590:	182C  3D      	NOMLAD: DEC     A               ; Count bits
3591:	182D  C21E18  	        JP      NZ,MLDBLP       ; More
3592:	1830  C9      	        RET
3593:			
3594:	1831  FE2D    	ASCTFP: CP      '-'             ; Negative?
3595:	1833  F5      	        PUSH    AF              ; Save it and flags
3596:	1834  CA3D18  	        JP      Z,CNVNUM        ; Yes - Convert number
3597:	1837  FE2B    	        CP      '+'             ; Positive?
3598:	1839  CA3D18  	        JP      Z,CNVNUM        ; Yes - Convert number
3599:	183C  2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
3600:	183D  CD4A15  	CNVNUM: CALL    RESZER          ; Set result to zero
3601:	1840  47      	        LD      B,A             ; Digits after point counter
3602:	1841  57      	        LD      D,A             ; Sign of exponent
3603:	1842  5F      	        LD      E,A             ; Exponent of ten
3604:	1843  2F      	        CPL
3605:	1844  4F      	        LD      C,A             ; Before or after point flag
3606:	1845  CDD508  	MANLP:  CALL    GETCHR          ; Get next character
3607:	1848  DA8E18  	        JP      C,ADDIG         ; Digit - Add to number
3608:	184B  FE2E    	        CP      '.'
3609:	184D  CA6918  	        JP      Z,DPOINT        ; '.' - Flag point
3610:	1850  FE45    	        CP      'E'
3611:	1852  C26D18  	        JP      NZ,CONEXP       ; Not 'E' - Scale number
3612:	1855  CDD508  	        CALL    GETCHR          ; Get next character
3613:	1858  CD810E  	        CALL    SGNEXP          ; Get sign of exponent
3614:	185B  CDD508  	EXPLP:  CALL    GETCHR          ; Get next character
3615:	185E  DAB018  	        JP      C,EDIGIT        ; Digit - Add to exponent
3616:	1861  14      	        INC     D               ; Is sign negative?
3617:	1862  C26D18  	        JP      NZ,CONEXP       ; No - Scale number
3618:	1865  AF      	        XOR     A
3619:	1866  93      	        SUB     E               ; Negate exponent
3620:	1867  5F      	        LD      E,A             ; And re-save it
3621:	1868  0C      	        INC     C               ; Flag end of number
3622:	1869  0C      	DPOINT: INC     C               ; Flag point passed
3623:	186A  CA4518  	        JP      Z,MANLP         ; Zero - Get another digit
3624:	186D  E5      	CONEXP: PUSH    HL              ; Save code string address
3625:	186E  7B      	        LD      A,E             ; Get exponent
3626:	186F  90      	        SUB     B               ; Subtract digits after point
3627:	1870  F48618  	SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
3628:	1873  F27C18  	        JP      P,ENDCON        ; Positive - All done
3629:	1876  F5      	        PUSH    AF              ; Save number of times to /10
3630:	1877  CD7216  	        CALL    DIV10           ; Divide by 10
3631:	187A  F1      	        POP     AF              ; Restore count
3632:	187B  3C      	        INC     A               ; Count divides
3633:			
3634:	187C  C27018  	ENDCON: JP      NZ,SCALMI       ; More to do
3635:	187F  D1      	        POP     DE              ; Restore code string address
3636:	1880  F1      	        POP     AF              ; Restore sign of number
3637:	1881  CC5317  	        CALL    Z,INVSGN        ; Negative - Negate number
3638:	1884  EB      	        EX      DE,HL           ; Code string address to HL
3639:	1885  C9      	        RET
3640:			
3641:	1886  C8      	SCALPL: RET     Z               ; Exit if no scaling needed
3642:	1887  F5      	MULTEN: PUSH    AF              ; Save count
3643:	1888  CD1317  	        CALL    MLSP10          ; Multiply number by 10
3644:	188B  F1      	        POP     AF              ; Restore count
3645:	188C  3D      	        DEC     A               ; Count multiplies
3646:	188D  C9      	        RET
3647:			
3648:	188E  D5      	ADDIG:  PUSH    DE              ; Save sign of exponent
3649:	188F  57      	        LD      D,A             ; Save digit
3650:	1890  78      	        LD      A,B             ; Get digits after point
3651:	1891  89      	        ADC     A,C             ; Add one if after point
3652:	1892  47      	        LD      B,A             ; Re-save counter
3653:	1893  C5      	        PUSH    BC              ; Save point flags
3654:	1894  E5      	        PUSH    HL              ; Save code string address
3655:	1895  D5      	        PUSH    DE              ; Save digit
3656:	1896  CD1317  	        CALL    MLSP10          ; Multiply number by 10
3657:	1899  F1      	        POP     AF              ; Restore digit
3658:	189A  D630    	        SUB     '0'             ; Make it absolute
3659:	189C  CDA518  	        CALL    RSCALE          ; Re-scale number
3660:	189F  E1      	        POP     HL              ; Restore code string address
3661:	18A0  C1      	        POP     BC              ; Restore point flags
3662:	18A1  D1      	        POP     DE              ; Restore sign of exponent
3663:	18A2  C34518  	        JP      MANLP           ; Get another digit
3664:			
3665:	18A5  CD5B17  	RSCALE: CALL    STAKFP          ; Put number on stack
3666:	18A8  CD3C17  	        CALL    FLGREL          ; Digit to add to FPREG
3667:	18AB  C1      	PADD:   POP     BC              ; Restore number
3668:	18AC  D1      	        POP     DE
3669:	18AD  C3E414  	        JP      FPADD           ; Add BCDE to FPREG and return
3670:			
3671:	18B0  7B      	EDIGIT: LD      A,E             ; Get digit
3672:	18B1  07      	        RLCA                    ; Times 2
3673:	18B2  07      	        RLCA                    ; Times 4
3674:	18B3  83      	        ADD     A,E             ; Times 5
3675:	18B4  07      	        RLCA                    ; Times 10
3676:	18B5  86      	        ADD     A,(HL)          ; Add next digit
3677:	18B6  D630    	        SUB     '0'             ; Make it absolute
3678:	18B8  5F      	        LD      E,A             ; Save new digit
3679:	18B9  C35B18  	        JP      EXPLP           ; Look for another digit
3680:			
3681:	18BC  E5      	LINEIN: PUSH    HL              ; Save code string address
3682:	18BD  214904  	        LD      HL,INMSG        ; Output " in "
3683:	18C0  CD2112  	        CALL    PRS             ; Output string at HL
3684:	18C3  E1      	        POP     HL              ; Restore code string address
3685:	18C4  EB      	PRNTHL: EX      DE,HL           ; Code string address to DE
3686:	18C5  AF      	        XOR     A
3687:	18C6  0698    	        LD      B,80H+24        ; 24 bits
3688:	18C8  CD4117  	        CALL    RETINT          ; Return the integer
3689:	18CB  212012  	        LD      HL,PRNUMS       ; Print number string
3690:	18CE  E5      	        PUSH    HL              ; Save for return
3691:	18CF  21E920  	NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
3692:	18D2  E5      	        PUSH    HL              ; Save for return
3693:	18D3  CD2A17  	        CALL    TSTSGN          ; Test sign of FPREG
3694:	18D6  3620    	        LD      (HL),' '        ; Space at start
3695:	18D8  F2DD18  	        JP      P,SPCFST        ; Positive - Space to start
3696:	18DB  362D    	        LD      (HL),'-'        ; '-' sign at start
3697:	18DD  23      	SPCFST: INC     HL              ; First byte of number
3698:	18DE  3630    	        LD      (HL),'0'        ; '0' if zero
3699:	18E0  CA9319  	        JP      Z,JSTZER        ; Return '0' if zero
3700:	18E3  E5      	        PUSH    HL              ; Save buffer address
3701:	18E4  FC5317  	        CALL    M,INVSGN        ; Negate FPREG if negative
3702:	18E7  AF      	        XOR     A               ; Zero A
3703:	18E8  F5      	        PUSH    AF              ; Save it
3704:	18E9  CD9919  	        CALL    RNGTST          ; Test number is in range
3705:	18EC  014391  	SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
3706:	18EF  11F84F  	        LD      DE,4FF8H
3707:	18F2  CDA517  	        CALL    CMPNUM          ; Compare numbers
3708:	18F5  B7      	        OR      A
3709:	18F6  E20A19  	        JP      PO,INRNG        ; > 99999.9 - Sort it out
3710:	18F9  F1      	        POP     AF              ; Restore count
3711:	18FA  CD8718  	        CALL    MULTEN          ; Multiply by ten
3712:	18FD  F5      	        PUSH    AF              ; Re-save count
3713:	18FE  C3EC18  	        JP      SIXDIG          ; Test it again
3714:			
3715:	1901  CD7216  	GTSIXD: CALL    DIV10           ; Divide by 10
3716:	1904  F1      	        POP     AF              ; Get count
3717:	1905  3C      	        INC     A               ; Count divides
3718:	1906  F5      	        PUSH    AF              ; Re-save count
3719:	1907  CD9919  	        CALL    RNGTST          ; Test number is in range
3720:	190A  CDD214  	INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
3721:	190D  3C      	        INC     A
3722:	190E  CDD217  	        CALL    FPINT           ; F.P to integer
3723:	1911  CD6B17  	        CALL    FPBCDE          ; Move BCDE to FPREG
3724:	1914  010603  	        LD      BC,0306H        ; 1E+06 to 1E-03 range
3725:	1917  F1      	        POP     AF              ; Restore count
3726:	1918  81      	        ADD     A,C             ; 6 digits before point
3727:	1919  3C      	        INC     A               ; Add one
3728:	191A  FA2619  	        JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
3729:	191D  FE08    	        CP      6+1+1           ; More than 999999 ?
3730:	191F  D22619  	        JP      NC,MAKNUM       ; Yes - Do it in 'E' form
3731:	1922  3C      	        INC     A               ; Adjust for exponent
3732:	1923  47      	        LD      B,A             ; Exponent of number
3733:	1924  3E02    	        LD      A,2             ; Make it zero after
3734:			
3735:	1926  3D      	MAKNUM: DEC     A               ; Adjust for digits to do
3736:	1927  3D      	        DEC     A
3737:	1928  E1      	        POP     HL              ; Restore buffer address
3738:	1929  F5      	        PUSH    AF              ; Save count
3739:	192A  11AC19  	        LD      DE,POWERS       ; Powers of ten
3740:	192D  05      	        DEC     B               ; Count digits before point
3741:	192E  C23719  	        JP      NZ,DIGTXT       ; Not zero - Do number
3742:	1931  362E    	        LD      (HL),'.'        ; Save point
3743:	1933  23      	        INC     HL              ; Move on
3744:	1934  3630    	        LD      (HL),'0'        ; Save zero
3745:	1936  23      	        INC     HL              ; Move on
3746:	1937  05      	DIGTXT: DEC     B               ; Count digits before point
3747:	1938  362E    	        LD      (HL),'.'        ; Save point in case
3748:	193A  CC8017  	        CALL    Z,INCHL         ; Last digit - move on
3749:	193D  C5      	        PUSH    BC              ; Save digits before point
3750:	193E  E5      	        PUSH    HL              ; Save buffer address
3751:	193F  D5      	        PUSH    DE              ; Save powers of ten
3752:	1940  CD7617  	        CALL    BCDEFP          ; Move FPREG to BCDE
3753:	1943  E1      	        POP     HL              ; Powers of ten table
3754:	1944  062F    	        LD      B, '0'-1        ; ASCII '0' - 1
3755:	1946  04      	TRYAGN: INC     B               ; Count subtractions
3756:	1947  7B      	        LD      A,E             ; Get LSB
3757:	1948  96      	        SUB     (HL)            ; Subtract LSB
3758:	1949  5F      	        LD      E,A             ; Save LSB
3759:	194A  23      	        INC     HL
3760:	194B  7A      	        LD      A,D             ; Get NMSB
3761:	194C  9E      	        SBC     A,(HL)          ; Subtract NMSB
3762:	194D  57      	        LD      D,A             ; Save NMSB
3763:	194E  23      	        INC     HL
3764:	194F  79      	        LD      A,C             ; Get MSB
3765:	1950  9E      	        SBC     A,(HL)          ; Subtract MSB
3766:	1951  4F      	        LD      C,A             ; Save MSB
3767:	1952  2B      	        DEC     HL              ; Point back to start
3768:	1953  2B      	        DEC     HL
3769:	1954  D24619  	        JP      NC,TRYAGN       ; No overflow - Try again
3770:	1957  CD8915  	        CALL    PLUCDE          ; Restore number
3771:	195A  23      	        INC     HL              ; Start of next number
3772:	195B  CD6B17  	        CALL    FPBCDE          ; Move BCDE to FPREG
3773:	195E  EB      	        EX      DE,HL           ; Save point in table
3774:	195F  E1      	        POP     HL              ; Restore buffer address
3775:	1960  70      	        LD      (HL),B          ; Save digit in buffer
3776:	1961  23      	        INC     HL              ; And move on
3777:	1962  C1      	        POP     BC              ; Restore digit count
3778:	1963  0D      	        DEC     C               ; Count digits
3779:	1964  C23719  	        JP      NZ,DIGTXT       ; More - Do them
3780:	1967  05      	        DEC     B               ; Any decimal part?
3781:	1968  CA7719  	        JP      Z,DOEBIT        ; No - Do 'E' bit
3782:	196B  2B      	SUPTLZ: DEC     HL              ; Move back through buffer
3783:	196C  7E      	        LD      A,(HL)          ; Get character
3784:	196D  FE30    	        CP      '0'             ; '0' character?
3785:	196F  CA6B19  	        JP      Z,SUPTLZ        ; Yes - Look back for more
3786:	1972  FE2E    	        CP      '.'             ; A decimal point?
3787:	1974  C48017  	        CALL    NZ,INCHL        ; Move back over digit
3788:			
3789:	1977  F1      	DOEBIT: POP     AF              ; Get 'E' flag
3790:	1978  CA9619  	        JP      Z,NOENED        ; No 'E' needed - End buffer
3791:	197B  3645    	        LD      (HL),'E'        ; Put 'E' in buffer
3792:	197D  23      	        INC     HL              ; And move on
3793:	197E  362B    	        LD      (HL),'+'        ; Put '+' in buffer
3794:	1980  F28719  	        JP      P,OUTEXP        ; Positive - Output exponent
3795:	1983  362D    	        LD      (HL),'-'        ; Put '-' in buffer
3796:	1985  2F      	        CPL                     ; Negate exponent
3797:	1986  3C      	        INC     A
3798:	1987  062F    	OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
3799:	1989  04      	EXPTEN: INC     B               ; Count subtractions
3800:	198A  D60A    	        SUB     10              ; Tens digit
3801:	198C  D28919  	        JP      NC,EXPTEN       ; More to do
3802:	198F  C63A    	        ADD     A,'0'+10        ; Restore and make ASCII
3803:	1991  23      	        INC     HL              ; Move on
3804:	1992  70      	        LD      (HL),B          ; Save MSB of exponent
3805:	1993  23      	JSTZER: INC     HL              ;
3806:	1994  77      	        LD      (HL),A          ; Save LSB of exponent
3807:	1995  23      	        INC     HL
3808:	1996  71      	NOENED: LD      (HL),C          ; Mark end of buffer
3809:	1997  E1      	        POP     HL              ; Restore code string address
3810:	1998  C9      	        RET
3811:			
3812:	1999  017494  	RNGTST: LD      BC,9474H        ; BCDE = 999999.
3813:	199C  11F723  	        LD      DE,23F7H
3814:	199F  CDA517  	        CALL    CMPNUM          ; Compare numbers
3815:	19A2  B7      	        OR      A
3816:	19A3  E1      	        POP     HL              ; Return address to HL
3817:	19A4  E20119  	        JP      PO,GTSIXD       ; Too big - Divide by ten
3818:	19A7  E9      	        JP      (HL)            ; Otherwise return to caller
3819:			
3820:	19A8  00000080	HALF:   .DB     00H,00H,00H,80H ; 0.5
3821:			
3822:	19AC  A08601  	POWERS: .DB     0A0H,086H,001H  ; 100000
3823:	19AF  102700  	        .DB     010H,027H,000H  ;  10000
3824:	19B2  E80300  	        .DB     0E8H,003H,000H  ;   1000
3825:	19B5  640000  	        .DB     064H,000H,000H  ;    100
3826:	19B8  0A0000  	        .DB     00AH,000H,000H  ;     10
3827:	19BB  010000  	        .DB     001H,000H,000H  ;      1
3828:			
3829:	19BE  215317  	NEGAFT: LD      HL,INVSGN       ; Negate result
3830:	19C1  E3      	        EX      (SP),HL         ; To be done after caller
3831:	19C2  E9      	        JP      (HL)            ; Return to caller
3832:			
3833:	19C3  CD5B17  	SQR:    CALL    STAKFP          ; Put value on stack
3834:	19C6  21A819  	        LD      HL,HALF         ; Set power to 1/2
3835:	19C9  CD6817  	        CALL    PHLTFP          ; Move 1/2 to FPREG
3836:			
3837:	19CC  C1      	POWER:  POP     BC              ; Get base
3838:	19CD  D1      	        POP     DE
3839:	19CE  CD2A17  	        CALL    TSTSGN          ; Test sign of power
3840:	19D1  78      	        LD      A,B             ; Get exponent of base
3841:	19D2  CA111A  	        JP      Z,EXP           ; Make result 1 if zero
3842:	19D5  F2DC19  	        JP      P,POWER1        ; Positive base - Ok
3843:	19D8  B7      	        OR      A               ; Zero to negative power?
3844:	19D9  CAB404  	        JP      Z,DZERR         ; Yes - ?/0 Error
3845:	19DC  B7      	POWER1: OR      A               ; Base zero?
3846:	19DD  CA4B15  	        JP      Z,SAVEXP        ; Yes - Return zero
3847:	19E0  D5      	        PUSH    DE              ; Save base
3848:	19E1  C5      	        PUSH    BC
3849:	19E2  79      	        LD      A,C             ; Get MSB of base
3850:	19E3  F67F    	        OR      01111111B       ; Get sign status
3851:	19E5  CD7617  	        CALL    BCDEFP          ; Move power to BCDE
3852:	19E8  F2F919  	        JP      P,POWER2        ; Positive base - Ok
3853:	19EB  D5      	        PUSH    DE              ; Save power
3854:	19EC  C5      	        PUSH    BC
3855:	19ED  CDFD17  	        CALL    INT             ; Get integer of power
3856:	19F0  C1      	        POP     BC              ; Restore power
3857:	19F1  D1      	        POP     DE
3858:	19F2  F5      	        PUSH    AF              ; MSB of base
3859:	19F3  CDA517  	        CALL    CMPNUM          ; Power an integer?
3860:	19F6  E1      	        POP     HL              ; Restore MSB of base
3861:	19F7  7C      	        LD      A,H             ; but don't affect flags
3862:	19F8  1F      	        RRA                     ; Exponent odd or even?
3863:	19F9  E1      	POWER2: POP     HL              ; Restore MSB and exponent
3864:	19FA  22E620  	        LD      (FPREG+2),HL    ; Save base in FPREG
3865:	19FD  E1      	        POP     HL              ; LSBs of base
3866:	19FE  22E420  	        LD      (FPREG),HL      ; Save in FPREG
3867:	1A01  DCBE19  	        CALL    C,NEGAFT        ; Odd power - Negate result
3868:	1A04  CC5317  	        CALL    Z,INVSGN        ; Negative base - Negate it
3869:	1A07  D5      	        PUSH    DE              ; Save power
3870:	1A08  C5      	        PUSH    BC
3871:	1A09  CDDE15  	        CALL    LOG             ; Get LOG of base
3872:	1A0C  C1      	        POP     BC              ; Restore power
3873:	1A0D  D1      	        POP     DE
3874:	1A0E  CD1F16  	        CALL    FPMULT          ; Multiply LOG by power
3875:			
3876:	1A11  CD5B17  	EXP:    CALL    STAKFP          ; Put value on stack
3877:	1A14  013881  	        LD      BC,08138H       ; BCDE = 1/Ln(2)
3878:	1A17  113BAA  	        LD      DE,0AA3BH
3879:	1A1A  CD1F16  	        CALL    FPMULT          ; Multiply value by 1/LN(2)
3880:	1A1D  3AE720  	        LD      A,(FPEXP)       ; Get exponent
3881:	1A20  FE88    	        CP      80H+8           ; Is it in range?
3882:	1A22  D20617  	        JP      NC,OVTST1       ; No - Test for overflow
3883:	1A25  CDFD17  	        CALL    INT             ; Get INT of FPREG
3884:	1A28  C680    	        ADD     A,80H           ; For excess 128
3885:	1A2A  C602    	        ADD     A,2             ; Exponent > 126?
3886:	1A2C  DA0617  	        JP      C,OVTST1        ; Yes - Test for overflow
3887:	1A2F  F5      	        PUSH    AF              ; Save scaling factor
3888:	1A30  21CD15  	        LD      HL,UNITY        ; Point to 1.
3889:	1A33  CDD514  	        CALL    ADDPHL          ; Add 1 to FPREG
3890:	1A36  CD1616  	        CALL    MULLN2          ; Multiply by LN(2)
3891:	1A39  F1      	        POP     AF              ; Restore scaling factor
3892:	1A3A  C1      	        POP     BC              ; Restore exponent
3893:	1A3B  D1      	        POP     DE
3894:	1A3C  F5      	        PUSH    AF              ; Save scaling factor
3895:	1A3D  CDE114  	        CALL    SUBCDE          ; Subtract exponent from FPREG
3896:	1A40  CD5317  	        CALL    INVSGN          ; Negate result
3897:	1A43  21511A  	        LD      HL,EXPTAB       ; Coefficient table
3898:	1A46  CD811A  	        CALL    SMSER1          ; Sum the series
3899:	1A49  110000  	        LD      DE,0            ; Zero LSBs
3900:	1A4C  C1      	        POP     BC              ; Scaling factor
3901:	1A4D  4A      	        LD      C,D             ; Zero MSB
3902:	1A4E  C31F16  	        JP      FPMULT          ; Scale result to correct value
3903:			
3904:	1A51  08      	EXPTAB: .DB     8                       ; Table used by EXP
3905:	1A52  402E9474	        .DB     040H,02EH,094H,074H     ; -1/7! (-1/5040)
3906:	1A56  704F2E77	        .DB     070H,04FH,02EH,077H     ;  1/6! ( 1/720)
3907:	1A5A  6E02887A	        .DB     06EH,002H,088H,07AH     ; -1/5! (-1/120)
3908:	1A5E  E6A02A7C	        .DB     0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
3909:	1A62  50AAAA7E	        .DB     050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
3910:	1A66  FFFF7F7F	        .DB     0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
3911:	1A6A  00008081	        .DB     000H,000H,080H,081H     ; -1/1! (-1/1)
3912:	1A6E  00000081	        .DB     000H,000H,000H,081H     ;  1/0! ( 1/1)
3913:			
3914:	1A72  CD5B17  	SUMSER: CALL    STAKFP          ; Put FPREG on stack
3915:	1A75  111D16  	        LD      DE,MULT         ; Multiply by "X"
3916:	1A78  D5      	        PUSH    DE              ; To be done after
3917:	1A79  E5      	        PUSH    HL              ; Save address of table
3918:	1A7A  CD7617  	        CALL    BCDEFP          ; Move FPREG to BCDE
3919:	1A7D  CD1F16  	        CALL    FPMULT          ; Square the value
3920:	1A80  E1      	        POP     HL              ; Restore address of table
3921:	1A81  CD5B17  	SMSER1: CALL    STAKFP          ; Put value on stack
3922:	1A84  7E      	        LD      A,(HL)          ; Get number of coefficients
3923:	1A85  23      	        INC     HL              ; Point to start of table
3924:	1A86  CD6817  	        CALL    PHLTFP          ; Move coefficient to FPREG
3925:	1A89  06      	        .DB     06H             ; Skip "POP AF"
3926:	1A8A  F1      	SUMLP:  POP     AF              ; Restore count
3927:	1A8B  C1      	        POP     BC              ; Restore number
3928:	1A8C  D1      	        POP     DE
3929:	1A8D  3D      	        DEC     A               ; Cont coefficients
3930:	1A8E  C8      	        RET     Z               ; All done
3931:	1A8F  D5      	        PUSH    DE              ; Save number
3932:	1A90  C5      	        PUSH    BC
3933:	1A91  F5      	        PUSH    AF              ; Save count
3934:	1A92  E5      	        PUSH    HL              ; Save address in table
3935:	1A93  CD1F16  	        CALL    FPMULT          ; Multiply FPREG by BCDE
3936:	1A96  E1      	        POP     HL              ; Restore address in table
3937:	1A97  CD7917  	        CALL    LOADFP          ; Number at HL to BCDE
3938:	1A9A  E5      	        PUSH    HL              ; Save address in table
3939:	1A9B  CDE414  	        CALL    FPADD           ; Add coefficient to FPREG
3940:	1A9E  E1      	        POP     HL              ; Restore address in table
3941:	1A9F  C38A1A  	        JP      SUMLP           ; More coefficients
3942:			
3943:	1AA2  CD2A17  	RND:    CALL    TSTSGN          ; Test sign of FPREG
3944:	1AA5  211920  	        LD      HL,SEED+2       ; Random number seed
3945:	1AA8  FA031B  	        JP      M,RESEED        ; Negative - Re-seed
3946:	1AAB  213A20  	        LD      HL,LSTRND       ; Last random number
3947:	1AAE  CD6817  	        CALL    PHLTFP          ; Move last RND to FPREG
3948:	1AB1  211920  	        LD      HL,SEED+2       ; Random number seed
3949:	1AB4  C8      	        RET     Z               ; Return if RND(0)
3950:	1AB5  86      	        ADD     A,(HL)          ; Add (SEED)+2)
3951:	1AB6  E607    	        AND     00000111B       ; 0 to 7
3952:	1AB8  0600    	        LD      B,0
3953:	1ABA  77      	        LD      (HL),A          ; Re-save seed
3954:	1ABB  23      	        INC     HL              ; Move to coefficient table
3955:	1ABC  87      	        ADD     A,A             ; 4 bytes
3956:	1ABD  87      	        ADD     A,A             ; per entry
3957:	1ABE  4F      	        LD      C,A             ; BC = Offset into table
3958:	1ABF  09      	        ADD     HL,BC           ; Point to coefficient
3959:	1AC0  CD7917  	        CALL    LOADFP          ; Coefficient to BCDE
3960:	1AC3  CD1F16  	        CALL    FPMULT  ;       ; Multiply FPREG by coefficient
3961:	1AC6  3A1820  	        LD      A,(SEED+1)      ; Get (SEED+1)
3962:	1AC9  3C      	        INC     A               ; Add 1
3963:	1ACA  E603    	        AND     00000011B       ; 0 to 3
3964:	1ACC  0600    	        LD      B,0
3965:	1ACE  FE01    	        CP      1               ; Is it zero?
3966:	1AD0  88      	        ADC     A,B             ; Yes - Make it 1
3967:	1AD1  321820  	        LD      (SEED+1),A      ; Re-save seed
3968:	1AD4  21071B  	        LD      HL,RNDTAB-4     ; Addition table
3969:	1AD7  87      	        ADD     A,A             ; 4 bytes
3970:	1AD8  87      	        ADD     A,A             ; per entry
3971:	1AD9  4F      	        LD      C,A             ; BC = Offset into table
3972:	1ADA  09      	        ADD     HL,BC           ; Point to value
3973:	1ADB  CDD514  	        CALL    ADDPHL          ; Add value to FPREG
3974:	1ADE  CD7617  	RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
3975:	1AE1  7B      	        LD      A,E             ; Get LSB
3976:	1AE2  59      	        LD      E,C             ; LSB = MSB
3977:	1AE3  EE4F    	        XOR     01001111B       ; Fiddle around
3978:	1AE5  4F      	        LD      C,A             ; New MSB
3979:	1AE6  3680    	        LD      (HL),80H        ; Set exponent
3980:	1AE8  2B      	        DEC     HL              ; Point to MSB
3981:	1AE9  46      	        LD      B,(HL)          ; Get MSB
3982:	1AEA  3680    	        LD      (HL),80H        ; Make value -0.5
3983:	1AEC  211720  	        LD      HL,SEED         ; Random number seed
3984:	1AEF  34      	        INC     (HL)            ; Count seed
3985:	1AF0  7E      	        LD      A,(HL)          ; Get seed
3986:	1AF1  D6AB    	        SUB     171             ; Do it modulo 171
3987:	1AF3  C2FA1A  	        JP      NZ,RND2         ; Non-zero - Ok
3988:	1AF6  77      	        LD      (HL),A          ; Zero seed
3989:	1AF7  0C      	        INC     C               ; Fillde about
3990:	1AF8  15      	        DEC     D               ; with the
3991:	1AF9  1C      	        INC     E               ; number
3992:	1AFA  CD3515  	RND2:   CALL    BNORM           ; Normalise number
3993:	1AFD  213A20  	        LD      HL,LSTRND       ; Save random number
3994:	1B00  C38217  	        JP      FPTHL           ; Move FPREG to last and return
3995:			
3996:	1B03  77      	RESEED: LD      (HL),A          ; Re-seed random numbers
3997:	1B04  2B      	        DEC     HL
3998:	1B05  77      	        LD      (HL),A
3999:	1B06  2B      	        DEC     HL
4000:	1B07  77      	        LD      (HL),A
4001:	1B08  C3DE1A  	        JP      RND1            ; Return RND seed
4002:			
4003:	1B0B  68B14668	RNDTAB: .DB  068H,0B1H,046H,068H     ; Table used by RND
4004:	1B0F  99E99269	        .DB  099H,0E9H,092H,069H
4005:	1B13  10D17568	        .DB  010H,0D1H,075H,068H
4006:			
4007:	1B17  21611B  	COS:    LD      HL,HALFPI       ; Point to PI/2
4008:	1B1A  CDD514  	        CALL    ADDPHL          ; Add it to PPREG
4009:	1B1D  CD5B17  	SIN:    CALL    STAKFP          ; Put angle on stack
4010:	1B20  014983  	        LD      BC,8349H        ; BCDE = 2 PI
4011:	1B23  11DB0F  	        LD      DE,0FDBH
4012:	1B26  CD6B17  	        CALL    FPBCDE          ; Move 2 PI to FPREG
4013:	1B29  C1      	        POP     BC              ; Restore angle
4014:	1B2A  D1      	        POP     DE
4015:	1B2B  CD8016  	        CALL    DVBCDE          ; Divide angle by 2 PI
4016:	1B2E  CD5B17  	        CALL    STAKFP          ; Put it on stack
4017:	1B31  CDFD17  	        CALL    INT             ; Get INT of result
4018:	1B34  C1      	        POP     BC              ; Restore number
4019:	1B35  D1      	        POP     DE
4020:	1B36  CDE114  	        CALL    SUBCDE          ; Make it 0 <= value < 1
4021:	1B39  21651B  	        LD      HL,QUARTR       ; Point to 0.25
4022:	1B3C  CDDB14  	        CALL    SUBPHL          ; Subtract value from 0.25
4023:	1B3F  CD2A17  	        CALL    TSTSGN          ; Test sign of value
4024:	1B42  37      	        SCF                     ; Flag positive
4025:	1B43  F24D1B  	        JP      P,SIN1          ; Positive - Ok
4026:	1B46  CDD214  	        CALL    ROUND           ; Add 0.5 to value
4027:	1B49  CD2A17  	        CALL    TSTSGN          ; Test sign of value
4028:	1B4C  B7      	        OR      A               ; Flag negative
4029:	1B4D  F5      	SIN1:   PUSH    AF              ; Save sign
4030:	1B4E  F45317  	        CALL    P,INVSGN        ; Negate value if positive
4031:	1B51  21651B  	        LD      HL,QUARTR       ; Point to 0.25
4032:	1B54  CDD514  	        CALL    ADDPHL          ; Add 0.25 to value
4033:	1B57  F1      	        POP     AF              ; Restore sign
4034:	1B58  D45317  	        CALL    NC,INVSGN       ; Negative - Make positive
4035:	1B5B  21691B  	        LD      HL,SINTAB       ; Coefficient table
4036:	1B5E  C3721A  	        JP      SUMSER          ; Evaluate sum of series
4037:			
4038:	1B61  DB0F4981	HALFPI: .DB  0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
4039:			
4040:	1B65  0000007F	QUARTR: .DB  000H,000H,000H,07FH     ; 0.25
4041:			
4042:	1B69  05      	SINTAB: .DB  5                       ; Table used by SIN
4043:	1B6A  BAD71E86	        .DB  0BAH,0D7H,01EH,086H     ; 39.711
4044:	1B6E  64269987	        .DB  064H,026H,099H,087H     ;-76.575
4045:	1B72  58342387	        .DB  058H,034H,023H,087H     ; 81.602
4046:	1B76  E05DA586	        .DB  0E0H,05DH,0A5H,086H     ;-41.342
4047:	1B7A  DA0F4983	        .DB  0DAH,00FH,049H,083H     ;  6.2832
4048:			
4049:	1B7E  CD5B17  	TAN:    CALL    STAKFP          ; Put angle on stack
4050:	1B81  CD1D1B  	        CALL    SIN             ; Get SIN of angle
4051:	1B84  C1      	        POP     BC              ; Restore angle
4052:	1B85  E1      	        POP     HL
4053:	1B86  CD5B17  	        CALL    STAKFP          ; Save SIN of angle
4054:	1B89  EB      	        EX      DE,HL           ; BCDE = Angle
4055:	1B8A  CD6B17  	        CALL    FPBCDE          ; Angle to FPREG
4056:	1B8D  CD171B  	        CALL    COS             ; Get COS of angle
4057:	1B90  C37E16  	        JP      DIV             ; TAN = SIN / COS
4058:			
4059:	1B93  CD2A17  	ATN:    CALL    TSTSGN          ; Test sign of value
4060:	1B96  FCBE19  	        CALL    M,NEGAFT        ; Negate result after if -ve
4061:	1B99  FC5317  	        CALL    M,INVSGN        ; Negate value if -ve
4062:	1B9C  3AE720  	        LD      A,(FPEXP)       ; Get exponent
4063:	1B9F  FE81    	        CP      81H             ; Number less than 1?
4064:	1BA1  DAB01B  	        JP      C,ATN1          ; Yes - Get arc tangnt
4065:	1BA4  010081  	        LD      BC,8100H        ; BCDE = 1
4066:	1BA7  51      	        LD      D,C
4067:	1BA8  59      	        LD      E,C
4068:	1BA9  CD8016  	        CALL    DVBCDE          ; Get reciprocal of number
4069:	1BAC  21DB14  	        LD      HL,SUBPHL       ; Sub angle from PI/2
4070:	1BAF  E5      	        PUSH    HL              ; Save for angle > 1
4071:	1BB0  21BA1B  	ATN1:   LD      HL,ATNTAB       ; Coefficient table
4072:	1BB3  CD721A  	        CALL    SUMSER          ; Evaluate sum of series
4073:	1BB6  21611B  	        LD      HL,HALFPI       ; PI/2 - angle in case > 1
4074:	1BB9  C9      	        RET                     ; Number > 1 - Sub from PI/2
4075:			
4076:	1BBA  09      	ATNTAB: .DB  9                       ; Table used by ATN
4077:	1BBB  4AD73B78	        .DB  04AH,0D7H,03BH,078H     ; 1/17
4078:	1BBF  026E847B	        .DB  002H,06EH,084H,07BH     ;-1/15
4079:	1BC3  FEC12F7C	        .DB  0FEH,0C1H,02FH,07CH     ; 1/13
4080:	1BC7  74319A7D	        .DB  074H,031H,09AH,07DH     ;-1/11
4081:	1BCB  843D5A7D	        .DB  084H,03DH,05AH,07DH     ; 1/9
4082:	1BCF  C87F917E	        .DB  0C8H,07FH,091H,07EH     ;-1/7
4083:	1BD3  E4BB4C7E	        .DB  0E4H,0BBH,04CH,07EH     ; 1/5
4084:	1BD7  6CAAAA7F	        .DB  06CH,0AAH,0AAH,07FH     ;-1/3
4085:	1BDB  00000081	        .DB  000H,000H,000H,081H     ; 1/1
4086:			
4087:			
4088:	1BDF  C9      	ARET:   RET                     ; A RETurn instruction
4089:			
4090:	1BE0  CD351D  	GETINP: CALL    CHRIN           ;input a character
4091:	1BE3  C9      	        RET
4092:			
4093:	1BE4          	CLS: 
4094:	1BE4  3E0C    	        LD      A,CS            ; ASCII Clear screen
4095:	1BE6  C3331D  	        JP      CHROUT          ; Output character
4096:			
4097:	1BE9  CDA914  	WIDTH:  CALL    GETINT          ; Get integer 0-255
4098:	1BEC  7B      	        LD      A,E             ; Width to A
4099:	1BED  324220  	        LD      (LWIDTH),A      ; Set width
4100:	1BF0  C9      	        RET
4101:			
4102:	1BF1  CD480D  	LINES:  CALL    GETNUM          ; Get a number
4103:	1BF4  CD8D09  	        CALL    DEINT           ; Get integer -32768 to 32767
4104:	1BF7  ED534620	        LD      (LINESC),DE     ; Set lines counter
4105:	1BFB  ED534820	        LD      (LINESN),DE     ; Set lines number
4106:	1BFF  C9      	        RET
4107:			
4108:	1C00  CD8D09  	DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
4109:	1C03  D5      	        PUSH    DE              ; Save number
4110:	1C04  E1      	        POP     HL              ; Number to HL
4111:	1C05  46      	        LD      B,(HL)          ; Get LSB of contents
4112:	1C06  23      	        INC     HL
4113:	1C07  7E      	        LD      A,(HL)          ; Get MSB of contents
4114:	1C08  C30311  	        JP      ABPASS          ; Return integer AB
4115:			
4116:	1C0B  CD480D  	DOKE:   CALL    GETNUM          ; Get a number
4117:	1C0E  CD8D09  	        CALL    DEINT           ; Get integer -32768 to 32767
4118:	1C11  D5      	        PUSH    DE              ; Save address
4119:	1C12  CD4B07  	        CALL    CHKSYN          ; Make sure ',' follows
4120:	1C15  2C      	        .DB     ','
4121:	1C16  CD480D  	        CALL    GETNUM          ; Get a number
4122:	1C19  CD8D09  	        CALL    DEINT           ; Get integer -32768 to 32767
4123:	1C1C  E3      	        EX      (SP),HL         ; Save value,get address
4124:	1C1D  73      	        LD      (HL),E          ; Save LSB of value
4125:	1C1E  23      	        INC     HL
4126:	1C1F  72      	        LD      (HL),D          ; Save MSB of value
4127:	1C20  E1      	        POP     HL              ; Restore code string address
4128:	1C21  C9      	        RET
4129:			
4130:			
4131:			; HEX$(nn) Convert 16 bit number to Hexadecimal string
4132:			
4133:	1C22  CD4B0D  	HEX:    CALL    TSTNUM          ; Verify it's a number
4134:	1C25  CD8D09  	        CALL    DEINT           ; Get integer -32768 to 32767
4135:	1C28  C5      	        PUSH    BC              ; Save contents of BC
4136:	1C29  21E920  	        LD      HL,PBUFF
4137:	1C2C  7A      	        LD      A,D             ; Get high order into A
4138:	1C2D  FE00    	        CP      0H
4139:	1C2F  280C    	        JR      Z,HEX2          ; Skip output if both high digits are zero
4140:	1C31  CD5A1C  	        CALL    BYT2ASC         ; Convert D to ASCII
4141:	1C34  78      	        LD      A,B
4142:	1C35  FE30    	        CP      '0'
4143:	1C37  2802    	        JR      Z,HEX1          ; Don't store high digit if zero
4144:	1C39  70      	        LD      (HL),B          ; Store it to PBUFF
4145:	1C3A  23      	        INC     HL              ; Next location
4146:	1C3B  71      	HEX1:   LD      (HL),C          ; Store C to PBUFF+1
4147:	1C3C  23      	        INC     HL              ; Next location
4148:	1C3D  7B      	HEX2:   LD      A,E             ; Get lower byte
4149:	1C3E  CD5A1C  	        CALL    BYT2ASC         ; Convert E to ASCII
4150:	1C41  7A      	        LD      A,D
4151:	1C42  FE00    	        CP      0H
4152:	1C44  2005    	        JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
4153:	1C46  78      	        LD      A,B
4154:	1C47  FE30    	        CP      '0'             ; If high digit of lower byte is zero then don't print
4155:	1C49  2802    	        JR      Z,HEX4
4156:	1C4B  70      	HEX3:   LD      (HL),B          ; to PBUFF+2
4157:	1C4C  23      	        INC     HL              ; Next location
4158:	1C4D  71      	HEX4:   LD      (HL),C          ; to PBUFF+3
4159:	1C4E  23      	        INC     HL              ; PBUFF+4 to zero
4160:	1C4F  AF      	        XOR     A               ; Terminating character
4161:	1C50  77      	        LD      (HL),A          ; Store zero to terminate
4162:	1C51  23      	        INC     HL              ; Make sure PBUFF is terminated
4163:	1C52  77      	        LD      (HL),A          ; Store the double zero there
4164:	1C53  C1      	        POP     BC              ; Get BC back
4165:	1C54  21E920  	        LD      HL,PBUFF        ; Reset to start of PBUFF
4166:	1C57  C3B111  	        JP      STR1            ; Convert the PBUFF to a string and return it
4167:			
4168:	1C5A  47      	BYT2ASC LD      B,A             ; Save original value
4169:	1C5B  E60F    	        AND     0FH             ; Strip off upper nybble
4170:	1C5D  FE0A    	        CP      0AH             ; 0-9?
4171:	1C5F  3802    	        JR      C,ADD30         ; If A-F, add 7 more
4172:	1C61  C607    	        ADD     A,07H           ; Bring value up to ASCII A-F
4173:	1C63  C630    	ADD30   ADD     A,30H           ; And make ASCII
4174:	1C65  4F      	        LD      C,A             ; Save converted char to C
4175:	1C66  78      	        LD      A,B             ; Retrieve original value
4176:	1C67  0F      	        RRCA                    ; and Rotate it right
4177:	1C68  0F      	        RRCA
4178:	1C69  0F      	        RRCA
4179:	1C6A  0F      	        RRCA
4180:	1C6B  E60F    	        AND     0FH             ; Mask off upper nybble
4181:	1C6D  FE0A    	        CP      0AH             ; 0-9? < A hex?
4182:	1C6F  3802    	        JR      C,ADD301        ; Skip Add 7
4183:	1C71  C607    	        ADD     A,07H           ; Bring it up to ASCII A-F
4184:	1C73  C630    	ADD301  ADD     A,30H           ; And make it full ASCII
4185:	1C75  47      	        LD      B,A             ; Store high order byte
4186:	1C76  C9      	        RET
4187:			
4188:			; Convert "&Hnnnn" to FPREG
4189:			; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
4190:			; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
4191:	1C77  EB      	HEXTFP  EX      DE,HL           ; Move code string pointer to DE
4192:	1C78  210000  	        LD      HL,0000H        ; Zero out the value
4193:	1C7B  CD901C  	        CALL    GETHEX          ; Check the number for valid hex
4194:	1C7E  DAB01C  	        JP      C,HXERR         ; First value wasn't hex, HX error
4195:	1C81  1805    	        JR      HEXLP1          ; Convert first character
4196:	1C83  CD901C  	HEXLP   CALL    GETHEX          ; Get second and addtional characters
4197:	1C86  381F    	        JR      C,HEXIT         ; Exit if not a hex character
4198:	1C88  29      	HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
4199:	1C89  29      	        ADD     HL,HL
4200:	1C8A  29      	        ADD     HL,HL
4201:	1C8B  29      	        ADD     HL,HL
4202:	1C8C  B5      	        OR      L               ; Add in D0-D3 into L
4203:	1C8D  6F      	        LD      L,A             ; Save new value
4204:	1C8E  18F3    	        JR      HEXLP           ; And continue until all hex characters are in
4205:			
4206:	1C90  13      	GETHEX  INC     DE              ; Next location
4207:	1C91  1A      	        LD      A,(DE)          ; Load character at pointer
4208:	1C92  FE20    	        CP      ' '
4209:	1C94  CA901C  	        JP      Z,GETHEX        ; Skip spaces
4210:	1C97  D630    	        SUB     30H             ; Get absolute value
4211:	1C99  D8      	        RET     C               ; < "0", error
4212:	1C9A  FE0A    	        CP      0AH
4213:	1C9C  3805    	        JR      C,NOSUB7        ; Is already in the range 0-9
4214:	1C9E  D607    	        SUB     07H             ; Reduce to A-F
4215:	1CA0  FE0A    	        CP      0AH             ; Value should be $0A-$0F at this point
4216:	1CA2  D8      	        RET     C               ; CY set if was :            ; < = > ? @
4217:	1CA3  FE10    	NOSUB7  CP      10H             ; > Greater than "F"?
4218:	1CA5  3F      	        CCF
4219:	1CA6  C9      	        RET                     ; CY set if it wasn't valid hex
4220:			
4221:	1CA7  EB      	HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
4222:	1CA8  7A      	        LD      A,D             ; Load DE into AC
4223:	1CA9  4B      	        LD      C,E             ; For prep to 
4224:	1CAA  E5      	        PUSH    HL
4225:	1CAB  CD0211  	        CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4226:	1CAE  E1      	        POP     HL
4227:	1CAF  C9      	        RET
4228:			
4229:	1CB0  1E26    	HXERR:  LD      E,HE            ; ?HEX Error
4230:	1CB2  C3C504  	        JP      ERROR
4231:			
4232:			; BIN$(NN) Convert integer to a 1-16 char binary string
4233:	1CB5  CD4B0D  	BIN:    CALL    TSTNUM          ; Verify it's a number
4234:	1CB8  CD8D09  	        CALL    DEINT           ; Get integer -32768 to 32767
4235:	1CBB  C5      	BIN2:   PUSH    BC              ; Save contents of BC
4236:	1CBC  21E920  	        LD      HL,PBUFF
4237:	1CBF  0611    	        LD      B,17            ; One higher than max char count
4238:	1CC1          	ZEROSUP:                        ; Suppress leading zeros
4239:	1CC1  05      	        DEC     B               ; Max 16 chars
4240:	1CC2  78      	        LD      A,B
4241:	1CC3  FE01    	        CP      01H
4242:	1CC5  2808    	        JR      Z,BITOUT        ; Always output at least one character
4243:	1CC7  CB13    	        RL      E
4244:	1CC9  CB12    	        RL      D
4245:	1CCB  30F4    	        JR      NC,ZEROSUP
4246:	1CCD  1804    	        JR      BITOUT2
4247:	1CCF          	BITOUT:
4248:	1CCF  CB13    	        RL      E
4249:	1CD1  CB12    	        RL      D               ; Top bit now in carry
4250:	1CD3          	BITOUT2:
4251:	1CD3  3E30    	        LD      A,'0'           ; Char for '0'
4252:	1CD5  CE00    	        ADC     A,0             ; If carry set then '0' --> '1'
4253:	1CD7  77      	        LD      (HL),A
4254:	1CD8  23      	        INC     HL
4255:	1CD9  05      	        DEC     B
4256:	1CDA  20F3    	        JR      NZ,BITOUT
4257:	1CDC  AF      	        XOR     A               ; Terminating character
4258:	1CDD  77      	        LD      (HL),A          ; Store zero to terminate
4259:	1CDE  23      	        INC     HL              ; Make sure PBUFF is terminated
4260:	1CDF  77      	        LD      (HL),A          ; Store the double zero there
4261:	1CE0  C1      	        POP     BC
4262:	1CE1  21E920  	        LD      HL,PBUFF
4263:	1CE4  C3B111  	        JP      STR1
4264:			
4265:			; Convert "&Bnnnn" to FPREG
4266:			; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
4267:	1CE7  EB      	BINTFP: EX      DE,HL           ; Move code string pointer to DE
4268:	1CE8  210000  	        LD      HL,0000H        ; Zero out the value
4269:	1CEB  CD041D  	        CALL    CHKBIN          ; Check the number for valid bin
4270:	1CEE  DA121D  	        JP      C,BINERR        ; First value wasn't bin, HX error
4271:	1CF1  D630    	BINIT:  SUB     '0'
4272:	1CF3  29      	        ADD     HL,HL           ; Rotate HL left
4273:	1CF4  B5      	        OR      L
4274:	1CF5  6F      	        LD      L,A
4275:	1CF6  CD041D  	        CALL    CHKBIN          ; Get second and addtional characters
4276:	1CF9  30F6    	        JR      NC,BINIT        ; Process if a bin character
4277:	1CFB  EB      	        EX      DE,HL           ; Value into DE, Code string into HL
4278:	1CFC  7A      	        LD      A,D             ; Load DE into AC
4279:	1CFD  4B      	        LD      C,E             ; For prep to 
4280:	1CFE  E5      	        PUSH    HL
4281:	1CFF  CD0211  	        CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4282:	1D02  E1      	        POP     HL
4283:	1D03  C9      	        RET
4284:			
4285:			; Char is in A, NC if char is 0 or 1
4286:	1D04  13      	CHKBIN: INC     DE
4287:	1D05  1A      	        LD      A,(DE)
4288:	1D06  FE20    	        CP      ' '
4289:	1D08  CA041D  	        JP      Z,CHKBIN        ; Skip spaces
4290:	1D0B  FE30    	        CP      '0'             ; Set C if < '0'
4291:	1D0D  D8      	        RET     C
4292:	1D0E  FE32    	        CP      '2'
4293:	1D10  3F      	        CCF                     ; Set C if > '1'
4294:	1D11  C9      	        RET
4295:			
4296:	1D12  1E28    	BINERR: LD      E,BN            ; ?BIN Error
4297:	1D14  C3C504  	        JP      ERROR
4298:			
4299:			;MONOUT: JP      0008H           ; output a char
4300:			
4301:			
4302:	1D17  76      	MONITR: HALT
4303:			        ;JP      0000H           ; Restart (Normally Monitor Start)
4304:			
4305:			
4306:	1D18  ED45    	ARETN:  RETN                    ; Return from NMI
4307:			
4308:			
4309:	1D1A  F5      	TSTBIT: PUSH    AF              ; Save bit mask
4310:	1D1B  A0      	        AND     B               ; Get common bits
4311:	1D1C  C1      	        POP     BC              ; Restore bit mask
4312:	1D1D  B8      	        CP      B               ; Same bit set?
4313:	1D1E  3E00    	        LD      A,0             ; Return 0 in A
4314:	1D20  C9      	        RET
4315:			
4316:	1D21  CD5607  	OUTNCR: CALL    OUTC            ; Output character in A
4317:	1D24  C3830B  	        JP      PRNTCRLF        ; Output CRLF
4318:			
4319:			; *** USR ***
4320:			; USR(X) jumps here, default USRJP at 0x2048 contains a jump to a RET code
4321:			; Put the user function into ram - int16_t arg: DE, int16_t ret: DE
4322:			; Put the function address into USRJP+1 (0x2049/0x204a = 8265/8266)
4323:	1D27  CD8D09  	USR:    CALL    DEINT           ; Get int16_t argument into DE
4324:	1D2A  CD0320  	        CALL    USRJP           ; Execute the user program
4325:	1D2D  7A      	        LD      A,D             ; int16_t result is returned in DE
4326:	1D2E  43      	        LD      B,E             ; Move result to AB
4327:	1D2F  CD0311  	        CALL    ABPASS          ; Pass the result back to BASIC
4328:	1D32  C9      	        RET
4329:			
4330:			
4331:			
4332:	1D33  CF      	CHROUT: RST     08H
4333:	1D34  C9      	        RET
4334:			
4335:	1D35  D7      	CHRIN:  RST     10H
4336:	1D36  C9      	        RET
4337:			
4338:	1D37  DF      	CHKIN:  RST     18H
4339:	1D38  C9      	        RET
4340:			
4341:			
4342:	1D39 ..1FFF 00	        .DC     (ROMSIZE - $), 0
4343:			
4344:	2000          	.end



Statistics:

     4	passes
     0	jr promotions
   641	symbols
  7936	bytes



Symbol Table:

ABPASS          1103      4355
ABS             174F      5967
ACCSUM           96C      2412
ACPASS          1102      4354
ADD30           1C63      7267
ADD301          1C73      7283
ADDEXP          16E8      5864
ADDIG           188E      6286
ADDPHL          14D5      5333
ALLFOL          13D1      5073
ANTVLU           C6C      3180
ARET            1BDF      7135
ARETN           1D18      7448
ARLDSV          1023      4131
ARREND          20DA      8410
ARRLP           129C      4764
ASC             13A2      5026
ASCTFP          1831      6193
ASPCS            BCE      3022
ATN             1B93      7059
ATN1            1BB0      7088
ATNTAB          1BBA      7098
ATOH             9A7      2471
BADINP           BF3      3059
BAKSTK           45A      1114
BAKTMP          1382      4994
BASTXT          205E      8286
BCDEFP          1776      6006
BFREE            1AA      426
BIN             1CB5      7349
BIN2            1CBB      7355
BINERR          1D12      7442
BINIT           1CF1      7409
BINTFP          1CE7      7399
BITOUT          1CCF      7375
BITOUT2         1CD3      7379
BKSP           =08        8
BN             =28        40
BNORM           1535      5429
BNRMLP          1538      5432
BRK              91E      2334
BRKFLG          204D      8269
BRKLIN          20CE      8398
BRKMSG           454      1108
BRKRET           1A4      420
BS             =10        16
BSERR           1056      4182
BUFFER          2061      8289
BYT2ASC         1C5A      7258
BYTSFT          166D      5741
CAN            =18        24
CFEVAL           FB9      4025
CHARTY           F67      3943
CHEKFN          119A      4506
CHKBIN          1D04      7428
CHKIN           1D37      7479
CHKLTR           979      2425
CHKSTK           48E      1166
CHKSUM          204A      8266
CHKSYN           74B      1867
CHKTYP           D4D      3405
CHR             13B3      5043
CHRIN           1D35      7477
CHROUT          1D33      7475
CLEAR            9CC      2508
CLOTST           780      1920
CLREG            5E3      1507
CLRPTR           5BE      1470
CLS             1BE4      7140
CMPFP           17BF      6079
CMPLG1           ECD      3789
CMPLOG           ECB      3787
CMPNUM          17A5      6053
CMPRES           F0F      3855
CMPSTR           EF7      3831
CN             =20        32
CNVNUM          183D      6205
COLD             100      256
COMMAN          2043      8259
COMPL           1595      5525
CONCAT          1317      4887
CONEXP          186D      6253
CONPOS          1532      5426
CONT             951      2385
CONTAD          20D4      8404
CONVAR           E38      3640
COPY             11D      285
COS             1B17      6935
COUNT            7F0      2032
CPDEHL           745      1861
CPYLIT           6B5      1717
CR             =0D        13
CRARLP          1076      4214
CREARY          105B      4187
CRESTR           ACB      2763
CRNCLP           616      1558
CRTMST          11D3      4563
CRTST           11DF      4575
CRTSTE          11F5      4597
CRUNCH           60D      1549
CS             =0C        12
CSTART           10C      268
CTLOFG          2045      8261
CTRLC          =03        3
CTRLG          =07        7
CTRLO          =0F        15
CTRLQ          =11        17
CTRLR          =12        18
CTRLS          =13        19
CTRLU          =15        21
CUROPR          20C5      8389
CURPOS          20AB      8363
DATA             A72      2674
DATFLG          20AE      8366
DATLIN          20C9      8393
DATSNR           4AB      1195
DCBCDE          17F6      6134
DD             =12        18
DDERR            4BA      1210
DEEK            1C00      7168
DEF             1117      4375
DEFSIZ          107E      4222
DEINT            98D      2445
DEL            =7F        127
DELCHR           6C5      1733
DEPINT           987      2439
DETHL4          1785      6021
DETHLB          1787      6023
DIGTXT          1937      6455
DIM              F39      3897
DIMRET           F30      3888
DINPOS           77A      1914
DIV             167E      5758
DIV1           =200A      8202
DIV10           1672      5746
DIV2           =200E      8206
DIV3           =2012      8210
DIV4           =2015      8213
DIVLP           16A5      5797
DIVSUP          2009      8201
DOAGN            5FC      1532
DOCOM            B9F      2975
DOEBIT          1977      6519
DOFN            1144      4420
DOKE            1C0B      7179
DONULL           B8D      2957
DOSPC            BC9      3017
DOTAB            BB6      2998
DPOINT          1869      6249
DTSTR           11E3      4579
DVBCDE          1680      5760
DZ             =14        20
DZERR            4B4      1204
EDIGIT          18B0      6320
ENDBUF           6BC      1724
ENDCON          187C      6268
ENDDIM          10DD      4317
ENDINP           B7E      2942
ENDNAM           F5B      3931
ENDPRG           92D      2349
ENFMEM           497      1175
ERRIN            4E5      1253
ERRLIN          20D2      8402
ERRMSG           442      1090
ERROR            4C5      1221
ERRORS           3B8      952
ESC            =1B        27
EVAL             D5A      3418
EVAL1            D5D      3421
EVAL2            D66      3430
EVAL3            D69      3433
EVLPAR           E1F      3615
EVNOT            F19      3865
EXCUTE           8B5      2229
EXP             1A11      6673
EXPLP           185B      6235
EXPTAB          1A51      6737
EXPTEN          1989      6537
EXTIG            CC8      3272
FANDT            CF2      3314
FC             =08        8
FCERR            9A2      2466
FDTLP            CD9      3289
FINDEL          10B9      4281
FLGDIF          1735      5941
FLGREL          173C      5948
FNARG           20E0      8416
FNCTAB           202      514
FNDARY          1029      4137
FNDELP          10BE      4286
FNDEND           591      1425
FNDNUM          14A6      5286
FNDTOK           7CF      1999
FNDVAR           FA0      4000
FNDWRD           640      1600
FNOFST           E49      3657
FNRGNM          20DE      8414
FNTHR            FAE      4014
FNVAL            E70      3696
FOPRND           D92      3474
FOR              81C      2076
FORFLG          20CB      8395
FORFND           84C      2124
FORSLP           830      2096
FPADD           14E4      5348
FPBCDE          176B      5995
FPEXP          =20E7      8423
FPINT           17D2      6098
FPMULT          161F      5663
FPREG           20E4      8420
FPROND          157C      5500
FPSINT           981      2433
FPTHL           1782      6018
FRE             10E1      4321
FRENUM          10FD      4349
FRMEVL           E3B      3643
GARBGE          1264      4708
GARBLP          1267      4711
GETCHR           8D5      2261
GETCMD           509      1289
GETHEX          1C90      7312
GETINP          1BE0      7136
GETINT          14A9      5289
GETLEN          1397      5015
GETLIN           6E2      1762
GETLN            9A8      2472
GETNUM           D48      3400
GETNXT           65B      1627
GETSTR          1361      4961
GETVAR           F3E      3902
GNXARY          129B      4763
GOFUNC           E78      3704
GOSUB            A1E      2590
GOTO             A2F      2607
GRBARY          12BB      4795
GRBDON          123C      4668
GRBLP           1275      4725
GSTRCU          1364      4964
GSTRDE          1368      4968
GSTRHL          1367      4967
GTFLNM          13A6      5030
GTFNAM           F43      3907
GTLNLP           9AB      2475
GTSIXD          1901      6401
GTVLUS           C44      3140
HALF            19A8      6568
HALFPI          1B61      7009
HE             =26        38
HEX             1C22      7202
HEX1            1C3B      7227
HEX2            1C3D      7229
HEX3            1C4B      7243
HEX4            1C4D      7245
HEXIT           1CA7      7335
HEXLP           1C83      7299
HEXLP1          1C88      7304
HEXTFP          1C77      7287
HXERR           1CB0      7344
ID             =16        22
IDTEST          118C      4492
IF               B01      2817
IFGO             B0F      2831
IFJMP            8BC      2236
INCHL           1780      6016
INCLEN           776      1910
INDFND           474      1140
INEWLN           559      1369
INIT             115      277
INITAB           3E2      994
INITBE           442      1090
INITST           110      272
INMSG            449      1097
INP             1466      5222
INPBIN           C96      3222
INPBRK           92A      2346
INPORT         =203F      8255
INPSUB          203E      8254
INPUT            C04      3076
INRNG           190A      6410
INT             17FD      6141
INTVAR           5CD      1485
INVSGN          1753      5971
ITBRET           3EA      1002
ITMSEP           C87      3207
JSTZER          1993      6547
KILFOR           D38      3384
KILIN            6DC      1756
LCRFLG          20AC      8364
LEFT            13C3      5059
LEN             1393      5011
LET              A89      2697
LETNUM           ADC      2780
LETSTR           AA4      2724
LF             =0A        10
LFRGNM          145C      5212
LINEAT          205C      8284
LINEIN          18BC      6332
LINES           1BF1      7153
LINESC          2046      8262
LINESN          2048      8264
LINFND           542      1346
LIST             791      1937
LISTLP           79D      1949
LOADFP          1779      6009
LOG             15DE      5598
LOGTAB          15D1      5585
LOKFOR           45E      1118
LOOPST          20C7      8391
LS             =1C        28
LSTBIN          20CC      8396
LSTLP2           7BD      1981
LSTLP3           7C0      1984
LSTRAM          20AF      8367
LSTRND          203A      8250
LTSTND           CA1      3233
LWIDTH          2042      8258
MAKINT          14AC      5292
MAKNUM          1926      6438
MANLP           1845      6213
MATCH            68D      1677
MEMMSG           1F7      503
MID             13FD      5117
MID1            13C9      5065
MIDNUM          1461      5217
MINCDE          1524      5412
MINUS            E27      3623
MKTMST          11D0      4560
MLDBLP          181E      6174
MLDEBC          1816      6166
MLOOP            145      325
MLSP10          1713      5907
MO             =24        36
MONITR          1D17      7447
MORDT            CAD      3245
MORINP           6E7      1767
MOVBUF           578      1400
MOVDIR           695      1685
MOVLP            483      1155
MOVSTR           480      1152
MOVUP            47D      1149
MRPRNT           B21      2849
MSIZE            132      306
MUL8LP          164A      5706
MULLN2          1616      5654
MULT            161D      5661
MULT8           1641      5697
MULTEN          1887      6279
MULVAL          20F6      8438
MVSTPT           AD3      2771
NEDMOR           C40      3136
NEGAFT          19BE      6590
NEW              5BD      1469
NEXITM           BD9      3033
NEXT             CFD      3325
NEXT1            D00      3328
NF             =00        0
NFERR            4B7      1207
NMIFLG          204C      8268
NOCHNG           685      1669
NOENED          1996      6550
NOLIN            940      2368
NOMADD          165B      5723
NOMLAD          182C      6188
NOPMPT           C1E      3102
NORMAL          154F      5455
NOSPC            67C      1660
NOSUB7          1CA3      7331
NOSWAP          14FE      5374
NOTAMP           DFC      3580
NOTSTR           F76      3958
NOXOR           148C      5260
NSCFOR           F86      3974
NULFLG          2044      8260
NULL             964      2404
NULLP            B94      2964
NULLS           2041      8257
NUMASC          18CF      6351
NXTARY          103D      4157
NXTBYT           66B      1643
NXTCHR           6AC      1708
NXTDAT          20DC      8412
NXTDTA           A71      2673
NXTITM           C38      3128
NXTOPR          20D0      8400
NXTSTL           A78      2680
NXTSTT           A7B      2683
OD             =06        6
OKMSG            44E      1102
OM             =0C        12
OMERR            4A6      1190
ON               AE3      2787
ONGO             AF2      2802
ONGOLP           AF3      2803
ONJMP            8BD      2237
OPNPAR           D56      3414
OPRND            DD1      3537
OS             =1A        26
OTKLN            6D9      1753
OTPORT         =2007      8199
OUTC             756      1878
OUTEXP          1987      6535
OUTIT            73F      1855
OUTNCR          1D21      7457
OUTSUB          2006      8198
OUTWRD           7D9      2009
OV             =0A        10
OVERR            4C0      1216
OVTST1          1706      5894
OVTST2          170B      5899
OVTST3          170C      5900
PADD            18AB      6315
PAND             E92      3730
PASSA           1112      4370
PBUFF           20E9      8425
PEEK            14BA      5306
PEND             925      2341
PHLTFP          1768      5992
PLUCDE          1589      5513
PNORM           1557      5463
POINT           2051      8273
POKE            14C1      5313
POPAF           1256      4694
POPHL           1380      4992
POPHRT          166B      5739
POPNOK           4FB      1275
POR              E91      3729
POR1             EB4      3764
POS             110F      4367
POSINT           984      2436
POUT            1472      5234
POWER           19CC      6604
POWER1          19DC      6620
POWER2          19F9      6649
POWERS          19AC      6572
PRINT            B25      2853
PRITAB           3A3      931
PRNTCRLF         B83      2947
PRNTHL          18C4      6340
PRNTLP           B28      2856
PRNTNB           B6B      2923
PRNTOK           4FC      1276
PRNTST           B6F      2927
PRNUMS          1220      4640
PROCES           6EB      1771
PROGND          20D6      8406
PROGST          20F9      8441
PROMPT           600      1536
PRS             1221      4641
PRS1            1224      4644
PRSLP           122B      4651
PSET            2054      8276
PSUB            14DF      5343
PTRLP            585      1413
PUTB1            738      1848
PUTBUF           725      1829
PUTCTL           72A      1834
PUTFID           891      2193
QTSTLP          11E6      4582
QTSTR           11E0      4576
QUARTR          1B65      7013
RAMEND         =3A00      14848
RAMSIZE        =1A00      6656
RAMSTRT        =2000      8192
READ             C33      3123
READFG          20CD      8397
REDO             BE0      3040
REM              A74      2676
RESDIV          16B8      5816
RESEED          1B03      6915
RESET           2057      8279
RESTNL           8FA      2298
RESTOR           8E5      2277
RESZER          154A      5450
RETADR           FED      4077
RETINT          1741      5953
RETLIN           A6C      2668
RETNAD           691      1681
RETNUL           FF0      4080
RETNUM           E33      3635
RETREL          1733      5939
RETURN           A4D      2637
RG             =04        4
RIGHT           13F3      5107
RIGHT1          13C7      5063
RINPUT          204E      8270
RLTLP            D76      3446
RND             1AA2      6818
RND1            1ADE      6878
RND2            1AFA      6906
RNDTAB          1B0B      6923
RNGTST          1999      6553
ROMSIZE        =2000      8192
RONDB           156B      5483
RONDUP          156A      5482
ROUND           14D2      5330
RSCALE          18A5      6309
RSLNBK           813      2067
RSTSTR          1416      5142
RUN              A12      2578
RUNCNT           895      2197
RUNFST           5C9      1481
RUNLIN           A2E      2606
SAVEXP          154B      5451
SAVSTP           888      2184
SAVSTR          11BB      4539
SBSCPT           FFB      4091
SCALE           15A9      5545
SCALLP          15AB      5547
SCALMI          1870      6256
SCALPL          1886      6278
SCNEND          12F2      4850
SCPTLP          1001      4097
SEARCH           659      1625
SEED            2017      8215
SETIO           1496      5270
SETLIN           7E7      2023
SETLIT           6A3      1699
SETPTR           580      1408
SETTOP           169      361
SFTPRG           54A      1354
SGN             1739      5945
SGNEXP           E81      3713
SGNRES          20E8      8424
SHRITE          15B8      5560
SHRLP           15BB      5563
SHRT1           15BF      5567
SIGNON           1B9      441
SIGNS           1790      6032
SIN             1B1D      6941
SIN1            1B4D      6989
SINTAB          1B69      7017
SIXDIG          18EC      6380
SMPVAR          1286      4742
SMSER1          1A81      6785
SN             =02        2
SNERR            4B1      1201
SPACE          =20        32
SPCFST          18DD      6365
SPCLP            BD2      3026
SQR             19C3      6595
SRCHLN           59D      1437
SRCHLP           5A0      1440
SSTSA           134E      4942
ST             =1E        30
STACK          =20A7      8359
STAKFP          175B      5979
STALL            912      2322
STKTHS           DBA      3514
STLOOK         =2200      8704
STOP             923      2339
STORED           9EF      2543
STPOOL          12C9      4809
STR             11AB      4523
STR1            11B1      4529
STRADD          12CC      4812
STRBOT          20C3      8387
STRENT           C8A      3210
STRSPC          205A      8282
STTLIN           B76      2934
SUBCDE          14E1      5345
SUBPHL          14DB      5339
SUMLP           1A8A      6794
SUMSER          1A72      6770
SUPTLZ          196B      6507
SVNAM2           F5A      3930
SVSTAD          11D9      4569
TAN             1B7E      7038
TESTOS          1258      4696
TESTR           123A      4666
TM             =18        24
TMERR            4C3      1219
TMPSTR          20BF      8383
TMSTPL          20B3      8371
TMSTPT          20B1      8369
TOPOOL          13BF      5055
TOSTRA          1357      4951
TRYAGN          1946      6470
TSALP           1358      4952
TSTBIT          1D1A      7450
TSTBRK           900      2304
TSTMEM           157      343
TSTNUM           D4B      3403
TSTOPL          1201      4609
TSTRED           EB9      3769
TSTREM           6A6      1702
TSTSGN          172A      5930
TSTSTR           D4C      3404
TTYLIN           6E2      1762
TYPE            20AD      8365
UF             =22        34
UFERR            4BD      1213
UL             =0E        14
ULERR            A48      2632
UNITY           15CD      5581
UPDATA           8FB      2299
USR             1D27      7463
USRJP           2003      8195
VAL             142D      5165
VAL1            144B      5195
VAL2            1455      5205
VAL3            1458      5208
VAREND          20D8      8408
WAIT            1478      5240
WAITLP          148D      5261
WARM             103      259
WARMST           1A1      417
WIDTH           1BE9      7145
WORDS            23A      570
WORDTB           359      857
WRKSPC          2000      8192
ZDATA          =83        131
ZDIV           =AF        175
ZEND           =80        128
ZEQUAL         =B4        180
ZERARY          109C      4252
ZERBYT         = 44D      1101
ZEROLP           FDF      4063
ZEROSUP         1CC1      7361
ZFN            =A7        167
ZFOR           =81        129
ZGOSUB         =8C        140
ZGOTO          =88        136
ZGTR           =B3        179
ZLEFT          =CF        207
ZLTH           =B5        181
ZMINUS         =AD        173
ZNEW           =A4        164
ZNOT           =AA        170
ZONELP           BAD      2989
ZOR            =B2        178
ZPLUS          =AC        172
ZPOINT         =C7        199
ZPRINT         =9E        158
ZREM           =8E        142
ZSGN           =B6        182
ZSPC           =A8        168
ZSTEP          =AB        171
ZTAB           =A5        165
ZTHEN          =A9        169
ZTIMES         =AE        174
ZTO            =A6        166
